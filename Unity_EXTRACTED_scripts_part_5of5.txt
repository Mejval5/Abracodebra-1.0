This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-04-24 19:30:48
PART 5 OF 5
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   └── PlantPrefab.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           └── DualGridRuleTile_Grass.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   └── Animal_000_Bunny.asset
│   ├── Animals Diet
│   │   └── Diet_000_Bunny.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   └── Node_002_FireflyPheromone.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   └── Tools
│       ├── ToolDefinition_000_GardeningHoe.asset
│       ├── ToolDefinition_001_WateringCan.asset
│       └── ToolDefinition_002_SeedPouch.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   └── ThoughtTrigger.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManagement.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       └── RuntimeCircleDrawer.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   └── SpriteEmissiveUnlit.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using UnityEngine;
using UnityEngine.Tilemaps;
using skner.DualGrid;
using System.Collections.Generic;
using System.Linq;
using TMPro;

public class TileInteractionManager : MonoBehaviour
{
    public static TileInteractionManager Instance { get; private set; }

    [System.Serializable]
    public class TileDefinitionMapping
    {
        public TileDefinition tileDef;
        public DualGridTilemapModule tilemapModule;
    }

    [Header("Tile Definition Mappings")]
    public List<TileDefinitionMapping> tileDefinitionMappings;

    // (If you have an interaction library for tool-based transformations)
    [Header("Interaction Library")]
    public TileInteractionLibrary interactionLibrary;

    [Header("Grid & Scene References")]
    public Grid interactionGrid;
    public Camera mainCamera;
    public Transform player;
    public float hoverRadius = 3f;
    public GameObject hoverHighlightObject;

    [Header("Tilemap Rendering Settings")]
    [Tooltip("The base sorting order value (the first tilemap will be this value, subsequent ones will decrease)")]
    public int baseSortingOrder = 0;

    [Header("Debug / UI")]
    public bool debugLogs = false;
    public TextMeshProUGUI hoveredTileText;
    public TextMeshProUGUI currentToolText;

    // quick lookups
    private Dictionary<TileDefinition, DualGridTilemapModule> moduleByDefinition;
    private Dictionary<DualGridTilemapModule, TileDefinition> definitionByModule;

    // track which cell is hovered
    private Vector3Int? currentlyHoveredCell = null;
    private TileDefinition hoveredTileDef = null;

    // --------- NEW: Timed reversion dictionary -----------
    // Key = cell position, Value = struct that holds the tileDefinition & time left
    private Dictionary<Vector3Int, TimedTileState> timedCells = new Dictionary<Vector3Int, TimedTileState>();

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // build dictionaries
        moduleByDefinition = new Dictionary<TileDefinition, DualGridTilemapModule>();
        definitionByModule = new Dictionary<DualGridTilemapModule, TileDefinition>();

        // Setup tilemaps with correct sorting orders and colors
        SetupTilemaps();
    }

    void Start()
    {
        // Ensure we always initialize the dictionary in Start() for runtime
        if (moduleByDefinition == null || moduleByDefinition.Count == 0)
        {
            SetupTilemaps();
        }
    }

    // Method to set up tilemap sorting order and apply initial colors
    private void SetupTilemaps()
    {
        moduleByDefinition = new Dictionary<TileDefinition, DualGridTilemapModule>();
        definitionByModule = new Dictionary<DualGridTilemapModule, TileDefinition>();
        
        for (int i = 0; i < tileDefinitionMappings.Count; i++)
        {
            var mapping = tileDefinitionMappings[i];
            if (mapping.tileDef == null || mapping.tilemapModule == null) 
                continue;

            // Add to dictionaries
            if (!moduleByDefinition.ContainsKey(mapping.tileDef))
            {
                moduleByDefinition[mapping.tileDef] = mapping.tilemapModule;
                definitionByModule[mapping.tilemapModule] = mapping.tileDef;
                
                // Get the RenderTilemap component
                Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                if (renderTilemapTransform != null)
                {
                    // Set the sorting order based on the index - INVERTED (negative values)
                    // First item (index 0) gets baseSortingOrder, then we subtract for each subsequent item
                    TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
                    if (renderer != null)
                    {
                        renderer.sortingOrder = baseSortingOrder - i;
                        if (debugLogs)
                            Debug.Log($"Setting sorting order for {mapping.tileDef.displayName} to {baseSortingOrder - i}");
                    }
                    
                    // Set the initial color from TileDefinition
                    Tilemap tilemap = renderTilemapTransform.GetComponent<Tilemap>();
                    if (tilemap != null)
                    {
                        tilemap.color = mapping.tileDef.tintColor;
                        if (debugLogs)
                            Debug.Log($"Setting color for {mapping.tileDef.displayName} to {mapping.tileDef.tintColor}");
                    }
                }
                
                if (debugLogs)
                    Debug.Log($"[Mapping] {mapping.tileDef.displayName} => {mapping.tilemapModule.gameObject.name}");
            }
            else
            {
                Debug.LogWarning($"Duplicate tileDef {mapping.tileDef.displayName} in tileDefinitionMappings.");
            }
        }
    }

    // New public method to update sorting order - can be called from custom editor
    public void UpdateSortingOrder()
    {
        for (int i = 0; i < tileDefinitionMappings.Count; i++)
        {
            var mapping = tileDefinitionMappings[i];
            if (mapping.tileDef == null || mapping.tilemapModule == null) 
                continue;
                
            Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
            if (renderTilemapTransform != null)
            {
                TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
                if (renderer != null)
                {
                    // Negative values - first in list gets highest order
                    renderer.sortingOrder = baseSortingOrder - i;
                    
                    #if UNITY_EDITOR
                    UnityEditor.EditorUtility.SetDirty(renderer);
                    #endif
                    
                    if (debugLogs)
                        Debug.Log($"Updated sorting order for {mapping.tileDef.displayName} to {baseSortingOrder - i}");
                }
            }
        }
    }

    // New public method to update all colors - can be called from custom editor
    public void UpdateAllColors()
    {
        foreach (var mapping in tileDefinitionMappings)
        {
            if (mapping.tileDef == null || mapping.tilemapModule == null) 
                continue;
                
            Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
            if (renderTilemapTransform != null)
            {
                Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
                if (renderTilemap != null)
                {
                    renderTilemap.color = mapping.tileDef.tintColor;
                    
                    #if UNITY_EDITOR
                    UnityEditor.EditorUtility.SetDirty(renderTilemap);
                    #endif
                    
                    if (debugLogs)
                        Debug.Log($"Updated color for {mapping.tileDef.displayName} to {mapping.tileDef.tintColor}");
                }
            }
        }
    }

    void Update()
    {
        HandleTileHover();
        UpdateReversion();
        UpdateDebugUI();
    }

    // ------------------- Timed Reversion Logic ------------------------
    // We'll store a small struct for each cell that is on a countdown
    private struct TimedTileState
    {
        public TileDefinition tileDef;
        public float timeLeft;
    }

    private void UpdateReversion()
    {
        if (timedCells.Count == 0) return;

        // We'll gather cells that are about to revert
        List<Vector3Int> cellsToRevert = null;

        // We'll copy keys to avoid modifying dictionary while iterating
        foreach (var kvp in timedCells.ToList())
        {
            Vector3Int cellPos = kvp.Key;
            TimedTileState state = kvp.Value;
            state.timeLeft -= Time.deltaTime;
            if (state.timeLeft <= 0f)
            {
                // we revert now
                if (cellsToRevert == null) 
                    cellsToRevert = new List<Vector3Int>();
                cellsToRevert.Add(cellPos);
            }
            else
            {
                // store updated time
                timedCells[cellPos] = state;
            }
        }

        if (cellsToRevert != null)
        {
            foreach (var cellPos in cellsToRevert)
            {
                if (timedCells.TryGetValue(cellPos, out TimedTileState st))
                {
                    timedCells.Remove(cellPos);
                    
                    // Always remove the current tile, regardless of doNotRemovePrevious
                    // This is needed for timed disappearing functionality
                    RemoveTile(st.tileDef, cellPos);
                    
                    // If there's a revert-to tile, place it
                    if (st.tileDef.revertToTile != null)
                    {
                        PlaceTile(st.tileDef.revertToTile, cellPos);
                    }
                }
            }
        }
    }

    // Our method to forcibly schedule a tile for timed reversion
    private void RegisterTimedTile(Vector3Int cellPos, TileDefinition tileDef)
    {
        if (tileDef.revertAfterSeconds > 0f && tileDef.revertToTile != null)
        {
            TimedTileState newState;
            newState.tileDef = tileDef;
            newState.timeLeft = tileDef.revertAfterSeconds;
            timedCells[cellPos] = newState;
        }
    }

    // --------------- Re-Use: Placing & Removing Tiles ---------------

    public void PlaceTile(TileDefinition tileDef, Vector3Int cellPos)
    {
        if (!moduleByDefinition.ContainsKey(tileDef))
        {
            Debug.LogWarning($"PlaceTile: {tileDef.displayName} not found in moduleByDefinition.");
            return;
        }
        var module = moduleByDefinition[tileDef];

        // If tileDef is an overlay, do NOT remove the old tile
        // Else we remove the old tile first
        if (!tileDef.keepBottomTile)
        {
            // e.g. if we are placing "DirtWet" which is keepBottomTile=false, 
            // we do remove the old tile from its tilemap
            // but we must find whichever tile is currently there
            TileDefinition existing = FindWhichTileDefinitionAt(cellPos);
            if (existing != null && existing != tileDef)
            {
                RemoveTile(existing, cellPos);
            }
        }

        // Set the cell in the tilemap to have a tile
        // The actual visual appearance is handled by the DualGridTilemapModule system
        // We just need to mark this cell as "filled"
        module.DataTilemap.SetTile(cellPos, ScriptableObject.CreateInstance<Tile>());

        // Set the RenderTilemap color to match the TileDefinition's tintColor
        Transform renderTilemapTransform = module.transform.Find("RenderTilemap");
        if (renderTilemapTransform != null)
        {
            Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
            if (renderTilemap != null)
            {
                renderTilemap.color = tileDef.tintColor;
                
#if UNITY_EDITOR
                if (!Application.isPlaying)
                {
                    UnityEditor.EditorUtility.SetDirty(renderTilemap);
                }
#endif
            }
        }

        // If it has a timed reversion, schedule that
        RegisterTimedTile(cellPos, tileDef);
    }

    public void RemoveTile(TileDefinition tileDef, Vector3Int cellPos)
    {
        if (!moduleByDefinition.ContainsKey(tileDef))
        {
            Debug.LogWarning($"RemoveTile: {tileDef.displayName} not in moduleByDefinition.");
            return;
        }
        var module = moduleByDefinition[tileDef];
        // remove from that tilemap
        module.DataTilemap.SetTile(cellPos, null);

        // Also if this cell was in timedCells for that tile, remove it
        if (timedCells.ContainsKey(cellPos))
        {
            // We only remove if the tile in timedCells is tileDef
            TimedTileState st = timedCells[cellPos];
            if (st.tileDef == tileDef)
            {
                timedCells.Remove(cellPos);
            }
        }
    }

    public TileDefinition FindWhichTileDefinitionAt(Vector3Int cellPos)
    {
        // To ensure we get the top-most visible tile for overlays, we need to check
        // tiles in reverse order (or specifically check overlay tiles first)
    
        // First, try to find any overlay tiles (keepBottomTile = true)
        foreach (var mapping in tileDefinitionMappings)
        {
            if (mapping.tileDef == null || mapping.tilemapModule == null) 
                continue;
            
            // Check specifically for overlay tiles first
            if (mapping.tileDef.keepBottomTile && 
                mapping.tilemapModule.DataTilemap.HasTile(cellPos))
            {
                return mapping.tileDef;
            }
        }
    
        // If no overlay tile found, find any base tile
        foreach (var pair in definitionByModule)
        {
            DualGridTilemapModule module = pair.Key;
            TileDefinition def = pair.Value;

            if (module.DataTilemap.HasTile(cellPos))
            {
                // Found a tile => that's the tile definition
                return def;
            }
        }
        return null;
    }

    // ------------------- Handle Hover & Debug UI (unchanged) -------------------
    private void HandleTileHover()
    {
        if (mainCamera == null || player == null) return;

        Vector3 mouseWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
        mouseWorldPos.z = 0f;
        Vector3Int cellPos = WorldToCell(mouseWorldPos);
        float distance = Vector2.Distance(player.position, CellCenterWorld(cellPos));

        TileDefinition foundTile = FindWhichTileDefinitionAt(cellPos);

        if (debugLogs)
        {
            string tileName = foundTile != null ? foundTile.displayName : "NULL";
            Debug.Log($"[Hover] cell={cellPos}, tile={tileName}, dist={distance:F2}");
        }

        if (distance <= hoverRadius)
        {
            currentlyHoveredCell = cellPos;
            hoveredTileDef = foundTile;
            if (hoverHighlightObject != null)
            {
                hoverHighlightObject.SetActive(true);
                hoverHighlightObject.transform.position = CellCenterWorld(cellPos);
            }
        }
        else
        {
            currentlyHoveredCell = null;
            hoveredTileDef = null;
            if (hoverHighlightObject != null)
                hoverHighlightObject.SetActive(false);
        }
    }

    private void UpdateDebugUI()
    {
        if (hoveredTileText != null)
        {
            if (currentlyHoveredCell.HasValue)
            {
                string tileName = hoveredTileDef != null ? hoveredTileDef.displayName : "None";
                hoveredTileText.text = $"Hovering: {tileName}";
            }
            else
            {
                hoveredTileText.text = "Hovering: (none)";
            }
        }

        if (currentToolText != null)
        {
            // Changed from FindObjectOfType to FindAnyObjectByType for better performance
            ToolSwitcher sw = Object.FindAnyObjectByType<ToolSwitcher>();
            if (sw != null && sw.CurrentTool != null)
            {
                currentToolText.text = $"Tool: {sw.CurrentTool.toolType}";
            }
            else
            {
                currentToolText.text = "Tool: None";
            }
        }
    }

    public Vector3Int WorldToCell(Vector3 worldPos)
    {
        if (interactionGrid != null)
            return interactionGrid.WorldToCell(worldPos);

        if (tileDefinitionMappings.Count > 0 &&
            tileDefinitionMappings[0].tilemapModule != null &&
            tileDefinitionMappings[0].tilemapModule.DataTilemap != null)
        {
            Grid g = tileDefinitionMappings[0].tilemapModule.DataTilemap.layoutGrid;
            return g.WorldToCell(worldPos);
        }

        return Vector3Int.zero;
    }

    private Vector3 CellCenterWorld(Vector3Int cellPos)
    {
        if (interactionGrid != null)
        {
            Vector3 corner = interactionGrid.CellToWorld(cellPos);
            return corner + interactionGrid.cellSize * 0.5f;
        }

        if (tileDefinitionMappings.Count > 0 &&
            tileDefinitionMappings[0].tilemapModule != null &&
            tileDefinitionMappings[0].tilemapModule.DataTilemap != null)
        {
            Grid g = tileDefinitionMappings[0].tilemapModule.DataTilemap.layoutGrid;
            Vector3 corner = g.CellToWorld(cellPos);
            return corner + g.cellSize * 0.5f;
        }

        return Vector3.zero;
    }
    
    // Update the method to include animation and delayed planting
    private void HandleSeedPlanting(Vector3Int cellPosition)
    {
        // Check if we have a PlantPlacementManager
        PlantPlacementManager plantManager = PlantPlacementManager.Instance;
        if (plantManager == null)
        {
            Debug.LogError("Cannot plant: PlantPlacementManager not found in scene!");
            return;
        }

        // Check if this tile is valid for planting
        TileDefinition tileDef = FindWhichTileDefinitionAt(cellPosition);
        if (!plantManager.IsTileValidForPlanting(tileDef))
        {
            // Optionally show a visual cue or play a sound to indicate invalid planting surface
            if (debugLogs)
            {
                string tileName = tileDef != null ? tileDef.displayName : "Unknown";
                Debug.Log($"Cannot plant on {tileName} - invalid tile for planting");
            }
            return; // Exit early, don't even trigger the planting animation
        }

        // Get the player's GardenerController to trigger animation
        GardenerController gardener = player?.GetComponent<GardenerController>();
        if (gardener == null)
        {
            Debug.LogError("Cannot plant: GardenerController not found on player reference!");
            return;
        }

        // Get world position of cell center for planting
        Vector3 worldPosition = CellCenterWorld(cellPosition);
    
        // Start the planting animation
        gardener.Plant();
    
        // Start a coroutine to plant the seed after the animation completes
        StartCoroutine(PlantAfterAnimation(gardener, plantManager, cellPosition, worldPosition));
    }
    
    // New coroutine to handle delayed planting after animation
    private IEnumerator PlantAfterAnimation(GardenerController gardener, PlantPlacementManager plantManager, 
        Vector3Int cellPosition, Vector3 worldPosition)
    {
        // Wait for the planting animation to complete
        yield return new WaitForSeconds(gardener.plantingDuration);
    
        // Try to plant seed at the cell position
        bool planted = plantManager.TryPlantSeed(cellPosition, worldPosition);
    
        if (debugLogs)
        {
            Debug.Log(planted ? 
                $"Planted seed successfully at cell {cellPosition}" : 
                $"Failed to plant seed at cell {cellPosition}");
        }
    }
    
    public void ApplyToolAction(ToolDefinition toolDef)
    {
        if (!currentlyHoveredCell.HasValue)
            return;

        // If we recognized no tile, do nothing
        if (hoveredTileDef == null)
        {
            if (debugLogs) Debug.Log("ApplyToolAction: No recognized tile at hovered cell.");
            return;
        }

        // Check distance
        float distance = Vector2.Distance(player.position, CellCenterWorld(currentlyHoveredCell.Value));
        if (distance > hoverRadius)
        {
            if (debugLogs)
                Debug.Log($"ApplyToolAction: Cell is {distance:F2} away, above {hoverRadius} radius. Aborting.");
            return;
        }

        if (debugLogs)
            Debug.Log(
                $"[ApplyToolAction] Tool={toolDef.toolType}, fromTile={hoveredTileDef.displayName} at cell={currentlyHoveredCell.Value}");

        // ADDED: Special handling for SeedPouch tool type
        if (toolDef.toolType == ToolType.SeedPouch)
        {
            // Handle seed planting action separately
            HandleSeedPlanting(currentlyHoveredCell.Value);
            return;
        }

        // Find matching rule
        TileInteractionRule rule = interactionLibrary.rules.FirstOrDefault(r =>
            r.tool == toolDef &&
            r.fromTile == hoveredTileDef
        );

        if (rule == null)
        {
            Debug.Log($"No rule for tool {toolDef.toolType} on tile {hoveredTileDef.displayName}.");
            return;
        }

        // Check whether the destination tile has keepBottomTile flag before removing source tile
        if (rule.toTile != null)
        {
            // Only remove the original tile if the new tile doesn't have keepBottomTile set
            if (!rule.toTile.keepBottomTile)
            {
                RemoveTile(hoveredTileDef, currentlyHoveredCell.Value);
            }

            // Place the new tile
            PlaceTile(rule.toTile, currentlyHoveredCell.Value);
        }
        else
        {
            // If there's no destination tile, just remove the current one
            RemoveTile(hoveredTileDef, currentlyHoveredCell.Value);
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionRule.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

[Serializable]
public class TileInteractionRule
{
    [Header("Tool Condition")]
    [Tooltip("Which tool triggers this rule.")]
    public ToolDefinition tool;

    [Header("Tile Transformation")]
    [Tooltip("Which tile must be present to apply the rule.")]
    public TileDefinition fromTile;
    [Tooltip("Which tile to transform into.")]
    public TileDefinition toTile;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Editor\TileDefinitionEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(TileDefinition))]
public class TileDefinitionEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
        
        TileDefinition tileDefinition = (TileDefinition)target;
        
        EditorGUILayout.Space();
        if (GUILayout.Button("UPDATE COLOR IN SCENE", GUILayout.Height(30)))
        {
            tileDefinition.UpdateColor();
        }
    }
}
#endif




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Editor\TileInteractionManagerEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(TileInteractionManager))]
public class TileInteractionManagerEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
        
        TileInteractionManager manager = (TileInteractionManager)target;
        
        EditorGUILayout.Space();
        EditorGUILayout.BeginHorizontal();
        
        if (GUILayout.Button("UPDATE SORTING ORDER", GUILayout.Height(30)))
        {
            manager.UpdateSortingOrder();
            EditorUtility.SetDirty(manager);
        }
        
        if (GUILayout.Button("UPDATE ALL COLORS", GUILayout.Height(30)))
        {
            manager.UpdateAllColors();
            EditorUtility.SetDirty(manager);
        }
        
        EditorGUILayout.EndHorizontal();
        
        EditorGUILayout.HelpBox("Order: First item in list gets highest sorting order value (" + 
                                manager.baseSortingOrder + "). Each subsequent item is " + 
                                (manager.baseSortingOrder - 1) + ", " + 
                                (manager.baseSortingOrder - 2) + ", etc.", MessageType.Info);
    }
}
#endif




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "ToolDefinition", menuName = "Tiles/Tool Definition")]
public class ToolDefinition : ScriptableObject
{
    [Tooltip("Which tool type this represents (e.g. Hoe, WateringCan).")]
    public ToolType toolType;

    [Tooltip("Human-readable name (for debugging/UI).")]
    public string displayName;

    [Tooltip("Icon sprite for the tool.")]
    public Sprite icon;

    [Tooltip("Tint color to apply to the icon sprite.")]
    public Color iconTint = Color.white;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolSwitcher.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class ToolSwitcher : MonoBehaviour
{
    [Tooltip("All available tool definitions, e.g. Hoe, WateringCan, etc.")]
    public ToolDefinition[] toolDefinitions;

    private int currentIndex = 0;

    /// <summary>
    /// The currently selected tool definition.
    /// </summary>
    public ToolDefinition CurrentTool { get; private set; } = null;

    private void Start()
    {
        if (toolDefinitions.Length > 0)
        {
            currentIndex = 0;
            CurrentTool = toolDefinitions[currentIndex];
            LogToolChange();
        }
    }

    private void Update()
    {
        if (toolDefinitions.Length == 0) return;

        if (Input.GetKeyDown(KeyCode.Q))
        {
            currentIndex--;
            if (currentIndex < 0)
                currentIndex = toolDefinitions.Length - 1;
            CurrentTool = toolDefinitions[currentIndex];
            LogToolChange();
        }
        else if (Input.GetKeyDown(KeyCode.E))
        {
            currentIndex++;
            if (currentIndex >= toolDefinitions.Length)
                currentIndex = 0;
            CurrentTool = toolDefinitions[currentIndex];
            LogToolChange();
        }
    }

    private void LogToolChange()
    {
        string toolName = (CurrentTool != null) ? CurrentTool.displayName : "(none)";
        Debug.Log($"Switched tool to: {toolName}");
    }
    
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolType.cs
////////////////////////////////////////////////////////////////////////////////
﻿public enum ToolType
{
    None,
    Hoe,
    WateringCan,
    SeedPouch // New tool type
    // etc.
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\NightColorPostProcess.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

// Ensure this script is attached to a GameObject in your scene
public class NightColorPostProcess : MonoBehaviour
{
    [Header("Core References")]
    [Tooltip("Assign the WeatherManager controlling the day/night cycle.")]
    public WeatherManager weatherManager;
    [Tooltip("Assign the Global Post Processing Volume.")]
    public Volume globalVolume;

    // --- Private references to the Volume Overrides ---
    private ColorAdjustments colorAdjustments;
    private FilmGrain filmGrain;
    private Vignette vignette;
    // private Bloom bloom; // Example if you wanted to add Bloom later

    [Header("Color Adjustments")]
    [Tooltip("The color filter at full day (sunIntensity = 1).")]
    public Color dayColorFilter = Color.white;
    [Tooltip("The color filter at full night (sunIntensity ~ 0).")]
    public Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);
    [Tooltip("Daytime Post-Exposure (Higher = brighter).")]
    public float dayPostExposure = 0f;
    [Tooltip("Nighttime Post-Exposure (Lower = darker).")]
    public float nightPostExposure = -0.5f;
    [Tooltip("Saturation at full day (0 = no change, <0 desaturates, >0 saturates).")]
    public float daySaturation = 0f;
    [Tooltip("Saturation at full night (e.g., -50 for more desaturation).")]
    public float nightSaturation = -50f;

    [Header("Film Grain")]
    [Tooltip("Film grain intensity at full day (0 = none).")]
    [Range(0f, 1f)] public float dayFilmGrainIntensity = 0.1f;
    [Tooltip("Film grain intensity at full night (e.g., 0.5 for noticeable grain).")]
    [Range(0f, 1f)] public float nightFilmGrainIntensity = 0.5f;
    // Note: You could also control FilmGrain.response if desired

    [Header("Vignette")]
    [Tooltip("Vignette intensity at full day (0 = none, higher = stronger effect).")]
    [Range(0f, 1f)] public float dayVignetteIntensity = 0.2f;
    [Tooltip("Vignette intensity at full night (e.g., 0.5 for darker edges).")]
    [Range(0f, 1f)] public float nightVignetteIntensity = 0.5f;
    [Tooltip("Vignette smoothness at full day (higher = softer edge).")]
    [Range(0.01f, 1f)] public float dayVignetteSmoothness = 0.2f;
    [Tooltip("Vignette smoothness at full night.")]
    [Range(0.01f, 1f)] public float nightVignetteSmoothness = 0.3f;
    // Note: You could also control Vignette.color or Vignette.rounded if desired


    private void Start()
    {
        // --- Validate Core References ---
        if (!weatherManager)
        {
            Debug.LogError($"[{nameof(NightColorPostProcess)}] WeatherManager not assigned!", this);
            enabled = false; // Disable script if core references are missing
            return;
        }
        if (!globalVolume)
        {
            Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume not assigned!", this);
            enabled = false;
            return;
        }
        if (globalVolume.profile == null)
        {
             Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume has no profile assigned!", this);
             enabled = false;
             return;
        }

        // --- Attempt to Get Volume Overrides ---
        // It's okay if some aren't found, the Update loop will check for null
        if (!globalVolume.profile.TryGet<ColorAdjustments>(out colorAdjustments))
        {
            Debug.LogWarning($"[{nameof(NightColorPostProcess)}] ColorAdjustments override not found in Volume profile.", this);
        }
        if (!globalVolume.profile.TryGet<FilmGrain>(out filmGrain))
        {
             Debug.LogWarning($"[{nameof(NightColorPostProcess)}] FilmGrain override not found in Volume profile.", this);
        }
        if (!globalVolume.profile.TryGet<Vignette>(out vignette))
        {
             Debug.LogWarning($"[{nameof(NightColorPostProcess)}] Vignette override not found in Volume profile.", this);
        }
        // Example for Bloom:
        // if (!globalVolume.profile.TryGet<Bloom>(out bloom))
        // {
        //      Debug.LogWarning($"[{nameof(NightColorPostProcess)}] Bloom override not found in Volume profile.", this);
        // }

        // --- Ensure Overrides are Active ---
        // Make sure the overrides you intend to use are actually enabled on the Volume component itself.
        // You might need to manually check the boxes in the Inspector for ColorAdjustments, FilmGrain, and Vignette.
        // Alternatively, you could force them active here, but it's usually better to configure in the editor:
        // if (colorAdjustments != null) colorAdjustments.active = true;
        // if (filmGrain != null) filmGrain.active = true;
        // if (vignette != null) vignette.active = true;
    }

    private void Update()
    {
        // No need to check weatherManager, Start() already disables if null
        // Check if any overrides are available before proceeding
        if (colorAdjustments == null && filmGrain == null && vignette == null)
            return; // Nothing to update if no overrides were found

        // Get the sun intensity (0 = night, 1 = day) and calculate interpolation factor t
        float sun = Mathf.Clamp01(weatherManager.sunIntensity);
        float t = 1f - sun;  // t=0 at day, t=1 at night

        // --- Interpolate and Apply Color Adjustments ---
        if (colorAdjustments != null)
        {
            colorAdjustments.colorFilter.value = Color.Lerp(dayColorFilter, nightColorFilter, t);
            colorAdjustments.postExposure.value = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
            colorAdjustments.saturation.value = Mathf.Lerp(daySaturation, nightSaturation, t);
        }

        // --- Interpolate and Apply Film Grain ---
        if (filmGrain != null)
        {
            filmGrain.intensity.value = Mathf.Lerp(dayFilmGrainIntensity, nightFilmGrainIntensity, t);
            // You can add Lerp for filmGrain.response here if needed
        }

        // --- Interpolate and Apply Vignette ---
        if (vignette != null)
        {
            vignette.intensity.value = Mathf.Lerp(dayVignetteIntensity, nightVignetteIntensity, t);
            vignette.smoothness.value = Mathf.Lerp(dayVignetteSmoothness, nightVignetteSmoothness, t);
             // You can add Lerp for vignette.color or vignette.rounded here if needed
        }

        // --- Example for Bloom ---
        // if (bloom != null)
        // {
        //     bloom.intensity.value = Mathf.Lerp(dayBloomIntensity, nightBloomIntensity, t);
        // }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\RuntimeCircleDrawer.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/Debug/RuntimeCircleDrawer.cs
using UnityEngine;

/// <summary>
/// Draws a circle outline using a LineRenderer attached to the same GameObject.
/// Requires a LineRenderer component.
/// </summary>
[RequireComponent(typeof(LineRenderer))]
public class RuntimeCircleDrawer : MonoBehaviour
{
    [Range(3, 60)]
    public int segments = 30; // Number of line segments to approximate the circle
    public float radius = 1.0f;
    public float lineWidth = 0.02f;
    public Color color = Color.yellow;
    public Material lineMaterial; // Assign the same material used for firefly lines, or a specific one

    private LineRenderer lineRenderer;
    private bool needsRedraw = true; // Flag to force redraw on first UpdateCircle call or when params change
    private float currentRadius = -1f; // Store current values to detect changes
    private Color currentColor = Color.clear;

    void Awake()
    {
        lineRenderer = GetComponent<LineRenderer>();
        if (lineRenderer == null) { // Should not happen with RequireComponent
            Debug.LogError($"[{gameObject.name}] RuntimeCircleDrawer: Missing required LineRenderer component!");
            enabled = false; // Disable script if component missing
            return;
        }
        ConfigureLineRendererDefaults();
        lineRenderer.enabled = false; // Start hidden
    }

    // Sets initial parameters that don't change often
    void ConfigureLineRendererDefaults()
    {
        lineRenderer.useWorldSpace = false; // Draw relative to this object's transform
        lineRenderer.loop = true; // Connect the last point to the first
        lineRenderer.startWidth = lineWidth;
        lineRenderer.endWidth = lineWidth;
        lineRenderer.material = lineMaterial;

        // Attempt to match sorting with parent sprite
        SpriteRenderer parentSprite = GetComponentInParent<SpriteRenderer>();
        if (parentSprite != null) {
            lineRenderer.sortingLayerName = parentSprite.sortingLayerName;
            lineRenderer.sortingOrder = parentSprite.sortingOrder + 1; // Draw slightly in front
        } else {
            // Default sorting if no parent sprite found
            lineRenderer.sortingLayerName = "Default";
            lineRenderer.sortingOrder = 1;
        }
    }

    // Call this method to update the circle's appearance and make it visible
    public void UpdateCircle(float newRadius, Color newColor)
    {
        // Check if parameters have actually changed
        if (!needsRedraw && Mathf.Approximately(currentRadius, newRadius) && currentColor == newColor)
        {
            // Ensure it's enabled if it wasn't already
             if (!lineRenderer.enabled) lineRenderer.enabled = true;
            return; // No change needed
        }

        // Update stored values
        currentRadius = newRadius;
        radius = newRadius; // Update public field for potential inspector viewing
        currentColor = newColor;
        color = newColor; // Update public field

        // Update LineRenderer appearance settings that might change
        lineRenderer.startColor = currentColor;
        lineRenderer.endColor = currentColor;
        // Update width if you add properties for it too
        // lineRenderer.startWidth = newWidth;
        // lineRenderer.endWidth = newWidth;

        DrawCircle(); // Recalculate points
        lineRenderer.enabled = true; // Ensure it's visible
        needsRedraw = false; // Mark as drawn
    }

    // Call this to hide the circle
    public void HideCircle()
    {
        if (lineRenderer != null && lineRenderer.enabled)
        {
            lineRenderer.enabled = false;
            needsRedraw = true; // Needs redraw next time it's shown
        }
    }

    void DrawCircle()
    {
        if (lineRenderer == null || segments <= 2 || radius <= 0f) {
            lineRenderer.positionCount = 0; // Clear points if invalid params
            return;
        };

        // Only resize array if segment count changes (optimization)
        if (lineRenderer.positionCount != segments + 1) {
            lineRenderer.positionCount = segments + 1;
        }

        float angleStep = 360f / segments;
        Vector3[] points = new Vector3[segments + 1];

        for (int i = 0; i <= segments; i++)
        {
            float currentAngle = Mathf.Deg2Rad * (i * angleStep);
            float x = Mathf.Cos(currentAngle) * radius;
            float y = Mathf.Sin(currentAngle) * radius;
            points[i] = new Vector3(x, y, 0); // Z is 0 for local space relative to transform
        }

        lineRenderer.SetPositions(points);
    }
}





--------------------------------------------------------------------------------
This is the final part (5 of 5).
--------------------------------------------------------------------------------