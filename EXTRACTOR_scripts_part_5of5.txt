This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-04-07 21:13:16
PART 5 OF 5
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   └── NodeDefinitionPostprocessor.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   └── Animal_Fox.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   └── PlantPrefab.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       └── ThoughtBubble.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   ├── PLains_0_Corner_LT.asset
│       │   ├── PLains_10.asset
│       │   ├── PLains_100.asset
│       │   ├── PLains_101.asset
│       │   ├── PLains_102.asset
│       │   ├── PLains_11.asset
│       │   ├── PLains_12.asset
│       │   ├── PLains_13.asset
│       │   ├── PLains_14.asset
│       │   ├── PLains_15.asset
│       │   ├── PLains_16.asset
│       │   ├── PLains_17.asset
│       │   ├── PLains_18.asset
│       │   ├── PLains_19.asset
│       │   ├── PLains_1_T.asset
│       │   ├── PLains_20.asset
│       │   ├── PLains_21.asset
│       │   ├── PLains_22.asset
│       │   ├── PLains_23.asset
│       │   ├── PLains_24.asset
│       │   ├── PLains_25.asset
│       │   ├── PLains_26.asset
│       │   ├── PLains_27.asset
│       │   ├── PLains_28.asset
│       │   ├── PLains_29.asset
│       │   ├── PLains_2_Corner_RT.asset
│       │   ├── PLains_30.asset
│       │   ├── PLains_31.asset
│       │   ├── PLains_32.asset
│       │   ├── PLains_33.asset
│       │   ├── PLains_34.asset
│       │   ├── PLains_35.asset
│       │   ├── PLains_36.asset
│       │   ├── PLains_37.asset
│       │   ├── PLains_38.asset
│       │   ├── PLains_39.asset
│       │   ├── PLains_3_Single_B.asset
│       │   ├── PLains_40.asset
│       │   ├── PLains_41.asset
│       │   ├── PLains_42.asset
│       │   ├── PLains_43.asset
│       │   ├── PLains_44.asset
│       │   ├── PLains_45.asset
│       │   ├── PLains_46.asset
│       │   ├── PLains_47.asset
│       │   ├── PLains_48.asset
│       │   ├── PLains_49.asset
│       │   ├── PLains_4_Single_B.TR.asset
│       │   ├── PLains_5.asset
│       │   ├── PLains_50.asset
│       │   ├── PLains_51.asset
│       │   ├── PLains_52_Grass_Center.asset
│       │   ├── PLains_53_Grass_Center.asset
│       │   ├── PLains_54_Grass_Center.asset
│       │   ├── PLains_55.asset
│       │   ├── PLains_56_Grass_Center.asset
│       │   ├── PLains_57.asset
│       │   ├── PLains_58.asset
│       │   ├── PLains_59.asset
│       │   ├── PLains_6.asset
│       │   ├── PLains_60.asset
│       │   ├── PLains_61_Grass_Center.asset
│       │   ├── PLains_62_Grass_Center.asset
│       │   ├── PLains_63.asset
│       │   ├── PLains_64_Grass_Center.asset
│       │   ├── PLains_65.asset
│       │   ├── PLains_66.asset
│       │   ├── PLains_67.asset
│       │   ├── PLains_68.asset
│       │   ├── PLains_69.asset
│       │   ├── PLains_7.asset
│       │   ├── PLains_70.asset
│       │   ├── PLains_71.asset
│       │   ├── PLains_72.asset
│       │   ├── PLains_73.asset
│       │   ├── PLains_74.asset
│       │   ├── PLains_75.asset
│       │   ├── PLains_76.asset
│       │   ├── PLains_77.asset
│       │   ├── PLains_78.asset
│       │   ├── PLains_79.asset
│       │   ├── PLains_8.asset
│       │   ├── PLains_80.asset
│       │   ├── PLains_81.asset
│       │   ├── PLains_82.asset
│       │   ├── PLains_83.asset
│       │   ├── PLains_84.asset
│       │   ├── PLains_85.asset
│       │   ├── PLains_86.asset
│       │   ├── PLains_87.asset
│       │   ├── PLains_88.asset
│       │   ├── PLains_89.asset
│       │   ├── PLains_9.asset
│       │   ├── PLains_90.asset
│       │   ├── PLains_91.asset
│       │   ├── PLains_92.asset
│       │   ├── PLains_93.asset
│       │   ├── PLains_94.asset
│       │   ├── PLains_95.asset
│       │   ├── PLains_96.asset
│       │   ├── PLains_97.asset
│       │   ├── PLains_98.asset
│       │   └── PLains_99.asset
│       ├── Palette_GroundTiles.prefab
│       └── Rule Tiles
│           └── TilingMaterial_Grass.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   └── Animal_000_Bunny.asset
│   ├── Animals Diet
│   │   └── Diet_000_Bunny.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   └── Nodes Plant
│       ├── NodeDefinitionLibrary.asset
│       ├── Node_000_Seed.asset
│       └── Node_001_Berry.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   └── ThoughtTrigger.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   └── Plants
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Tiles
│   │   ├── Data
│   │   │   └── TilingMaterialDefinition.cs
│   │   └── Editor
│   │       └── TilingMaterialGeneratorEditor.cs
│   ├── UI
│   └── Visuals
│       └── NightColorPostProcess.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Test
├── TextureImporter.preset
├── Tiles
│   └── GeneratedRuleTiles
│       └── Grass_WangRuleTile.asset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Editor\TilingMaterialGeneratorEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;          // Required for Editor, SerializedObject, etc.
using UnityEngine.Tilemaps; // Required for RuleTile, Tile
using System.Collections.Generic;
using System.IO;            // Required for path manipulation
using System.Text;          // Required for StringBuilder
using System.Linq;          // Required for OfType() and OrderBy()

[CustomEditor(typeof(TilingMaterialDefinition))]
public class TilingMaterialGeneratorEditor : Editor
{
    // Target script properties
    private SerializedProperty materialNameProp;
    private SerializedProperty spritesProp;
    private SerializedProperty defaultColliderProp;
    private SerializedProperty defaultGameObjectProp;
    private SerializedProperty tintColorProp;

    // Editor-only fields
    private Texture2D sourceSpriteSheet;
    private TilePalette targetPalette; // Type requires UnityEditor.Tilemaps namespace
    private bool addToPalette = true;

    private const string outputFolderPath = "Assets/Tiles/GeneratedRuleTiles"; // Adjust as needed

    private void OnEnable()
    {
        materialNameProp = serializedObject.FindProperty("materialName");
        spritesProp = serializedObject.FindProperty("sprites");
        defaultColliderProp = serializedObject.FindProperty("defaultCollider");
        defaultGameObjectProp = serializedObject.FindProperty("defaultGameObject");
        tintColorProp = serializedObject.FindProperty("tintColor");
    }

    public override void OnInspectorGUI()
    {
        TilingMaterialDefinition definition = (TilingMaterialDefinition)target;
        serializedObject.Update();

        EditorGUILayout.PropertyField(materialNameProp);
        EditorGUILayout.Space();

        // --- Auto-Fill Section ---
        EditorGUILayout.LabelField("Auto-Fill Sprites (Optional)", EditorStyles.boldLabel);
        sourceSpriteSheet = (Texture2D)EditorGUILayout.ObjectField(
            new GUIContent("Source Spritesheet", "Drag a sliced spritesheet Texture (16 sprites, named correctly) here."),
            sourceSpriteSheet, typeof(Texture2D), false);

        if (GUILayout.Button("Auto-Fill Sprites From Source Sheet")) {
            if (sourceSpriteSheet != null) AutoFillSpritesFromSheet(definition, sourceSpriteSheet);
            else EditorUtility.DisplayDialog("No Source Sheet", "Please assign a Source Spritesheet first.", "OK");
        }
        EditorGUILayout.HelpBox("Requires Texture sliced into 16 sprites named like 'Name_0' to 'Name_15'.", MessageType.Info);
        EditorGUILayout.Space();

        // --- Manual Sprite Assignment Section ---
        EditorGUILayout.LabelField("Manual Sprite Assignment (Indices 0-15)", EditorStyles.boldLabel);
        EditorGUILayout.HelpBox("Index based on NESW neighbours (N=8, E=4, S=2, W=1). Sum values for matching sides.", MessageType.Info);
        if (spritesProp.arraySize != 16) spritesProp.arraySize = 16;
        for (int i = 0; i < 16; i++) {
            string tooltip = GetTooltipForWangIndex(i);
            EditorGUILayout.PropertyField(spritesProp.GetArrayElementAtIndex(i), new GUIContent($"Sprite {i}", tooltip));
        }
        EditorGUILayout.Space();

        // --- Generated Tile Settings Section ---
        EditorGUILayout.LabelField("Generated Tile Settings", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(defaultColliderProp);
        EditorGUILayout.PropertyField(defaultGameObjectProp);
        EditorGUILayout.PropertyField(tintColorProp);
        EditorGUILayout.Space();

        // --- Palette Automation Section ---
        EditorGUILayout.LabelField("Tile Palette Automation", EditorStyles.boldLabel);
        addToPalette = EditorGUILayout.Toggle(new GUIContent("Add to Palette on Generate", "Automatically add the generated RuleTile to the selected Tile Palette asset below."), addToPalette);
        EditorGUI.BeginDisabledGroup(!addToPalette);
        // ObjectField requires the correct type, which comes from the namespace
        targetPalette = (TilePalette)EditorGUILayout.ObjectField(
            new GUIContent("Target Palette", "Drag the Tile Palette asset you want to add the generated tile to."),
            targetPalette,
            typeof(TilePalette), // Type defined in UnityEditor.Tilemaps
            false
        );
        EditorGUI.EndDisabledGroup();
        EditorGUILayout.Space();


        // --- Generation Button ---
        GUI.backgroundColor = Color.cyan;
        if (GUILayout.Button("Generate/Update RuleTile", GUILayout.Height(35))) {
            if (ValidateSprites(definition)) {
                if (addToPalette && targetPalette == null) {
                    EditorUtility.DisplayDialog("Palette Missing", "Please assign a Target Palette asset or uncheck 'Add to Palette'.", "OK");
                } else if (EditorUtility.DisplayDialog("Confirm RuleTile Generation", $"Create/Update RuleTile for '{definition.materialName}'?", "Generate", "Cancel")) {
                    GenerateRuleTileAsset(definition);
                }
            } else {
                EditorUtility.DisplayDialog("Sprite Error", "Assign all 16 sprite slots first.", "OK");
            }
        }
        GUI.backgroundColor = Color.white;

        serializedObject.ApplyModifiedProperties();
    }

    // --- Auto-Fill Logic ---
    private void AutoFillSpritesFromSheet(TilingMaterialDefinition definition, Texture2D sheet)
    {
        string path = AssetDatabase.GetAssetPath(sheet);
        if (string.IsNullOrEmpty(path)) return;

        Object[] loadedAssets = AssetDatabase.LoadAllAssetRepresentationsAtPath(path);
        List<Sprite> loadedSprites = loadedAssets.OfType<Sprite>()
            .Select(sprite => new { Sprite = sprite, SortKey = GetSortKeyFromName(sprite.name) })
            .OrderBy(item => item.SortKey)
            .Select(item => item.Sprite)
            .ToList();

        if (loadedSprites.Count != 16) {
            EditorUtility.DisplayDialog("Sprite Count Error", $"Found {loadedSprites.Count}/16 sprites in '{sheet.name}'. Check slicing and naming (e.g., Name_0 to Name_15).", "OK");
            return;
        }

        serializedObject.Update();
        bool changed = false;
        for (int i = 0; i < 16; i++) {
            SerializedProperty prop = spritesProp.GetArrayElementAtIndex(i);
            if (prop.objectReferenceValue != loadedSprites[i]) {
                prop.objectReferenceValue = loadedSprites[i];
                changed = true;
            }
        }

        if (changed) {
            serializedObject.ApplyModifiedProperties();
            EditorUtility.SetDirty(definition);
            EditorUtility.DisplayDialog("Success", "Auto-filled 16 sprites.", "OK");
        } else {
            EditorUtility.DisplayDialog("No Changes", "Sprites already assigned.", "OK");
        }
    }

    // --- Helper function to extract numeric sort key from sprite name ---
    private int GetSortKeyFromName(string spriteName)
    {
        int lastUnderscore = spriteName.LastIndexOf('_');
        if (lastUnderscore != -1 && lastUnderscore < spriteName.Length - 1) {
            if (int.TryParse(spriteName.Substring(lastUnderscore + 1), out int number)) {
                return number;
            }
        }
        Debug.LogWarning($"Could not parse number from sprite name '{spriteName}'. Using fallback sort.");
        return int.MaxValue;
    }

    // --- Sprite Validation ---
    private bool ValidateSprites(TilingMaterialDefinition definition)
    {
        if (definition.sprites == null || definition.sprites.Length != 16) return false;
        return !definition.sprites.Any(sprite => sprite == null);
    }

    // --- Tooltip Generation Helper ---
    private string GetTooltipForWangIndex(int index)
    {
        if (index < 0 || index > 15) return "Invalid Index";
        StringBuilder sb = new StringBuilder();
        sb.Append($"Index {index} ({System.Convert.ToString(index, 2).PadLeft(4, '0')}): Matches ");
        List<string> dirs = new List<string>();
        if ((index & 8) != 0) dirs.Add("N"); if ((index & 4) != 0) dirs.Add("E");
        if ((index & 2) != 0) dirs.Add("S"); if ((index & 1) != 0) dirs.Add("W");
        if (dirs.Count == 0) sb.Append("None"); else sb.Append(string.Join("+", dirs));
        return sb.ToString();
    }

    // --- RuleTile Generation Logic ---
    private void GenerateRuleTileAsset(TilingMaterialDefinition definition)
    {
        if (!Directory.Exists(outputFolderPath)) { Directory.CreateDirectory(outputFolderPath); AssetDatabase.Refresh(); }

        string assetName = $"{definition.materialName}_WangRuleTile.asset";
        string assetPath = Path.Combine(outputFolderPath, assetName).Replace("\\", "/");
        RuleTile ruleTile = AssetDatabase.LoadAssetAtPath<RuleTile>(assetPath);
        bool createdNew = false;
        if (ruleTile == null) { ruleTile = ScriptableObject.CreateInstance<RuleTile>(); AssetDatabase.CreateAsset(ruleTile, assetPath); createdNew = true; }

        SerializedObject tileSO = new SerializedObject(ruleTile);
        SerializedProperty defaultSpriteProp_Tile = tileSO.FindProperty("m_DefaultSprite");
        SerializedProperty defaultGoProp_Tile = tileSO.FindProperty("m_DefaultGameObject");
        SerializedProperty defaultColliderProp_Tile = tileSO.FindProperty("m_DefaultColliderType");
        SerializedProperty rulesProp = tileSO.FindProperty("m_TilingRules");
        SerializedProperty colorProp = tileSO.FindProperty("m_Color");

        defaultSpriteProp_Tile.objectReferenceValue = definition.sprites[15];
        defaultGoProp_Tile.objectReferenceValue = definition.defaultGameObject;
        defaultColliderProp_Tile.enumValueIndex = (int)definition.defaultCollider;
        colorProp.colorValue = definition.tintColor;

        rulesProp.ClearArray();
        Tile.ColliderType defaultCollider = (Tile.ColliderType)defaultColliderProp_Tile.enumValueIndex;
        for (int i = 0; i < 16; i++) {
            if (definition.sprites[i] == null) continue;
            AddRule(tileSO.targetObject, rulesProp, definition.sprites[i], GetNeighborsFromWangIndex(i), defaultCollider);
        }

        tileSO.ApplyModifiedProperties();
        EditorUtility.SetDirty(ruleTile);
        if (createdNew) Debug.Log($"Created RuleTile: {assetPath}"); else Debug.Log($"Updated RuleTile: {assetPath}");

        // --- Add to Palette Logic ---
        if (addToPalette && targetPalette != null)
        {
            // GridPaintingState and related methods require UnityEditor.Tilemaps namespace
            try
            {
                GridPaintingState.palette = targetPalette;
                GridPaintingState.UnlockPalette();
                GridPaintingState.SetTile(null, ruleTile); // Adds or updates tile
                EditorUtility.SetDirty(targetPalette);
                GridPaintingState.SavePalette();
                GridPaintingState.LockPalette(true);
                Debug.Log($"Added/Updated '{ruleTile.name}' in palette '{targetPalette.name}'.");
            }
            catch (System.Exception e) {
                Debug.LogError($"Failed to add tile to palette '{targetPalette.name}': {e.Message}");
                if (GridPaintingState.palette == targetPalette) GridPaintingState.LockPalette(true);
            }
            finally {
                 GridPaintingState.palette = null; // Reset active palette
            }
        }
        // --- End Add to Palette ---

        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
        EditorGUIUtility.PingObject(ruleTile);
    }

    // --- Helper to convert index to neighbor array (NESW = 8421) ---
    private int[] GetNeighborsFromWangIndex(int index)
    {
        const int T = RuleTile.TilingRule.Neighbor.This, N = RuleTile.TilingRule.Neighbor.NotThis;
        bool n=(index&8)!=0, e=(index&4)!=0, s=(index&2)!=0, w=(index&1)!=0;
        int nN=n?T:N, nE=e?T:N, nS=s?T:N, nW=w?T:N;
        int nTL=(n&&w)?T:N, nTR=(n&&e)?T:N, nBL=(s&&w)?T:N, nBR=(s&&e)?T:N;
        return new int[]{nTL, nN, nTR, nW, nE, nBL, nS, nBR};
    }

    // --- Helper to add a rule using SerializedProperty API ---
    private void AddRule(Object targetObject, SerializedProperty rulesListProp, Sprite sprite, int[] neighbors, Tile.ColliderType defaultColliderType)
    {
        rulesListProp.InsertArrayElementAtIndex(rulesListProp.arraySize);
        SerializedProperty newRuleProp = rulesListProp.GetArrayElementAtIndex(rulesListProp.arraySize - 1);
        SerializedProperty neighborsProp = newRuleProp.FindPropertyRelative("m_Neighbors");
        SerializedProperty spritesProp = newRuleProp.FindPropertyRelative("m_Sprites");
        SerializedProperty outputProp = newRuleProp.FindPropertyRelative("m_Output");
        SerializedProperty colliderProp = newRuleProp.FindPropertyRelative("m_ColliderType");
        SerializedProperty transformProp = newRuleProp.FindPropertyRelative("m_RuleTransform");

        if (neighborsProp.arraySize != 8) neighborsProp.arraySize = 8;
        for (int i = 0; i < 8; i++) { neighborsProp.GetArrayElementAtIndex(i).intValue = neighbors[i]; }
        if (spritesProp.arraySize != 1) spritesProp.arraySize = 1;
        spritesProp.GetArrayElementAtIndex(0).objectReferenceValue = sprite;
        outputProp.enumValueIndex = (int)RuleTile.TilingRule.OutputSprite.Single;
        colliderProp.enumValueIndex = (int)defaultColliderType;
        transformProp.enumValueIndex = (int)RuleTile.TilingRule.Transform.Fixed;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\NightColorPostProcess.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class NightColorPostProcess : MonoBehaviour
{
    [Header("References")]
    public WeatherManager weatherManager;        // Assign your existing WeatherManager
    public Volume globalVolume;                  // The Volume with the Color Adjustments override

    private ColorAdjustments colorAdjustments;   // We'll read/write color filter, post exposure, and saturation

    [Header("Color Settings")]
    [Tooltip("The color filter at full day (sunIntensity = 1).")]
    public Color dayColorFilter = Color.white;
    [Tooltip("The color filter at full night (sunIntensity ~ 0).")]
    public Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);

    [Tooltip("Daytime Post-Exposure (e.g. 0). Higher = brighter.")]
    public float dayPostExposure = 0f;
    [Tooltip("Nighttime Post-Exposure (e.g. -0.5). Lower = darker.")]
    public float nightPostExposure = -0.5f;

    [Header("Saturation Settings")]
    [Tooltip("Saturation at full day (0 means no change).")]
    public float daySaturation = 0f;
    [Tooltip("Saturation at full night (e.g. -50 for more desaturation at night).")]
    public float nightSaturation = -50f;

    private void Start()
    {
        if (!globalVolume)
        {
            Debug.LogWarning("[NightColorPostProcess] No globalVolume assigned!");
            return;
        }

        // Try to get the ColorAdjustments override from the volume's profile
        if (globalVolume.profile.TryGet<ColorAdjustments>(out var colorAdj))
        {
            colorAdjustments = colorAdj;
        }
        else
        {
            Debug.LogWarning("[NightColorPostProcess] No ColorAdjustments override found in the Volume profile!");
        }
    }

    private void Update()
    {
        if (!weatherManager || colorAdjustments == null)
            return;
        
        // Get the sun intensity (0 = night, 1 = day)
        float sun = Mathf.Clamp01(weatherManager.sunIntensity);
        float t = 1f - sun;  // t=0 at day, t=1 at night
        
        // Lerp the color filter
        Color finalFilter = Color.Lerp(dayColorFilter, nightColorFilter, t);
        colorAdjustments.colorFilter.value = finalFilter;
        
        // Lerp post exposure
        float finalExposure = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
        colorAdjustments.postExposure.value = finalExposure;
        
        // Lerp saturation
        float finalSaturation = Mathf.Lerp(daySaturation, nightSaturation, t);
        colorAdjustments.saturation.value = finalSaturation;
    }
}







--------------------------------------------------------------------------------
This is the final part (5 of 5).
--------------------------------------------------------------------------------