This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-04-07 21:13:16
================================================================================

DIRECTORY STRUCTURE
--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   └── NodeDefinitionPostprocessor.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   └── Animal_Fox.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   └── PlantPrefab.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       └── ThoughtBubble.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   ├── PLains_0_Corner_LT.asset
│       │   ├── PLains_10.asset
│       │   ├── PLains_100.asset
│       │   ├── PLains_101.asset
│       │   ├── PLains_102.asset
│       │   ├── PLains_11.asset
│       │   ├── PLains_12.asset
│       │   ├── PLains_13.asset
│       │   ├── PLains_14.asset
│       │   ├── PLains_15.asset
│       │   ├── PLains_16.asset
│       │   ├── PLains_17.asset
│       │   ├── PLains_18.asset
│       │   ├── PLains_19.asset
│       │   ├── PLains_1_T.asset
│       │   ├── PLains_20.asset
│       │   ├── PLains_21.asset
│       │   ├── PLains_22.asset
│       │   ├── PLains_23.asset
│       │   ├── PLains_24.asset
│       │   ├── PLains_25.asset
│       │   ├── PLains_26.asset
│       │   ├── PLains_27.asset
│       │   ├── PLains_28.asset
│       │   ├── PLains_29.asset
│       │   ├── PLains_2_Corner_RT.asset
│       │   ├── PLains_30.asset
│       │   ├── PLains_31.asset
│       │   ├── PLains_32.asset
│       │   ├── PLains_33.asset
│       │   ├── PLains_34.asset
│       │   ├── PLains_35.asset
│       │   ├── PLains_36.asset
│       │   ├── PLains_37.asset
│       │   ├── PLains_38.asset
│       │   ├── PLains_39.asset
│       │   ├── PLains_3_Single_B.asset
│       │   ├── PLains_40.asset
│       │   ├── PLains_41.asset
│       │   ├── PLains_42.asset
│       │   ├── PLains_43.asset
│       │   ├── PLains_44.asset
│       │   ├── PLains_45.asset
│       │   ├── PLains_46.asset
│       │   ├── PLains_47.asset
│       │   ├── PLains_48.asset
│       │   ├── PLains_49.asset
│       │   ├── PLains_4_Single_B.TR.asset
│       │   ├── PLains_5.asset
│       │   ├── PLains_50.asset
│       │   ├── PLains_51.asset
│       │   ├── PLains_52_Grass_Center.asset
│       │   ├── PLains_53_Grass_Center.asset
│       │   ├── PLains_54_Grass_Center.asset
│       │   ├── PLains_55.asset
│       │   ├── PLains_56_Grass_Center.asset
│       │   ├── PLains_57.asset
│       │   ├── PLains_58.asset
│       │   ├── PLains_59.asset
│       │   ├── PLains_6.asset
│       │   ├── PLains_60.asset
│       │   ├── PLains_61_Grass_Center.asset
│       │   ├── PLains_62_Grass_Center.asset
│       │   ├── PLains_63.asset
│       │   ├── PLains_64_Grass_Center.asset
│       │   ├── PLains_65.asset
│       │   ├── PLains_66.asset
│       │   ├── PLains_67.asset
│       │   ├── PLains_68.asset
│       │   ├── PLains_69.asset
│       │   ├── PLains_7.asset
│       │   ├── PLains_70.asset
│       │   ├── PLains_71.asset
│       │   ├── PLains_72.asset
│       │   ├── PLains_73.asset
│       │   ├── PLains_74.asset
│       │   ├── PLains_75.asset
│       │   ├── PLains_76.asset
│       │   ├── PLains_77.asset
│       │   ├── PLains_78.asset
│       │   ├── PLains_79.asset
│       │   ├── PLains_8.asset
│       │   ├── PLains_80.asset
│       │   ├── PLains_81.asset
│       │   ├── PLains_82.asset
│       │   ├── PLains_83.asset
│       │   ├── PLains_84.asset
│       │   ├── PLains_85.asset
│       │   ├── PLains_86.asset
│       │   ├── PLains_87.asset
│       │   ├── PLains_88.asset
│       │   ├── PLains_89.asset
│       │   ├── PLains_9.asset
│       │   ├── PLains_90.asset
│       │   ├── PLains_91.asset
│       │   ├── PLains_92.asset
│       │   ├── PLains_93.asset
│       │   ├── PLains_94.asset
│       │   ├── PLains_95.asset
│       │   ├── PLains_96.asset
│       │   ├── PLains_97.asset
│       │   ├── PLains_98.asset
│       │   └── PLains_99.asset
│       ├── Palette_GroundTiles.prefab
│       └── Rule Tiles
│           └── TilingMaterial_Grass.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   └── Animal_000_Bunny.asset
│   ├── Animals Diet
│   │   └── Diet_000_Bunny.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   └── Nodes Plant
│       ├── NodeDefinitionLibrary.asset
│       ├── Node_000_Seed.asset
│       └── Node_001_Berry.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   └── ThoughtTrigger.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   └── Plants
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Tiles
│   │   ├── Data
│   │   │   └── TilingMaterialDefinition.cs
│   │   └── Editor
│   │       └── TilingMaterialGeneratorEditor.cs
│   ├── UI
│   └── Visuals
│       └── NightColorPostProcess.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Test
├── TextureImporter.preset
├── Tiles
│   └── GeneratedRuleTiles
│       └── Grass_WangRuleTile.asset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionAutoAdder.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionAutoAdder : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets,
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string folderPath = Path.GetDirectoryName(assetPath);
                string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
                if (libraryFiles.Length > 0)
                {
                    NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
                    if (library != null && !library.definitions.Contains(nodeDef))
                    {
                        library.definitions.Add(nodeDef);
                        EditorUtility.SetDirty(library);
                        AssetDatabase.SaveAssets();
                    }
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionCreator.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;

public static class NodeDefinitionCreator
{
    private const string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

    [MenuItem(MenuPath, false, 50)]
    public static void CreateNodeDefinition()
    {
        // Figure out which folder the user is in, or use Assets/
        string folder = GetSelectedPathOrFallback();

        // Determine the next numeric index for "Node_XXX_"
        int nextNumber = GetNextNodeNumber(folder);

        // e.g., "Node_007_"
        string newName = $"Node_{nextNumber:D3}_";
        string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

        // Create the NodeDefinition
        NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
        AssetDatabase.CreateAsset(nodeDef, newPath);
        
        // Save and refresh, but DO NOT select or focus the ProjectWindow.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        Debug.Log($"Created NodeDefinition at: {newPath}");
        // Notice we don't call Selection.activeObject = nodeDef
        // or EditorUtility.FocusProjectWindow()
        // or ProjectWindowUtil.ShowCreatedAsset(nodeDef)
        // thus we avoid changing the user's folder.
    }

    // (Optional) Validate the menu item so it’s disabled if the game is running
    [MenuItem(MenuPath, true)]
    private static bool ValidateCreateNodeDefinition()
    {
        return !Application.isPlaying;
    }

    private static string GetSelectedPathOrFallback()
    {
        // Attempt to get the folder the user has selected in the Project window
        string path = "Assets";
        foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets))
        {
            path = AssetDatabase.GetAssetPath(obj);
            if (!string.IsNullOrEmpty(path))
            {
                // If it's a file, get its parent folder
                if (File.Exists(path))
                {
                    path = Path.GetDirectoryName(path);
                }
                break;
            }
        }
        return path;
    }

    private static int GetNextNodeNumber(string folderPath)
    {
        int nextNumber = 1;
        // Look for existing Node_XXX_ files
        string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
        foreach (var file in files)
        {
            string fName = Path.GetFileNameWithoutExtension(file);
            if (fName.StartsWith("Node_") && fName.Length >= 8)
            {
                // extract the 3-digit number from Node_000_
                string numberPart = fName.Substring(5, 3);
                if (int.TryParse(numberPart, out int num) && num >= nextNumber)
                {
                    nextNumber = num + 1;
                }
            }
        }
        return nextNumber;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(NodeDefinition))]
public class NodeDefinitionEditor : Editor
{
    // Serialized properties for all the fields in NodeDefinition
    SerializedProperty displayName;
    SerializedProperty description;
    SerializedProperty thumbnail;
    SerializedProperty thumbnailTintColor;
    SerializedProperty backgroundColor;
    SerializedProperty nodeViewPrefab;
    SerializedProperty effects;

    private void OnEnable()
    {
        displayName = serializedObject.FindProperty("displayName");
        description = serializedObject.FindProperty("description");
        thumbnail = serializedObject.FindProperty("thumbnail");
        thumbnailTintColor = serializedObject.FindProperty("thumbnailTintColor");
        backgroundColor = serializedObject.FindProperty("backgroundColor");
        nodeViewPrefab = serializedObject.FindProperty("nodeViewPrefab");
        effects = serializedObject.FindProperty("effects");
    }

    public override void OnInspectorGUI()
    {
        serializedObject.Update();

        // "Display" section
        EditorGUILayout.LabelField("Display", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(displayName);
        EditorGUILayout.PropertyField(description);
        EditorGUILayout.PropertyField(thumbnail);
        EditorGUILayout.PropertyField(thumbnailTintColor);
        EditorGUILayout.PropertyField(backgroundColor);

        EditorGUILayout.Space();

        // "Prefab & Effects" section
        EditorGUILayout.LabelField("Prefab & Effects", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(nodeViewPrefab);

        // Draw the effects field with a minimum height
        EditorGUILayout.PropertyField(effects, new GUIContent("Effects"), true, GUILayout.MinHeight(1300f));

        serializedObject.ApplyModifiedProperties();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionLibraryEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;

[CustomEditor(typeof(NodeDefinitionLibrary))]
public class NodeDefinitionLibraryEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            UpdateLibrary();
        }
    }

    private void UpdateLibrary()
    {
        NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

        // Get the folder of the current library asset.
        string libraryPath = AssetDatabase.GetAssetPath(library);
        string folderPath = Path.GetDirectoryName(libraryPath);

        // Find all .asset files in the folder.
        string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

        // Load NodeDefinition assets from that folder.
        List<NodeDefinition> defs = new List<NodeDefinition>();
        foreach (string file in assetFiles)
        {
            // Ignore the library asset itself.
            if (file == libraryPath)
                continue;

            NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
            if (def != null)
                defs.Add(def);
        }

        // Sort definitions by the numeric portion in the file name (assumes "Node_XXX_...").
        defs = defs.OrderBy(d => {
            string name = d.name;
            if (name.StartsWith("Node_") && name.Length >= 8)
            {
                string numStr = name.Substring(5, 3);
                if (int.TryParse(numStr, out int num))
                    return num;
            }
            return int.MaxValue; // if no number is found, sort last.
        }).ToList();

        library.definitions = defs;
        EditorUtility.SetDirty(library);
        AssetDatabase.SaveAssets();
        Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionPostprocessor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionPostprocessor : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, 
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string fileName = Path.GetFileNameWithoutExtension(assetPath);
                // Check if file name already starts with "Node_"
                if (!fileName.StartsWith("Node_"))
                {
                    string folderPath = Path.GetDirectoryName(assetPath);
                    // Get all files in folder that start with "Node_"
                    var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
                    int nextNumber = 1;
                    foreach (var file in files)
                    {
                        string fName = Path.GetFileNameWithoutExtension(file);
                        string[] parts = fName.Split('_');
                        if (parts.Length >= 2 && int.TryParse(parts[1], out int num))
                        {
                            if (num >= nextNumber)
                                nextNumber = num + 1;
                        }
                    }
                    string newName = $"Node_{nextNumber:D3}_";
                    AssetDatabase.RenameAsset(assetPath, newName);
                    AssetDatabase.SaveAssets();
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantCell.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantCell.cs (or similar path)
using UnityEngine;

public class PlantCell : MonoBehaviour
{
    // Set these references when the cell is spawned by PlantGrowth
    [HideInInspector] public PlantGrowth ParentPlantGrowth;
    [HideInInspector] public Vector2Int GridCoord;
    [HideInInspector] public PlantCellType CellType; // Store type info here

    // Called automatically by Unity when this GameObject is destroyed
    private void OnDestroy()
    {
        // Notify the parent plant that this cell is gone, if the parent still exists
        if (ParentPlantGrowth != null)
        {
            ParentPlantGrowth.ReportCellDestroyed(GridCoord);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro;

public enum PlantCellType { Seed, Stem, Leaf, Flower, Fruit }
public enum PlantState { Initializing, Growing, Mature_Idle, Mature_Executing }

public class PlantGrowth : MonoBehaviour
{
    // --- Serialized Fields ---
    [Header("UI & Visuals")]
    [SerializeField] private TMP_Text energyText;
    [SerializeField] private GameObject seedCellPrefab;
    [SerializeField] private GameObject stemCellPrefab;
    [SerializeField] private GameObject leafCellPrefab;
    [SerializeField] private GameObject berryCellPrefab;
    [SerializeField] private float cellSpacing = 8f;

    [Header("Growth & UI Timing")]
    [SerializeField] private bool showGrowthPercentage = true;
    [SerializeField] private bool allowPhotosynthesisDuringGrowth = false;
    [SerializeField] private bool useSmoothPercentageCounter = true;
    [SerializeField] [Range(1, 10)] private int percentageIncrement = 2;

    // --- Internal State & Data ---
    private NodeGraph nodeGraph;
    public PlantState currentState = PlantState.Initializing;
    public float currentEnergy = 0f;
    private Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
    private Coroutine percentageCounterCoroutine;

    // --- Calculated Stats ---
    private int targetStemLength;
    private float finalGrowthSpeed;
    private int finalLeafGap;
    private int finalLeafPattern;
    private float finalGrowthRandomness;
    private float finalMaxEnergy;
    private float finalPhotosynthesisRate;
    private float cycleCooldown;
    private float nodeCastDelay;

    // --- Runtime Variables ---
    private int currentStemCount = 0;
    private float cycleTimer = 0f;
    private float displayedGrowthPercentage = 0f;
    private float totalGrowthDuration;
    private bool? offsetRightForPattern1 = null;

    // --- Unity Methods ---
    private void Awake() => EnsureUIReferences();
    private void Update() => StateMachineUpdate();
    private void OnDestroy() => StopAllCoroutines(); // Ensure cleanup

    // --- Public Initialization ---
    public void InitializeAndGrow(NodeGraph graph)
    {
        if (graph == null || graph.nodes == null) {
            Debug.LogError($"[{gameObject.name}] Null/empty NodeGraph provided.", gameObject); Destroy(gameObject); return;
        }
        nodeGraph = graph;
        currentState = PlantState.Initializing;
        currentEnergy = 0f;
        displayedGrowthPercentage = 0f;
        if (percentageCounterCoroutine != null) { StopCoroutine(percentageCounterCoroutine); percentageCounterCoroutine = null; }

        CalculateAndApplyStats();

        if (targetStemLength > 0) {
            StartGrowthVisuals();
        } else { // Skip visual growth
             Debug.LogWarning($"[{gameObject.name}] Target stem length is {targetStemLength}. Skipping visual growth.", gameObject);
            currentState = PlantState.Mature_Idle;
            cycleTimer = cycleCooldown;
            if (!cells.ContainsKey(Vector2Int.zero)) { SpawnCellVisual(PlantCellType.Seed, Vector2Int.zero); }
        }
        UpdateUI();
    }

    // --- State Machine & Updates ---
    private void StateMachineUpdate()
    {
        switch (currentState)
        {
            case PlantState.Growing:
                if (allowPhotosynthesisDuringGrowth) AccumulateEnergy();
                if (!showGrowthPercentage || !useSmoothPercentageCounter) UpdateUI();
                break;
            case PlantState.Mature_Idle:
                AccumulateEnergy();
                UpdateUI();
                cycleTimer -= Time.deltaTime;
                if (cycleTimer <= 0f && currentEnergy >= 1f) // Basic energy check
                {
                    currentState = PlantState.Mature_Executing;
                    StartCoroutine(ExecuteMatureCycle());
                }
                break;
            case PlantState.Mature_Executing:
                AccumulateEnergy();
                UpdateUI();
                break;
        }
    }

    private void AccumulateEnergy()
    {
        float sunlight = WeatherManager.Instance ? WeatherManager.Instance.sunIntensity : 1f;
        // *** Uses the 'cells' dictionary which is now kept up-to-date via ReportCellDestroyed ***
        int leafCount = cells.Values.Count(c => c == PlantCellType.Leaf);
        float delta = finalPhotosynthesisRate * leafCount * sunlight * Time.deltaTime;
        currentEnergy = Mathf.Clamp(currentEnergy + delta, 0f, finalMaxEnergy);
    }

    private void UpdateUI()
    {
        if (energyText == null) return;
        switch (currentState) {
            case PlantState.Growing when showGrowthPercentage:
                int perc = useSmoothPercentageCounter ? Mathf.RoundToInt(displayedGrowthPercentage) :
                           (targetStemLength <= 0 ? 100 : Mathf.RoundToInt((float)currentStemCount / targetStemLength * 100f));
                energyText.text = $"{Mathf.Clamp(perc, 0, 100)}%";
                break;
            case PlantState.Growing: // Not showing percentage, show energy
            case PlantState.Mature_Idle:
            case PlantState.Mature_Executing:
                energyText.text = $"{Mathf.FloorToInt(currentEnergy)}/{Mathf.FloorToInt(finalMaxEnergy)}";
                break;
            default: energyText.text = "..."; break;
        }
    }

    // --- Cell Management ---

    /// <summary>
    /// Called by PlantCell component when its GameObject is destroyed.
    /// Removes the cell from the internal dictionary.
    /// </summary>
    public void ReportCellDestroyed(Vector2Int coord)
    {
        if (cells.ContainsKey(coord))
        {
            cells.Remove(coord);
            // Debug.Log($"Cell at {coord} reported destroyed and removed from dictionary.");
        }
    }

    // --- Stat Calculation ---
        /// <summary>
        /// <summary>
    /// Calculates final plant stats (growth speed, max energy, etc.)
    /// based on the SUM of passive effects from the assigned NodeGraph.
    /// </summary>
    private void CalculateAndApplyStats()
    {
        if (nodeGraph == null)
        {
            Debug.LogError($"[{gameObject.name}] CalculateAndApplyStats called with null NodeGraph!");
            return;
        }

        // --- Define BASE values (Defaults if NO relevant Node Effect modifies them) ---
        // *** CRITICAL: Set bases to 0 or identity values if effects should fully define the stat ***
        float baseEnergyStorage = 0f;           // <<< FIX 1: Set base to 0. Effects will define the total.
        float basePhotosynthesisRate = 0f;      // <<< FIX 2: Set base rate to 0. Effects define total rate per leaf.
        int baseStemMin = 0;                    // Base range if no modifier
        int baseStemMax = 0;
        float baseGrowthSpeed = 0f;             // <<< FIX 3: Base time (seconds) per step. Effects ADD to this time.
        int baseLeafGap = 0;                    // <<< FIX 4: Base gap. 0 = leaves every stem. Effects ADD to this gap.
        int baseLeafPattern = 0;
        float baseGrowthRandomness = 0f;
        float baseCooldown = 0f;
        float baseCastDelay = 0f;

        // --- Accumulators for Modifiers from Node Effects ---
        float accumulatedEnergyStorage = 0f;
        float accumulatedPhotosynthesis = 0f;
        int stemLengthModifier = 0;
        float growthSpeedTimeModifier = 0f;     // How much time to ADD to baseGrowthSpeed
        int leafGapModifier = 0;
        int currentLeafPattern = baseLeafPattern;
        float growthRandomnessModifier = 0f;
        float cooldownModifier = 0f;
        float castDelayModifier = 0f;
        bool seedFound = false;

        // --- Iterate through nodes and their PASSIVE effects ---
        // Debug.Log($"[{gameObject.name}] Calculating Stats..."); // Optional: Start log
        foreach (NodeData node in nodeGraph.nodes.OrderBy(n => n.orderIndex))
        {
            if (node.effects == null) continue;
            // string nodeEffectsLog = $"Node '{node.nodeDisplayName}': "; // Optional: Log effects per node
            foreach (NodeEffectData effect in node.effects)
            {
                if (!effect.isPassive) continue; // Only process PASSIVE effects here

                // nodeEffectsLog += $" {effect.effectType}({effect.primaryValue})"; // Optional: Log effects per node

                switch (effect.effectType)
                {
                    case NodeEffectType.SeedSpawn:
                        seedFound = true;
                        break;
                    case NodeEffectType.EnergyStorage:
                        // Debug.Log($"  -> Found EnergyStorage: +{effect.primaryValue}"); // Optional: Log specific effect
                        accumulatedEnergyStorage += effect.primaryValue;
                        break;
                    case NodeEffectType.EnergyPhotosynthesis:
                        // Debug.Log($"  -> Found EnergyPhotosynthesis: +{effect.primaryValue}"); // Optional
                        accumulatedPhotosynthesis += effect.primaryValue;
                        break;
                    case NodeEffectType.StemLength:
                        stemLengthModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.GrowthSpeed:
                        // Positive value = Slower (Adds Time), Negative = Faster (Subtracts Time)
                        // Debug.Log($"  -> Found GrowthSpeed Mod: {effect.primaryValue} (Time Adj)"); // Optional
                        growthSpeedTimeModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.LeafGap:
                        // Debug.Log($"  -> Found LeafGap Mod: +{Mathf.RoundToInt(effect.primaryValue)}"); // Optional
                        leafGapModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.LeafPattern:
                        currentLeafPattern = Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.StemRandomness:
                        growthRandomnessModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.Cooldown:
                        cooldownModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.CastDelay:
                        castDelayModifier += effect.primaryValue;
                        break;
                }
            }
             // Debug.Log(nodeEffectsLog); // Optional: Log effects per node
        }

        // --- Final Stat Calculation & Clamping ---

        // 1. Max Energy: Base (now 0) + Accumulated. Min value of 1.
        finalMaxEnergy = Mathf.Max(1f, baseEnergyStorage + accumulatedEnergyStorage);
        // This should now directly reflect the sum of EnergyStorage effects (or 1 if sum is < 1).

        // 2. Photosynthesis Rate: Base (now 0) + Accumulated. Min 0. Rate PER LEAF.
        finalPhotosynthesisRate = Mathf.Max(0f, basePhotosynthesisRate + accumulatedPhotosynthesis);
        // This reflects the sum of EnergyPhotosynthesis effects.

        // 3. Stem Length
        int finalStemMin = Mathf.Max(1, baseStemMin + stemLengthModifier);
        int finalStemMax = Mathf.Max(finalStemMin, baseStemMax + stemLengthModifier);

        // 4. Growth Speed (Time per step): Base Time + Time Modifier. Min 0.1s.
        finalGrowthSpeed = Mathf.Max(0.1f, baseGrowthSpeed + growthSpeedTimeModifier);
        // If base=1s, effect=+0.5 -> 1.5s/step (Slower). If effect=-0.5 -> 0.5s/step (Faster).

        // 5. Leaf Gap: Base Gap (now 0) + Modifier. Min 0.
        finalLeafGap = Mathf.Max(0, baseLeafGap + leafGapModifier);
        // Gap=0 -> Leaves every stem (Modulo Check: % (0+1) == 0 -> always true)
        // Gap=1 -> Leaves every 2nd stem (Modulo Check: % (1+1) == 0 -> true for 2,4,6...)
        // Gap=2 -> Leaves every 3rd stem (Modulo Check: % (2+1) == 0 -> true for 3,6,9...)

        // 6. Other Stats
        finalLeafPattern = Mathf.Clamp(currentLeafPattern, 0, 4); // Assuming patterns 0-4
        finalGrowthRandomness = Mathf.Clamp01(baseGrowthRandomness + growthRandomnessModifier);
        cycleCooldown = Mathf.Max(0.1f, baseCooldown + cooldownModifier);
        nodeCastDelay = Mathf.Max(0.01f, baseCastDelay + castDelayModifier);

        // --- Instance Specific ---
        targetStemLength = seedFound ? Random.Range(finalStemMin, finalStemMax + 1) : 0;
        totalGrowthDuration = targetStemLength * finalGrowthSpeed;

        if (!seedFound) {
             Debug.LogWarning($"[{gameObject.name}] NodeGraph lacks SeedSpawn effect. Growth aborted.", gameObject);
        }

        // --- FINAL DEBUG LOG --- (Highly recommended until stats are confirmed correct)
         Debug.Log($"[{gameObject.name}] === STATS CALCULATED ===\n" +
                   $"  Max Energy: {finalMaxEnergy} (Base:{baseEnergyStorage} + Acc:{accumulatedEnergyStorage})\n" +
                   $"  Photo Rate (Per Leaf): {finalPhotosynthesisRate} (Base:{basePhotosynthesisRate} + Acc:{accumulatedPhotosynthesis})\n" +
                   $"  Growth Speed (Time/Step): {finalGrowthSpeed} (Base:{baseGrowthSpeed} + Mod:{growthSpeedTimeModifier})\n" +
                   $"  Leaf Gap: {finalLeafGap} (Base:{baseLeafGap} + Mod:{leafGapModifier})\n" +
                   $"  Target Length: {targetStemLength} (Range: {finalStemMin}-{finalStemMax})\n" +
                   $"  Pattern: {finalLeafPattern} | Randomness: {finalGrowthRandomness:P0}\n" +
                   $"  Cooldown: {cycleCooldown} | Cast Delay: {nodeCastDelay}\n" +
                   $"  Seed Found: {seedFound}");
        // --- END FINAL DEBUG LOG ---
    }

    // --- Visual Growth & Spawning ---
    private void StartGrowthVisuals()
    {
        // Clear existing cells (excluding UI)
        foreach (Transform child in transform) {
            if (child != transform && child.GetComponent<Canvas>() == null && (energyText == null || child != energyText.transform)) {
                Destroy(child.gameObject);
            }
        }
        cells.Clear();
        currentStemCount = 0;
        offsetRightForPattern1 = null;

        SpawnCellVisual(PlantCellType.Seed, Vector2Int.zero); // Spawn seed

        currentState = PlantState.Growing;
        if (useSmoothPercentageCounter && showGrowthPercentage) {
            percentageCounterCoroutine = StartCoroutine(PercentageCounterRoutine());
        }
        StartCoroutine(GrowRoutine());
    }

    private IEnumerator PercentageCounterRoutine()
    {
        // Smoothly updates displayed percentage UI during growth
        displayedGrowthPercentage = 0; UpdateUI();
        if (totalGrowthDuration <= 0 || percentageIncrement <= 0) yield break;
        int steps = Mathf.Max(1, 100 / percentageIncrement);
        float timePerStep = totalGrowthDuration / steps;
        for (int i = 1; i <= steps; i++) {
            yield return new WaitForSeconds(timePerStep);
            if (currentState != PlantState.Growing) break;
            displayedGrowthPercentage = Mathf.Min(i * percentageIncrement, 100f);
            UpdateUI();
        }
        if (currentState == PlantState.Growing || currentState == PlantState.Mature_Idle) {
            displayedGrowthPercentage = 100f; UpdateUI(); // Ensure 100% at end
        }
        percentageCounterCoroutine = null;
    }

    private IEnumerator GrowRoutine()
    {
        Vector2Int currentPos = Vector2Int.zero;
        int spiralDir = 1, patternCount = 0;

        while (currentState == PlantState.Growing)
        {
            // Check if target length reached *before* the wait to fix UI lag
            if (currentStemCount >= targetStemLength)
            {
                // --- GROWTH COMPLETE ---
                 // Debug.Log($"[{gameObject.name}] Growth complete ({currentStemCount}/{targetStemLength}).");
                if (percentageCounterCoroutine != null) {
                    StopCoroutine(percentageCounterCoroutine); percentageCounterCoroutine = null;
                    if (showGrowthPercentage) { displayedGrowthPercentage = 100f; UpdateUI(); } // Ensure 100% shows briefly if needed
                }
                currentState = PlantState.Mature_Idle; // Change state HERE
                cycleTimer = cycleCooldown;
                UpdateUI(); // Update UI to show energy *immediately*
                yield break; // Exit coroutine
            }

            // Wait for the growth interval
            yield return new WaitForSeconds(finalGrowthSpeed);

            // --- PERFORM GROWTH STEP --- (Only if not completed above)
            currentStemCount++;
            Vector2Int growthDir = (currentStemCount == 1) ? Vector2Int.up : GetStemDirection();
            currentPos += growthDir;

            SpawnCellVisual(PlantCellType.Stem, currentPos); // Spawns Stem and adds to dictionary

            // Leaf spawning logic
            if ((finalLeafGap >= 0) && (currentStemCount % (finalLeafGap + 1)) == 0) {
                patternCount++;
                ExecuteLeafPatternLogic(currentPos, currentPos + Vector2Int.left, currentPos + Vector2Int.right, patternCount, ref spiralDir);
            }

            // Update non-smooth UI if needed
            if (showGrowthPercentage && !useSmoothPercentageCounter) UpdateUI();
            else if (!showGrowthPercentage) UpdateUI();

        } // End while loop
    }


    private void ExecuteLeafPatternLogic(Vector2Int stemPos, Vector2Int leftBase, Vector2Int rightBase, int counter, ref int spiralDir)
    {
        // Spawns leaves based on finalLeafPattern
        switch (finalLeafPattern) {
            case 0: SpawnLeafIfEmpty(leftBase); SpawnLeafIfEmpty(rightBase); break; // Parallel
            case 1: // Offset-Parallel
                if (offsetRightForPattern1 == null) offsetRightForPattern1 = Random.value < 0.5f;
                if (offsetRightForPattern1.Value) { SpawnLeafIfEmpty(leftBase); SpawnLeafIfEmpty(rightBase + Vector2Int.up); }
                else { SpawnLeafIfEmpty(leftBase + Vector2Int.up); SpawnLeafIfEmpty(rightBase); }
                break;
            case 2: // Alternating Height
                 switch (counter % 4) { default: case 0: case 2: SpawnLeafIfEmpty(leftBase); SpawnLeafIfEmpty(rightBase); break; case 1: SpawnLeafIfEmpty(leftBase + Vector2Int.up); SpawnLeafIfEmpty(rightBase); break; case 3: SpawnLeafIfEmpty(leftBase); SpawnLeafIfEmpty(rightBase + Vector2Int.up); break; } break;
            case 3: // Double-Spiral
                 SpawnLeafIfEmpty(leftBase + new Vector2Int(0, spiralDir > 0 ? 1 : 0)); SpawnLeafIfEmpty(rightBase + new Vector2Int(0, spiralDir > 0 ? 0 : 1)); spiralDir *= -1; break;
            case 4: SpawnLeafIfEmpty(rightBase); SpawnLeafIfEmpty(rightBase + Vector2Int.up); break; // One-Sided Right Example
        }
    }

    private Vector2Int GetStemDirection()
    {
        // Returns Up, UpLeft, or UpRight based on randomness
        if (Random.value < finalGrowthRandomness) return (Random.value < 0.5f) ? Vector2Int.left + Vector2Int.up : Vector2Int.right + Vector2Int.up;
        return Vector2Int.up;
    }

    private void SpawnLeafIfEmpty(Vector2Int coords)
    {
        if (!cells.ContainsKey(coords)) SpawnCellVisual(PlantCellType.Leaf, coords);
    }

    /// <summary>
    /// Instantiates cell prefab, adds to dictionary, configures PlantCell component.
    /// </summary>
    private void SpawnCellVisual(PlantCellType cellType, Vector2Int coords)
    {
        // Check if already exists (e.g., stem collision)
        if (cells.ContainsKey(coords) && cells[coords] != cellType) {
             Debug.LogWarning($"Spawn collision at {coords}. Overwriting {cells[coords]} with {cellType}.", gameObject);
            // Optionally destroy old visual first
        } else if (cells.ContainsKey(coords)) {
            // Already exists with same type, do nothing (e.g. leaf overlap check)
            return;
        }

        GameObject prefab = null;
        switch (cellType) {
            case PlantCellType.Seed: prefab = seedCellPrefab; break;
            case PlantCellType.Stem: prefab = stemCellPrefab; break;
            case PlantCellType.Leaf: prefab = leafCellPrefab; break;
            case PlantCellType.Fruit: prefab = berryCellPrefab; break;
        }

        if (prefab != null) {
            Vector2 worldPos = (Vector2)transform.position + (Vector2)coords * cellSpacing;
            GameObject instance = Instantiate(prefab, worldPos, Quaternion.identity, transform);

            // --- Setup PlantCell Component ---
            PlantCell cellComp = instance.GetComponent<PlantCell>();
            if (cellComp == null) {
                 Debug.LogError($"Prefab '{prefab.name}' for {cellType} is MISSING the PlantCell component!", instance);
            } else {
                cellComp.ParentPlantGrowth = this; // Link back to parent
                cellComp.GridCoord = coords;       // Store its grid position
                cellComp.CellType = cellType;      // Store its type
            }
            // --- End Setup PlantCell ---

            cells[coords] = cellType; // Add/Update dictionary entry *after* potential warning

            SortableEntity sorter = instance.GetComponent<SortableEntity>() ?? instance.AddComponent<SortableEntity>();
            if (cellType != PlantCellType.Seed) sorter.SetUseParentYCoordinate(true);

            // Optional FoodItem validation
            if (cellType == PlantCellType.Fruit && (instance.GetComponent<FoodItem>() == null || instance.GetComponent<FoodItem>().foodType == null)) {
                 Debug.LogError($"Spawned Berry Prefab '{prefab.name}' at {coords} has MISSING/unassigned FoodItem!", instance);
            }
        } else {
             Debug.LogWarning($"[{gameObject.name}] No prefab assigned for {cellType}.", gameObject);
        }
    }


    // --- Mature Cycle ---
    private IEnumerator ExecuteMatureCycle()
    {
        if (nodeGraph?.nodes == null) {
            Debug.LogError($"[{gameObject.name}] NodeGraph missing!", gameObject);
            currentState = PlantState.Mature_Idle; cycleTimer = cycleCooldown; yield break;
        }

        float damageMultiplier = 1.0f;

        foreach (var node in nodeGraph.nodes.OrderBy(n => n.orderIndex)) {
            if (node.effects == null || node.effects.Count == 0) continue;

            // Calculate cost and find other active effects
            bool hasAnyActiveEffect = false;
            float nodeEnergyCost = 0f;
            List<NodeEffectData> otherActiveEffects = new List<NodeEffectData>();
            foreach (var effect in node.effects) {
                if (!effect.isPassive) {
                    hasAnyActiveEffect = true;
                    if (effect.effectType == NodeEffectType.EnergyCost) nodeEnergyCost += Mathf.Max(0f, effect.primaryValue);
                    else otherActiveEffects.Add(effect);
                }
            }

            if (hasAnyActiveEffect) {
                // Apply delay
                if (nodeCastDelay > 0.01f) yield return new WaitForSeconds(nodeCastDelay);

                // Check Energy
                if (currentEnergy >= nodeEnergyCost) {
                    // Consume energy
                    currentEnergy = Mathf.Max(0f, currentEnergy - nodeEnergyCost);

                    // Execute other effects
                    foreach (var activeEffect in otherActiveEffects) {
                        switch (activeEffect.effectType) {
                            case NodeEffectType.Output: GetComponentInChildren<OutputNodeEffect>()?.Activate(damageMultiplier); break;
                            case NodeEffectType.Damage: damageMultiplier = Mathf.Max(0.1f, damageMultiplier + activeEffect.primaryValue); break;
                            case NodeEffectType.GrowBerry: TrySpawnBerry(); break;
                                // Add other active cases
                        }
                    }
                     // Debug.Log($"Node '{node.nodeDisplayName}' activated (Cost: {nodeEnergyCost})");
                } else {
                     // Debug.Log($"Node '{node.nodeDisplayName}' skipped (Cost: {nodeEnergyCost}, Available: {currentEnergy})");
                     // Add fizzle feedback?
                }
            }
        } // End foreach node

        cycleTimer = cycleCooldown;
        currentState = PlantState.Mature_Idle;
    }

    private void TrySpawnBerry()
    {
        if (berryCellPrefab == null) { Debug.LogWarning($"[{gameObject.name}] Berry Prefab not assigned.", gameObject); return; }

        // Find empty spots below leaves or above stems
        var potentialCoords = cells
            .SelectMany(cell => {
                List<Vector2Int> candidates = new List<Vector2Int>();
                if (cell.Value == PlantCellType.Leaf) candidates.Add(cell.Key + Vector2Int.down);
                else if (cell.Value == PlantCellType.Stem) candidates.Add(cell.Key + Vector2Int.up);
                return candidates;
            })
            .Where(coord => !cells.ContainsKey(coord)) // Filter out occupied coords
            .Distinct()
            .ToList();

        if (potentialCoords.Count > 0) {
            SpawnCellVisual(PlantCellType.Fruit, potentialCoords[Random.Range(0, potentialCoords.Count)]);
        }
    }

    // --- UI Reference Helper ---
    private void EnsureUIReferences()
    {
        if (energyText) return;
        // Simplified search logic from previous versions
        energyText = GetComponentInChildren<TMP_Text>(true); // Find first active or inactive
        if (!energyText) Debug.LogWarning($"[{gameObject.name}] Energy Text (TMP_Text) not found in children.", gameObject);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\WeatherManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class WeatherManager : MonoBehaviour
{
    public static WeatherManager Instance { get; private set; }

    [Header("Day/Night Cycle Settings")]
    public bool dayNightCycleEnabled = true;
    
    [Tooltip("Duration of full day (seconds)")]
    public float dayDuration = 20f;
    [Tooltip("Duration of full night (seconds)")]
    public float nightDuration = 20f;
    [Tooltip("Duration of transitions (seconds)")]
    public float transitionDuration = 5f;

    [Tooltip("Curve that controls the sunIntensity during transitions (X=0 start, X=1 end).")]
    public AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

    [Header("Sunlight Settings")]
    [Range(0f, 1f)]
    public float sunIntensity = 1f;  // 0=night, 1=day

    [Header("Fixed Sunlight When Cycle Off")]
    [Tooltip("If dayNightCycleEnabled is false, we use this fixed intensity.")]
    [Range(0f, 1f)]
    public float fixedSunIntensity = 1f;

    [Header("Sunlight Visualization")]
    public SpriteRenderer fadeSprite;
    public float minAlpha = 0f;
    public float maxAlpha = 1f;

    // Internals
    private enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }
    private CyclePhase currentPhase = CyclePhase.Day;
    private float phaseTimer = 0f; // counts down in each phase
    private float totalPhaseTime = 0f; // length of current phase

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    private void Start()
    {
        // Initialize to Day phase
        EnterPhase(CyclePhase.Day);
    }

    private void Update()
    {
        if (!dayNightCycleEnabled)
        {
            // If the cycle is disabled, just use the fixed sun intensity
            sunIntensity = fixedSunIntensity;
            UpdateFadeSprite();
            return;
        }

        // else dayNightCycle is enabled
        phaseTimer -= Time.deltaTime;
        if (phaseTimer <= 0f)
        {
            // move to next phase
            switch (currentPhase)
            {
                case CyclePhase.Day:
                    EnterPhase(CyclePhase.TransitionToNight);
                    break;
                case CyclePhase.TransitionToNight:
                    EnterPhase(CyclePhase.Night);
                    break;
                case CyclePhase.Night:
                    EnterPhase(CyclePhase.TransitionToDay);
                    break;
                case CyclePhase.TransitionToDay:
                    EnterPhase(CyclePhase.Day);
                    break;
            }
        }
        else
        {
            // while in the current phase, update sunIntensity accordingly
            float progress = 1f - (phaseTimer / totalPhaseTime);
            switch (currentPhase)
            {
                case CyclePhase.Day:
                    // Full day, sunIntensity = 1
                    sunIntensity = 1f;
                    break;
                case CyclePhase.TransitionToNight:
                    // 0..1 => day(1) to night(0) using transitionCurve
                    float tToNight = transitionCurve.Evaluate(progress);
                    sunIntensity = Mathf.Lerp(1f, 0f, tToNight);
                    break;
                case CyclePhase.Night:
                    // Full night, sunIntensity = 0
                    sunIntensity = 0f;
                    break;
                case CyclePhase.TransitionToDay:
                    // 0..1 => night(0) to day(1) using transitionCurve
                    float tToDay = transitionCurve.Evaluate(progress);
                    sunIntensity = Mathf.Lerp(0f, 1f, tToDay);
                    break;
            }
        }

        UpdateFadeSprite();
    }

    private void EnterPhase(CyclePhase nextPhase)
    {
        currentPhase = nextPhase;
        switch (nextPhase)
        {
            case CyclePhase.Day:
                totalPhaseTime = dayDuration;
                break;
            case CyclePhase.Night:
                totalPhaseTime = nightDuration;
                break;
            case CyclePhase.TransitionToNight:
            case CyclePhase.TransitionToDay:
                totalPhaseTime = transitionDuration;
                break;
        }
        phaseTimer = totalPhaseTime;
    }

    private void UpdateFadeSprite()
    {
        if (fadeSprite != null)
        {
            float alpha = Mathf.Lerp(minAlpha, maxAlpha, sunIntensity);
            Color c = fadeSprite.color;
            c.a = alpha;
            fadeSprite.color = c;
        }
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\SpellProjectile.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SpellProjectile : MonoBehaviour
{
    [Header("Projectile Stats")]
    public float damage;
    public float speed;
    [Tooltip("If true, the projectile will be destroyed upon hitting a wizard.")]
    public bool destroyOnHit = true;

    [Header("Burning Effect (optional)")]
    public float burningDamage;   // DPS
    public float burningDuration; // Duration in seconds

    [Header("Friendly Fire")]
    public bool friendlyFire = false;
    public bool casterIsEnemy = false;

    public void Initialize(float dmg, float spd)
    {
        damage = dmg;
        speed = spd;
    }

    private void Update()
    {
        transform.Translate(Vector2.up * speed * Time.deltaTime);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\BurningStatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public class BurningStatusEffect : StatusEffect
{
    public BurningStatusEffect(float d, float dps) : base(d, dps) { }

    
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\StatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public abstract class StatusEffect
{
    public float duration; // Total duration.
    public float damagePerSecond;
    protected float elapsed = 0f;

    // Public property to expose elapsed time.
    public float Elapsed { get { return elapsed; } }

    public StatusEffect(float d, float dps)
    {
        duration = d;
        damagePerSecond = dps;
    }

    public bool IsExpired() => elapsed >= duration;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\SortableEntity.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SortableEntity : MonoBehaviour
{
    [Header("Sorting Configuration")]
    [Tooltip("Offset added to Y position for sorting calculation")]
    [SerializeField] private float sortingLayerYOffset = 0f;

    [Tooltip("Use parent's Y coordinate for sorting")]
    [SerializeField] private bool useParentYCoordinate = false;

    [Tooltip("Debug logging for sorting")]
    public bool debugSorting = false;

    private SpriteRenderer spriteRenderer;

    private void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        // If no SpriteRenderer, try to find one in children
        if (spriteRenderer == null)
            spriteRenderer = GetComponentInChildren<SpriteRenderer>();

        // Ensure sprite renderer exists
        if (spriteRenderer == null)
        {
            Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
        }
    }

    private void Start()
    {
        UpdateSortingOrder();
    }

    private void LateUpdate()
    {
        UpdateSortingOrder();
    }

    public void UpdateSortingOrder()
    {
        if (spriteRenderer == null) return;

        // Determine Y position for sorting
        float yPositionForSorting = useParentYCoordinate && transform.parent != null 
            ? transform.parent.position.y 
            : transform.position.y;

        int sortOrder = CalculateSortOrder(yPositionForSorting);
        spriteRenderer.sortingOrder = sortOrder;

        if (debugSorting)
        {
            Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
        }
    }

    private int CalculateSortOrder(float yPosition)
    {
        // Subtract offset to effectively move the sorting position
        return Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
    }

    // Public method to get current sorting order
    public int GetCurrentSortOrder()
    {
        if (spriteRenderer == null) return 0;
        return spriteRenderer.sortingOrder;
    }

    // Public method to set sorting order directly if needed
    public void SetSortingOrder(int order)
    {
        if (spriteRenderer != null)
            spriteRenderer.sortingOrder = order;
    }

    // Public method to set the parent Y coordinate usage flag
    // This eliminates the need for reflection in other scripts
    public void SetUseParentYCoordinate(bool value)
    {
        useParentYCoordinate = value;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "Animal_", menuName = "Ecosystem/Animal Definition (Simplified)")]
public class AnimalDefinition : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("The species name (e.g., 'Bunny', 'Fox').")]
    public string animalName = "DefaultAnimal";

    [Header("Core Stats")]
    public float maxHealth = 10f; // Keep health for potential future damage/predators
    public float movementSpeed = 2f;

    [Header("Diet")]
    [Tooltip("Reference to the AnimalDiet ScriptableObject defining eating habits.")]
    public AnimalDiet diet; // Needs to reference the simplified AnimalDiet SO

    [Header("Visuals")]
    [Tooltip("The prefab to instantiate for this animal.")]
    public GameObject prefab;

    // Removed meatFoodType
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "AnimalLibrary", menuName = "Ecosystem/Animal Library")]
public class AnimalLibrary : ScriptableObject
{
    public List<AnimalDefinition> animals;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using TMPro; // <<< ADDED THIS using statement for TextMeshPro

[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(SortableEntity))]
public class AnimalController : MonoBehaviour
{
    // References set by FaunaManager or Initialize
    private AnimalDefinition definition;
    private AnimalDiet animalDiet;

    // Inspector Assigned References (Optional Features)
    [Header("Optional Features")]
    public AnimalThoughtLibrary thoughtLibrary;
    public GameObject thoughtBubblePrefab;
    public Transform bubbleSpawnTransform;
    public Transform poopSpawnPoint;
    public List<GameObject> poopPrefabs;
    public Animator animator; // Assign if using animations

    [Header("UI References (Optional - Auto-Detected)")]
    [Tooltip("Reference to the TextMeshPro component for displaying HP. Found automatically if not assigned.")]
    [SerializeField] private TextMeshProUGUI hpText; // <<< ADDED HP TEXT REFERENCE

    [Header("Behavior Tuning")]
    public float searchRadius = 5f;
    public float eatDistance = 0.5f;
    public float eatDuration = 1.5f;
    [Range(0f, 1f)] public float wanderPauseChance = 0.3f;
    public float wanderMinMoveDuration = 1f;
    public float wanderMaxMoveDuration = 3f;
    public float wanderMinPauseDuration = 0.5f;
    public float wanderMaxPauseDuration = 2f;
    public float minPoopDelay = 5f;
    public float maxPoopDelay = 10f;
    public float poopDuration = 1f;
    public float poopColorVariation = 0.1f;
    public float thoughtCooldownTime = 5f;


    // --- Internal State ---
    private float currentHealth;
    private float currentHunger;
    private GameObject currentTargetFood = null;
    private Vector2 moveDirection = Vector2.zero;
    private bool isEating = false;
    private float eatTimer = 0f;
    private bool isWanderPaused = false;
    private float wanderStateTimer = 0f;
    private bool isPooping = false;
    private float poopTimer = 0f;
    private float poopDelayTimer = 0f;
    private bool hasPooped = true;
    private float thoughtCooldownTimer = 0f;

    // --- Component References ---
    private Rigidbody2D rb;
    private SpriteRenderer spriteRenderer;

    // --- Movement Bounds ---
    private Vector2 minBounds;
    private Vector2 maxBounds;

    // --- Public Accessors ---
    public float CurrentHealth => currentHealth;
    public string SpeciesName => definition ? definition.animalName : "Uninitialized";


    /// <summary>
    /// Initializes the Animal Controller. Called by FaunaManager.
    /// </summary>
    public void Initialize(AnimalDefinition def, Vector2 minB, Vector2 maxB)
    {
        definition = def;
        if (definition == null) {
            Debug.LogError($"[{gameObject.name}] Null definition provided!", gameObject);
            Destroy(gameObject); return;
        }

        animalDiet = def.diet;
        if (animalDiet == null) {
            Debug.LogError($"[{gameObject.name}] AnimalDefinition '{def.name}' missing required Diet!", gameObject);
            enabled = false; // Disable controller
            return;
        }

        // Get Components
        rb = GetComponent<Rigidbody2D>();
        spriteRenderer = GetComponentInChildren<SpriteRenderer>(); // Allows sprite to be child
        // Animator is assigned via inspector if used

        // Set Initial State
        currentHealth = definition.maxHealth; // Use maxHealth from definition
        currentHunger = 0f; // Start not hungry
        hasPooped = true;
        poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);
        minBounds = minB;
        maxBounds = maxB;

        EnsureHpTextReference(); // <<< CALL METHOD TO FIND HP TEXT
        UpdateHpText(); // <<< CALL METHOD TO SET INITIAL HP TEXT

        if (spriteRenderer == null) {
             Debug.LogWarning($"[{gameObject.name}] No SpriteRenderer found in children.", gameObject);
        }
    }

    void Update()
    {
        if (!enabled) return; // Do nothing if not initialized correctly

        UpdateHunger(); // This now calls UpdateHpText if starvation happens
        HandlePooping();
        UpdateThoughts();

        if (isEating) {
            HandleEating();
            moveDirection = Vector2.zero;
        } else if (isPooping) {
            // Pooping state/timer handled in HandlePooping
            moveDirection = Vector2.zero;
        } else {
            DecideNextAction(); // Decide whether to wander or seek food
        }

        FlipSpriteBasedOnDirection();
        UpdateAnimationState();
    }

    void FixedUpdate()
    {
        // Apply movement if applicable
        if (rb != null && !isEating && !isPooping && moveDirection != Vector2.zero)
        {
            Vector2 currentPos = rb.position;
            // Use normalized direction to ensure consistent speed
            Vector2 desiredMove = moveDirection.normalized * definition.movementSpeed * Time.fixedDeltaTime;
            Vector2 newPos = currentPos + desiredMove;

            // Clamp position
            newPos.x = Mathf.Clamp(newPos.x, minBounds.x, maxBounds.x);
            newPos.y = Mathf.Clamp(newPos.y, minBounds.y, maxBounds.y);

            rb.MovePosition(newPos);
        }
    }

    // --- State Update Methods ---

    void UpdateHunger()
    {
        currentHunger += animalDiet.hungerIncreaseRate * Time.deltaTime;
        currentHunger = Mathf.Min(currentHunger, animalDiet.maxHunger);

        // Removed starvation logic for simplicity, but keep structure
        // if (currentHunger >= animalDiet.maxHunger) {
        //     ApplyStarvationDamage(); // Check for starvation
        // }
    }

    // Placeholder for potential future starvation damage
    void ApplyStarvationDamage()
    {
        // This method would be called if starvation logic is re-added
        // currentHealth -= animalDiet.starvationDamageRate * Time.deltaTime;
        UpdateHpText(); // <<< UPDATE HP TEXT AFTER TAKING DAMAGE (important if starvation added back)
        // if (currentHealth <= 0)
        // {
        //     Die(CauseOfDeath.Starvation); // Use existing Die method
        // }
    }

    void HandlePooping()
    {
        if (!isEating && !hasPooped) {
            poopDelayTimer -= Time.deltaTime;
            if (!isPooping && poopDelayTimer <= 0f) { StartPooping(); }
            if (isPooping) {
                poopTimer -= Time.deltaTime;
                if (poopTimer <= 0f) { FinishPooping(); }
            }
        }
    }

     void UpdateThoughts() {
         if (thoughtCooldownTimer > 0) { thoughtCooldownTimer -= Time.deltaTime; }
     }


    // --- Action Execution Methods ---

    void DecideNextAction()
    {
        if (currentHunger >= animalDiet.hungerThreshold) {
            SeekFood();
        } else {
            Wander();
            currentTargetFood = null; // Lose target if not hungry
        }
    }

    void SeekFood()
    {
        if (CanShowThought()) ShowThought(ThoughtTrigger.Hungry);

        // Check if target is still valid (exists and has FoodItem)
        bool targetValid = currentTargetFood != null && currentTargetFood.activeInHierarchy && currentTargetFood.GetComponent<FoodItem>() != null;

        if (!targetValid) {
            currentTargetFood = FindNearestFood();
        }

        if (currentTargetFood != null) {
            MoveTowardFood(currentTargetFood);
        } else {
            Wander(); // Can't find food
        }
    }

    GameObject FindNearestFood()
    {
        Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, searchRadius);
        return animalDiet.FindBestFood(colliders, transform.position); // Use Diet's logic
    }

    void MoveTowardFood(GameObject foodObj)
    {
        if (foodObj == null) return;
        float distance = Vector2.Distance(transform.position, foodObj.transform.position);

        if (distance <= eatDistance) {
            StartEating();
        } else {
            moveDirection = (foodObj.transform.position - transform.position).normalized;
            isWanderPaused = false; // Ensure not paused while seeking food
            wanderStateTimer = 0f;
        }
    }

    void StartEating()
    {
        isEating = true;
        eatTimer = eatDuration;
        moveDirection = Vector2.zero;
        if (CanShowThought()) ShowThought(ThoughtTrigger.Eating);
    }

    void HandleEating()
    {
        eatTimer -= Time.deltaTime;
        if (eatTimer <= 0f) {
            isEating = false;
            FinishEatingAction(); // Renamed for clarity
        }
    }

    // Called when the eat timer finishes
    void FinishEatingAction()
    {
        if (currentTargetFood == null) return; // Target disappeared mid-eat

        FoodItem foodItem = currentTargetFood.GetComponent<FoodItem>();
        if (foodItem != null && foodItem.foodType != null)
        {
            // 1. Get Satiation
            float satiationGain = animalDiet.GetSatiationValue(foodItem.foodType);

            // 2. Apply Satiation
            currentHunger -= satiationGain;
            currentHunger = Mathf.Max(0f, currentHunger);

            // 3. Destroy the Food GameObject
            Destroy(currentTargetFood);

            // 4. Reset Poop Timer
            hasPooped = false;
            poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);

            // 5. Clear Target Reference
            currentTargetFood = null;
        }
         else {
             // Target was invalid (missing FoodItem/FoodType), clear it
             // Debug.LogWarning($"[{gameObject.name}] Tried to finish eating invalid target '{currentTargetFood?.name}'. Clearing target.", currentTargetFood);
             currentTargetFood = null;
         }
    }

    void StartPooping()
    {
        isPooping = true;
        poopTimer = poopDuration;
        moveDirection = Vector2.zero;
        if (CanShowThought()) ShowThought(ThoughtTrigger.Pooping);
    }

    void FinishPooping()
    {
        SpawnPoop();
        isPooping = false;
        hasPooped = true;
    }

    void SpawnPoop()
    {
        if (poopPrefabs == null || poopPrefabs.Count == 0) return;

        int index = Random.Range(0, poopPrefabs.Count);
        GameObject prefab = poopPrefabs[index];
        if (prefab == null) return;

        Transform spawnT = poopSpawnPoint ? poopSpawnPoint : transform;
        GameObject poopObj = Instantiate(prefab, spawnT.position, Quaternion.identity);

        // Apply visual variations
        SpriteRenderer sr = poopObj.GetComponent<SpriteRenderer>();
        if (sr != null) {
            sr.flipX = Random.value > 0.5f;
            Color c = sr.color;
            float v = poopColorVariation;
            sr.color = new Color(
                Mathf.Clamp01(c.r + Random.Range(-v, v)),
                Mathf.Clamp01(c.g + Random.Range(-v, v)),
                Mathf.Clamp01(c.b + Random.Range(-v, v)),
                c.a);
        }

        // Ensure PoopController exists and initialize
        PoopController pc = poopObj.GetComponent<PoopController>() ?? poopObj.AddComponent<PoopController>();
        pc.Initialize();
    }

    void Wander()
    {
        if (wanderStateTimer <= 0f) {
            if (isWanderPaused) {
                // Finish pause, start moving
                isWanderPaused = false;
                moveDirection = Random.insideUnitCircle.normalized;
                wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration);
            } else {
                // Finish moving, decide to pause or change direction
                if (Random.value < wanderPauseChance) {
                    isWanderPaused = true;
                    moveDirection = Vector2.zero;
                    wanderStateTimer = Random.Range(wanderMinPauseDuration, wanderMaxPauseDuration);
                } else {
                    moveDirection = Random.insideUnitCircle.normalized;
                    wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration);
                }
            }
        } else {
            wanderStateTimer -= Time.deltaTime;
        }
    }


    // --- Movement & Visuals ---

    void FlipSpriteBasedOnDirection()
    {
        if (spriteRenderer != null && Mathf.Abs(moveDirection.x) > 0.01f) {
            spriteRenderer.flipX = moveDirection.x < 0;
        }
    }

    void UpdateAnimationState()
    {
        if (animator == null) return;
        bool isMoving = !isEating && !isPooping && moveDirection.sqrMagnitude > 0.01f;
        // Use parameter names matching your Animator controller
        animator.SetBool("IsMoving", isMoving);
        animator.SetBool("IsEating", isEating);
        // animator.SetBool("IsPooping", isPooping); // Add if needed
    }

    // --- Thought Bubbles ---

    bool CanShowThought() {
        return thoughtLibrary != null && thoughtBubblePrefab != null && thoughtCooldownTimer <= 0f;
    }

    void ShowThought(ThoughtTrigger trigger)
    {
        // Simplified - assumes CanShowThought() was checked
        if (thoughtLibrary == null || thoughtLibrary.allThoughts == null) return; // Added null check

        var entry = thoughtLibrary.allThoughts.FirstOrDefault(t => t != null && t.speciesName == SpeciesName && t.trigger == trigger); // Added null check for entry
        if (entry != null && entry.lines != null && entry.lines.Count > 0) {
            string line = entry.lines[Random.Range(0, entry.lines.Count)];
            Transform spawnT = bubbleSpawnTransform ? bubbleSpawnTransform : transform;
            GameObject bubbleGO = Instantiate(thoughtBubblePrefab, spawnT.position, Quaternion.identity, spawnT);
            bubbleGO.transform.localPosition = Vector3.zero;
            ThoughtBubbleController bubble = bubbleGO.GetComponent<ThoughtBubbleController>();
            if (bubble) {
                bubble.Initialize(line, spawnT, 2f); // 2s default life
                thoughtCooldownTimer = thoughtCooldownTime;
            } else {
                Destroy(bubbleGO);
            }
        }
    }

     // --- Death Handling --- (Simplified, no starvation damage)
     public enum CauseOfDeath { Unknown, Starvation, EatenByPredator }

     private void Die(CauseOfDeath cause) // Keep structure in case starvation is added back
     {
          Debug.Log($"[{SpeciesName} on {gameObject.name}] Died due to {cause}.", gameObject);
          // Add meat spawning logic here later if needed
          Destroy(gameObject);
     }

    // --- Helper Methods ---
    public bool SpeciesNameEquals(string otherSpeciesName) {
         return definition != null && definition.animalName == otherSpeciesName;
     }

    /// <summary>
    /// Ensures the hpText reference is set, finding it if necessary.
    /// </summary>
    private void EnsureHpTextReference() // <<< NEW METHOD
    {
        // If not assigned in inspector, try to find it in children
        if (hpText == null)
        {
            hpText = GetComponentInChildren<TextMeshProUGUI>(true); // Include inactive

            if (hpText == null) {
                 // This warning is okay, HP text is optional
                 // Debug.LogWarning($"[{gameObject.name}] Could not automatically find TextMeshProUGUI for HP display.", gameObject);
            }
        }
    }

    /// <summary>
    /// Updates the HP text display.
    /// </summary>
    private void UpdateHpText() // <<< NEW METHOD
    {
        if (hpText == null || definition == null) return; // Exit if no text component or definition

        // Format the text (using FloorToInt for cleaner display, adjust if floats needed)
        hpText.text = $"HP: {Mathf.FloorToInt(currentHealth)} / {Mathf.FloorToInt(definition.maxHealth)}";
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalSpawnData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[System.Serializable]
public class AnimalSpawnData {
    public AnimalDefinition animalDefinition;
    [Range(0f, 1f)]
    [Tooltip("Spawn rate multiplier (0 = no spawn; lower values = less frequent spawns).")]
    public float spawnRateMultiplier = 1f;
    [Tooltip("Maximum number of this animal type allowed to be spawned (0 = no limit).")]
    public int maximumSpawned = 0;
    
    [HideInInspector]
    public float spawnTimer = 0f;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalThoughtLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "AnimalThoughtLibrary", menuName = "Ecosystem/Animal Thought Library")]
public class AnimalThoughtLibrary : ScriptableObject
{
    public List<AnimalThoughtLine> allThoughts;
}

[System.Serializable]
public class AnimalThoughtLine
{
    [Header("Which Animal?")]
    public string speciesName; // e.g. "Bunny", "Fox", "Bird"

    [Header("Trigger Condition")]
    public ThoughtTrigger trigger;

    [Header("Possible Lines to Randomly Choose From")]
    public List<string> lines;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\EcosystemManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class EcosystemManager : MonoBehaviour
{
    public static EcosystemManager Instance { get; private set; }

    [Header("Parent Transforms")]
    public Transform animalParent;   // e.g., an empty GameObject "SpawnedEcosystem/Animals"
    public Transform plantParent;    // e.g., an empty GameObject "SpawnedEcosystem/Plants"

    [Header("Sorting Options")]
    public bool sortAnimalsBySpecies = true;
    public bool sortPlantsBySpecies = true;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FaunaManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

public class FaunaManager : MonoBehaviour
{
    [Header("Animal Spawn Settings")]
    public List<AnimalSpawnData> animalsToSpawn;
    public float globalSpawnCooldown = 5f;
    public float spawnRadius = 3f;
    public bool continuousSpawn = true;
    public Vector2 spawnCenter = Vector2.zero;

    [Header("Ecosystem Parent Settings")]
    public Transform ecosystemParent; // e.g., "SpawnedEcosystem/Animals"

    [Header("Global Movement Bounds for Animals")]
    public Vector2 animalMinBounds = new Vector2(-10f, -5f);
    public Vector2 animalMaxBounds = new Vector2(10f, 5f);

    private void Start()
    {
        // Initialize each spawn entry's timer to its effective cooldown.
        foreach (var spawnData in animalsToSpawn)
        {
            if (spawnData.spawnRateMultiplier > 0f)
                spawnData.spawnTimer = globalSpawnCooldown / spawnData.spawnRateMultiplier;
            else
                spawnData.spawnTimer = Mathf.Infinity; // won't spawn if 0
        }
    }

        private void Update()
    {
        if (continuousSpawn)
        {
            foreach (var spawnData in animalsToSpawn)
            {
                if (spawnData.spawnRateMultiplier <= 0f)
                    continue;

                // Check current count for this species.
                int currentCount = 0;
                if (ecosystemParent != null && spawnData.animalDefinition != null && !string.IsNullOrEmpty(spawnData.animalDefinition.animalName))
                {
                    // Try finding the dedicated parent first (more efficient if structure is maintained)
                    Transform speciesParent = ecosystemParent.Find(spawnData.animalDefinition.animalName);
                    if (speciesParent != null)
                        currentCount = speciesParent.childCount;
                    else {
                        // Fallback if species parent doesn't exist yet, count all matching animals
                        // Use FindObjectsByType for modern Unity versions - faster as we don't need sorting
                        AnimalController[] allAnimals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
                        currentCount = 0; // Reset count before iterating through found animals
                        foreach (var a in allAnimals)
                        {
                            if (a != null && a.SpeciesNameEquals(spawnData.animalDefinition.animalName))
                                currentCount++;
                        }
                    }
                }
                else // Fallback if no ecosystem parent or definition name
                {
                     // Use FindObjectsByType for modern Unity versions - faster as we don't need sorting
                    AnimalController[] allAnimals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None); // <--- THIS LINE IS UPDATED
                    currentCount = 0;
                    foreach (var a in allAnimals)
                    {
                        if (a != null && spawnData.animalDefinition != null && a.SpeciesNameEquals(spawnData.animalDefinition.animalName)) // Added null check for spawnData.animalDefinition
                            currentCount++;
                    }
                }
                // If maximum is set (>0) and current count is reached, skip spawn.
                if (spawnData.maximumSpawned > 0 && currentCount >= spawnData.maximumSpawned)
                    continue;

                // Decrement spawn timer and spawn if ready.
                spawnData.spawnTimer -= Time.deltaTime;
                if (spawnData.spawnTimer <= 0f)
                {
                    float effectiveCooldown = globalSpawnCooldown / spawnData.spawnRateMultiplier;
                    Vector2 randomOffset = Random.insideUnitCircle * spawnRadius;
                    SpawnAnimal(spawnData.animalDefinition, spawnCenter + randomOffset);
                    // Reset timer only AFTER successful spawn attempt potentially
                    spawnData.spawnTimer = effectiveCooldown > 0 ? effectiveCooldown : float.PositiveInfinity; // Prevent division by zero/negative cooldowns
                }
            }
        }
    }

    public GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position)
    {
        if (definition == null || definition.prefab == null)
        {
            Debug.LogWarning("[FaunaManager] Invalid animal definition or missing prefab!");
            return null;
        }

        GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

        // Parent the animal under ecosystemParent with species grouping.
        if (ecosystemParent != null)
        {
            Transform speciesParent = ecosystemParent;
            if (!string.IsNullOrEmpty(definition.animalName))
            {
                speciesParent = ecosystemParent.Find(definition.animalName);
                if (speciesParent == null)
                {
                    GameObject subParent = new GameObject(definition.animalName);
                    subParent.transform.SetParent(ecosystemParent);
                    speciesParent = subParent.transform;
                }
            }
            animalObj.transform.SetParent(speciesParent);
        }

        // Get the existing AnimalController on the prefab.
        AnimalController controller = animalObj.GetComponent<AnimalController>();
        if (controller != null)
        {
            controller.Initialize(definition, animalMinBounds, animalMaxBounds); // Pass bounds
        }
        else
        {
            Debug.LogError($"[{gameObject.name}] Animal prefab '{definition.prefab.name}' is missing the AnimalController script!", animalObj);
            Destroy(animalObj); // Destroy if controller is missing
            return null;
        }
// ... rest of parenting logic ...
        return animalObj;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\PoopController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class PoopController : MonoBehaviour
{
    [Tooltip("Total lifetime of this poop (in seconds) before disappearing.")]
    public float lifetime = 10f;
    [Tooltip("Duration at the end of the lifetime during which the poop fades out.")]
    public float fadeDuration = 2f;
    [Tooltip("Fadeout curve to control the alpha during fade-out. X axis goes from 0 (start of fade) to 1 (end of fade).")]
    public AnimationCurve fadeCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);

    private SpriteRenderer sr;
    private float timer = 0f;
    private Color initialColor;

    private void Awake()
    {
        sr = GetComponent<SpriteRenderer>();
        if (sr != null)
        {
            initialColor = sr.color;
        }
    }

    private void Update()
    {
        timer += Time.deltaTime;
        if (timer >= lifetime)
        {
            Destroy(gameObject);
            return;
        }

        // If within fadeDuration at the end, apply fade-out using the fadeCurve.
        float remaining = lifetime - timer;
        if (remaining < fadeDuration && sr != null)
        {
            // Normalize fade time (0 = start, 1 = end)
            float t = 1f - (remaining / fadeDuration);
            float alphaMultiplier = fadeCurve.Evaluate(t);
            Color newColor = initialColor;
            newColor.a = alphaMultiplier;
            sr.color = newColor;
        }
    }

    // Initialize with default parameters if none are provided.
    public void Initialize(float lifetimeValue = -1f, float fadeDurationValue = -1f)
    {
        if (lifetimeValue > 0f)
            lifetime = lifetimeValue;
        if (fadeDurationValue > 0f)
            fadeDuration = fadeDurationValue;
        timer = 0f;
        if (sr != null)
            initialColor = sr.color;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtBubbleController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class ThoughtBubbleController : MonoBehaviour
{
    public TMP_Text messageText;
    public float lifetime = 2f;

    private Transform followTarget;

    public void Initialize(string message, Transform target, float duration = 2f)
    {
        if (messageText != null)
            messageText.text = message;
        followTarget = target;
        lifetime = duration;
    }

    private void Update()
    {
        lifetime -= Time.deltaTime;
        if (lifetime <= 0f)
            Destroy(gameObject);

        // Follow the target if needed (optional if already a child)
        if (followTarget != null)
        {
            transform.position = followTarget.position;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtTrigger.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public enum ThoughtTrigger
{
    Hungry,
    Eating,
    HealthLow,
    Fleeing,
    Pooping,
    // Add more triggers as needed
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\AnimalDiet.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;

// Simplified Preference: Links FoodType to satiation amount and behavior priority
[System.Serializable]
public class DietPreferenceSimplified
{
    [Tooltip("The specific FoodType this preference applies to.")]
    public FoodType foodType;

    [Tooltip("How much satiation (hunger reduction) is gained when this food is eaten.")]
    public float satiationAmount = 5f;

    [Tooltip("Priority for seeking this food (higher value = higher priority). Used for choosing between nearby valid foods.")]
    [Range(0.1f, 5f)]
    public float preferencePriority = 1f;
}


// Simplified Diet: Defines hunger stats and list of preferences
[CreateAssetMenu(fileName = "Diet_", menuName = "Ecosystem/Animal Diet (Simplified)")]
public class AnimalDiet : ScriptableObject
{
    [Header("Diet Preferences")]
    [Tooltip("List of foods this animal can eat and how much they satisfy hunger.")]
    public List<DietPreferenceSimplified> acceptableFoods = new List<DietPreferenceSimplified>();

    [Header("Hunger Mechanics")]
    [Tooltip("Maximum hunger level.")]
    public float maxHunger = 20f;
    [Tooltip("Rate at which hunger increases per second.")]
    public float hungerIncreaseRate = 0.5f;
    [Tooltip("Hunger level above which the animal will actively seek food.")]
    public float hungerThreshold = 10f;

    // Removed starvation for simplicity, can be added back later if needed
    // [Header("Starvation")]
    // public float starvationDamageRate = 0.5f;

    /// <summary>
    /// Checks if a specific FoodType is included in this diet's acceptable foods.
    /// </summary>
    public bool CanEat(FoodType food)
    {
        if (food == null) return false;
        return acceptableFoods.Any(pref => pref.foodType == food);
    }

    /// <summary>
    /// Gets the DietPreferenceSimplified entry for a specific FoodType.
    /// </summary>
    public DietPreferenceSimplified GetPreference(FoodType food)
    {
         if (food == null) return null;
         return acceptableFoods.FirstOrDefault(p => p.foodType == food);
    }

    /// <summary>
    /// Gets the satiation amount provided by a specific FoodType for this diet.
    /// </summary>
    public float GetSatiationValue(FoodType food)
    {
        var pref = GetPreference(food);
        return pref != null ? pref.satiationAmount : 0f;
    }

    /// <summary>
    /// Finds the best food target from nearby colliders based on preference and distance.
    /// </summary>
    public GameObject FindBestFood(Collider2D[] nearbyColliders, Vector3 animalPosition)
    {
        GameObject bestTarget = null;
        float highestScore = -1f; // Start below any possible score

        foreach (var collider in nearbyColliders)
        {
            if (collider == null) continue;

            FoodItem foodItem = collider.GetComponent<FoodItem>();

            // Must have FoodItem and its FoodType must be edible by this diet
            if (foodItem != null && foodItem.foodType != null && CanEat(foodItem.foodType))
            {
                DietPreferenceSimplified pref = GetPreference(foodItem.foodType);
                if (pref == null) continue; // Should be caught by CanEat, but safe check

                float distance = Vector3.Distance(animalPosition, collider.transform.position);
                // Simple score: Higher preference is better, closer is better.
                // Avoid division by zero or very small distances inflating score excessively.
                float score = pref.preferencePriority / (1f + distance); // Inverse distance weighting

                if (score > highestScore)
                {
                    highestScore = score;
                    bestTarget = collider.gameObject;
                }
            }
        }
        return bestTarget;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[RequireComponent(typeof(Collider2D))] // Still need collider for detection
public class FoodItem : MonoBehaviour
{
    [Header("Food Identification")]
    [Tooltip("Reference to the ScriptableObject defining what type of food this is.")]
    public FoodType foodType;

    private void Start()
    {
        // Simple validation
        if (foodType == null)
        {
            Debug.LogWarning($"FoodItem on GameObject '{gameObject.name}' is missing its FoodType reference!", gameObject);
            // Optionally disable the collider so it can't be detected as food
            // Collider2D col = GetComponent<Collider2D>();
            // if (col != null) col.enabled = false;
            enabled = false; // Disable script if not configured
        }
        // No health, no consume logic needed here anymore.
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodType.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "FoodType_", menuName = "Ecosystem/Food Type (Simplified)")]
public class FoodType : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Identifying name for this food type (e.g., 'Leaf', 'Fruit').")]
    public string foodName = "Default Food";
    [Tooltip("Icon used in UI or debugging.")]
    public Sprite icon;

    // Keep category for potential filtering later, but not actively used by core logic yet
    public enum FoodCategory { Plant_Leaf, Plant_Fruit, Plant_Stem, Plant_Seed, Other }
    [Header("Categorization")]
    [Tooltip("General category this food falls into.")]
    public FoodCategory category = FoodCategory.Other;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public List<NodeEffectData> effects = new List<NodeEffectData>();
    public int orderIndex;

    // Runtime flags
    [HideInInspector] // Don't show in NodeDefinition inspector, set at runtime
    public bool canBeDeleted = true; // <<< NEW FLAG (Defaults to true)

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
        // Ensure default deletability on creation
        canBeDeleted = true;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    [Header("Display")]
    public string displayName;
    [TextArea]
    public string description;
    public Sprite thumbnail;
    [Tooltip("Tint color applied to the thumbnail image.")]
    public Color thumbnailTintColor = Color.white; // ADDED: Thumbnail tint
    [Tooltip("Background color for the Node View representation.")]
    public Color backgroundColor = Color.gray;

    [Header("Prefab & Effects")]
    [Tooltip("Optional: Specific NodeView prefab for this node type. If null, the default from NodeEditorGridController is used.")]
    public GameObject nodeViewPrefab;
    [Tooltip("List of effects this node applies.")]
    public List<NodeEffectData> effects;

    // Method to clone the effects list for NodeData.
    public List<NodeEffectData> CloneEffects()
    {
        List<NodeEffectData> copy = new List<NodeEffectData>();
        if (effects == null) return copy; // Handle null list

        foreach (var eff in effects)
        {
            NodeEffectData newEff = new NodeEffectData()
            {
                effectType = eff.effectType,
                primaryValue = eff.primaryValue,
                secondaryValue = eff.secondaryValue,
                isPassive = eff.isPassive  // Add this line to copy the flag
            };
            copy.Add(newEff);
        }
        return copy;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System; // Needed for [Serializable]

// Define the configuration for a single initial node
[Serializable] // Make it visible and editable in the Inspector
public struct InitialNodeConfig
{
    [Tooltip("The Node Definition to spawn.")]
    public NodeDefinition nodeDefinition;

    [Tooltip("The zero-based index of the cell where this node should spawn (0 is the leftmost cell).")]
    [Min(0)]
    public int cellIndex;

    [Tooltip("Can the player drag this initial node to other cells?")]
    public bool canMove;

    [Tooltip("Can the player delete this initial node using the Delete key?")]
    public bool canDelete;
}


[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    [Header("Available Node Definitions")]
    [Tooltip("List of all Node Definitions available in the dropdown menu.")]
    public List<NodeDefinition> definitions; // Your existing list

    [Header("Initial Node Layout")]
    [Tooltip("Nodes to automatically spawn in specific slots when the grid initializes.")]
    public List<InitialNodeConfig> initialNodes; // <<< NEW LIST ADDED
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;
    public float primaryValue;
    public float secondaryValue;

    // Renamed from isGrowthPhaseOnly and default changed to false
    [Tooltip("If TRUE, this effect only contributes once to calculate initial plant stats (Passive Growth Effect). If FALSE, this effect executes during the periodic Mature Phase cycles (Active Effect).")]
    public bool isPassive = false; // Defaulting to false, meaning effects are Active unless specified otherwise
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
using System;
using UnityEngine;

public enum NodeEffectType
{
    // --- Passive / Growth Phase Effects (isPassive = true) ---
    // These typically run once at the start to define the plant's structure and base stats.

    // [Tooltip("Base cost calculation (Not currently implemented in PlantGrowth execution).")]
    // ManaCost, // REMOVED
    [Tooltip("Determines the maximum energy the plant can store.")]
    EnergyStorage,
    [Tooltip("Determines the base rate of energy generation through photosynthesis per leaf.")]
    EnergyPhotosynthesis,
    [Tooltip("A required marker effect for a node chain to be spawnable as a plant.")]
    SeedSpawn,
    [Tooltip("Modifies the minimum and maximum potential length of the main stem.")]
    StemLength,
    [Tooltip("Modifies the time interval between each step of stem/leaf growth.")]
    GrowthSpeed,
    [Tooltip("Modifies the number of stem segments between leaf spawns.")]
    LeafGap,
    [Tooltip("Sets the pattern in which leaves are spawned (e.g., Parallel, Alternating).")]
    LeafPattern,
    [Tooltip("Modifies the chance for the stem to grow diagonally instead of straight up.")]
    StemRandomness,
    [Tooltip("Modifies the base time duration between Mature Phase execution cycles.")]
    Cooldown,
    [Tooltip("Modifies the base time delay between executing the effects of sequential nodes within a Mature Phase cycle.")]
    CastDelay,


    // --- Active / Mature Phase Effects (isPassive = false) ---
    // These execute periodically after the plant has finished growing.

    [Tooltip("Energy cost deducted from the plant when this node's active effects are executed during the mature cycle.")]
    EnergyCost, // <<< RENAMED/ADDED
    [Tooltip("Triggers the spawning of a projectile or other output effect (requires OutputNodeEffect component).")]
    Output,
    [Tooltip("Modifies the damage potential of subsequent 'Output' effects in the same cycle.")]
    Damage,
    [Tooltip("Causes the plant to attempt to spawn a berry in an available adjacent slot during the mature cycle.")]
    GrowBerry,
    // Add potentially more active effects: Heal, ApplyStatus, AreaEffect, etc.
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\OutputNodeEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

// Example - This component might be on the Plant Prefab or dynamically added/found
public class OutputNodeEffect : MonoBehaviour
{
    [Header("References")]
    [Tooltip("Prefab for the projectile to spawn.")]
    public GameObject projectilePrefab; // Assign your projectile prefab

    [Header("Settings")]
    public Vector2 spawnOffset = Vector2.up; // Offset relative to plant transform

    /// <summary>
    /// Activated by PlantGrowth during the Mature Execution Cycle.
    /// </summary>
    /// <param name="damageMultiplier">Contextual damage modifier calculated from the node chain.</param>
    public void Activate(float damageMultiplier) // Example parameter
    {
        if (projectilePrefab == null) {
            Debug.LogError("[OutputNodeEffect] Projectile Prefab not assigned!", gameObject);
            return;
        }

        Debug.Log($"[OutputNodeEffect] Activate called. Damage Multiplier: {damageMultiplier}. Spawning projectile.");

        // --- Calculate Spawn Position ---
        Vector2 spawnPos = (Vector2)transform.position + spawnOffset;

        // --- Instantiate Projectile ---
        GameObject projGO = Instantiate(projectilePrefab, spawnPos, transform.rotation); // Use plant's rotation or aim logic

        // --- Initialize Projectile (if needed) ---
        SpellProjectile spellProj = projGO.GetComponent<SpellProjectile>();
        if(spellProj != null)
        {
            // TODO: Calculate final damage/speed etc. based on node effects and damageMultiplier
            float finalDamage = 10f * damageMultiplier; // Example calculation
            float speed = 5f; // Get speed from effects?
            spellProj.Initialize(finalDamage, speed);
            // Set other properties like friendly fire based on plant context?
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;
using TMPro;
using System.Linq;

public class NodeExecutor : MonoBehaviour
{
    [Header("UI Graph Source")]
    [SerializeField] private NodeEditorGridController nodeEditorGrid;

    [Header("Plant Spawning")]
    [SerializeField] private GameObject plantPrefab;
    [SerializeField] private GardenerController gardener;

    [Header("Debugging")]
    [SerializeField] private TMP_Text debugOutput;

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space)) SpawnPlantFromUIGraph();
    }

    public void SpawnPlantFromUIGraph()
{
    if (nodeEditorGrid == null) { DebugLogError("Node Editor Grid Controller not assigned!"); return; }
    if (plantPrefab == null) { DebugLogError("Plant prefab not assigned!"); return; }
    if (gardener == null) { DebugLogError("Gardener Controller not assigned!"); return; }

    NodeGraph graphToSpawn = nodeEditorGrid.GetCurrentUIGraph();

    if (graphToSpawn == null || graphToSpawn.nodes == null || graphToSpawn.nodes.Count == 0) { DebugLog("No nodes in UI graph."); return; }

    // Use the renamed flag 'isPassive'
    bool seedFound = graphToSpawn.nodes.Any(node => node.effects != null && node.effects.Any(eff => eff.effectType == NodeEffectType.SeedSpawn && eff.isPassive)); 
    if (!seedFound) { DebugLog("Node chain lacks a passive SeedSpawn effect."); return; }

    DebugLog($"Spawning plant from UI graph with {graphToSpawn.nodes.Count} nodes...");
    Vector2 spawnPos = gardener.GetPlantingPosition();
    
    // Get parent for plants from EcosystemManager
    Transform plantParent = null;
    if (EcosystemManager.Instance != null && EcosystemManager.Instance.plantParent != null)
    {
        plantParent = EcosystemManager.Instance.plantParent;
    }
    
    // Instantiate with proper parent
    GameObject plantObj = Instantiate(plantPrefab, spawnPos, Quaternion.identity, plantParent);

    PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
    if (growthComponent != null)
    {
        NodeGraph graphCopy = new NodeGraph();
        graphCopy.nodes = new List<NodeData>();
        foreach(NodeData originalNodeData in graphToSpawn.nodes)
        {
             NodeData newNodeData = new NodeData {
                nodeId = originalNodeData.nodeId,
                nodeDisplayName = originalNodeData.nodeDisplayName,
                orderIndex = originalNodeData.orderIndex,
                effects = CloneEffectsList(originalNodeData.effects) // Deep copy effects
            };
            graphCopy.nodes.Add(newNodeData);
        }
        growthComponent.InitializeAndGrow(graphCopy);
        DebugLog("Plant spawned and initialized.");
    }
    else { DebugLogError($"Prefab '{plantPrefab.name}' missing PlantGrowth!"); Destroy(plantObj); }
}

    private List<NodeEffectData> CloneEffectsList(List<NodeEffectData> originalList)
    {
        if (originalList == null) return new List<NodeEffectData>();
        List<NodeEffectData> newList = new List<NodeEffectData>(originalList.Count);
        foreach(var eff in originalList)
        {
             NodeEffectData newEff = new NodeEffectData {
                 effectType = eff.effectType,
                 primaryValue = eff.primaryValue,
                 secondaryValue = eff.secondaryValue,
                 isPassive = eff.isPassive // Use the renamed flag
             };
             newList.Add(newEff);
        }
        return newList;
    }

    private void DebugLog(string msg) { Debug.Log($"[NodeExecutor] {msg}"); if (debugOutput != null) debugOutput.text += msg + "\n"; }
    private void DebugLogError(string msg) { Debug.LogError($"[NodeExecutor] {msg}"); if (debugOutput != null) debugOutput.text += $"ERROR: {msg}\n"; }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes = new List<NodeData>();
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\ColorExtensions.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public static class ColorExtensions
{
    public static Color WithAlpha(this Color c, float alpha)
    {
        return new Color(c.r, c.g, c.b, alpha);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\DeselectOnClickOutside.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems; // Required for IPointerClickHandler

// Add this script to an invisible, fullscreen background UI Image
// Make sure it's the first child of the Canvas to render behind everything else
public class DeselectOnClickOutside : MonoBehaviour, IPointerClickHandler
{
    public void OnPointerClick(PointerEventData eventData)
    {
        // Check if the click was with the left mouse button
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            // If the background is clicked, clear the current node selection
            // Debug.Log("Background Clicked. Clearing Node Selection.");
            NodeCell.ClearSelection();
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeCell.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
// Remove IPointerClickHandler interface from here
// Keep IDropHandler for dropping onto the cell background
public class NodeCell : MonoBehaviour, IPointerClickHandler, IDropHandler // Keep IPointerClickHandler for RIGHT click on empty
{
    public static NodeCell CurrentlySelectedCell { get; private set; }
    public int CellIndex { get; private set; }

    private NodeEditorGridController _controller;
    private NodeData _nodeData;
    private NodeView _nodeView;
    private Image _backgroundImage;

    // --- Init remains the same ---
    public void Init(int index, NodeEditorGridController gridController, Image bgImage)
    {
        CellIndex = index;
        _controller = gridController;
        _backgroundImage = bgImage;

        if (_backgroundImage != null && _controller != null)
        {
            _backgroundImage.color = _controller.EmptyCellColor;
            _backgroundImage.enabled = true;
        }
    }

    // --- HasNode, Getters remain the same ---
    public bool HasNode() => _nodeData != null && _nodeView != null;
    public NodeData GetNodeData() => _nodeData;
    public NodeView GetNodeView() => _nodeView;

    // --- AssignNode, AssignNodeView remain the same ---
     public void AssignNode(NodeDefinition def)
    {
        if (def == null || _controller == null) return;
        RemoveNode();

        _nodeData = new NodeData() { /* ... data setup ... */
            nodeId = System.Guid.NewGuid().ToString(),
            nodeDisplayName = def.displayName,
            effects = def.CloneEffects(),
            orderIndex = this.CellIndex
        };

        GameObject prefabToInstantiate = def.nodeViewPrefab != null ? def.nodeViewPrefab : _controller.NodeViewPrefab;
        if (prefabToInstantiate == null) { /* ... error handling ... */ Debug.LogError($"..."); _nodeData = null; return; }

        GameObject nodeViewGO = Instantiate(prefabToInstantiate, transform);
        _nodeView = nodeViewGO.GetComponent<NodeView>();
        if (_nodeView == null) { /* ... error handling ... */ Debug.LogError($"..."); Destroy(nodeViewGO); _nodeData = null; return; }

        _nodeView.Initialize(_nodeData, def, _controller); // Init NodeView

        NodeDraggable draggable = _nodeView.GetComponent<NodeDraggable>();
        if (draggable == null) draggable = _nodeView.gameObject.AddComponent<NodeDraggable>();
        draggable.Initialize(_controller, this); // Init Draggable

        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }
     public void AssignNodeView(NodeView view, NodeData data)
    {
         RemoveNode();
         _nodeView = view;
         _nodeData = data;
         if (_nodeView != null) {
             _nodeView.transform.SetParent(transform, false);
             if (_nodeData != null) _nodeData.orderIndex = this.CellIndex;
             // Parent ref will be updated by NodeDraggable.SnapToCell which calls NodeView.UpdateParent...
         }
         if(_backgroundImage != null) _backgroundImage.enabled = true;
    }


    // --- RemoveNode, ClearNodeReference remain the same ---
    public void RemoveNode()
    {
        bool wasSelected = (CurrentlySelectedCell == this);
        if (_nodeView != null) {
            if (wasSelected) {
                 _nodeView.Unhighlight();
                 CurrentlySelectedCell = null;
            }
            Destroy(_nodeView.gameObject);
        }
        _nodeView = null; _nodeData = null;
        if (wasSelected && CurrentlySelectedCell == this) CurrentlySelectedCell = null;
        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }
     public void ClearNodeReference()
    {
        _nodeView = null; _nodeData = null;
        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }

    // --- Selection Handling (SelectCell, ClearSelection) remains the same ---
     public static void SelectCell(NodeCell cellToSelect)
    {
        if (cellToSelect == null || !cellToSelect.HasNode()) { ClearSelection(); return; }
        if (CurrentlySelectedCell == cellToSelect) return;
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Unhighlight();
        }
        CurrentlySelectedCell = cellToSelect;
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Highlight();
        }
    }
     public static void ClearSelection()
    {
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Unhighlight();
        }
        CurrentlySelectedCell = null;
    }

    // --- Event Handlers UPDATED ---

    /// <summary>
    /// Handles clicks on the CELL BACKGROUND image.
    /// Left Click: Does nothing (NodeView handles selection).
    /// Right Click: Opens add node menu ONLY if the cell is currently empty.
    /// </summary>
    public void OnPointerClick(PointerEventData eventData)
    {
        // This click is on the NodeCell's background image

        if (eventData.button == PointerEventData.InputButton.Right)
        {
            // Right Click: Only allow opening the dropdown if the cell is currently EMPTY.
            if (!HasNode())
            {
                // Debug.Log($"NodeCell Background Clicked (Right) on Empty Cell {CellIndex}. Opening dropdown.");
                ClearSelection(); // Clear selection before showing add menu
                _controller?.OnEmptyCellRightClicked(this, eventData);
            }
            // If right-clicking the background of an occupied cell, do nothing.
        }
        // Left click on the background does nothing regarding selection now.
    }


    // --- OnDrop remains the same ---
    public void OnDrop(PointerEventData eventData)
    {
        GameObject draggedObject = eventData.pointerDrag;
        if (draggedObject != null) {
            NodeDraggable draggedNode = draggedObject.GetComponent<NodeDraggable>();
            if (draggedNode != null && _controller != null) {
                 _controller.HandleNodeDrop(draggedNode, draggedNode.OriginalCell, eventData.position);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeDraggable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
public class NodeDraggable : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
    private RectTransform _rectTransform;
    private CanvasGroup _canvasGroup;
    private Vector2 _originalAnchoredPosition;
    private Transform _originalParent;
    private NodeCell _originalCell;
    private NodeEditorGridController _gridController;
    private Canvas _rootCanvas;

    // No _isDragging flag needed if managed carefully by events

    public NodeCell OriginalCell => _originalCell;

    void Awake()
    {
        _rectTransform = GetComponent<RectTransform>();
        _canvasGroup = GetComponent<CanvasGroup>();
        if (_canvasGroup == null)
        {
            _canvasGroup = gameObject.AddComponent<CanvasGroup>();
        }
        // CRITICAL: Default state MUST allow interactions (clicks, hovers)
        _canvasGroup.blocksRaycasts = true;
        _canvasGroup.alpha = 1f; // Ensure fully visible
    }

    public void Initialize(NodeEditorGridController controller, NodeCell startingCell)
    {
        _gridController = controller;
        _originalCell = startingCell;
        _rootCanvas = GetComponentInParent<Canvas>()?.rootCanvas;
        if (_rootCanvas == null) Debug.LogError("[NodeDraggable] Could not find root Canvas!");

        // Ensure initial state after initialization
        if (_canvasGroup != null) {
             _canvasGroup.blocksRaycasts = true;
             _canvasGroup.alpha = 1f;
        }
    }

    public void OnBeginDrag(PointerEventData eventData)
    {
        if (eventData.button != PointerEventData.InputButton.Left) return;
        if (_gridController == null || _rootCanvas == null) return;

        _originalParent = transform.parent;
        _originalCell = _originalParent?.GetComponent<NodeCell>();
        _originalAnchoredPosition = _rectTransform.anchoredPosition;

        // Become transparent and STOP blocking raycasts so underlying cells can be detected
        _canvasGroup.alpha = 0.6f;
        _canvasGroup.blocksRaycasts = false;

        // Reparent for top rendering
        transform.SetParent(_rootCanvas.transform, true);
        transform.SetAsLastSibling();
         // Debug.Log($"[NodeDraggable OnBeginDrag] Started drag. blocksRaycasts: {_canvasGroup.blocksRaycasts}", gameObject);
    }

    public void OnDrag(PointerEventData eventData)
    {
        // Only process drag if it's the left button and dragging is conceptually active (raycasts blocked)
        if (eventData.button != PointerEventData.InputButton.Left || _canvasGroup == null || _canvasGroup.blocksRaycasts) return;
        if (_gridController == null || _rootCanvas == null) return;

        // Move logic (unchanged)
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
             _rootCanvas.transform as RectTransform, eventData.position,
             _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera, out Vector2 currentLocalPoint);
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
            _rootCanvas.transform as RectTransform, eventData.position - eventData.delta,
            _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera, out Vector2 previousLocalPoint);
        Vector2 localDelta = currentLocalPoint - previousLocalPoint;
        _rectTransform.localPosition += (Vector3)localDelta;
    }

    public void OnEndDrag(PointerEventData eventData)
    {
         // Debug.Log($"[NodeDraggable OnEndDrag] Drag ended. Button: {eventData.button}", gameObject);

        // Ensure visuals and raycast blocking are reset REGARDLESS of button, BEFORE handling drop
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true; // CRITICAL: Re-enable raycasts immediately
             // Debug.Log($"--> Reset alpha and blocksRaycasts to: {_canvasGroup.blocksRaycasts}");
        }

        // Only handle the drop logic if the drag was initiated by the left button
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            if (_gridController != null) {
                _gridController.HandleNodeDrop(this, _originalCell, eventData.position);
            } else {
                 // No controller, attempt reset
                 ResetPosition();
            }
        }
        else
        {
             // If drag ended via another button (unlikely but possible), ensure reset
             ResetPosition();
        }
    }

    public void ResetPosition()
    {
        // Debug.Log($"[NodeDraggable ResetPosition] Resetting {gameObject.name}", gameObject);
        // Reset parent and position
        transform.SetParent(_originalParent, false);
        _rectTransform.anchoredPosition = _originalAnchoredPosition;
        _originalCell = _originalParent?.GetComponent<NodeCell>(); // Update cell ref

        // Ensure visuals and raycasts are correct after reset
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
        }

        // Update parent cell reference on the NodeView
        NodeView view = GetComponent<NodeView>();
        view?.UpdateParentCellReference();
    }

    public void SnapToCell(NodeCell targetCell)
    {
        // Debug.Log($"[NodeDraggable SnapToCell] Snapping {gameObject.name} to Cell {targetCell?.CellIndex}", gameObject);
        if (targetCell == null) { ResetPosition(); return; }

        // Set Parent and Position
        transform.SetParent(targetCell.transform, false);
        _rectTransform.anchoredPosition = Vector2.zero;

        // Update Internal Draggable References
        _originalParent = targetCell.transform;
        _originalCell = targetCell;
        _originalAnchoredPosition = Vector2.zero;

        // Ensure visuals and raycasts are correct after snap
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
        }

        // Update the NodeView's parent reference
        NodeView view = GetComponent<NodeView>();
        view?.UpdateParentCellReference();
    }

    // OnDisable might not be strictly needed now but can be kept as safety
    void OnDisable()
    {
        // If it was disabled mid-drag (blocksRaycasts == false), reset state
        if (_canvasGroup != null && !_canvasGroup.blocksRaycasts)
        {
             Debug.LogWarning($"[NodeDraggable] Disabled while dragging {gameObject.name}. Resetting CanvasGroup.", gameObject);
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
            // Resetting position might be desired but complex here, ensure visuals are ok.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeEditorGridController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using TMPro;
using System.Linq;

[RequireComponent(typeof(RectTransform))]
public class NodeEditorGridController : MonoBehaviour
{
    public static NodeEditorGridController Instance { get; private set; }

    [Header("Grid Layout & Appearance")]
    [SerializeField][Min(1)] private int emptyCellsCount = 8;
    [SerializeField] private Vector2 cellSize = new Vector2(64f, 64f);
    [SerializeField] private float cellMargin = 10f;

    [Header("Empty Cell Visuals")]
    [SerializeField] private Sprite emptyCellSprite;
    [SerializeField] private Color emptyCellColor = Color.white;
    [SerializeField] private Vector3 emptyCellScale = Vector3.one;

    [Header("Node Visuals")]
    [SerializeField] private GameObject nodeViewPrefab;
    [SerializeField] private Vector3 nodeImageScale = Vector3.one;
    [SerializeField] private Color selectedNodeBackgroundColor = new Color(0.9f, 0.9f, 0.7f, 1f);

    [Header("Node Definitions & Interaction")]
    [SerializeField] private NodeDefinitionLibrary definitionLibrary; // Keep this reference
    [SerializeField] private TMP_Dropdown nodeDropdown;

    [Header("UI Toggle")]
    [SerializeField] private GameObject gridUIParent;


    private List<NodeCell> nodeCells = new List<NodeCell>();
    private RectTransform _rectTransform;
    private Canvas _rootCanvas;
    private NodeGraph _uiGraphRepresentation = new NodeGraph();


    public GameObject NodeViewPrefab => nodeViewPrefab;
    public Vector3 NodeImageScale => nodeImageScale;
    public NodeDefinitionLibrary DefinitionLibrary => definitionLibrary;
    public Color SelectedNodeBackgroundColor => selectedNodeBackgroundColor;
    public Color EmptyCellColor => emptyCellColor;
    public NodeGraph GetCurrentUIGraph() => _uiGraphRepresentation;


    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        _rectTransform = GetComponent<RectTransform>();
        _rootCanvas = GetComponentInParent<Canvas>();
        if (_rootCanvas == null) Debug.LogError("[NodeEditorGridController] Root Canvas not found!", gameObject);
        if (gridUIParent == null) Debug.LogWarning("[NodeEditorGridController] Grid UI Parent not assigned. UI Toggling might not work.", gameObject);
    }

    void OnDestroy()
    {
        if (Instance == this) Instance = null;
    }

    void Start()
    {
        if (nodeDropdown != null) nodeDropdown.gameObject.SetActive(false);
        else Debug.LogWarning("[NodeEditorGridController] Node Dropdown not assigned.", gameObject);
        if (definitionLibrary == null) Debug.LogError("[NodeEditorGridController] Node Definition Library not assigned!", gameObject);

        CreateCells();
        SpawnInitialNodes(); // <<< CALL NEW METHOD
        RefreshGraph(); // Refresh after potentially spawning initial nodes
    }

    private void CreateCells()
    {
        // Clear existing cells if any (e.g., during hot reload in editor)
        foreach (Transform child in transform) {
            // Avoid destroying self or essential components if they are children by mistake
            if (child.GetComponent<NodeCell>() != null) {
                Destroy(child.gameObject);
            }
        }
        nodeCells.Clear();
        NodeCell.ClearSelection(); // Ensure no selection persists

        float totalWidth = (emptyCellsCount * cellSize.x) + ((emptyCellsCount - 1) * cellMargin);
        // Calculate start based on pivot (assuming center pivot 0.5, 0.5)
        float startX = -(totalWidth / 2f) + (cellSize.x / 2f);
        // If using bottom-left pivot (0,0): float startX = 0;
        // Adjust Y based on pivot too
        float startY = 0; // Assuming center Y pivot

        for (int i = 0; i < emptyCellsCount; i++)
        {
            GameObject cellGO = new GameObject($"Cell_{i}");
            RectTransform rt = cellGO.AddComponent<RectTransform>();
            cellGO.transform.SetParent(transform, false);

            // Set anchors and pivot (e.g., center)
            rt.anchorMin = new Vector2(0.5f, 0.5f);
            rt.anchorMax = new Vector2(0.5f, 0.5f);
            rt.pivot = new Vector2(0.5f, 0.5f);
            rt.sizeDelta = cellSize; // Set size

            // Calculate position
            float xPos = startX + i * (cellSize.x + cellMargin);
            float yPos = startY;
            rt.anchoredPosition = new Vector2(xPos, yPos);

            Image cellImage = cellGO.AddComponent<Image>();
            cellImage.sprite = emptyCellSprite;
            cellImage.color = emptyCellColor;
            cellImage.raycastTarget = true; // Important for drop detection
            // rt.localScale = emptyCellScale; // Apply scale if needed

            NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
            cellLogic.Init(i, this, cellImage);
            nodeCells.Add(cellLogic);
        }
    }

    /// <summary>
    /// Spawns nodes defined in the NodeDefinitionLibrary's initialNodes list.
    /// </summary>
    private void SpawnInitialNodes() // <<< NEW METHOD
    {
        if (definitionLibrary == null || definitionLibrary.initialNodes == null)
        {
            // Debug.Log("No initial nodes defined in the library.");
            return;
        }

        foreach (var config in definitionLibrary.initialNodes)
        {
            // Validate Node Definition
            if (config.nodeDefinition == null)
            {
                Debug.LogWarning($"Initial node config has null NodeDefinition. Skipping.");
                continue;
            }

            // Validate Cell Index
            if (config.cellIndex < 0 || config.cellIndex >= nodeCells.Count)
            {
                Debug.LogWarning($"Initial node config for '{config.nodeDefinition.name}' has invalid cell index ({config.cellIndex}). Max index is {nodeCells.Count - 1}. Skipping.");
                continue;
            }

            // Get Target Cell
            NodeCell targetCell = nodeCells[config.cellIndex];
            if (targetCell.HasNode())
            {
                Debug.LogWarning($"Initial node config for '{config.nodeDefinition.name}' targets cell {config.cellIndex}, but it's already occupied. Skipping.");
                continue;
            }

            // Spawn the Node
            // Debug.Log($"Spawning initial node '{config.nodeDefinition.name}' in cell {config.cellIndex}. Move:{config.canMove}, Delete:{config.canDelete}");
            targetCell.AssignNode(config.nodeDefinition);

            // Apply Move/Delete settings
            NodeView spawnedView = targetCell.GetNodeView();
            if (spawnedView != null)
            {
                // Control Movability
                NodeDraggable draggable = spawnedView.GetComponent<NodeDraggable>();
                if (draggable != null)
                {
                    draggable.enabled = config.canMove;
                } else if (config.canMove) {
                     Debug.LogWarning($"Initial node '{config.nodeDefinition.name}' in cell {config.cellIndex} is set to 'canMove=true' but its prefab is missing the NodeDraggable component.", spawnedView.gameObject);
                }


                // Control Deletability
                NodeData spawnedData = targetCell.GetNodeData();
                if (spawnedData != null)
                {
                    spawnedData.canBeDeleted = config.canDelete;
                }
            }
        }
    }


    void Update()
    {
        // UI Toggle
        if (Input.GetKeyDown(KeyCode.Tab)) ToggleGridUI();

        // --- Delete Node Handling (Modified) ---
        if (Input.GetKeyDown(KeyCode.Delete))
        {
            if (NodeCell.CurrentlySelectedCell != null)
            {
                NodeCell selected = NodeCell.CurrentlySelectedCell;
                NodeData data = selected.GetNodeData(); // Get the node data instance

                // Check if the node exists AND if its 'canBeDeleted' flag is true
                if (data != null && data.canBeDeleted) // <<< CHECK ADDED
                {
                    // Debug.Log($"Deleting node '{data.nodeDisplayName}' from cell {selected.CellIndex}.");
                    selected.RemoveNode(); // RemoveNode handles deselection
                    RefreshGraph(); // Update internal graph representation
                }
                else if (data != null && !data.canBeDeleted)
                {
                    // Optional: Give visual/audio feedback that deletion is blocked
                     Debug.Log($"Node '{data.nodeDisplayName}' cannot be deleted.");
                    // Example: Play a short "error" sound or flash the node briefly
                }
                // If data is null (empty cell selected), do nothing
            }
        }

        // Dropdown Escape Handling
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf)
            {
                HideDropdown();
            }
             // Also deselect node if Escape is pressed and dropdown isn't active?
             else if (NodeCell.CurrentlySelectedCell != null) {
                 NodeCell.ClearSelection();
             }
        }
    }

    // --- ToggleGridUI --- (Keep existing method)
    public void ToggleGridUI()
    {
        if (gridUIParent != null) {
            bool currentState = gridUIParent.activeSelf;
            gridUIParent.SetActive(!currentState);
            if (!gridUIParent.activeSelf) { // If hiding UI
                 if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) HideDropdown();
                 NodeCell.ClearSelection(); // Deselect nodes when UI hides
            }
        }
        else Debug.LogWarning("[NodeEditorGridController] Grid UI Parent not assigned.");
    }

    // --- OnEmptyCellRightClicked --- (Keep existing method)
    public void OnEmptyCellRightClicked(NodeCell cell, PointerEventData eventData)
    {
        if (nodeDropdown == null) { Debug.LogError("[NodeEditorGridController] Node Dropdown not assigned."); return; }
        if (definitionLibrary == null || definitionLibrary.definitions == null) { Debug.LogError("[NodeEditorGridController] Node Definition Library not assigned or has no definitions."); return; }

        // Stop potentially existing dropdown coroutine to prevent conflicts
        StopCoroutine("ShowDropdownCoroutine");
        StartCoroutine(ShowDropdownCoroutine(cell, eventData));
    }

    // --- ShowDropdownCoroutine --- (Keep existing method)
     private IEnumerator ShowDropdownCoroutine(NodeCell cell, PointerEventData eventData)
     {
         // Build Options
         List<TMP_Dropdown.OptionData> options = new List<TMP_Dropdown.OptionData>();
         options.Add(new TMP_Dropdown.OptionData("Select Node...")); // Placeholder option
         // Sort definitions alphabetically for the dropdown
         var sortedDefinitions = definitionLibrary.definitions
                                     .Where(def => def != null) // Filter out null entries
                                     .OrderBy(def => def.displayName)
                                     .ToList();
         foreach (var def in sortedDefinitions) {
             TMP_Dropdown.OptionData option = new TMP_Dropdown.OptionData();
             option.text = def.displayName;
             option.image = def.thumbnail; // Use thumbnail as icon
             options.Add(option);
         }
         nodeDropdown.ClearOptions();
         nodeDropdown.AddOptions(options);

         // Setup Listener (Use lambda to capture cell and sorted list)
         nodeDropdown.onValueChanged.RemoveAllListeners(); // Clear previous listeners
         nodeDropdown.onValueChanged.AddListener((selectedIndex) => {
             OnDropdownValueChanged(selectedIndex, cell, sortedDefinitions); // Pass necessary context
         });

         // Position the Dropdown near the click position
         RectTransform dropdownRect = nodeDropdown.GetComponent<RectTransform>();
         RectTransformUtility.ScreenPointToLocalPointInRectangle(
             dropdownRect.parent as RectTransform, // Parent RectTransform
             eventData.position,                   // Screen click position
             _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera, // Camera for non-overlay canvas
             out Vector2 localPos);
         dropdownRect.localPosition = localPos;

         // Activate Dropdown GameObject if not already active
         if (!nodeDropdown.gameObject.activeSelf) nodeDropdown.gameObject.SetActive(true);

         // Wait one frame to allow UI layout to update before showing
         yield return null;

         // Show the dropdown options list
         try {
             // Ensure template is assigned before showing
             if (nodeDropdown.template == null) {
                 Debug.LogError("Dropdown template is not assigned in the Inspector!", nodeDropdown.gameObject);
                 HideDropdown();
                 yield break;
             }
             nodeDropdown.Show();
         } catch (System.NullReferenceException nre) {
             // Catch potential NRE if something internal goes wrong
              Debug.LogError($"Error showing dropdown: {nre.Message}", nodeDropdown.gameObject);
             HideDropdown();
             yield break;
         }

         // Set initial value and refresh display
         nodeDropdown.value = 0; // Select the "Select Node..." placeholder
         nodeDropdown.RefreshShownValue();
     }

    // --- OnDropdownValueChanged --- (Keep existing method)
     private void OnDropdownValueChanged(int selectedIndex, NodeCell targetCell, List<NodeDefinition> sortedDefs)
     {
         HideDropdown(); // Hide dropdown immediately after selection

         // Index 0 is the placeholder "Select Node..."
         if (selectedIndex > 0) {
             // Adjust index to match the sortedDefs list (since dropdown index 1 corresponds to list index 0)
             int definitionIndex = selectedIndex - 1;
             if (definitionIndex >= 0 && definitionIndex < sortedDefs.Count) {
                 NodeDefinition selectedDef = sortedDefs[definitionIndex];
                 if (selectedDef != null) {
                      // Debug.Log($"Assigning node '{selectedDef.name}' to cell {targetCell.CellIndex}");
                     targetCell.AssignNode(selectedDef); // Assign the chosen node
                     NodeCell.SelectCell(targetCell);   // Select the newly placed node
                     RefreshGraph();                    // Update the internal graph representation
                 }
             } else {
                  Debug.LogError($"Dropdown selection index ({selectedIndex}) resulted in an out-of-bounds index ({definitionIndex}) for the definition list.");
             }
         }
         // If selectedIndex is 0, do nothing (user clicked the placeholder)
     }

    // --- HideDropdown --- (Keep existing method)
    public void HideDropdown()
    {
        if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf)
        {
            nodeDropdown.Hide(); // Hide the options list
            nodeDropdown.gameObject.SetActive(false); // Deactivate the main dropdown object
        }
    }

    // --- RefreshGraph --- (Keep existing method)
    public void RefreshGraph()
    {
        if (_uiGraphRepresentation == null) _uiGraphRepresentation = new NodeGraph();
        _uiGraphRepresentation.nodes.Clear();
        // Ensure cells are ordered correctly by index when building the graph
        foreach (var cell in nodeCells.OrderBy(c => c.CellIndex))
        {
            NodeData data = cell.GetNodeData();
            if (data != null)
            {
                // Update orderIndex just in case it changed (though it shouldn't if not moved)
                data.orderIndex = cell.CellIndex;
                _uiGraphRepresentation.nodes.Add(data);
            }
        }
        // Optional: Add debug log to see the refreshed graph node count
        // Debug.Log($"UI Graph Refreshed. Node Count: {_uiGraphRepresentation.nodes.Count}");
    }

    // --- HandleNodeDrop --- (Keep existing method)
     public bool HandleNodeDrop(NodeDraggable draggedDraggable, NodeCell originalCell, Vector2 screenPosition)
     {
         NodeCell targetCell = FindCellAtScreenPosition(screenPosition);
         bool changed = false;

         if (targetCell != null && originalCell != null)
         {
             // Get data from the node being dragged
             NodeView draggedView = draggedDraggable.GetComponent<NodeView>();
             NodeData draggedData = draggedView?.GetNodeData();

             // Ensure we have valid data to move
             if (draggedView == null || draggedData == null) {
                 Debug.LogError("Dragged object missing NodeView or NodeData!", draggedDraggable.gameObject);
                 draggedDraggable.ResetPosition(); // Reset if invalid
                 return false;
             }

             // Case 1: Dropped back onto the original cell
             if (targetCell == originalCell) {
                 draggedDraggable.ResetPosition(); // Snap back cleanly
                 NodeCell.SelectCell(targetCell); // Reselect it
                 return false; // No change in layout
             }

             // --- Proceed with swap/move ---
             NodeView existingViewInTarget = targetCell.GetNodeView();
             NodeData existingDataInTarget = targetCell.GetNodeData();

             // Clear selection during swap
             NodeCell.ClearSelection();

             // 1. Clear the original cell's reference to the node being moved
             originalCell.ClearNodeReference();

             // 2. If the target cell had a node, move it to the original cell
             if (existingViewInTarget != null && existingDataInTarget != null) {
                 NodeDraggable existingDraggable = existingViewInTarget.GetComponent<NodeDraggable>();
                 // Assign the existing node to the original cell
                 originalCell.AssignNodeView(existingViewInTarget, existingDataInTarget);
                 // Snap its visual representation
                 if (existingDraggable != null) existingDraggable.SnapToCell(originalCell);
             }

             // 3. Assign the dragged node to the target cell
             targetCell.AssignNodeView(draggedView, draggedData);
             draggedDraggable.SnapToCell(targetCell); // Snap its visual representation

             // 4. Select the cell where the node was dropped
             NodeCell.SelectCell(targetCell);
             changed = true;
         }
         else // Dropped outside grid or invalid original cell
         {
             // Reset the dragged node to its original position
             draggedDraggable.ResetPosition();
             // Reselect the original cell if it still has the node (it should after ResetPosition)
             if (originalCell != null && originalCell.HasNode()) {
                 NodeCell.SelectCell(originalCell);
             } else {
                 NodeCell.ClearSelection(); // Should not happen often here
             }
         }

         // If the layout changed, refresh the internal graph representation
         if (changed) RefreshGraph();

         return changed;
     }

    // --- FindCellAtScreenPosition --- (Keep existing method)
     private NodeCell FindCellAtScreenPosition(Vector2 screenPosition)
     {
         NodeCell foundCell = null;
         // Check all cells
         foreach (var cell in nodeCells)
         {
             RectTransform cellRect = cell.GetComponent<RectTransform>();
             // Use RectTransformUtility for accurate checks across different canvas modes
             bool contains = RectTransformUtility.RectangleContainsScreenPoint(
                 cellRect,
                 screenPosition,
                 _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera
             );
             if (contains) {
                 foundCell = cell;
                 break; // Found the cell under the cursor
             }
         }
         return foundCell;
     }

    // --- OnDrawGizmos --- (Keep existing method)
     #if UNITY_EDITOR
     void OnDrawGizmos()
     {
         // Draw gizmos only in the editor and when not playing
         if (!Application.isPlaying && TryGetComponent<RectTransform>(out var rt))
         {
             Gizmos.color = new Color(0f, 1f, 0f, 0.5f); // Semi-transparent green

             float totalWidth = (emptyCellsCount * cellSize.x) + ((emptyCellsCount - 1) * cellMargin);
             // Adjust start position based on pivot (assuming 0.5, 0.5)
             float startX_for_gizmo = -(totalWidth / 2f) + (cellSize.x / 2f);
             float startY_for_gizmo = 0; // Assuming center Y pivot

             // Store original matrix
             Matrix4x4 originalMatrix = Gizmos.matrix;

             for (int i = 0; i < emptyCellsCount; i++)
             {
                 // Calculate center position of the cell in local space relative to pivot
                 float xOffset = startX_for_gizmo + i * (cellSize.x + cellMargin);
                 Vector3 localCellCenter = new Vector3(xOffset, startY_for_gizmo, 0);

                 // Transform local center to world space, considering rotation and scale
                 Vector3 worldCellCenter = rt.TransformPoint(localCellCenter);

                 // Calculate gizmo size based on RectTransform's lossy scale
                 Vector3 gizmoSize = new Vector3(cellSize.x * rt.lossyScale.x, cellSize.y * rt.lossyScale.y, 0.1f);

                 // Set Gizmos matrix to handle rotation
                 Gizmos.matrix = Matrix4x4.TRS(worldCellCenter, rt.rotation, Vector3.one);

                 // Draw wire cube centered at the transformed position (local origin within the matrix)
                 Gizmos.DrawWireCube(Vector3.zero, gizmoSize);
             }
             // Restore original Gizmos matrix
             Gizmos.matrix = originalMatrix;
         }
     }
     #endif
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeSelectable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

public class NodeSelectable : MonoBehaviour, IPointerClickHandler
{
    public static GameObject CurrentSelected { get; set; }

    public void OnPointerClick(PointerEventData eventData)
    {
        Select(gameObject);
    }

    public static void Select(GameObject node)
    {
        if (CurrentSelected != null && CurrentSelected != node)
        {
            // (Optional) Remove highlight from previously selected node.
        }
        CurrentSelected = node;
        // (Optional) Add highlight effect here.
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeView.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.EventSystems;
using System.Collections.Generic;
using System.Text;

[RequireComponent(typeof(RectTransform))]
public class NodeView : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler
{
    // --- Fields remain the same ---
    [Header("UI Elements (Assign in Prefab)")]
    [SerializeField] private Image thumbnailImage;
    [SerializeField] private Image backgroundImage;
    [SerializeField] private GameObject tooltipPanel;
    [SerializeField] private TMP_Text tooltipText;
    [SerializeField] private TMP_Text nodeNameText;
    [Header("Configuration")]
    [SerializeField] private bool displayNodeName = false;

    private NodeData _nodeData;
    private NodeDefinition _nodeDefinition;
    private NodeEditorGridController _controller;
    private NodeCell _parentCell;
    private Color _originalBackgroundColor;

    // --- Initialize, UpdateParentCellReference, Getters, Highlight, Unhighlight remain the same ---
     public void Initialize(NodeData data, NodeDefinition definition, NodeEditorGridController controller)
    { /* ... as before ... */
         _nodeData = data; _nodeDefinition = definition; _controller = controller;
         UpdateParentCellReference();
         if (_nodeData == null || _nodeDefinition == null || _controller == null || _parentCell == null) { gameObject.SetActive(false); return; }
         if (thumbnailImage != null) { thumbnailImage.sprite = _nodeDefinition.thumbnail; thumbnailImage.color = _nodeDefinition.thumbnailTintColor; thumbnailImage.rectTransform.localScale = _controller.NodeImageScale; thumbnailImage.enabled = (thumbnailImage.sprite != null); if (!thumbnailImage.raycastTarget) thumbnailImage.raycastTarget = true; }
         if (backgroundImage != null) { _originalBackgroundColor = _nodeDefinition.backgroundColor; backgroundImage.color = _originalBackgroundColor; backgroundImage.enabled = true; if (!backgroundImage.raycastTarget) backgroundImage.raycastTarget = true; }
         if (tooltipPanel != null) tooltipPanel.SetActive(false);
         if (nodeNameText != null) { nodeNameText.text = _nodeData.nodeDisplayName; nodeNameText.gameObject.SetActive(displayNodeName); }
    }
     public void UpdateParentCellReference() { _parentCell = GetComponentInParent<NodeCell>(); /* ... null check ... */ }
     public NodeData GetNodeData() => _nodeData;
     public NodeDefinition GetNodeDefinition() => _nodeDefinition;
     public NodeCell GetParentCell() => _parentCell;
     public void Highlight() { if (backgroundImage != null && _controller != null) backgroundImage.color = _controller.SelectedNodeBackgroundColor; }
     public void Unhighlight() { if (backgroundImage != null) backgroundImage.color = _originalBackgroundColor; }


    // --- Tooltip Handling with Logging ---
    public void OnPointerEnter(PointerEventData eventData)
    {
        // --- Add Log ---
        Debug.Log($"[NodeView OnPointerEnter] Fired on {gameObject.name}. Tooltip Panel assigned: {tooltipPanel != null}", gameObject);

        // Ensure the CanvasGroup allows raycasts IF it exists
        CanvasGroup cg = GetComponent<CanvasGroup>();
        if (cg != null && cg.blocksRaycasts == false)
        {
             Debug.LogWarning($"--> PointerEnter detected but CanvasGroup is blocking raycasts! Drag state might be stuck?", gameObject);
             // Optionally force it: cg.blocksRaycasts = true;
        }


        if (tooltipPanel != null && tooltipText != null && _nodeDefinition != null && _nodeData != null)
        {
            // --- Add Log ---
            // Debug.Log("--> Activating Tooltip Panel");
            tooltipPanel.SetActive(true);
            tooltipText.text = BuildTooltipString();
        }
         else if (tooltipPanel == null) {
             // Debug.LogWarning("--> Tooltip Panel is not assigned in Inspector.", gameObject);
         }
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        // --- Add Log ---
        // Debug.Log($"[NodeView OnPointerExit] Fired on {gameObject.name}", gameObject);

        if (tooltipPanel != null)
        {
             // Debug.Log("--> Deactivating Tooltip Panel");
            tooltipPanel.SetActive(false);
        }
    }

    // --- Pointer Down remains the same ---
    public void OnPointerDown(PointerEventData eventData) { /* ... as before ... */
         // Debug.Log($"[NodeView OnPointerDown] Fired on: {gameObject.name} in Cell: {_parentCell?.CellIndex} | Button: {eventData.button}", gameObject);
        if (eventData.button == PointerEventData.InputButton.Left) {
            if (_parentCell != null) {
                 // Debug.Log($"--> Left Click Confirmed. Requesting SelectCell for {_parentCell.CellIndex}");
                NodeCell.SelectCell(_parentCell);
            } else { UpdateParentCellReference(); if (_parentCell != null) NodeCell.SelectCell(_parentCell); else Debug.LogError("[NodeView] ParentCell null on PointerDown!", gameObject); }
        }
    }

    // --- BuildTooltipString remains the same ---
    private string BuildTooltipString() { /* ... as before ... */
         StringBuilder sb = new StringBuilder(); sb.Append("<b>").Append(_nodeData.nodeDisplayName).Append("</b>\n"); if (!string.IsNullOrEmpty(_nodeDefinition.description)) sb.Append(_nodeDefinition.description).Append("\n"); if (_nodeData.effects != null && _nodeData.effects.Count > 0) { sb.Append("<i>Effects:</i>\n"); foreach (var eff in _nodeData.effects) { sb.Append("- ").Append(eff.effectType.ToString()).Append(": "); sb.Append(eff.primaryValue.ToString("G3")); if (eff.secondaryValue != 0) sb.Append(" / ").Append(eff.secondaryValue.ToString("G3")); sb.Append("\n"); } } return sb.ToString().TrimEnd();
     }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Player\GardenerController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class GardenerController : MonoBehaviour
{
    [Header("Movement Settings")]
    public float moveSpeed = 5f;
    
    [Header("Planting Settings")]
    public Vector2 seedPlantingOffset = new Vector2(0f, -0.5f); // Configurable offset for seed planting

    [Header("Visual Settings")]
    [Tooltip("If true, the sprite will be flipped when moving left")]
    public bool flipSpriteWhenMovingLeft = true;
    [Tooltip("If true, the character will face the opposite direction when flipped")]
    public bool flipHorizontalDirection = true;

    [Header("Animation Settings")]
    [Tooltip("Set to false to disable animations")]
    public bool useAnimations = true;
    public string runningParameterName = "isRunning";
    public string plantingParameterName = "isPlanting";
    [Tooltip("Should match your planting animation length exactly")]
    public float plantingDuration = 0.25f; // UPDATED to match your 0.25s animation


    
    // Private references
    private Rigidbody2D rb;
    private Vector2 movement;
    private SortableEntity sortableEntity;
    private SpriteRenderer spriteRenderer;
    private Animator animator;
    // Private variables
    private bool isPlanting = false;
    private float plantingTimer = 0f;
    private bool wasMovingBeforePlanting = false;

    private void Awake()
    {
        // Get required components
        rb = GetComponent<Rigidbody2D>();
        sortableEntity = GetComponent<SortableEntity>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        animator = GetComponent<Animator>();
        
        // Add SortableEntity if not already present
        if (sortableEntity == null)
            sortableEntity = gameObject.AddComponent<SortableEntity>();
            
        // Warn if sprite renderer is missing
        if (spriteRenderer == null)
            Debug.LogWarning("GardenerController: SpriteRenderer component not found. Sprite flipping won't work.");
            
        // Warn if animator is missing but animations are enabled
        if (animator == null && useAnimations)
            Debug.LogWarning("GardenerController: Animator component not found but useAnimations is true.");
    }

    private void Update()
    {
        // Handle movement input and planting action
        if (!isPlanting)
        {
            movement.x = Input.GetAxisRaw("Horizontal");
            movement.y = Input.GetAxisRaw("Vertical");
        
            // Check if we're moving (store for later)
            bool isMoving = movement.sqrMagnitude > 0.01f;
        
            // Handle planting action
            if (Input.GetKeyDown(KeyCode.Space))
            {
                // Store movement state before planting
                wasMovingBeforePlanting = isMoving;
                StartPlantingAnimation();
            }
        }
        else
        {
            // When planting, we don't accept movement input
            movement = Vector2.zero;
        
            // Handle planting timer
            plantingTimer -= Time.deltaTime;
            if (plantingTimer <= 0)
            {
                EndPlantingAnimation();
            }
        }
    
        // Update animations after all state changes are processed
        UpdateAnimations();
    
        // Handle sprite flipping based on movement direction
        UpdateSpriteDirection();
    }

    private void FixedUpdate()
    {
        // Only move if not planting
        if (!isPlanting)
        {
            rb.MovePosition(rb.position + movement.normalized * moveSpeed * Time.fixedDeltaTime);
        }
    }
    
    // Update character animations based on state
    private void UpdateAnimations()
    {
        if (!useAnimations || animator == null) return;
    
        // Set running animation parameter
        bool isMoving = movement.sqrMagnitude > 0.01f;
        animator.SetBool(runningParameterName, isMoving);
    }
    
    // Update sprite direction based on movement
    private void UpdateSpriteDirection()
    {
        if (spriteRenderer == null || !flipSpriteWhenMovingLeft) return;
        
        if (movement.x != 0)
        {
            // Only flip if moving horizontally
            bool shouldFlip = (movement.x < 0);
            
            // Apply flipping logic based on settings
            if (flipHorizontalDirection)
            {
                spriteRenderer.flipX = shouldFlip;
            }
            else
            {
                // Alternative approach: flip the entire transform
                // This is useful if the sprite is already facing left initially
                Vector3 scale = transform.localScale;
                scale.x = shouldFlip ? -Mathf.Abs(scale.x) : Mathf.Abs(scale.x);
                transform.localScale = scale;
            }
        }
    }
    
    // Start planting animation and process
    public void StartPlantingAnimation()
    {
        if (!useAnimations || isPlanting) return;
    
        isPlanting = true;
        plantingTimer = plantingDuration;
    
        // Set animation parameters
        if (animator != null)
        {
            // Set planting to true and ensure running is false
            animator.SetBool(plantingParameterName, true);
            animator.SetBool(runningParameterName, false);
        }
    }
    
    // End planting animation and resume normal control
    
    private void EndPlantingAnimation()
    {
        // Reset planting state
        isPlanting = false;
    
        // Reset animation parameters
        if (animator != null)
        {
            animator.SetBool(plantingParameterName, false);
        
            // Important: don't immediately set isRunning based on current movement
            // because movement is zero during planting. Instead:
            if (wasMovingBeforePlanting && (Input.GetAxisRaw("Horizontal") != 0 || Input.GetAxisRaw("Vertical") != 0))
            {
                // Only resume running if we were running before AND still have directional input
                animator.SetBool(runningParameterName, true);
            }
        }
    
        // Now update movement based on current input
        movement.x = Input.GetAxisRaw("Horizontal");
        movement.y = Input.GetAxisRaw("Vertical");
    }
    
    // Returns the position used for planting seeds, now with configurable offset
    public Vector2 GetPlantingPosition()
    {
        return (Vector2)transform.position + seedPlantingOffset;
    }
    
    // Public method to set planting animation duration
    public void SetPlantingDuration(float duration)
    {
        plantingDuration = Mathf.Max(0.1f, duration); // Ensure minimum duration
    }
    
    // Public method to trigger planting animation from other scripts
    public void Plant()
    {
        StartPlantingAnimation();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TilingMaterialDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Tilemaps; // Needed for Tile.ColliderType

// Defines the necessary data for a 16-tile Wang-style material
[CreateAssetMenu(fileName = "TilingMaterial_", menuName = "2D/Tiles/Tiling Material Definition")]
public class TilingMaterialDefinition : ScriptableObject
{
    [Header("Material Identity")]
    [Tooltip("Descriptive name for this material (e.g., Grass, Dirt, Water). Used for naming generated assets.")]
    public string materialName = "NewMaterial";

    [Header("Sprites (16 Required)")]
    [Tooltip("Assign the 16 sprites corresponding to the binary Wang Tile indices (0-15). Order is crucial! Index 0 = no neighbours, Index 15 = all neighbours.")]
    public Sprite[] sprites = new Sprite[16]; // Must have exactly 16 elements

    [Header("Generated Tile Settings")]
    [Tooltip("Default collider type for the generated RuleTile.")]
    public Tile.ColliderType defaultCollider = Tile.ColliderType.None;
    [Tooltip("Optional: Default GameObject prefab to instantiate with the tile.")]
    public GameObject defaultGameObject;
    [Tooltip("Color tint to apply to the generated RuleTile. White = no tint.")]
    public Color tintColor = Color.white; // <<< ADDED TINT COLOR

    // --- Validation ---
    private void OnValidate()
    {
        // Ensure the sprites array always has exactly 16 elements in the inspector
        if (sprites == null || sprites.Length != 16)
        {
            Debug.LogWarning($"'{materialName}' Material Definition: Sprites array must contain exactly 16 sprites. Resizing array.", this);
            System.Array.Resize(ref sprites, 16);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Editor\TilingMaterialGeneratorEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;          // Required for Editor, SerializedObject, etc.
using UnityEngine.Tilemaps; // Required for RuleTile, Tile
using System.Collections.Generic;
using System.IO;            // Required for path manipulation
using System.Text;          // Required for StringBuilder
using System.Linq;          // Required for OfType() and OrderBy()

[CustomEditor(typeof(TilingMaterialDefinition))]
public class TilingMaterialGeneratorEditor : Editor
{
    // Target script properties
    private SerializedProperty materialNameProp;
    private SerializedProperty spritesProp;
    private SerializedProperty defaultColliderProp;
    private SerializedProperty defaultGameObjectProp;
    private SerializedProperty tintColorProp;

    // Editor-only fields
    private Texture2D sourceSpriteSheet;
    private TilePalette targetPalette; // Type requires UnityEditor.Tilemaps namespace
    private bool addToPalette = true;

    private const string outputFolderPath = "Assets/Tiles/GeneratedRuleTiles"; // Adjust as needed

    private void OnEnable()
    {
        materialNameProp = serializedObject.FindProperty("materialName");
        spritesProp = serializedObject.FindProperty("sprites");
        defaultColliderProp = serializedObject.FindProperty("defaultCollider");
        defaultGameObjectProp = serializedObject.FindProperty("defaultGameObject");
        tintColorProp = serializedObject.FindProperty("tintColor");
    }

    public override void OnInspectorGUI()
    {
        TilingMaterialDefinition definition = (TilingMaterialDefinition)target;
        serializedObject.Update();

        EditorGUILayout.PropertyField(materialNameProp);
        EditorGUILayout.Space();

        // --- Auto-Fill Section ---
        EditorGUILayout.LabelField("Auto-Fill Sprites (Optional)", EditorStyles.boldLabel);
        sourceSpriteSheet = (Texture2D)EditorGUILayout.ObjectField(
            new GUIContent("Source Spritesheet", "Drag a sliced spritesheet Texture (16 sprites, named correctly) here."),
            sourceSpriteSheet, typeof(Texture2D), false);

        if (GUILayout.Button("Auto-Fill Sprites From Source Sheet")) {
            if (sourceSpriteSheet != null) AutoFillSpritesFromSheet(definition, sourceSpriteSheet);
            else EditorUtility.DisplayDialog("No Source Sheet", "Please assign a Source Spritesheet first.", "OK");
        }
        EditorGUILayout.HelpBox("Requires Texture sliced into 16 sprites named like 'Name_0' to 'Name_15'.", MessageType.Info);
        EditorGUILayout.Space();

        // --- Manual Sprite Assignment Section ---
        EditorGUILayout.LabelField("Manual Sprite Assignment (Indices 0-15)", EditorStyles.boldLabel);
        EditorGUILayout.HelpBox("Index based on NESW neighbours (N=8, E=4, S=2, W=1). Sum values for matching sides.", MessageType.Info);
        if (spritesProp.arraySize != 16) spritesProp.arraySize = 16;
        for (int i = 0; i < 16; i++) {
            string tooltip = GetTooltipForWangIndex(i);
            EditorGUILayout.PropertyField(spritesProp.GetArrayElementAtIndex(i), new GUIContent($"Sprite {i}", tooltip));
        }
        EditorGUILayout.Space();

        // --- Generated Tile Settings Section ---
        EditorGUILayout.LabelField("Generated Tile Settings", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(defaultColliderProp);
        EditorGUILayout.PropertyField(defaultGameObjectProp);
        EditorGUILayout.PropertyField(tintColorProp);
        EditorGUILayout.Space();

        // --- Palette Automation Section ---
        EditorGUILayout.LabelField("Tile Palette Automation", EditorStyles.boldLabel);
        addToPalette = EditorGUILayout.Toggle(new GUIContent("Add to Palette on Generate", "Automatically add the generated RuleTile to the selected Tile Palette asset below."), addToPalette);
        EditorGUI.BeginDisabledGroup(!addToPalette);
        // ObjectField requires the correct type, which comes from the namespace
        targetPalette = (TilePalette)EditorGUILayout.ObjectField(
            new GUIContent("Target Palette", "Drag the Tile Palette asset you want to add the generated tile to."),
            targetPalette,
            typeof(TilePalette), // Type defined in UnityEditor.Tilemaps
            false
        );
        EditorGUI.EndDisabledGroup();
        EditorGUILayout.Space();


        // --- Generation Button ---
        GUI.backgroundColor = Color.cyan;
        if (GUILayout.Button("Generate/Update RuleTile", GUILayout.Height(35))) {
            if (ValidateSprites(definition)) {
                if (addToPalette && targetPalette == null) {
                    EditorUtility.DisplayDialog("Palette Missing", "Please assign a Target Palette asset or uncheck 'Add to Palette'.", "OK");
                } else if (EditorUtility.DisplayDialog("Confirm RuleTile Generation", $"Create/Update RuleTile for '{definition.materialName}'?", "Generate", "Cancel")) {
                    GenerateRuleTileAsset(definition);
                }
            } else {
                EditorUtility.DisplayDialog("Sprite Error", "Assign all 16 sprite slots first.", "OK");
            }
        }
        GUI.backgroundColor = Color.white;

        serializedObject.ApplyModifiedProperties();
    }

    // --- Auto-Fill Logic ---
    private void AutoFillSpritesFromSheet(TilingMaterialDefinition definition, Texture2D sheet)
    {
        string path = AssetDatabase.GetAssetPath(sheet);
        if (string.IsNullOrEmpty(path)) return;

        Object[] loadedAssets = AssetDatabase.LoadAllAssetRepresentationsAtPath(path);
        List<Sprite> loadedSprites = loadedAssets.OfType<Sprite>()
            .Select(sprite => new { Sprite = sprite, SortKey = GetSortKeyFromName(sprite.name) })
            .OrderBy(item => item.SortKey)
            .Select(item => item.Sprite)
            .ToList();

        if (loadedSprites.Count != 16) {
            EditorUtility.DisplayDialog("Sprite Count Error", $"Found {loadedSprites.Count}/16 sprites in '{sheet.name}'. Check slicing and naming (e.g., Name_0 to Name_15).", "OK");
            return;
        }

        serializedObject.Update();
        bool changed = false;
        for (int i = 0; i < 16; i++) {
            SerializedProperty prop = spritesProp.GetArrayElementAtIndex(i);
            if (prop.objectReferenceValue != loadedSprites[i]) {
                prop.objectReferenceValue = loadedSprites[i];
                changed = true;
            }
        }

        if (changed) {
            serializedObject.ApplyModifiedProperties();
            EditorUtility.SetDirty(definition);
            EditorUtility.DisplayDialog("Success", "Auto-filled 16 sprites.", "OK");
        } else {
            EditorUtility.DisplayDialog("No Changes", "Sprites already assigned.", "OK");
        }
    }

    // --- Helper function to extract numeric sort key from sprite name ---
    private int GetSortKeyFromName(string spriteName)
    {
        int lastUnderscore = spriteName.LastIndexOf('_');
        if (lastUnderscore != -1 && lastUnderscore < spriteName.Length - 1) {
            if (int.TryParse(spriteName.Substring(lastUnderscore + 1), out int number)) {
                return number;
            }
        }
        Debug.LogWarning($"Could not parse number from sprite name '{spriteName}'. Using fallback sort.");
        return int.MaxValue;
    }

    // --- Sprite Validation ---
    private bool ValidateSprites(TilingMaterialDefinition definition)
    {
        if (definition.sprites == null || definition.sprites.Length != 16) return false;
        return !definition.sprites.Any(sprite => sprite == null);
    }

    // --- Tooltip Generation Helper ---
    private string GetTooltipForWangIndex(int index)
    {
        if (index < 0 || index > 15) return "Invalid Index";
        StringBuilder sb = new StringBuilder();
        sb.Append($"Index {index} ({System.Convert.ToString(index, 2).PadLeft(4, '0')}): Matches ");
        List<string> dirs = new List<string>();
        if ((index & 8) != 0) dirs.Add("N"); if ((index & 4) != 0) dirs.Add("E");
        if ((index & 2) != 0) dirs.Add("S"); if ((index & 1) != 0) dirs.Add("W");
        if (dirs.Count == 0) sb.Append("None"); else sb.Append(string.Join("+", dirs));
        return sb.ToString();
    }

    // --- RuleTile Generation Logic ---
    private void GenerateRuleTileAsset(TilingMaterialDefinition definition)
    {
        if (!Directory.Exists(outputFolderPath)) { Directory.CreateDirectory(outputFolderPath); AssetDatabase.Refresh(); }

        string assetName = $"{definition.materialName}_WangRuleTile.asset";
        string assetPath = Path.Combine(outputFolderPath, assetName).Replace("\\", "/");
        RuleTile ruleTile = AssetDatabase.LoadAssetAtPath<RuleTile>(assetPath);
        bool createdNew = false;
        if (ruleTile == null) { ruleTile = ScriptableObject.CreateInstance<RuleTile>(); AssetDatabase.CreateAsset(ruleTile, assetPath); createdNew = true; }

        SerializedObject tileSO = new SerializedObject(ruleTile);
        SerializedProperty defaultSpriteProp_Tile = tileSO.FindProperty("m_DefaultSprite");
        SerializedProperty defaultGoProp_Tile = tileSO.FindProperty("m_DefaultGameObject");
        SerializedProperty defaultColliderProp_Tile = tileSO.FindProperty("m_DefaultColliderType");
        SerializedProperty rulesProp = tileSO.FindProperty("m_TilingRules");
        SerializedProperty colorProp = tileSO.FindProperty("m_Color");

        defaultSpriteProp_Tile.objectReferenceValue = definition.sprites[15];
        defaultGoProp_Tile.objectReferenceValue = definition.defaultGameObject;
        defaultColliderProp_Tile.enumValueIndex = (int)definition.defaultCollider;
        colorProp.colorValue = definition.tintColor;

        rulesProp.ClearArray();
        Tile.ColliderType defaultCollider = (Tile.ColliderType)defaultColliderProp_Tile.enumValueIndex;
        for (int i = 0; i < 16; i++) {
            if (definition.sprites[i] == null) continue;
            AddRule(tileSO.targetObject, rulesProp, definition.sprites[i], GetNeighborsFromWangIndex(i), defaultCollider);
        }

        tileSO.ApplyModifiedProperties();
        EditorUtility.SetDirty(ruleTile);
        if (createdNew) Debug.Log($"Created RuleTile: {assetPath}"); else Debug.Log($"Updated RuleTile: {assetPath}");

        // --- Add to Palette Logic ---
        if (addToPalette && targetPalette != null)
        {
            // GridPaintingState and related methods require UnityEditor.Tilemaps namespace
            try
            {
                GridPaintingState.palette = targetPalette;
                GridPaintingState.UnlockPalette();
                GridPaintingState.SetTile(null, ruleTile); // Adds or updates tile
                EditorUtility.SetDirty(targetPalette);
                GridPaintingState.SavePalette();
                GridPaintingState.LockPalette(true);
                Debug.Log($"Added/Updated '{ruleTile.name}' in palette '{targetPalette.name}'.");
            }
            catch (System.Exception e) {
                Debug.LogError($"Failed to add tile to palette '{targetPalette.name}': {e.Message}");
                if (GridPaintingState.palette == targetPalette) GridPaintingState.LockPalette(true);
            }
            finally {
                 GridPaintingState.palette = null; // Reset active palette
            }
        }
        // --- End Add to Palette ---

        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
        EditorGUIUtility.PingObject(ruleTile);
    }

    // --- Helper to convert index to neighbor array (NESW = 8421) ---
    private int[] GetNeighborsFromWangIndex(int index)
    {
        const int T = RuleTile.TilingRule.Neighbor.This, N = RuleTile.TilingRule.Neighbor.NotThis;
        bool n=(index&8)!=0, e=(index&4)!=0, s=(index&2)!=0, w=(index&1)!=0;
        int nN=n?T:N, nE=e?T:N, nS=s?T:N, nW=w?T:N;
        int nTL=(n&&w)?T:N, nTR=(n&&e)?T:N, nBL=(s&&w)?T:N, nBR=(s&&e)?T:N;
        return new int[]{nTL, nN, nTR, nW, nE, nBL, nS, nBR};
    }

    // --- Helper to add a rule using SerializedProperty API ---
    private void AddRule(Object targetObject, SerializedProperty rulesListProp, Sprite sprite, int[] neighbors, Tile.ColliderType defaultColliderType)
    {
        rulesListProp.InsertArrayElementAtIndex(rulesListProp.arraySize);
        SerializedProperty newRuleProp = rulesListProp.GetArrayElementAtIndex(rulesListProp.arraySize - 1);
        SerializedProperty neighborsProp = newRuleProp.FindPropertyRelative("m_Neighbors");
        SerializedProperty spritesProp = newRuleProp.FindPropertyRelative("m_Sprites");
        SerializedProperty outputProp = newRuleProp.FindPropertyRelative("m_Output");
        SerializedProperty colliderProp = newRuleProp.FindPropertyRelative("m_ColliderType");
        SerializedProperty transformProp = newRuleProp.FindPropertyRelative("m_RuleTransform");

        if (neighborsProp.arraySize != 8) neighborsProp.arraySize = 8;
        for (int i = 0; i < 8; i++) { neighborsProp.GetArrayElementAtIndex(i).intValue = neighbors[i]; }
        if (spritesProp.arraySize != 1) spritesProp.arraySize = 1;
        spritesProp.GetArrayElementAtIndex(0).objectReferenceValue = sprite;
        outputProp.enumValueIndex = (int)RuleTile.TilingRule.OutputSprite.Single;
        colliderProp.enumValueIndex = (int)defaultColliderType;
        transformProp.enumValueIndex = (int)RuleTile.TilingRule.Transform.Fixed;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\NightColorPostProcess.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class NightColorPostProcess : MonoBehaviour
{
    [Header("References")]
    public WeatherManager weatherManager;        // Assign your existing WeatherManager
    public Volume globalVolume;                  // The Volume with the Color Adjustments override

    private ColorAdjustments colorAdjustments;   // We'll read/write color filter, post exposure, and saturation

    [Header("Color Settings")]
    [Tooltip("The color filter at full day (sunIntensity = 1).")]
    public Color dayColorFilter = Color.white;
    [Tooltip("The color filter at full night (sunIntensity ~ 0).")]
    public Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);

    [Tooltip("Daytime Post-Exposure (e.g. 0). Higher = brighter.")]
    public float dayPostExposure = 0f;
    [Tooltip("Nighttime Post-Exposure (e.g. -0.5). Lower = darker.")]
    public float nightPostExposure = -0.5f;

    [Header("Saturation Settings")]
    [Tooltip("Saturation at full day (0 means no change).")]
    public float daySaturation = 0f;
    [Tooltip("Saturation at full night (e.g. -50 for more desaturation at night).")]
    public float nightSaturation = -50f;

    private void Start()
    {
        if (!globalVolume)
        {
            Debug.LogWarning("[NightColorPostProcess] No globalVolume assigned!");
            return;
        }

        // Try to get the ColorAdjustments override from the volume's profile
        if (globalVolume.profile.TryGet<ColorAdjustments>(out var colorAdj))
        {
            colorAdjustments = colorAdj;
        }
        else
        {
            Debug.LogWarning("[NightColorPostProcess] No ColorAdjustments override found in the Volume profile!");
        }
    }

    private void Update()
    {
        if (!weatherManager || colorAdjustments == null)
            return;
        
        // Get the sun intensity (0 = night, 1 = day)
        float sun = Mathf.Clamp01(weatherManager.sunIntensity);
        float t = 1f - sun;  // t=0 at day, t=1 at night
        
        // Lerp the color filter
        Color finalFilter = Color.Lerp(dayColorFilter, nightColorFilter, t);
        colorAdjustments.colorFilter.value = finalFilter;
        
        // Lerp post exposure
        float finalExposure = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
        colorAdjustments.postExposure.value = finalExposure;
        
        // Lerp saturation
        float finalSaturation = Mathf.Lerp(daySaturation, nightSaturation, t);
        colorAdjustments.saturation.value = finalSaturation;
    }
}



