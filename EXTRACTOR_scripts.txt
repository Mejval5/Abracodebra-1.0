This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-03-30 04:39:01
================================================================================

DIRECTORY STRUCTURE
--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   └── NodeDefinitionPostprocessor.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   └── Animal_Fox.prefab
│   │   ├── Plants
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelFruit.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   └── PlantPrefab.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       └── ThoughtBubble.prefab
│   └── General
│       ├── GardenerPrefab.prefab
│       ├── NodeView.prefab
│       └── Projectile_Basic_Pixel.prefab
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   └── Animal_000_Bunny.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   └── Nodes Plant
│       ├── NodeDefinitionLibrary.asset
│       ├── Node_000_Seed.asset
│       ├── Node_003_Output.asset
│       ├── Node_004_ManaSource.asset
│       └── Node_005_DamageNode.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   └── ThoughtTrigger.cs
│   │   └── Plants
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── UI
│   └── Visuals
│       └── NightColorPostProcess.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Test
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionAutoAdder.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionAutoAdder : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets,
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string folderPath = Path.GetDirectoryName(assetPath);
                string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
                if (libraryFiles.Length > 0)
                {
                    NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
                    if (library != null && !library.definitions.Contains(nodeDef))
                    {
                        library.definitions.Add(nodeDef);
                        EditorUtility.SetDirty(library);
                        AssetDatabase.SaveAssets();
                    }
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionCreator.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;

public static class NodeDefinitionCreator
{
    private const string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

    [MenuItem(MenuPath, false, 50)]
    public static void CreateNodeDefinition()
    {
        // Figure out which folder the user is in, or use Assets/
        string folder = GetSelectedPathOrFallback();

        // Determine the next numeric index for "Node_XXX_"
        int nextNumber = GetNextNodeNumber(folder);

        // e.g., "Node_007_"
        string newName = $"Node_{nextNumber:D3}_";
        string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

        // Create the NodeDefinition
        NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
        AssetDatabase.CreateAsset(nodeDef, newPath);
        
        // Save and refresh, but DO NOT select or focus the ProjectWindow.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        Debug.Log($"Created NodeDefinition at: {newPath}");
        // Notice we don't call Selection.activeObject = nodeDef
        // or EditorUtility.FocusProjectWindow()
        // or ProjectWindowUtil.ShowCreatedAsset(nodeDef)
        // thus we avoid changing the user's folder.
    }

    // (Optional) Validate the menu item so it’s disabled if the game is running
    [MenuItem(MenuPath, true)]
    private static bool ValidateCreateNodeDefinition()
    {
        return !Application.isPlaying;
    }

    private static string GetSelectedPathOrFallback()
    {
        // Attempt to get the folder the user has selected in the Project window
        string path = "Assets";
        foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets))
        {
            path = AssetDatabase.GetAssetPath(obj);
            if (!string.IsNullOrEmpty(path))
            {
                // If it's a file, get its parent folder
                if (File.Exists(path))
                {
                    path = Path.GetDirectoryName(path);
                }
                break;
            }
        }
        return path;
    }

    private static int GetNextNodeNumber(string folderPath)
    {
        int nextNumber = 1;
        // Look for existing Node_XXX_ files
        string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
        foreach (var file in files)
        {
            string fName = Path.GetFileNameWithoutExtension(file);
            if (fName.StartsWith("Node_") && fName.Length >= 8)
            {
                // extract the 3-digit number from Node_000_
                string numberPart = fName.Substring(5, 3);
                if (int.TryParse(numberPart, out int num) && num >= nextNumber)
                {
                    nextNumber = num + 1;
                }
            }
        }
        return nextNumber;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionLibraryEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;

[CustomEditor(typeof(NodeDefinitionLibrary))]
public class NodeDefinitionLibraryEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            UpdateLibrary();
        }
    }

    private void UpdateLibrary()
    {
        NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

        // Get the folder of the current library asset.
        string libraryPath = AssetDatabase.GetAssetPath(library);
        string folderPath = Path.GetDirectoryName(libraryPath);

        // Find all .asset files in the folder.
        string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

        // Load NodeDefinition assets from that folder.
        List<NodeDefinition> defs = new List<NodeDefinition>();
        foreach (string file in assetFiles)
        {
            // Ignore the library asset itself.
            if (file == libraryPath)
                continue;

            NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
            if (def != null)
                defs.Add(def);
        }

        // Sort definitions by the numeric portion in the file name (assumes "Node_XXX_...").
        defs = defs.OrderBy(d => {
            string name = d.name;
            if (name.StartsWith("Node_") && name.Length >= 8)
            {
                string numStr = name.Substring(5, 3);
                if (int.TryParse(numStr, out int num))
                    return num;
            }
            return int.MaxValue; // if no number is found, sort last.
        }).ToList();

        library.definitions = defs;
        EditorUtility.SetDirty(library);
        AssetDatabase.SaveAssets();
        Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionPostprocessor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionPostprocessor : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, 
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string fileName = Path.GetFileNameWithoutExtension(assetPath);
                // Check if file name already starts with "Node_"
                if (!fileName.StartsWith("Node_"))
                {
                    string folderPath = Path.GetDirectoryName(assetPath);
                    // Get all files in folder that start with "Node_"
                    var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
                    int nextNumber = 1;
                    foreach (var file in files)
                    {
                        string fName = Path.GetFileNameWithoutExtension(file);
                        string[] parts = fName.Split('_');
                        if (parts.Length >= 2 && int.TryParse(parts[1], out int num))
                        {
                            if (num >= nextNumber)
                                nextNumber = num + 1;
                        }
                    }
                    string newName = $"Node_{nextNumber:D3}_";
                    AssetDatabase.RenameAsset(assetPath, newName);
                    AssetDatabase.SaveAssets();
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro;

public enum PlantCellType
{
    Seed,
    Stem,
    Leaf,
    Flower,
    Fruit
}

public class PlantGrowth : MonoBehaviour
{
    [Header("Seed Gene Parameters (set via Seed node effect)")]
    public int stemMinLength = 3;            // Minimum stem length (cells)
    public int stemMaxLength = 6;            // Maximum stem length (cells)
    public float growthSpeed = 1f;           // Seconds per growth step
    [Tooltip("Leaf Gap: 0 = leaves on every stem cell; 1 = leaves on every 2nd stem cell; etc.")]
    public int leafGap = 1;
    [Tooltip("Leaf pattern type: 0=Parallel, 1=Offset-Parallel, 2=Alternating (L/R/R/L), 3=Double-Spiral, 4=One-Sided")]
    public int leafPattern = 0;
    public float growthRandomness = 0f;      // [0..1]: 0=always up; 1=always diagonal

    [Header("Energy System")]
    [Tooltip("Max energy available from all Energy Storage nodes in BFS.")]
    public float maxEnergy = 0f;
    [Tooltip("Current energy accumulated.")]
    public float currentEnergy = 0f;
    [Tooltip("Base photosynthesis rate from Energy Photosynthesis nodes in BFS.")]
    public float basePhotosynthesis = 0f;

    [Header("Cell Prefabs")]
    public GameObject seedCellPrefab;
    public GameObject stemCellPrefab;
    public GameObject leafCellPrefab;

    [Header("Cell Grid Settings")]
    [Tooltip("Distance (in game units) between adjacent cells.")]
    public float cellSpacing = 8f; 

    [Header("UI")]
    [Tooltip("TextMeshProUGUI displaying current energy and max energy below the plant.")]
    public TMP_Text energyText;

    private Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
    private bool growing = true;
    private int currentStemCount = 0;
    private int targetStemLength = 0;
    
    private bool? offsetRightForPattern1 = null;


    private void Start()
    {
        targetStemLength = Random.Range(stemMinLength, stemMaxLength + 1);
        Debug.Log($"[PlantGrowth] Target stem length: {targetStemLength}");

        cells[new Vector2Int(0, 0)] = PlantCellType.Seed;
        SpawnCellVisual(PlantCellType.Seed, new Vector2Int(0, 0));

        // Set up sorting inheritance
        SortableEntity[] cellEntities = GetComponentsInChildren<SortableEntity>();
        foreach (var cellEntity in cellEntities)
        {
            // Skip the seed cell, which will determine sorting
            if (cellEntity.transform == transform)
                continue;

            // Use the public method to set parent Y coordinate usage
            cellEntity.SetUseParentYCoordinate(true);
        }

        StartCoroutine(GrowRoutine());
    }

    private void Update()
    {
        // Use sunIntensity from WeatherManager.
        float sunlight = (WeatherManager.Instance != null) ? WeatherManager.Instance.sunIntensity : 1f;
        float leafCount = cells.Values.Count(cell => cell == PlantCellType.Leaf);
        float deltaPhotosynthesis = basePhotosynthesis * leafCount * sunlight * Time.deltaTime;
        currentEnergy += deltaPhotosynthesis;
        if (currentEnergy > maxEnergy)
            currentEnergy = maxEnergy;

        if (energyText != null)
        {
            energyText.text = $"{Mathf.Floor(currentEnergy)}/{Mathf.Floor(maxEnergy)}";
        }
    }

    private IEnumerator GrowRoutine()
{
    Vector2Int currentPos = new Vector2Int(0, 0);
    int spiralDirection = 1;  // Used for spiral pattern: 1=right, -1=left
    int patternCounter = 0;   // Used to track position in complex patterns
    
    while (growing)
    {
        yield return new WaitForSeconds(growthSpeed);

        if (currentStemCount < targetStemLength)
        {
            currentStemCount++;
            Vector2Int dir;
            if (currentStemCount == 1)
            {
                // Always grow directly up for the first stem cell.
                dir = new Vector2Int(0, 1);
            }
            else
            {
                dir = GetStemDirection();
            }
            currentPos += dir;
            cells[currentPos] = PlantCellType.Stem;
            SpawnCellVisual(PlantCellType.Stem, currentPos);
            Debug.Log($"[PlantGrowth] Stem grown at {currentPos}");

            if ((currentStemCount % (leafGap + 1)) == 0)
            {
                Vector2Int baseLeftPos = currentPos + new Vector2Int(-1, 0);
                Vector2Int baseRightPos = currentPos + new Vector2Int(1, 0);
                patternCounter++;

                // Process according to leaf pattern
                switch (leafPattern)
                {
                    case 0: // Parallel: spawn both leaves at same height
                        SpawnLeafIfEmpty(baseLeftPos);
                        SpawnLeafIfEmpty(baseRightPos);
                        Debug.Log($"[PlantGrowth] Parallel leaves at {baseLeftPos} and {baseRightPos}");
                        break;
                        
                    case 1: // Offset-Parallel: both sides have leaves, but one side is raised
                    {
                        // Choose the starting side only once per plant
                        if (offsetRightForPattern1 == null)
                        {
                            offsetRightForPattern1 = (Random.value < 0.5f);
                        }
                        if (offsetRightForPattern1.Value)
                        {
                            // Right side is raised.
                            Vector2Int raisedRightPos = baseRightPos + new Vector2Int(0, 1);
                            SpawnLeafIfEmpty(baseLeftPos);
                            SpawnLeafIfEmpty(raisedRightPos);
                            Debug.Log($"[PlantGrowth] Offset-Parallel (right offset) leaves at {baseLeftPos} and {raisedRightPos}");
                        }
                        else
                        {
                            // Left side is raised.
                            Vector2Int raisedLeftPos = baseLeftPos + new Vector2Int(0, 1);
                            SpawnLeafIfEmpty(raisedLeftPos);
                            SpawnLeafIfEmpty(baseRightPos);
                            Debug.Log($"[PlantGrowth] Offset-Parallel (left offset) leaves at {raisedLeftPos} and {baseRightPos}");
                        }
                        break;
                    }


                        
                    case 2: // Alternating-2 (L/R/R/L/L/R/R/L): proper rotation pattern
                        // This creates the L/R/R/L/L/R/R/L pattern
                        // patternCounter % 4 gives us:
                        // 1 -> Left side offset (L)
                        // 2 -> Right side normal (R)
                        // 3 -> Right side offset (R)
                        // 0 -> Left side normal (L)
                        
                        Vector2Int leftPos, rightPos;
                        
                        // Determine positions based on pattern position
                        switch (patternCounter % 4) {
                            case 1: // Left side offset, right side normal
                                leftPos = baseLeftPos + new Vector2Int(0, 1);
                                rightPos = baseRightPos;
                                Debug.Log($"[PlantGrowth] Alternating leaves at {leftPos} (offset) and {rightPos}");
                                break;
                            case 2: // Left side normal, right side normal
                                leftPos = baseLeftPos;
                                rightPos = baseRightPos;
                                Debug.Log($"[PlantGrowth] Alternating leaves at {leftPos} and {rightPos}");
                                break;
                            case 3: // Left side normal, right side offset
                                leftPos = baseLeftPos;
                                rightPos = baseRightPos + new Vector2Int(0, 1);
                                Debug.Log($"[PlantGrowth] Alternating leaves at {leftPos} and {rightPos} (offset)");
                                break;
                            case 0: // Left side normal, right side normal (cycle complete)
                                leftPos = baseLeftPos;
                                rightPos = baseRightPos;
                                Debug.Log($"[PlantGrowth] Alternating leaves at {leftPos} and {rightPos}");
                                break;
                            default:
                                leftPos = baseLeftPos;
                                rightPos = baseRightPos;
                                break;
                        }
                        
                        SpawnLeafIfEmpty(leftPos);
                        SpawnLeafIfEmpty(rightPos);
                        break;
                        
                    case 3: // Double-Spiral: two leaves per node, spiral pattern
                        // Create two leaves that spiral around the stem, with vertical offset
                        Vector2Int leftSpiral = baseLeftPos + new Vector2Int(0, spiralDirection > 0 ? 1 : 0);
                        Vector2Int rightSpiral = baseRightPos + new Vector2Int(0, spiralDirection > 0 ? 0 : 1);
                        
                        SpawnLeafIfEmpty(leftSpiral);
                        SpawnLeafIfEmpty(rightSpiral);
                        
                        Debug.Log($"[PlantGrowth] Double-Spiral leaves at {leftSpiral} and {rightSpiral}");
                        
                        // Toggle spiral direction for next node
                        spiralDirection *= -1;
                        break;
                        
                    case 4: // One-Sided: leaves only grow on one side
                        // For balance, create two leaves on the same side
                        SpawnLeafIfEmpty(baseRightPos);
                        SpawnLeafIfEmpty(baseRightPos + new Vector2Int(0, 1));
                        Debug.Log($"[PlantGrowth] One-sided leaves at {baseRightPos} and {baseRightPos + new Vector2Int(0, 1)}");
                        break;
                        
                    default: // Fallback to parallel
                        SpawnLeafIfEmpty(baseLeftPos);
                        SpawnLeafIfEmpty(baseRightPos);
                        break;
                }
            }
        }
        else
        {
            growing = false;
            Debug.Log("[PlantGrowth] Growth complete.");
        }
    }
}

    private Vector2Int GetStemDirection()
    {
        Vector2Int up = new Vector2Int(0, 1);
        Vector2Int leftDiag = new Vector2Int(-1, 1);
        Vector2Int rightDiag = new Vector2Int(1, 1);

        float r = Mathf.Clamp01(growthRandomness);
        float roll = Random.value;
        float threshold = 1f - r;  
        if (roll < threshold)
            return up;
        else
            return (Random.value < 0.5f) ? leftDiag : rightDiag;
    }

    private void SpawnLeafIfEmpty(Vector2Int coords)
    {
        if (!cells.ContainsKey(coords))
        {
            cells[coords] = PlantCellType.Leaf;
            SpawnCellVisual(PlantCellType.Leaf, coords);
        }
    }

    private void SpawnCellVisual(PlantCellType cellType, Vector2Int coords)
    {
        Vector2 worldPos = (Vector2)transform.position + (Vector2)coords * cellSpacing;
        GameObject prefabToUse = null;
        switch (cellType)
        {
            case PlantCellType.Seed:
                prefabToUse = seedCellPrefab;
                break;
            case PlantCellType.Stem:
                prefabToUse = stemCellPrefab;
                break;
            case PlantCellType.Leaf:
                prefabToUse = leafCellPrefab;
                break;
        }
        if (prefabToUse != null)
        {
            GameObject cellInstance = Instantiate(prefabToUse, worldPos, Quaternion.identity, transform);
        
            // Add SortableEntity if not already present
            SortableEntity sortableEntity = cellInstance.GetComponent<SortableEntity>();
            if (sortableEntity == null)
                sortableEntity = cellInstance.AddComponent<SortableEntity>();
        
            // For non-seed cells, enable "Y from parent"
            if (cellType != PlantCellType.Seed)
            {
                sortableEntity.SetUseParentYCoordinate(true);
            }
        }
        else
        {
            Debug.LogWarning($"[PlantGrowth] No prefab assigned for cell type {cellType}");
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\WeatherManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class WeatherManager : MonoBehaviour
{
    public static WeatherManager Instance { get; private set; }

    [Header("Day/Night Cycle Settings")]
    public bool dayNightCycleEnabled = true;
    
    [Tooltip("Duration of full day (seconds)")]
    public float dayDuration = 20f;
    [Tooltip("Duration of full night (seconds)")]
    public float nightDuration = 20f;
    [Tooltip("Duration of transitions (seconds)")]
    public float transitionDuration = 5f;

    [Tooltip("Curve that controls the sunIntensity during transitions (X=0 start, X=1 end).")]
    public AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

    [Header("Sunlight Settings")]
    [Range(0f, 1f)]
    public float sunIntensity = 1f;  // 0=night, 1=day

    [Header("Fixed Sunlight When Cycle Off")]
    [Tooltip("If dayNightCycleEnabled is false, we use this fixed intensity.")]
    [Range(0f, 1f)]
    public float fixedSunIntensity = 1f;

    [Header("Sunlight Visualization")]
    public SpriteRenderer fadeSprite;
    public float minAlpha = 0f;
    public float maxAlpha = 1f;

    // Internals
    private enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }
    private CyclePhase currentPhase = CyclePhase.Day;
    private float phaseTimer = 0f; // counts down in each phase
    private float totalPhaseTime = 0f; // length of current phase

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    private void Start()
    {
        // Initialize to Day phase
        EnterPhase(CyclePhase.Day);
    }

    private void Update()
    {
        if (!dayNightCycleEnabled)
        {
            // If the cycle is disabled, just use the fixed sun intensity
            sunIntensity = fixedSunIntensity;
            UpdateFadeSprite();
            return;
        }

        // else dayNightCycle is enabled
        phaseTimer -= Time.deltaTime;
        if (phaseTimer <= 0f)
        {
            // move to next phase
            switch (currentPhase)
            {
                case CyclePhase.Day:
                    EnterPhase(CyclePhase.TransitionToNight);
                    break;
                case CyclePhase.TransitionToNight:
                    EnterPhase(CyclePhase.Night);
                    break;
                case CyclePhase.Night:
                    EnterPhase(CyclePhase.TransitionToDay);
                    break;
                case CyclePhase.TransitionToDay:
                    EnterPhase(CyclePhase.Day);
                    break;
            }
        }
        else
        {
            // while in the current phase, update sunIntensity accordingly
            float progress = 1f - (phaseTimer / totalPhaseTime);
            switch (currentPhase)
            {
                case CyclePhase.Day:
                    // Full day, sunIntensity = 1
                    sunIntensity = 1f;
                    break;
                case CyclePhase.TransitionToNight:
                    // 0..1 => day(1) to night(0) using transitionCurve
                    float tToNight = transitionCurve.Evaluate(progress);
                    sunIntensity = Mathf.Lerp(1f, 0f, tToNight);
                    break;
                case CyclePhase.Night:
                    // Full night, sunIntensity = 0
                    sunIntensity = 0f;
                    break;
                case CyclePhase.TransitionToDay:
                    // 0..1 => night(0) to day(1) using transitionCurve
                    float tToDay = transitionCurve.Evaluate(progress);
                    sunIntensity = Mathf.Lerp(0f, 1f, tToDay);
                    break;
            }
        }

        UpdateFadeSprite();
    }

    private void EnterPhase(CyclePhase nextPhase)
    {
        currentPhase = nextPhase;
        switch (nextPhase)
        {
            case CyclePhase.Day:
                totalPhaseTime = dayDuration;
                break;
            case CyclePhase.Night:
                totalPhaseTime = nightDuration;
                break;
            case CyclePhase.TransitionToNight:
            case CyclePhase.TransitionToDay:
                totalPhaseTime = transitionDuration;
                break;
        }
        phaseTimer = totalPhaseTime;
    }

    private void UpdateFadeSprite()
    {
        if (fadeSprite != null)
        {
            float alpha = Mathf.Lerp(minAlpha, maxAlpha, sunIntensity);
            Color c = fadeSprite.color;
            c.a = alpha;
            fadeSprite.color = c;
        }
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\SpellProjectile.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SpellProjectile : MonoBehaviour
{
    [Header("Projectile Stats")]
    public float damage;
    public float speed;
    [Tooltip("If true, the projectile will be destroyed upon hitting a wizard.")]
    public bool destroyOnHit = true;

    [Header("Burning Effect (optional)")]
    public float burningDamage;   // DPS
    public float burningDuration; // Duration in seconds

    [Header("Friendly Fire")]
    public bool friendlyFire = false;
    public bool casterIsEnemy = false;

    public void Initialize(float dmg, float spd)
    {
        damage = dmg;
        speed = spd;
    }

    private void Update()
    {
        transform.Translate(Vector2.up * speed * Time.deltaTime);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\BurningStatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public class BurningStatusEffect : StatusEffect
{
    public BurningStatusEffect(float d, float dps) : base(d, dps) { }

    
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\StatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public abstract class StatusEffect
{
    public float duration; // Total duration.
    public float damagePerSecond;
    protected float elapsed = 0f;

    // Public property to expose elapsed time.
    public float Elapsed { get { return elapsed; } }

    public StatusEffect(float d, float dps)
    {
        duration = d;
        damagePerSecond = dps;
    }

    public bool IsExpired() => elapsed >= duration;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\SortableEntity.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SortableEntity : MonoBehaviour
{
    [Header("Sorting Configuration")]
    [Tooltip("Offset added to Y position for sorting calculation")]
    [SerializeField] private float sortingLayerYOffset = 0f;

    [Tooltip("Use parent's Y coordinate for sorting")]
    [SerializeField] private bool useParentYCoordinate = false;

    [Tooltip("Debug logging for sorting")]
    public bool debugSorting = false;

    private SpriteRenderer spriteRenderer;

    private void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        // If no SpriteRenderer, try to find one in children
        if (spriteRenderer == null)
            spriteRenderer = GetComponentInChildren<SpriteRenderer>();

        // Ensure sprite renderer exists
        if (spriteRenderer == null)
        {
            Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
        }
    }

    private void Start()
    {
        UpdateSortingOrder();
    }

    private void LateUpdate()
    {
        UpdateSortingOrder();
    }

    public void UpdateSortingOrder()
    {
        if (spriteRenderer == null) return;

        // Determine Y position for sorting
        float yPositionForSorting = useParentYCoordinate && transform.parent != null 
            ? transform.parent.position.y 
            : transform.position.y;

        int sortOrder = CalculateSortOrder(yPositionForSorting);
        spriteRenderer.sortingOrder = sortOrder;

        if (debugSorting)
        {
            Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
        }
    }

    private int CalculateSortOrder(float yPosition)
    {
        // Subtract offset to effectively move the sorting position
        return Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
    }

    // Public method to get current sorting order
    public int GetCurrentSortOrder()
    {
        if (spriteRenderer == null) return 0;
        return spriteRenderer.sortingOrder;
    }

    // Public method to set sorting order directly if needed
    public void SetSortingOrder(int order)
    {
        if (spriteRenderer != null)
            spriteRenderer.sortingOrder = order;
    }

    // Public method to set the parent Y coordinate usage flag
    // This eliminates the need for reflection in other scripts
    public void SetUseParentYCoordinate(bool value)
    {
        useParentYCoordinate = value;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "AnimalDefinition", menuName = "Ecosystem/Animal Definition")]
public class AnimalDefinition : ScriptableObject
{
    [Header("Basic Stats")]
    public string animalName;
    public float maxHealth = 10f;
    public float hungerDecayRate = 0.5f;  // How quickly the animal gets hungry (units/sec)
    public float movementSpeed = 2f;

    [Header("Eating & Satiation")]
    public float hungerThreshold = 5f;    // If hunger > threshold, tries to eat
    public float eatAmount = 5f;         // How much hunger is reduced when it eats a leaf
    public float leafDamage = 1f;        // How much health (or 'life') is removed from a leaf

    [Header("Prefab/Visuals")]
    public GameObject prefab;  // The character prefab to instantiate
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "AnimalLibrary", menuName = "Ecosystem/Animal Library")]
public class AnimalLibrary : ScriptableObject
{
    public List<AnimalDefinition> animals;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Linq;
using System.Collections.Generic;

[RequireComponent(typeof(Rigidbody2D))]
public class AnimalController : MonoBehaviour
{
    // Assigned via FaunaManager on instantiation
    private AnimalDefinition definition;

    [Header("Thought/Dialogue Setup")]
    public AnimalThoughtLibrary thoughtLibrary;      // Assign GlobalAnimalThoughtLibrary asset
    public GameObject thoughtBubblePrefab;           // Assign your ThoughtBubble prefab

    [Header("Transforms for Visual Alignment")]
    public Transform mouthTransform;                 // For aligning mouth (for future pooping VFX)
    public Transform bubbleSpawnTransform;           // Where thought bubbles spawn

    [Header("Thought Bubble Settings")]
    public float thoughtCooldownTime = 5f;             // Minimum time between thought bubbles
    private float thoughtCooldownTimer = 0f;

    private string speciesName;                      // Derived from definition.animalName

    // Basic runtime stats
    private float currentHealth;
    private float currentHunger;

    private Rigidbody2D rb;
    private SpriteRenderer spriteRenderer;           // For sprite flipping
    private Vector2 moveDirection;

    // Global movement bounds (set via FaunaManager; hidden in Inspector)
    [HideInInspector] private Vector2 minBounds;
    [HideInInspector] private Vector2 maxBounds;

    [Header("Eating Settings")]
    public float eatDuration = 2f;                    // Time spent eating
    [Tooltip("How close the animal must be to a leaf to eat it.")]
    public float eatDistance = 0.5f;
    private bool isEating = false;
    private float eatTimer = 0f;
    private GameObject currentTargetLeaf;

    [Header("Wander Behavior Settings")]
    [Tooltip("Intensity multiplier (0 to 1) controlling the chance to pause while wandering.")]
    [Range(0f, 1f)]
    public float wanderPauseIntensity = 0.5f;
    [Tooltip("Minimum duration for a moving phase while wandering.")]
    public float wanderMinMoveDuration = 1f;
    [Tooltip("Maximum duration for a moving phase while wandering.")]
    public float wanderMaxMoveDuration = 3f;
    [Tooltip("Minimum duration for a pause while wandering.")]
    public float wanderMinPauseDuration = 0.5f;
    [Tooltip("Maximum duration for a pause while wandering.")]
    public float wanderMaxPauseDuration = 2f;
    private bool isWanderPaused = false;
    private float wanderStateTimer = 0f;

    [Header("Pooping Settings")]
    [Tooltip("Minimum delay after eating before the animal poops.")]
    public float minPoopDelay = 5f;
    [Tooltip("Maximum delay after eating before the animal poops.")]
    public float maxPoopDelay = 10f;
    [Tooltip("Duration (in seconds) the animal spends pooping (not moving).")]
    public float poopDuration = 1f;
    [Tooltip("List of poop prefabs for random selection.")]
    public List<GameObject> poopPrefabs;
    [Tooltip("Maximum amount to vary each color channel (0-1) for the poop sprite.")]
    public float poopColorVariation = 0.1f;

    // Internal pooping state variables
    private bool isPooping = false;
    private float poopTimer = 0f;      // For the pooping phase duration
    private float poopDelayTimer = 0f; // Delay before pooping after eating
    private bool hasPooped = false;    // True if the animal has already pooped after the last eating cycle

    public void Initialize(AnimalDefinition def)
    {
        definition = def;
        currentHealth = definition.maxHealth;
        currentHunger = 0f;
        speciesName = definition.animalName; // e.g., "Bunny"
        // Start with no pending poop (already pooped)
        hasPooped = true;
        poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);
    }

    private void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        if (!spriteRenderer)
            spriteRenderer = GetComponentInChildren<SpriteRenderer>();
    }

    private void Update()
    {
        if (definition == null)
        {
            Debug.LogWarning("[AnimalController] 'definition' is null. Did you call Initialize()?");
            return;
        }

        // Decrement thought bubble cooldown timer
        thoughtCooldownTimer -= Time.deltaTime;

        // Increase hunger over time
        currentHunger += definition.hungerDecayRate * Time.deltaTime;

        // Process pooping only if not eating and hasn't already pooped in this cycle
        if (!isEating && !hasPooped)
        {
            poopDelayTimer -= Time.deltaTime;
            if (!isPooping && poopDelayTimer <= 0f)
            {
                // Start pooping phase
                isPooping = true;
                poopTimer = poopDuration;
                ShowThought(ThoughtTrigger.Pooping);
                moveDirection = Vector2.zero; // Stop moving during pooping
            }
            if (isPooping)
            {
                poopTimer -= Time.deltaTime;
                if (poopTimer <= 0f)
                {
                    SpawnPoop();
                    isPooping = false;
                    hasPooped = true; // Mark that we've pooped this cycle
                }
            }
        }

        // If in eating state, update timer and exit early
        if (isEating)
        {
            eatTimer -= Time.deltaTime;
            if (eatTimer <= 0f)
            {
                isEating = false;
                FinishEatingLeaf();
            }
            return;
        }

        // Behavior based on hunger:
        if (currentHunger >= definition.hungerThreshold)
        {
            //Debug.Log($"{speciesName} is hungry! (Hunger: {currentHunger:0.00}/{definition.hungerThreshold})");
            if (thoughtCooldownTimer <= 0f)
            {
                ShowThought(ThoughtTrigger.Hungry);
                thoughtCooldownTimer = thoughtCooldownTime;
            }
            if (currentTargetLeaf == null)
                currentTargetLeaf = FindNearestLeaf();
            if (currentTargetLeaf != null)
                MoveTowardLeaf(currentTargetLeaf);
            else
                Wander();
        }
        else
        {
            Wander();
            currentTargetLeaf = null;
        }

        FlipSpriteBasedOnDirection(moveDirection);
    }

    private void FixedUpdate()
    {
        if (isEating || rb == null)
            return;
        Vector2 newPos = rb.position + moveDirection * definition.movementSpeed * Time.fixedDeltaTime;
        newPos.x = Mathf.Clamp(newPos.x, minBounds.x, maxBounds.x);
        newPos.y = Mathf.Clamp(newPos.y, minBounds.y, maxBounds.y);
        rb.MovePosition(newPos);
    }

    // Wander behavior: alternate between moving and pausing with random durations.
    private void Wander()
    {
        if (wanderStateTimer <= 0f)
        {
            if (isWanderPaused)
            {
                isWanderPaused = false;
                float angle = Random.Range(0f, 360f);
                moveDirection = new Vector2(Mathf.Cos(angle), Mathf.Sin(angle));
                wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration);
            }
            else
            {
                if (Random.value < wanderPauseIntensity)
                {
                    isWanderPaused = true;
                    moveDirection = Vector2.zero;
                    wanderStateTimer = Random.Range(wanderMinPauseDuration, wanderMaxPauseDuration);
                }
                else
                {
                    float angle = Random.Range(0f, 360f);
                    moveDirection = new Vector2(Mathf.Cos(angle), Mathf.Sin(angle));
                    wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration);
                }
            }
        }
        else
        {
            wanderStateTimer -= Time.deltaTime;
        }
    }

    private void MoveTowardLeaf(GameObject leafObj)
    {
        if (isEating)
            return; // Avoid re-triggering if already eating
        if (!leafObj)
        {
            currentTargetLeaf = null;
            return;
        }
        Vector2 leafPos = leafObj.transform.position;
        Vector2 myPos = transform.position;
        float distance = Vector2.Distance(myPos, leafPos);
        if (distance <= eatDistance)
        {
            isEating = true;
            eatTimer = eatDuration;
            ShowThought(ThoughtTrigger.Eating);
        }
        else
        {
            moveDirection = (leafPos - myPos).normalized;
        }
    }

    private void FinishEatingLeaf()
    {
        if (currentTargetLeaf)
        {
            Destroy(currentTargetLeaf);
            currentTargetLeaf = null;
        }
        currentHunger -= definition.eatAmount;
        if (currentHunger < 0f)
            currentHunger = 0f;
        // Reset pooping state for this eating cycle.
        hasPooped = false;
        poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);
    }

    private GameObject FindNearestLeaf()
    {
        GameObject[] leaves = GameObject.FindGameObjectsWithTag("Leaf");
        if (leaves.Length == 0)
            return null;
        Vector2 myPos = transform.position;
        GameObject nearest = null;
        float nearestDist = float.MaxValue;
        foreach (var leaf in leaves)
        {
            float dist = Vector2.Distance(myPos, leaf.transform.position);
            if (dist < nearestDist)
            {
                nearestDist = dist;
                nearest = leaf;
            }
        }
        return nearest;
    }

    // Thought bubble logic: spawn a bubble as a child of bubbleSpawnTransform.
    private void ShowThought(ThoughtTrigger trigger)
    {
        if (!thoughtLibrary || !thoughtBubblePrefab)
        {
            Debug.LogWarning($"[{speciesName}] Missing thought library or bubble prefab!");
            return;
        }
        if (string.IsNullOrEmpty(speciesName))
            return;
        var matchingEntries = thoughtLibrary.allThoughts
            .Where(t => t.speciesName == speciesName && t.trigger == trigger)
            .ToList();
        if (matchingEntries.Count == 0)
        {
            Debug.Log($"[{speciesName}] No thought lines for trigger {trigger}.");
            return;
        }
        var chosenEntry = matchingEntries[Random.Range(0, matchingEntries.Count)];
        if (chosenEntry.lines == null || chosenEntry.lines.Count == 0)
        {
            Debug.Log($"[{speciesName}] Thought entry for trigger {trigger} has no lines.");
            return;
        }
        string randomLine = chosenEntry.lines[Random.Range(0, chosenEntry.lines.Count)];
        Debug.Log($"[{speciesName}] Spawning thought bubble: {randomLine}");
        Transform spawnParent = bubbleSpawnTransform ? bubbleSpawnTransform : transform;
        GameObject bubbleObj = Instantiate(thoughtBubblePrefab, spawnParent.position, Quaternion.identity, spawnParent);
        bubbleObj.transform.localPosition = Vector3.zero;
        ThoughtBubbleController bubble = bubbleObj.GetComponent<ThoughtBubbleController>();
        if (bubble != null)
            bubble.Initialize(randomLine, spawnParent, 2f);
        else
            Debug.LogWarning($"[{speciesName}] ThoughtBubblePrefab is missing ThoughtBubbleController!");
    }

    // Spawn a poop object at the mouthTransform (or fallback to self)
    private void SpawnPoop()
    {
        if (poopPrefabs != null && poopPrefabs.Count > 0)
        {
            int index = Random.Range(0, poopPrefabs.Count);
            GameObject selectedPrefab = poopPrefabs[index];
            Transform spawnPoint = mouthTransform ? mouthTransform : transform;
            GameObject poopObj = Instantiate(selectedPrefab, spawnPoint.position, Quaternion.identity);
            // Random flip and color variation as before.
            SpriteRenderer sr = poopObj.GetComponent<SpriteRenderer>();
            if (sr != null)
            {
                sr.flipX = (Random.value > 0.5f);
                Color originalColor = sr.color;
                float variation = poopColorVariation;
                float newR = Mathf.Clamp01(originalColor.r + Random.Range(-variation, variation));
                float newG = Mathf.Clamp01(originalColor.g + Random.Range(-variation, variation));
                float newB = Mathf.Clamp01(originalColor.b + Random.Range(-variation, variation));
                sr.color = new Color(newR, newG, newB, originalColor.a);
            }
            // Attach PoopController if not present.
            PoopController pc = poopObj.GetComponent<PoopController>();
            if (pc == null)
            {
                pc = poopObj.AddComponent<PoopController>();
            }
            // Initialize PoopController using its Inspector settings (no lifetime passed).
            pc.Initialize();
        }
        else
        {
            Debug.LogWarning($"[{speciesName}] No poopPrefabs assigned!");
        }
    }

    // Sprite flipping based on horizontal movement direction.
    private void FlipSpriteBasedOnDirection(Vector2 direction)
    {
        if (!spriteRenderer)
            return;
        if (direction.x < -0.01f)
            spriteRenderer.flipX = true;
        else if (direction.x > 0.01f)
            spriteRenderer.flipX = false;
    }

    // Public setter for movement bounds (called from FaunaManager)
    public void SetMovementBounds(Vector2 min, Vector2 max)
    {
        minBounds = min;
        maxBounds = max;
    }

    // Public method to compare species name (used by FaunaManager)
    public bool SpeciesNameEquals(string other)
    {
        return speciesName == other;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalSpawnData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[System.Serializable]
public class AnimalSpawnData {
    public AnimalDefinition animalDefinition;
    [Range(0f, 1f)]
    [Tooltip("Spawn rate multiplier (0 = no spawn; lower values = less frequent spawns).")]
    public float spawnRateMultiplier = 1f;
    [Tooltip("Maximum number of this animal type allowed to be spawned (0 = no limit).")]
    public int maximumSpawned = 0;
    
    [HideInInspector]
    public float spawnTimer = 0f;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalThoughtLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "AnimalThoughtLibrary", menuName = "Ecosystem/Animal Thought Library")]
public class AnimalThoughtLibrary : ScriptableObject
{
    public List<AnimalThoughtLine> allThoughts;
}

[System.Serializable]
public class AnimalThoughtLine
{
    [Header("Which Animal?")]
    public string speciesName; // e.g. "Bunny", "Fox", "Bird"

    [Header("Trigger Condition")]
    public ThoughtTrigger trigger;

    [Header("Possible Lines to Randomly Choose From")]
    public List<string> lines;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\EcosystemManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class EcosystemManager : MonoBehaviour
{
    public static EcosystemManager Instance { get; private set; }

    [Header("Parent Transforms")]
    public Transform animalParent;   // e.g., an empty GameObject "SpawnedEcosystem/Animals"
    public Transform plantParent;    // e.g., an empty GameObject "SpawnedEcosystem/Plants"

    [Header("Sorting Options")]
    public bool sortAnimalsBySpecies = true;
    public bool sortPlantsBySpecies = true;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FaunaManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

public class FaunaManager : MonoBehaviour
{
    [Header("Animal Spawn Settings")]
    public List<AnimalSpawnData> animalsToSpawn;
    public float globalSpawnCooldown = 5f;
    public float spawnRadius = 3f;
    public bool continuousSpawn = true;
    public Vector2 spawnCenter = Vector2.zero;

    [Header("Ecosystem Parent Settings")]
    public Transform ecosystemParent; // e.g., "SpawnedEcosystem/Animals"

    [Header("Global Movement Bounds for Animals")]
    public Vector2 animalMinBounds = new Vector2(-10f, -5f);
    public Vector2 animalMaxBounds = new Vector2(10f, 5f);

    private void Start()
    {
        // Initialize each spawn entry's timer to its effective cooldown.
        foreach (var spawnData in animalsToSpawn)
        {
            if (spawnData.spawnRateMultiplier > 0f)
                spawnData.spawnTimer = globalSpawnCooldown / spawnData.spawnRateMultiplier;
            else
                spawnData.spawnTimer = Mathf.Infinity; // won't spawn if 0
        }
    }

    private void Update()
    {
        if (continuousSpawn)
        {
            foreach (var spawnData in animalsToSpawn)
            {
                if (spawnData.spawnRateMultiplier <= 0f)
                    continue;

                // Check current count for this species.
                int currentCount = 0;
                if (ecosystemParent != null && spawnData.animalDefinition != null && !string.IsNullOrEmpty(spawnData.animalDefinition.animalName))
                {
                    Transform speciesParent = ecosystemParent.Find(spawnData.animalDefinition.animalName);
                    if (speciesParent != null)
                        currentCount = speciesParent.childCount;
                }
                else
                {
                    AnimalController[] allAnimals = FindObjectsOfType<AnimalController>();
                    currentCount = 0;
                    foreach (var a in allAnimals)
                    {
                        if (a != null && a.SpeciesNameEquals(spawnData.animalDefinition.animalName))
                            currentCount++;
                    }
                }
                // If maximum is set (>0) and current count is reached, skip spawn.
                if (spawnData.maximumSpawned > 0 && currentCount >= spawnData.maximumSpawned)
                    continue;

                // Decrement spawn timer and spawn if ready.
                spawnData.spawnTimer -= Time.deltaTime;
                if (spawnData.spawnTimer <= 0f)
                {
                    float effectiveCooldown = globalSpawnCooldown / spawnData.spawnRateMultiplier;
                    Vector2 randomOffset = Random.insideUnitCircle * spawnRadius;
                    SpawnAnimal(spawnData.animalDefinition, spawnCenter + randomOffset);
                    spawnData.spawnTimer = effectiveCooldown;
                }
            }
        }
    }

    public GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position)
    {
        if (definition == null || definition.prefab == null)
        {
            Debug.LogWarning("[FaunaManager] Invalid animal definition or missing prefab!");
            return null;
        }

        GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

        // Parent the animal under ecosystemParent with species grouping.
        if (ecosystemParent != null)
        {
            Transform speciesParent = ecosystemParent;
            if (!string.IsNullOrEmpty(definition.animalName))
            {
                speciesParent = ecosystemParent.Find(definition.animalName);
                if (speciesParent == null)
                {
                    GameObject subParent = new GameObject(definition.animalName);
                    subParent.transform.SetParent(ecosystemParent);
                    speciesParent = subParent.transform;
                }
            }
            animalObj.transform.SetParent(speciesParent);
        }

        // Get the existing AnimalController on the prefab.
        AnimalController controller = animalObj.GetComponent<AnimalController>();
        if (!controller)
        {
            Debug.LogWarning("[FaunaManager] Prefab missing AnimalController. Adding one dynamically.");
            controller = animalObj.AddComponent<AnimalController>();
        }
        controller.Initialize(definition);
        controller.SetMovementBounds(animalMinBounds, animalMaxBounds);
        return animalObj;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\PoopController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class PoopController : MonoBehaviour
{
    [Tooltip("Total lifetime of this poop (in seconds) before disappearing.")]
    public float lifetime = 10f;
    [Tooltip("Duration at the end of the lifetime during which the poop fades out.")]
    public float fadeDuration = 2f;
    [Tooltip("Fadeout curve to control the alpha during fade-out. X axis goes from 0 (start of fade) to 1 (end of fade).")]
    public AnimationCurve fadeCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);

    private SpriteRenderer sr;
    private float timer = 0f;
    private Color initialColor;

    private void Awake()
    {
        sr = GetComponent<SpriteRenderer>();
        if (sr != null)
        {
            initialColor = sr.color;
        }
    }

    private void Update()
    {
        timer += Time.deltaTime;
        if (timer >= lifetime)
        {
            Destroy(gameObject);
            return;
        }

        // If within fadeDuration at the end, apply fade-out using the fadeCurve.
        float remaining = lifetime - timer;
        if (remaining < fadeDuration && sr != null)
        {
            // Normalize fade time (0 = start, 1 = end)
            float t = 1f - (remaining / fadeDuration);
            float alphaMultiplier = fadeCurve.Evaluate(t);
            Color newColor = initialColor;
            newColor.a = alphaMultiplier;
            sr.color = newColor;
        }
    }

    // Initialize with default parameters if none are provided.
    public void Initialize(float lifetimeValue = -1f, float fadeDurationValue = -1f)
    {
        if (lifetimeValue > 0f)
            lifetime = lifetimeValue;
        if (fadeDurationValue > 0f)
            fadeDuration = fadeDurationValue;
        timer = 0f;
        if (sr != null)
            initialColor = sr.color;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtBubbleController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class ThoughtBubbleController : MonoBehaviour
{
    public TMP_Text messageText;
    public float lifetime = 2f;

    private Transform followTarget;

    public void Initialize(string message, Transform target, float duration = 2f)
    {
        if (messageText != null)
            messageText.text = message;
        followTarget = target;
        lifetime = duration;
    }

    private void Update()
    {
        lifetime -= Time.deltaTime;
        if (lifetime <= 0f)
            Destroy(gameObject);

        // Follow the target if needed (optional if already a child)
        if (followTarget != null)
        {
            transform.position = followTarget.position;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtTrigger.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public enum ThoughtTrigger
{
    Hungry,
    Eating,
    HealthLow,
    Fleeing,
    Pooping,
    // Add more triggers as needed
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public List<NodeEffectData> effects = new List<NodeEffectData>();

    // (Optional) To store the order if you need explicit ordering.
    public int orderIndex;

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    public string displayName;
    public Color backgroundColor = Color.gray;
    [TextArea]
    public string description;
    public Sprite thumbnail;

    // Add this field for the NodeView prefab.
    public GameObject nodeViewPrefab;

    // List of effects
    public List<NodeEffectData> effects;

    // Method to clone the effects list for NodeData.
    public List<NodeEffectData> CloneEffects()
    {
        List<NodeEffectData> copy = new List<NodeEffectData>();
        foreach (var eff in effects)
        {
            NodeEffectData newEff = new NodeEffectData()
            {
                effectType = eff.effectType,
                primaryValue = eff.primaryValue,
                secondaryValue = eff.secondaryValue
            };
            copy.Add(newEff);
        }
        return copy;
    }

}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    public List<NodeDefinition> definitions;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;
    public float primaryValue;
    public float secondaryValue;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿public enum NodeEffectType
{
    ManaCost,
    Damage,
    EnergyStorage,
    EnergyPhotosynthesis,
    Output,
    SeedSpawn,
    StemLength,
    GrowthSpeed,
    LeafGap,
    LeafPattern,
    StemRandomness
    // Add or adjust types as needed.
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\OutputNodeEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Linq;

/// <summary>
/// Attach this to the NodeView prefab if the node has Output effect,
/// or have BFS call it directly. 
/// It calls WizardController to spawn a projectile/spell.
/// </summary>
public class OutputNodeEffect : MonoBehaviour
{
    /// <summary>
    /// This method is invoked by NodeExecutor when BFS processes an 'Output' node.
    /// You can pass any parameters (damage, aim, etc.) or just do a test projectile.
    /// </summary>
    public void Activate()
    {
        Debug.Log("[OutputNodeEffect] Activate() called. Spawning projectile or calling wizard cast.");

        

        
        
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;
using TMPro;
using System.Linq;

public class NodeExecutor : MonoBehaviour
{
    [Header("Execution Settings")]
    public NodeGraph currentGraph;
    public TMP_Text debugOutput;

    [Header("Plant Spawning")]
    public GameObject plantPrefab;
    public GardenerController gardener;

    private void Update()
    {
        // Press spacebar to execute the node chain.
        if (Input.GetKeyDown(KeyCode.Space))
        {
            ExecuteGraph();
        }
    }

    public void SetGraph(NodeGraph graph)
    {
        currentGraph = graph;
    }

    public void ExecuteGraph()
    {
        if (currentGraph == null || currentGraph.nodes.Count == 0)
        {
            DebugLog("No nodes to execute!");
            return;
        }

        // Process nodes left-to-right based on orderIndex.
        var sortedNodes = currentGraph.nodes.OrderBy(n => n.orderIndex).ToList();

        float accumulatedEnergyStorage = 0f;
        float accumulatedPhotosynthesis = 0f;
        bool seedFound = false;

        foreach (var node in sortedNodes)
        {
            DebugLog($"Processing node: {node.nodeDisplayName}");
            foreach (var eff in node.effects)
            {
                if (eff.effectType == NodeEffectType.EnergyStorage)
                    accumulatedEnergyStorage += eff.primaryValue;
                else if (eff.effectType == NodeEffectType.EnergyPhotosynthesis)
                    accumulatedPhotosynthesis += eff.primaryValue;
                else if (eff.effectType == NodeEffectType.SeedSpawn)
                    seedFound = true;
            }
        }

        if (seedFound)
        {
            SpawnPlant(accumulatedEnergyStorage, accumulatedPhotosynthesis);
        }
        else
        {
            DebugLog("No SeedSpawn in chain. Plant not spawned.");
        }

        DebugLog("Execution complete.");
    }

    private void SpawnPlant(float energyStorage, float photosynthesis)
    {
        if (plantPrefab == null)
        {
            DebugLog("Plant prefab not assigned!");
            return;
        }
        if (gardener == null)
        {
            DebugLog("No GardenerController found!");
            return;
        }
        Vector2 spawnPos = gardener.GetPlantingPosition();
        GameObject plantObj = Instantiate(plantPrefab, spawnPos, Quaternion.identity);
        PlantGrowth growth = plantObj.GetComponent<PlantGrowth>();
        if (growth != null)
        {
            growth.maxEnergy = energyStorage;
            growth.basePhotosynthesis = photosynthesis;
        }
        DebugLog("Plant spawned.");
    }

    private void DebugLog(string msg)
    {
        Debug.Log(msg);
        if (debugOutput != null)
            debugOutput.text += msg + "\n";
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes = new List<NodeData>();
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\ColorExtensions.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public static class ColorExtensions
{
    public static Color WithAlpha(this Color c, float alpha)
    {
        return new Color(c.r, c.g, c.b, alpha);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeCell.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

public class NodeCell : MonoBehaviour, IPointerClickHandler
{
    public int cellIndex;
    private NodeEditorGridController controller;
    private NodeData nodeData;   // Null if cell is empty.
    private NodeView nodeView;   // Reference to NodeView child, if any.

    public void Init(int index, NodeEditorGridController gridController)
    {
        cellIndex = index;
        controller = gridController;
    }

    public bool HasNode()
    {
        return nodeData != null;
    }

    public NodeData GetNodeData()
    {
        return nodeData;
    }

    // Returns the NodeView component (if any)
    public NodeView GetNodeView()
    {
        return nodeView;
    }

    // Called when the user selects a node definition from the dropdown.
    public void SetNodeDefinition(NodeDefinition def)
    {
        // Create new NodeData using the definition.
        nodeData = new NodeData()
        {
            nodeId = System.Guid.NewGuid().ToString(),
            nodeDisplayName = def.displayName,
            effects = def.CloneEffects() // Using the method defined in NodeDefinition.
        };

        // Remove any existing NodeView.
        if (nodeView != null)
        {
            Destroy(nodeView.gameObject);
            nodeView = null;
        }

        // Determine which NodeView prefab to use:
        GameObject prefabToUse = def.nodeViewPrefab != null ? def.nodeViewPrefab : controller.defaultNodeViewPrefab;
        if (prefabToUse == null)
        {
            Debug.LogError("No NodeView prefab assigned in NodeDefinition or default in NodeEditorGridController.");
            return;
        }

        // Instantiate the NodeView prefab as a child of this cell.
        GameObject nodeViewObj = Instantiate(prefabToUse, transform);
        nodeView = nodeViewObj.GetComponent<NodeView>();
        if (nodeView != null)
        {
            nodeView.Initialize(nodeData, def.thumbnail, def.backgroundColor, def.description, nodeData.effects);
        }
        
        

    }

    // On right-click, if empty, notify the controller to show the dropdown.
    public void OnPointerClick(PointerEventData eventData)
    {
        if (eventData.button == PointerEventData.InputButton.Right)
        {
            if (!HasNode())
            {
                controller.OnEmptyCellRightClicked(this, eventData);
            }
            else
            {
                // Optionally, add logic for right-click on an occupied cell.
            }
        }
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeDraggable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

public class NodeDraggable : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
    private RectTransform rectTransform;
    private CanvasGroup canvasGroup;
    private Vector2 originalPosition;
    private Transform originalParent;
    private NodeEditorGridController gridController;

    private void Awake()
    {
        rectTransform = GetComponent<RectTransform>();
        canvasGroup = GetComponent<CanvasGroup>();
        if (canvasGroup == null)
            canvasGroup = gameObject.AddComponent<CanvasGroup>();
        gridController = GetComponentInParent<NodeEditorGridController>();
    }

    public void OnBeginDrag(PointerEventData eventData)
    {
        originalPosition = rectTransform.anchoredPosition;
        originalParent = transform.parent;
        canvasGroup.blocksRaycasts = false;
        canvasGroup.alpha = 0.6f;
    }

    public void OnDrag(PointerEventData eventData)
    {
        rectTransform.anchoredPosition += eventData.delta;
    }

    public void OnEndDrag(PointerEventData eventData)
    {
        canvasGroup.blocksRaycasts = true;
        canvasGroup.alpha = 1f;
        if (gridController != null)
        {
            bool dropped = gridController.HandleNodeDrop(this, eventData.position);
            if (!dropped)
            {
                rectTransform.anchoredPosition = originalPosition;
                transform.SetParent(originalParent);
            }
        }
        else
        {
            rectTransform.anchoredPosition = originalPosition;
            transform.SetParent(originalParent);
        }
    }

    public void SetParent(Transform newParent)
    {
        transform.SetParent(newParent, false);
        rectTransform.anchoredPosition = Vector2.zero;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeEditorGridController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;
using TMPro;
using System.Linq;

public class NodeEditorGridController : MonoBehaviour
{
    [Header("Grid Settings")]
    [Tooltip("Maximum number of cells (gene capacity)")]
    public int maxCells = 8;
    [Tooltip("Spacing between cells (pixels)")]
    public float cellSpacing = 10f;
    [Tooltip("Size (width/height in pixels) for each cell")]
    public float cellSize = 64f;
    [Tooltip("Parent RectTransform where cells will be instantiated")]
    public RectTransform cellsParent;

    [Header("Prefabs & Library")]
    [Tooltip("Prefab for an empty cell")]
    public NodeCell cellPrefab;
    [Tooltip("Default NodeView prefab (used if a NodeDefinition has none assigned)")]
    public GameObject defaultNodeViewPrefab;
    [Tooltip("Library of node definitions")]
    public NodeDefinitionLibrary definitionLibrary;

    [Header("TMP Dropdown")]
    [Tooltip("TMP_Dropdown used for node selection (should be inactive by default)")]
    public TMP_Dropdown nodeDropdown;

    [Header("Execution")]
    [Tooltip("Reference to the NodeExecutor to update its graph")]
    public NodeExecutor nodeExecutor;

    // List of instantiated cell references
    private List<NodeCell> nodeCells = new List<NodeCell>();

    private void Start()
    {
        if (nodeDropdown != null)
            nodeDropdown.gameObject.SetActive(false);

        CreateCells();

        if (nodeExecutor != null)
            nodeExecutor.SetGraph(new NodeGraph());

        RefreshGraph();
    }

    // Create exactly maxCells cells, arranged in one centered row.
    private void CreateCells()
    {
        // Clear previous children if any.
        foreach (Transform child in cellsParent)
        {
            Destroy(child.gameObject);
        }
        nodeCells.Clear();

        // Total width = (maxCells * cellSize) + ((maxCells - 1) * cellSpacing)
        float totalWidth = maxCells * cellSize + (maxCells - 1) * cellSpacing;
        // Starting x position (centered): -totalWidth/2 + cellSize/2
        float startX = -totalWidth / 2f + cellSize / 2f;

        for (int i = 0; i < maxCells; i++)
        {
            NodeCell cell = Instantiate(cellPrefab, cellsParent);
            RectTransform rt = cell.GetComponent<RectTransform>();
            rt.sizeDelta = new Vector2(cellSize, cellSize);
            float xPos = startX + i * (cellSize + cellSpacing);
            rt.anchoredPosition = new Vector2(xPos, 0f);
            cell.Init(i, this);
            nodeCells.Add(cell);
        }
    }

    // Called by a NodeCell when right-clicked (and empty)
    public void OnEmptyCellRightClicked(NodeCell cell, PointerEventData eventData)
    {
        if (nodeDropdown == null || definitionLibrary == null) return;

        // Build dropdown options using TMP_Dropdown.OptionData.
        List<TMP_Dropdown.OptionData> options = new List<TMP_Dropdown.OptionData>();
        options.Add(new TMP_Dropdown.OptionData("Select Node")); // default option
        foreach (var def in definitionLibrary.definitions)
        {
            options.Add(new TMP_Dropdown.OptionData(def.displayName));
        }
        nodeDropdown.ClearOptions();
        nodeDropdown.AddOptions(options);
        nodeDropdown.value = 0;
        nodeDropdown.RefreshShownValue();

        // Position dropdown at pointer.
        RectTransform dropdownRect = nodeDropdown.GetComponent<RectTransform>();
        dropdownRect.position = eventData.position;

        nodeDropdown.gameObject.SetActive(true);
        nodeDropdown.onValueChanged.RemoveAllListeners();
        nodeDropdown.onValueChanged.AddListener((val) => OnDropdownValueChanged(val, cell));
    }

    private void OnDropdownValueChanged(int value, NodeCell cell)
    {
        nodeDropdown.gameObject.SetActive(false);
        if (value == 0) return; // "Select Node" option
        int index = value - 1;
        if (index >= 0 && index < definitionLibrary.definitions.Count)
        {
            NodeDefinition def = definitionLibrary.definitions[index];
            cell.SetNodeDefinition(def);
            RefreshGraph();
        }
    }

    // Rebuild the NodeGraph from all non-empty cells, in order from left to right.
    public void RefreshGraph()
    {
        if (nodeExecutor == null || nodeExecutor.currentGraph == null) return;
        nodeExecutor.currentGraph.nodes.Clear();
        foreach (var cell in nodeCells.OrderBy(c => c.cellIndex))
        {
            if (cell.HasNode())
            {
                nodeExecutor.currentGraph.nodes.Add(cell.GetNodeData());
            }
        }
    }

    // Called by NodeDraggable when a node is dropped; checks if the drop is on a cell.
    public bool HandleNodeDrop(NodeDraggable draggedNode, Vector2 screenPosition)
    {
        foreach (var cell in nodeCells)
        {
            RectTransform cellRect = cell.GetComponent<RectTransform>();
            if (RectTransformUtility.RectangleContainsScreenPoint(cellRect, screenPosition))
            {
                // If the cell already has a node, swap them.
                if (cell.HasNode())
                {
                    NodeView existingView = cell.GetNodeView();
                    if (existingView != null)
                    {
                        // Get original cell of dragged node.
                        NodeCell originCell = draggedNode.GetComponentInParent<NodeCell>();
                        if (originCell != null)
                        {
                            existingView.transform.SetParent(originCell.transform, false);
                            existingView.GetComponent<RectTransform>().anchoredPosition = Vector2.zero;
                        }
                    }
                }
                // Place the dragged node in this cell.
                draggedNode.SetParent(cell.transform);
                return true;
            }
        }
        return false;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeSelectable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

public class NodeSelectable : MonoBehaviour, IPointerClickHandler
{
    public static GameObject CurrentSelected { get; set; }

    public void OnPointerClick(PointerEventData eventData)
    {
        Select(gameObject);
    }

    public static void Select(GameObject node)
    {
        if (CurrentSelected != null && CurrentSelected != node)
        {
            // (Optional) Remove highlight from previously selected node.
        }
        CurrentSelected = node;
        // (Optional) Add highlight effect here.
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeView.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.EventSystems;
using System.Collections.Generic;

public class NodeView : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler
{
    [Header("UI Elements")]
    public Image thumbnailImage;
    public Image backgroundImage;
    public GameObject tooltipPanel;
    public TMP_Text tooltipText;

    [Header("Node Name Display")]
    public TMP_Text nodeNameText;
    [Tooltip("If false, the node name text will be hidden.")]
    public bool displayNodeName = true;

    private NodeData nodeData;
    private string nodeDescription;
    private List<NodeEffectData> nodeEffects;

    public void Initialize(NodeData data, Sprite thumbnail, Color bgColor, string description, List<NodeEffectData> effects)
    {
        nodeData = data;
        nodeDescription = description;
        nodeEffects = effects;

        if (thumbnailImage != null)
            thumbnailImage.sprite = thumbnail;
        if (backgroundImage != null)
            backgroundImage.color = bgColor;
        if (tooltipPanel != null)
            tooltipPanel.SetActive(false);
        if (nodeNameText != null)
        {
            nodeNameText.text = data.nodeDisplayName;
            nodeNameText.gameObject.SetActive(displayNodeName);
        }
    }

    public NodeData GetNodeData() => nodeData;

    public void OnPointerEnter(PointerEventData eventData)
    {
        if (tooltipPanel != null && tooltipText != null)
        {
            tooltipPanel.SetActive(true);
            string tip = $"{nodeData.nodeDisplayName}\n{nodeDescription}\nEffects:\n";
            foreach (var eff in nodeEffects)
            {
                tip += $"- {eff.effectType}: {eff.primaryValue}";
                if (eff.secondaryValue != 0)
                    tip += $" / {eff.secondaryValue}";
                tip += "\n";
            }
            tooltipText.text = tip;
        }
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        if (tooltipPanel != null)
            tooltipPanel.SetActive(false);
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        // Implement selection logic here if needed.
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Player\GardenerController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class GardenerController : MonoBehaviour
{
    [Header("Movement Settings")]
    public float moveSpeed = 5f;
    
    [Header("Planting Settings")]
    public Vector2 seedPlantingOffset = new Vector2(0f, -0.5f); // Configurable offset for seed planting

    [Header("Visual Settings")]
    [Tooltip("If true, the sprite will be flipped when moving left")]
    public bool flipSpriteWhenMovingLeft = true;
    [Tooltip("If true, the character will face the opposite direction when flipped")]
    public bool flipHorizontalDirection = true;

    [Header("Animation Settings")]
    [Tooltip("Set to false to disable animations")]
    public bool useAnimations = true;
    public string runningParameterName = "isRunning";
    public string plantingParameterName = "isPlanting";
    [Tooltip("Should match your planting animation length exactly")]
    public float plantingDuration = 0.25f; // UPDATED to match your 0.25s animation


    
    // Private references
    private Rigidbody2D rb;
    private Vector2 movement;
    private SortableEntity sortableEntity;
    private SpriteRenderer spriteRenderer;
    private Animator animator;
    // Private variables
    private bool isPlanting = false;
    private float plantingTimer = 0f;
    private bool wasMovingBeforePlanting = false;

    private void Awake()
    {
        // Get required components
        rb = GetComponent<Rigidbody2D>();
        sortableEntity = GetComponent<SortableEntity>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        animator = GetComponent<Animator>();
        
        // Add SortableEntity if not already present
        if (sortableEntity == null)
            sortableEntity = gameObject.AddComponent<SortableEntity>();
            
        // Warn if sprite renderer is missing
        if (spriteRenderer == null)
            Debug.LogWarning("GardenerController: SpriteRenderer component not found. Sprite flipping won't work.");
            
        // Warn if animator is missing but animations are enabled
        if (animator == null && useAnimations)
            Debug.LogWarning("GardenerController: Animator component not found but useAnimations is true.");
    }

    private void Update()
    {
        // Handle movement input and planting action
        if (!isPlanting)
        {
            movement.x = Input.GetAxisRaw("Horizontal");
            movement.y = Input.GetAxisRaw("Vertical");
        
            // Check if we're moving (store for later)
            bool isMoving = movement.sqrMagnitude > 0.01f;
        
            // Handle planting action
            if (Input.GetKeyDown(KeyCode.Space))
            {
                // Store movement state before planting
                wasMovingBeforePlanting = isMoving;
                StartPlantingAnimation();
            }
        }
        else
        {
            // When planting, we don't accept movement input
            movement = Vector2.zero;
        
            // Handle planting timer
            plantingTimer -= Time.deltaTime;
            if (plantingTimer <= 0)
            {
                EndPlantingAnimation();
            }
        }
    
        // Update animations after all state changes are processed
        UpdateAnimations();
    
        // Handle sprite flipping based on movement direction
        UpdateSpriteDirection();
    }

    private void FixedUpdate()
    {
        // Only move if not planting
        if (!isPlanting)
        {
            rb.MovePosition(rb.position + movement.normalized * moveSpeed * Time.fixedDeltaTime);
        }
    }
    
    // Update character animations based on state
    private void UpdateAnimations()
    {
        if (!useAnimations || animator == null) return;
    
        // Set running animation parameter
        bool isMoving = movement.sqrMagnitude > 0.01f;
        animator.SetBool(runningParameterName, isMoving);
    }
    
    // Update sprite direction based on movement
    private void UpdateSpriteDirection()
    {
        if (spriteRenderer == null || !flipSpriteWhenMovingLeft) return;
        
        if (movement.x != 0)
        {
            // Only flip if moving horizontally
            bool shouldFlip = (movement.x < 0);
            
            // Apply flipping logic based on settings
            if (flipHorizontalDirection)
            {
                spriteRenderer.flipX = shouldFlip;
            }
            else
            {
                // Alternative approach: flip the entire transform
                // This is useful if the sprite is already facing left initially
                Vector3 scale = transform.localScale;
                scale.x = shouldFlip ? -Mathf.Abs(scale.x) : Mathf.Abs(scale.x);
                transform.localScale = scale;
            }
        }
    }
    
    // Start planting animation and process
    public void StartPlantingAnimation()
    {
        if (!useAnimations || isPlanting) return;
    
        isPlanting = true;
        plantingTimer = plantingDuration;
    
        // Set animation parameters
        if (animator != null)
        {
            // Set planting to true and ensure running is false
            animator.SetBool(plantingParameterName, true);
            animator.SetBool(runningParameterName, false);
        }
    }
    
    // End planting animation and resume normal control
    
    private void EndPlantingAnimation()
    {
        // Reset planting state
        isPlanting = false;
    
        // Reset animation parameters
        if (animator != null)
        {
            animator.SetBool(plantingParameterName, false);
        
            // Important: don't immediately set isRunning based on current movement
            // because movement is zero during planting. Instead:
            if (wasMovingBeforePlanting && (Input.GetAxisRaw("Horizontal") != 0 || Input.GetAxisRaw("Vertical") != 0))
            {
                // Only resume running if we were running before AND still have directional input
                animator.SetBool(runningParameterName, true);
            }
        }
    
        // Now update movement based on current input
        movement.x = Input.GetAxisRaw("Horizontal");
        movement.y = Input.GetAxisRaw("Vertical");
    }
    
    // Returns the position used for planting seeds, now with configurable offset
    public Vector2 GetPlantingPosition()
    {
        return (Vector2)transform.position + seedPlantingOffset;
    }
    
    // Public method to set planting animation duration
    public void SetPlantingDuration(float duration)
    {
        plantingDuration = Mathf.Max(0.1f, duration); // Ensure minimum duration
    }
    
    // Public method to trigger planting animation from other scripts
    public void Plant()
    {
        StartPlantingAnimation();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\NightColorPostProcess.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class NightColorPostProcess : MonoBehaviour
{
    [Header("References")]
    public WeatherManager weatherManager;        // Assign your existing WeatherManager
    public Volume globalVolume;                  // The Volume with the Color Adjustments override

    private ColorAdjustments colorAdjustments;   // We'll read/write color filter, post exposure, and saturation

    [Header("Color Settings")]
    [Tooltip("The color filter at full day (sunIntensity = 1).")]
    public Color dayColorFilter = Color.white;
    [Tooltip("The color filter at full night (sunIntensity ~ 0).")]
    public Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);

    [Tooltip("Daytime Post-Exposure (e.g. 0). Higher = brighter.")]
    public float dayPostExposure = 0f;
    [Tooltip("Nighttime Post-Exposure (e.g. -0.5). Lower = darker.")]
    public float nightPostExposure = -0.5f;

    [Header("Saturation Settings")]
    [Tooltip("Saturation at full day (0 means no change).")]
    public float daySaturation = 0f;
    [Tooltip("Saturation at full night (e.g. -50 for more desaturation at night).")]
    public float nightSaturation = -50f;

    private void Start()
    {
        if (!globalVolume)
        {
            Debug.LogWarning("[NightColorPostProcess] No globalVolume assigned!");
            return;
        }

        // Try to get the ColorAdjustments override from the volume's profile
        if (globalVolume.profile.TryGet<ColorAdjustments>(out var colorAdj))
        {
            colorAdjustments = colorAdj;
        }
        else
        {
            Debug.LogWarning("[NightColorPostProcess] No ColorAdjustments override found in the Volume profile!");
        }
    }

    private void Update()
    {
        if (!weatherManager || colorAdjustments == null)
            return;
        
        // Get the sun intensity (0 = night, 1 = day)
        float sun = Mathf.Clamp01(weatherManager.sunIntensity);
        float t = 1f - sun;  // t=0 at day, t=1 at night
        
        // Lerp the color filter
        Color finalFilter = Color.Lerp(dayColorFilter, nightColorFilter, t);
        colorAdjustments.colorFilter.value = finalFilter;
        
        // Lerp post exposure
        float finalExposure = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
        colorAdjustments.postExposure.value = finalExposure;
        
        // Lerp saturation
        float finalSaturation = Mathf.Lerp(daySaturation, nightSaturation, t);
        colorAdjustments.saturation.value = finalSaturation;
    }
}



