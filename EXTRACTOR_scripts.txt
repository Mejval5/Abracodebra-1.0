This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-03-29 18:44:30
================================================================================

DIRECTORY STRUCTURE
--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── HexGridRendererEditor.cs
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDataDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   └── Animal_Fox.prefab
│   │   ├── Plants
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelFruit.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   └── PlantPrefab.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       └── ThoughtBubble.prefab
│   └── General
│       ├── GardenerPrefab.prefab
│       ├── NodeView.prefab
│       └── Projectile_Basic_Pixel.prefab
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   └── Animal_000_Bunny.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   └── Nodes Plant
│       ├── NodeDefinitionLibrary.asset
│       ├── Node_000_Seed.asset
│       ├── Node_001_AimSpread.asset
│       ├── Node_002_Piercing.asset
│       ├── Node_003_Output.asset
│       ├── Node_004_ManaSource.asset
│       ├── Node_005_DamageNode.asset
│       ├── Node_006_Burn.asset
│       └── Node_007_FriendlyFire.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   └── ThoughtTrigger.cs
│   │   └── Plants
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── HexCoords.cs
│   │   │   ├── HexGridManager.cs
│   │   │   ├── HexGridRenderer.cs
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   ├── NodePort.cs
│   │   │   ├── OutputNodeEffect.cs
│   │   │   └── PortDefinition.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── NodeEditorController.cs
│   │       ├── NodeHexDraggable.cs
│   │       ├── NodeSelectable.cs
│   │       ├── NodeTestInitializer.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── UI
│   └── Visuals
│       └── NightColorPostProcess.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Test
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\HexGridRendererEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(HexGridRenderer))]
public class HexGridRendererEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            HexGridRenderer grid = (HexGridRenderer)target;
            grid.SetVerticesDirty();
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionAutoAdder.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionAutoAdder : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets,
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string folderPath = Path.GetDirectoryName(assetPath);
                string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
                if (libraryFiles.Length > 0)
                {
                    NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
                    if (library != null && !library.definitions.Contains(nodeDef))
                    {
                        library.definitions.Add(nodeDef);
                        EditorUtility.SetDirty(library);
                        AssetDatabase.SaveAssets();
                    }
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionCreator.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;

public static class NodeDefinitionCreator
{
    private const string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

    [MenuItem(MenuPath, false, 50)]
    public static void CreateNodeDefinition()
    {
        // Figure out which folder the user is in, or use Assets/
        string folder = GetSelectedPathOrFallback();

        // Determine the next numeric index for "Node_XXX_"
        int nextNumber = GetNextNodeNumber(folder);

        // e.g., "Node_007_"
        string newName = $"Node_{nextNumber:D3}_";
        string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

        // Create the NodeDefinition
        NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
        AssetDatabase.CreateAsset(nodeDef, newPath);
        
        // Save and refresh, but DO NOT select or focus the ProjectWindow.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        Debug.Log($"Created NodeDefinition at: {newPath}");
        // Notice we don't call Selection.activeObject = nodeDef
        // or EditorUtility.FocusProjectWindow()
        // or ProjectWindowUtil.ShowCreatedAsset(nodeDef)
        // thus we avoid changing the user's folder.
    }

    // (Optional) Validate the menu item so it’s disabled if the game is running
    [MenuItem(MenuPath, true)]
    private static bool ValidateCreateNodeDefinition()
    {
        return !Application.isPlaying;
    }

    private static string GetSelectedPathOrFallback()
    {
        // Attempt to get the folder the user has selected in the Project window
        string path = "Assets";
        foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets))
        {
            path = AssetDatabase.GetAssetPath(obj);
            if (!string.IsNullOrEmpty(path))
            {
                // If it's a file, get its parent folder
                if (File.Exists(path))
                {
                    path = Path.GetDirectoryName(path);
                }
                break;
            }
        }
        return path;
    }

    private static int GetNextNodeNumber(string folderPath)
    {
        int nextNumber = 1;
        // Look for existing Node_XXX_ files
        string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
        foreach (var file in files)
        {
            string fName = Path.GetFileNameWithoutExtension(file);
            if (fName.StartsWith("Node_") && fName.Length >= 8)
            {
                // extract the 3-digit number from Node_000_
                string numberPart = fName.Substring(5, 3);
                if (int.TryParse(numberPart, out int num) && num >= nextNumber)
                {
                    nextNumber = num + 1;
                }
            }
        }
        return nextNumber;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionLibraryEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;

[CustomEditor(typeof(NodeDefinitionLibrary))]
public class NodeDefinitionLibraryEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            UpdateLibrary();
        }
    }

    private void UpdateLibrary()
    {
        NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

        // Get the folder of the current library asset.
        string libraryPath = AssetDatabase.GetAssetPath(library);
        string folderPath = Path.GetDirectoryName(libraryPath);

        // Find all .asset files in the folder.
        string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

        // Load NodeDefinition assets from that folder.
        List<NodeDefinition> defs = new List<NodeDefinition>();
        foreach (string file in assetFiles)
        {
            // Ignore the library asset itself.
            if (file == libraryPath)
                continue;

            NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
            if (def != null)
                defs.Add(def);
        }

        // Sort definitions by the numeric portion in the file name (assumes "Node_XXX_...").
        defs = defs.OrderBy(d => {
            string name = d.name;
            if (name.StartsWith("Node_") && name.Length >= 8)
            {
                string numStr = name.Substring(5, 3);
                if (int.TryParse(numStr, out int num))
                    return num;
            }
            return int.MaxValue; // if no number is found, sort last.
        }).ToList();

        library.definitions = defs;
        EditorUtility.SetDirty(library);
        AssetDatabase.SaveAssets();
        Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionPostprocessor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionPostprocessor : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, 
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string fileName = Path.GetFileNameWithoutExtension(assetPath);
                // Check if file name already starts with "Node_"
                if (!fileName.StartsWith("Node_"))
                {
                    string folderPath = Path.GetDirectoryName(assetPath);
                    // Get all files in folder that start with "Node_"
                    var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
                    int nextNumber = 1;
                    foreach (var file in files)
                    {
                        string fName = Path.GetFileNameWithoutExtension(file);
                        string[] parts = fName.Split('_');
                        if (parts.Length >= 2 && int.TryParse(parts[1], out int num))
                        {
                            if (num >= nextNumber)
                                nextNumber = num + 1;
                        }
                    }
                    string newName = $"Node_{nextNumber:D3}_";
                    AssetDatabase.RenameAsset(assetPath, newName);
                    AssetDatabase.SaveAssets();
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeEffectDataDrawer.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;

[CustomPropertyDrawer(typeof(NodeEffectData))]
public class NodeEffectDataDrawer : PropertyDrawer
{
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        SerializedProperty typeProp        = property.FindPropertyRelative("effectType");
        SerializedProperty valueProp       = property.FindPropertyRelative("effectValue");
        SerializedProperty secondaryProp   = property.FindPropertyRelative("secondaryValue");
        SerializedProperty extra1Prop      = property.FindPropertyRelative("extra1");
        SerializedProperty extra2Prop      = property.FindPropertyRelative("extra2");

        // Draw effectType
        Rect typeRect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);
        EditorGUI.PropertyField(typeRect, typeProp, new GUIContent("Effect Type"));
        NodeEffectType effectType = (NodeEffectType)typeProp.enumValueIndex;
        float yOffset = typeRect.yMax + EditorGUIUtility.standardVerticalSpacing;

        Rect NextLineRect()
        {
            Rect r = new Rect(position.x, yOffset, position.width, EditorGUIUtility.singleLineHeight);
            yOffset += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;
            return r;
        }

        // Draw fields based on effectType
        switch (effectType)
        {
            case NodeEffectType.ManaCost:
            {
                GUIContent content = new GUIContent("Mana Cost", "Amount of mana required to process this node.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.Damage:
            {
                GUIContent content = new GUIContent("Damage", "Damage value contributed by this node.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.Output:
            {
                GUIContent content = new GUIContent("Output", "This node outputs the final chain result (no parameters).");
                Rect line = NextLineRect();
                EditorGUI.LabelField(line, content);
                break;
            }
            case NodeEffectType.Burning:
            {
                // Fire DPS in value, Duration in secondaryValue
                GUIContent contentDps = new GUIContent("Fire DPS", "Damage per second of burning.");
                Rect line1 = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line1, contentDps, valueProp.floatValue);

                GUIContent contentDur = new GUIContent("Duration", "Duration (seconds) of burning effect.");
                Rect line2 = NextLineRect();
                secondaryProp.floatValue = EditorGUI.FloatField(line2, contentDur, secondaryProp.floatValue);
                break;
            }
            case NodeEffectType.AimSpread:
            {
                GUIContent content = new GUIContent("Aim Spread Modifier", "Modifier to add to the wizard's base aim spread.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.Piercing:
            {
                GUIContent content = new GUIContent("Piercing", "Set to 1 for piercing, 0 otherwise.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.FriendlyFire:
            {
                GUIContent content = new GUIContent("Friendly Fire", "Set to 1 for friendly fire, 0 for none.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.SeedSpawn:
            {
                GUIContent content = new GUIContent("Seed Spawner", "Base effect required to spawn a plant. Add other plant effects to customize.");
                Rect line = NextLineRect();
                EditorGUI.LabelField(line, content);
                break;
            }
            case NodeEffectType.StemLength:
            {
                // Min stem length
                var line1 = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line1,
                    new GUIContent("Min Stem Length", "Minimum length of the stem in cells"), valueProp.floatValue);

                // Max stem length
                var line2 = NextLineRect();
                secondaryProp.floatValue = EditorGUI.FloatField(line2,
                    new GUIContent("Max Stem Length", "Maximum length of the stem in cells"), secondaryProp.floatValue);
                break;
            }
            case NodeEffectType.GrowthSpeed:
            {
                // Growth speed
                var line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line,
                    new GUIContent("Growth Speed (sec)", "Seconds per growth step"), valueProp.floatValue);
                break;
            }
            case NodeEffectType.LeafGap:
            {
                // Leaf gap
                var line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line,
                    new GUIContent("Leaf Gap", "0=leaves on every cell, 1=every 2nd cell, etc."), valueProp.floatValue);
                break;
            }
            // Update the LeafPattern case in the NodeEffectDataDrawer.cs OnGUI method
            case NodeEffectType.LeafPattern:
            {
                // Leaf Pattern as regular float field with improved tooltip
                var line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, 
                    new GUIContent("Leaf Pattern", 
                        "Choose a leaf pattern by number:\n" +
                        "0 = Parallel (leaves on both sides at same height)\n" +
                        "1 = Offset-Parallel (right side leaves always higher)\n" +
                        "2 = Alternating (L/R/R/L/L/R/R/L rotation pattern)\n" +
                        "3 = Double-Spiral (leaves spiral up the stem)\n" +
                        "4 = One-Sided (two leaves on right side only)"), 
                    valueProp.floatValue);
                break;
            }
            case NodeEffectType.StemRandomness:
            {
                // Growth Randomness => [0..1]
                var line = NextLineRect();
                valueProp.floatValue = EditorGUI.Slider(line,
                    new GUIContent("Growth Randomness", "0=straight up, 1=always diagonal"), valueProp.floatValue, 0f, 1f);
                break;
            }
            default:
            {
                // Fallback for unrecognized effect
                GUIContent content = new GUIContent("Value", "");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
        }
    }

    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
    {
        SerializedProperty typeProp = property.FindPropertyRelative("effectType");
        NodeEffectType effectType = (NodeEffectType)typeProp.enumValueIndex;

        float lineHeight = EditorGUIUtility.singleLineHeight;
        float spacing = EditorGUIUtility.standardVerticalSpacing;

        // Start with 1 line for the effectType + spacing
        float totalHeight = lineHeight + spacing;

        switch (effectType)
        {
            case NodeEffectType.ManaCost:
            case NodeEffectType.Damage:
            case NodeEffectType.AimSpread:
            case NodeEffectType.Piercing:
            case NodeEffectType.FriendlyFire:
            case NodeEffectType.GrowthSpeed:
            case NodeEffectType.LeafGap:
            case NodeEffectType.LeafPattern:
            case NodeEffectType.StemRandomness:
                // +1 line each
                totalHeight += (lineHeight + spacing);
                break;

            case NodeEffectType.Output:
            case NodeEffectType.SeedSpawn:
                // +1 line
                totalHeight += (lineHeight + spacing);
                break;

            case NodeEffectType.Burning:
                // +2 lines
                totalHeight += (lineHeight + spacing) * 2;
                break;

            case NodeEffectType.StemLength:
                // +2 lines (min and max)
                totalHeight += (lineHeight + spacing) * 2;
                break;

            default:
                // fallback +1 line
                totalHeight += (lineHeight + spacing);
                break;
        }
        return totalHeight;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro;

public enum PlantCellType
{
    Seed,
    Stem,
    Leaf,
    Flower,
    Fruit
}

public class PlantGrowth : MonoBehaviour
{
    [Header("Seed Gene Parameters (set via Seed node effect)")]
    public int stemMinLength = 3;            // Minimum stem length (cells)
    public int stemMaxLength = 6;            // Maximum stem length (cells)
    public float growthSpeed = 1f;           // Seconds per growth step
    [Tooltip("Leaf Gap: 0 = leaves on every stem cell; 1 = leaves on every 2nd stem cell; etc.")]
    public int leafGap = 1;
    [Tooltip("Leaf pattern type: 0=Parallel, 1=Offset-Parallel, 2=Alternating (L/R/R/L), 3=Double-Spiral, 4=One-Sided")]
    public int leafPattern = 0;
    public float growthRandomness = 0f;      // [0..1]: 0=always up; 1=always diagonal

    [Header("Energy System")]
    [Tooltip("Max energy available from all Energy Storage nodes in BFS.")]
    public float maxEnergy = 0f;
    [Tooltip("Current energy accumulated.")]
    public float currentEnergy = 0f;
    [Tooltip("Base photosynthesis rate from Energy Photosynthesis nodes in BFS.")]
    public float basePhotosynthesis = 0f;

    [Header("Cell Prefabs")]
    public GameObject seedCellPrefab;
    public GameObject stemCellPrefab;
    public GameObject leafCellPrefab;

    [Header("Cell Grid Settings")]
    [Tooltip("Distance (in game units) between adjacent cells.")]
    public float cellSpacing = 8f; 

    [Header("UI")]
    [Tooltip("TextMeshProUGUI displaying current energy and max energy below the plant.")]
    public TMP_Text energyText;

    private Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
    private bool growing = true;
    private int currentStemCount = 0;
    private int targetStemLength = 0;
    
    private bool? offsetRightForPattern1 = null;


    private void Start()
    {
        targetStemLength = Random.Range(stemMinLength, stemMaxLength + 1);
        Debug.Log($"[PlantGrowth] Target stem length: {targetStemLength}");

        cells[new Vector2Int(0, 0)] = PlantCellType.Seed;
        SpawnCellVisual(PlantCellType.Seed, new Vector2Int(0, 0));

        // Set up sorting inheritance
        SortableEntity[] cellEntities = GetComponentsInChildren<SortableEntity>();
        foreach (var cellEntity in cellEntities)
        {
            // Skip the seed cell, which will determine sorting
            if (cellEntity.transform == transform)
                continue;

            // Use the public method to set parent Y coordinate usage
            cellEntity.SetUseParentYCoordinate(true);
        }

        StartCoroutine(GrowRoutine());
    }

    private void Update()
    {
        // Use sunIntensity from WeatherManager.
        float sunlight = (WeatherManager.Instance != null) ? WeatherManager.Instance.sunIntensity : 1f;
        float leafCount = cells.Values.Count(cell => cell == PlantCellType.Leaf);
        float deltaPhotosynthesis = basePhotosynthesis * leafCount * sunlight * Time.deltaTime;
        currentEnergy += deltaPhotosynthesis;
        if (currentEnergy > maxEnergy)
            currentEnergy = maxEnergy;

        if (energyText != null)
        {
            energyText.text = $"{Mathf.Floor(currentEnergy)}/{Mathf.Floor(maxEnergy)}";
        }
    }

    private IEnumerator GrowRoutine()
{
    Vector2Int currentPos = new Vector2Int(0, 0);
    int spiralDirection = 1;  // Used for spiral pattern: 1=right, -1=left
    int patternCounter = 0;   // Used to track position in complex patterns
    
    while (growing)
    {
        yield return new WaitForSeconds(growthSpeed);

        if (currentStemCount < targetStemLength)
        {
            currentStemCount++;
            Vector2Int dir;
            if (currentStemCount == 1)
            {
                // Always grow directly up for the first stem cell.
                dir = new Vector2Int(0, 1);
            }
            else
            {
                dir = GetStemDirection();
            }
            currentPos += dir;
            cells[currentPos] = PlantCellType.Stem;
            SpawnCellVisual(PlantCellType.Stem, currentPos);
            Debug.Log($"[PlantGrowth] Stem grown at {currentPos}");

            if ((currentStemCount % (leafGap + 1)) == 0)
            {
                Vector2Int baseLeftPos = currentPos + new Vector2Int(-1, 0);
                Vector2Int baseRightPos = currentPos + new Vector2Int(1, 0);
                patternCounter++;

                // Process according to leaf pattern
                switch (leafPattern)
                {
                    case 0: // Parallel: spawn both leaves at same height
                        SpawnLeafIfEmpty(baseLeftPos);
                        SpawnLeafIfEmpty(baseRightPos);
                        Debug.Log($"[PlantGrowth] Parallel leaves at {baseLeftPos} and {baseRightPos}");
                        break;
                        
                    case 1: // Offset-Parallel: both sides have leaves, but one side is raised
                    {
                        // Choose the starting side only once per plant
                        if (offsetRightForPattern1 == null)
                        {
                            offsetRightForPattern1 = (Random.value < 0.5f);
                        }
                        if (offsetRightForPattern1.Value)
                        {
                            // Right side is raised.
                            Vector2Int raisedRightPos = baseRightPos + new Vector2Int(0, 1);
                            SpawnLeafIfEmpty(baseLeftPos);
                            SpawnLeafIfEmpty(raisedRightPos);
                            Debug.Log($"[PlantGrowth] Offset-Parallel (right offset) leaves at {baseLeftPos} and {raisedRightPos}");
                        }
                        else
                        {
                            // Left side is raised.
                            Vector2Int raisedLeftPos = baseLeftPos + new Vector2Int(0, 1);
                            SpawnLeafIfEmpty(raisedLeftPos);
                            SpawnLeafIfEmpty(baseRightPos);
                            Debug.Log($"[PlantGrowth] Offset-Parallel (left offset) leaves at {raisedLeftPos} and {baseRightPos}");
                        }
                        break;
                    }


                        
                    case 2: // Alternating-2 (L/R/R/L/L/R/R/L): proper rotation pattern
                        // This creates the L/R/R/L/L/R/R/L pattern
                        // patternCounter % 4 gives us:
                        // 1 -> Left side offset (L)
                        // 2 -> Right side normal (R)
                        // 3 -> Right side offset (R)
                        // 0 -> Left side normal (L)
                        
                        Vector2Int leftPos, rightPos;
                        
                        // Determine positions based on pattern position
                        switch (patternCounter % 4) {
                            case 1: // Left side offset, right side normal
                                leftPos = baseLeftPos + new Vector2Int(0, 1);
                                rightPos = baseRightPos;
                                Debug.Log($"[PlantGrowth] Alternating leaves at {leftPos} (offset) and {rightPos}");
                                break;
                            case 2: // Left side normal, right side normal
                                leftPos = baseLeftPos;
                                rightPos = baseRightPos;
                                Debug.Log($"[PlantGrowth] Alternating leaves at {leftPos} and {rightPos}");
                                break;
                            case 3: // Left side normal, right side offset
                                leftPos = baseLeftPos;
                                rightPos = baseRightPos + new Vector2Int(0, 1);
                                Debug.Log($"[PlantGrowth] Alternating leaves at {leftPos} and {rightPos} (offset)");
                                break;
                            case 0: // Left side normal, right side normal (cycle complete)
                                leftPos = baseLeftPos;
                                rightPos = baseRightPos;
                                Debug.Log($"[PlantGrowth] Alternating leaves at {leftPos} and {rightPos}");
                                break;
                            default:
                                leftPos = baseLeftPos;
                                rightPos = baseRightPos;
                                break;
                        }
                        
                        SpawnLeafIfEmpty(leftPos);
                        SpawnLeafIfEmpty(rightPos);
                        break;
                        
                    case 3: // Double-Spiral: two leaves per node, spiral pattern
                        // Create two leaves that spiral around the stem, with vertical offset
                        Vector2Int leftSpiral = baseLeftPos + new Vector2Int(0, spiralDirection > 0 ? 1 : 0);
                        Vector2Int rightSpiral = baseRightPos + new Vector2Int(0, spiralDirection > 0 ? 0 : 1);
                        
                        SpawnLeafIfEmpty(leftSpiral);
                        SpawnLeafIfEmpty(rightSpiral);
                        
                        Debug.Log($"[PlantGrowth] Double-Spiral leaves at {leftSpiral} and {rightSpiral}");
                        
                        // Toggle spiral direction for next node
                        spiralDirection *= -1;
                        break;
                        
                    case 4: // One-Sided: leaves only grow on one side
                        // For balance, create two leaves on the same side
                        SpawnLeafIfEmpty(baseRightPos);
                        SpawnLeafIfEmpty(baseRightPos + new Vector2Int(0, 1));
                        Debug.Log($"[PlantGrowth] One-sided leaves at {baseRightPos} and {baseRightPos + new Vector2Int(0, 1)}");
                        break;
                        
                    default: // Fallback to parallel
                        SpawnLeafIfEmpty(baseLeftPos);
                        SpawnLeafIfEmpty(baseRightPos);
                        break;
                }
            }
        }
        else
        {
            growing = false;
            Debug.Log("[PlantGrowth] Growth complete.");
        }
    }
}

    private Vector2Int GetStemDirection()
    {
        Vector2Int up = new Vector2Int(0, 1);
        Vector2Int leftDiag = new Vector2Int(-1, 1);
        Vector2Int rightDiag = new Vector2Int(1, 1);

        float r = Mathf.Clamp01(growthRandomness);
        float roll = Random.value;
        float threshold = 1f - r;  
        if (roll < threshold)
            return up;
        else
            return (Random.value < 0.5f) ? leftDiag : rightDiag;
    }

    private void SpawnLeafIfEmpty(Vector2Int coords)
    {
        if (!cells.ContainsKey(coords))
        {
            cells[coords] = PlantCellType.Leaf;
            SpawnCellVisual(PlantCellType.Leaf, coords);
        }
    }

    private void SpawnCellVisual(PlantCellType cellType, Vector2Int coords)
    {
        Vector2 worldPos = (Vector2)transform.position + (Vector2)coords * cellSpacing;
        GameObject prefabToUse = null;
        switch (cellType)
        {
            case PlantCellType.Seed:
                prefabToUse = seedCellPrefab;
                break;
            case PlantCellType.Stem:
                prefabToUse = stemCellPrefab;
                break;
            case PlantCellType.Leaf:
                prefabToUse = leafCellPrefab;
                break;
        }
        if (prefabToUse != null)
        {
            GameObject cellInstance = Instantiate(prefabToUse, worldPos, Quaternion.identity, transform);
        
            // Add SortableEntity if not already present
            SortableEntity sortableEntity = cellInstance.GetComponent<SortableEntity>();
            if (sortableEntity == null)
                sortableEntity = cellInstance.AddComponent<SortableEntity>();
        
            // For non-seed cells, enable "Y from parent"
            if (cellType != PlantCellType.Seed)
            {
                sortableEntity.SetUseParentYCoordinate(true);
            }
        }
        else
        {
            Debug.LogWarning($"[PlantGrowth] No prefab assigned for cell type {cellType}");
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\WeatherManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class WeatherManager : MonoBehaviour
{
    public static WeatherManager Instance { get; private set; }

    [Header("Day/Night Cycle Settings")]
    public bool dayNightCycleEnabled = true;
    
    [Tooltip("Duration of full day (seconds)")]
    public float dayDuration = 20f;
    [Tooltip("Duration of full night (seconds)")]
    public float nightDuration = 20f;
    [Tooltip("Duration of transitions (seconds)")]
    public float transitionDuration = 5f;

    [Tooltip("Curve that controls the sunIntensity during transitions (X=0 start, X=1 end).")]
    public AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

    [Header("Sunlight Settings")]
    [Range(0f, 1f)]
    public float sunIntensity = 1f;  // 0=night, 1=day

    [Header("Fixed Sunlight When Cycle Off")]
    [Tooltip("If dayNightCycleEnabled is false, we use this fixed intensity.")]
    [Range(0f, 1f)]
    public float fixedSunIntensity = 1f;

    [Header("Sunlight Visualization")]
    public SpriteRenderer fadeSprite;
    public float minAlpha = 0f;
    public float maxAlpha = 1f;

    // Internals
    private enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }
    private CyclePhase currentPhase = CyclePhase.Day;
    private float phaseTimer = 0f; // counts down in each phase
    private float totalPhaseTime = 0f; // length of current phase

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    private void Start()
    {
        // Initialize to Day phase
        EnterPhase(CyclePhase.Day);
    }

    private void Update()
    {
        if (!dayNightCycleEnabled)
        {
            // If the cycle is disabled, just use the fixed sun intensity
            sunIntensity = fixedSunIntensity;
            UpdateFadeSprite();
            return;
        }

        // else dayNightCycle is enabled
        phaseTimer -= Time.deltaTime;
        if (phaseTimer <= 0f)
        {
            // move to next phase
            switch (currentPhase)
            {
                case CyclePhase.Day:
                    EnterPhase(CyclePhase.TransitionToNight);
                    break;
                case CyclePhase.TransitionToNight:
                    EnterPhase(CyclePhase.Night);
                    break;
                case CyclePhase.Night:
                    EnterPhase(CyclePhase.TransitionToDay);
                    break;
                case CyclePhase.TransitionToDay:
                    EnterPhase(CyclePhase.Day);
                    break;
            }
        }
        else
        {
            // while in the current phase, update sunIntensity accordingly
            float progress = 1f - (phaseTimer / totalPhaseTime);
            switch (currentPhase)
            {
                case CyclePhase.Day:
                    // Full day, sunIntensity = 1
                    sunIntensity = 1f;
                    break;
                case CyclePhase.TransitionToNight:
                    // 0..1 => day(1) to night(0) using transitionCurve
                    float tToNight = transitionCurve.Evaluate(progress);
                    sunIntensity = Mathf.Lerp(1f, 0f, tToNight);
                    break;
                case CyclePhase.Night:
                    // Full night, sunIntensity = 0
                    sunIntensity = 0f;
                    break;
                case CyclePhase.TransitionToDay:
                    // 0..1 => night(0) to day(1) using transitionCurve
                    float tToDay = transitionCurve.Evaluate(progress);
                    sunIntensity = Mathf.Lerp(0f, 1f, tToDay);
                    break;
            }
        }

        UpdateFadeSprite();
    }

    private void EnterPhase(CyclePhase nextPhase)
    {
        currentPhase = nextPhase;
        switch (nextPhase)
        {
            case CyclePhase.Day:
                totalPhaseTime = dayDuration;
                break;
            case CyclePhase.Night:
                totalPhaseTime = nightDuration;
                break;
            case CyclePhase.TransitionToNight:
            case CyclePhase.TransitionToDay:
                totalPhaseTime = transitionDuration;
                break;
        }
        phaseTimer = totalPhaseTime;
    }

    private void UpdateFadeSprite()
    {
        if (fadeSprite != null)
        {
            float alpha = Mathf.Lerp(minAlpha, maxAlpha, sunIntensity);
            Color c = fadeSprite.color;
            c.a = alpha;
            fadeSprite.color = c;
        }
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\SpellProjectile.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SpellProjectile : MonoBehaviour
{
    [Header("Projectile Stats")]
    public float damage;
    public float speed;
    [Tooltip("If true, the projectile will be destroyed upon hitting a wizard.")]
    public bool destroyOnHit = true;

    [Header("Burning Effect (optional)")]
    public float burningDamage;   // DPS
    public float burningDuration; // Duration in seconds

    [Header("Friendly Fire")]
    public bool friendlyFire = false;
    public bool casterIsEnemy = false;

    public void Initialize(float dmg, float spd)
    {
        damage = dmg;
        speed = spd;
    }

    private void Update()
    {
        transform.Translate(Vector2.up * speed * Time.deltaTime);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\BurningStatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public class BurningStatusEffect : StatusEffect
{
    public BurningStatusEffect(float d, float dps) : base(d, dps) { }

    
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\StatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public abstract class StatusEffect
{
    public float duration; // Total duration.
    public float damagePerSecond;
    protected float elapsed = 0f;

    // Public property to expose elapsed time.
    public float Elapsed { get { return elapsed; } }

    public StatusEffect(float d, float dps)
    {
        duration = d;
        damagePerSecond = dps;
    }

    public bool IsExpired() => elapsed >= duration;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\SortableEntity.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SortableEntity : MonoBehaviour
{
    [Header("Sorting Configuration")]
    [Tooltip("Offset added to Y position for sorting calculation")]
    [SerializeField] private float sortingLayerYOffset = 0f;

    [Tooltip("Use parent's Y coordinate for sorting")]
    [SerializeField] private bool useParentYCoordinate = false;

    [Tooltip("Debug logging for sorting")]
    public bool debugSorting = false;

    private SpriteRenderer spriteRenderer;

    private void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        // If no SpriteRenderer, try to find one in children
        if (spriteRenderer == null)
            spriteRenderer = GetComponentInChildren<SpriteRenderer>();

        // Ensure sprite renderer exists
        if (spriteRenderer == null)
        {
            Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
        }
    }

    private void Start()
    {
        UpdateSortingOrder();
    }

    private void LateUpdate()
    {
        UpdateSortingOrder();
    }

    public void UpdateSortingOrder()
    {
        if (spriteRenderer == null) return;

        // Determine Y position for sorting
        float yPositionForSorting = useParentYCoordinate && transform.parent != null 
            ? transform.parent.position.y 
            : transform.position.y;

        int sortOrder = CalculateSortOrder(yPositionForSorting);
        spriteRenderer.sortingOrder = sortOrder;

        if (debugSorting)
        {
            Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
        }
    }

    private int CalculateSortOrder(float yPosition)
    {
        // Subtract offset to effectively move the sorting position
        return Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
    }

    // Public method to get current sorting order
    public int GetCurrentSortOrder()
    {
        if (spriteRenderer == null) return 0;
        return spriteRenderer.sortingOrder;
    }

    // Public method to set sorting order directly if needed
    public void SetSortingOrder(int order)
    {
        if (spriteRenderer != null)
            spriteRenderer.sortingOrder = order;
    }

    // Public method to set the parent Y coordinate usage flag
    // This eliminates the need for reflection in other scripts
    public void SetUseParentYCoordinate(bool value)
    {
        useParentYCoordinate = value;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "AnimalDefinition", menuName = "Ecosystem/Animal Definition")]
public class AnimalDefinition : ScriptableObject
{
    [Header("Basic Stats")]
    public string animalName;
    public float maxHealth = 10f;
    public float hungerDecayRate = 0.5f;  // How quickly the animal gets hungry (units/sec)
    public float movementSpeed = 2f;

    [Header("Eating & Satiation")]
    public float hungerThreshold = 5f;    // If hunger > threshold, tries to eat
    public float eatAmount = 5f;         // How much hunger is reduced when it eats a leaf
    public float leafDamage = 1f;        // How much health (or 'life') is removed from a leaf

    [Header("Prefab/Visuals")]
    public GameObject prefab;  // The character prefab to instantiate
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "AnimalLibrary", menuName = "Ecosystem/Animal Library")]
public class AnimalLibrary : ScriptableObject
{
    public List<AnimalDefinition> animals;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Linq;
using System.Collections.Generic;

[RequireComponent(typeof(Rigidbody2D))]
public class AnimalController : MonoBehaviour
{
    // Assigned via FaunaManager on instantiation
    private AnimalDefinition definition;

    [Header("Thought/Dialogue Setup")]
    public AnimalThoughtLibrary thoughtLibrary;      // Assign GlobalAnimalThoughtLibrary asset
    public GameObject thoughtBubblePrefab;           // Assign your ThoughtBubble prefab

    [Header("Transforms for Visual Alignment")]
    public Transform mouthTransform;                 // For aligning mouth (for future pooping VFX)
    public Transform bubbleSpawnTransform;           // Where thought bubbles spawn

    [Header("Thought Bubble Settings")]
    public float thoughtCooldownTime = 5f;             // Minimum time between thought bubbles
    private float thoughtCooldownTimer = 0f;

    private string speciesName;                      // Derived from definition.animalName

    // Basic runtime stats
    private float currentHealth;
    private float currentHunger;

    private Rigidbody2D rb;
    private SpriteRenderer spriteRenderer;           // For sprite flipping
    private Vector2 moveDirection;

    // Global movement bounds (set via FaunaManager; hidden in Inspector)
    [HideInInspector] private Vector2 minBounds;
    [HideInInspector] private Vector2 maxBounds;

    [Header("Eating Settings")]
    public float eatDuration = 2f;                    // Time spent eating
    [Tooltip("How close the animal must be to a leaf to eat it.")]
    public float eatDistance = 0.5f;
    private bool isEating = false;
    private float eatTimer = 0f;
    private GameObject currentTargetLeaf;

    [Header("Wander Behavior Settings")]
    [Tooltip("Intensity multiplier (0 to 1) controlling the chance to pause while wandering.")]
    [Range(0f, 1f)]
    public float wanderPauseIntensity = 0.5f;
    [Tooltip("Minimum duration for a moving phase while wandering.")]
    public float wanderMinMoveDuration = 1f;
    [Tooltip("Maximum duration for a moving phase while wandering.")]
    public float wanderMaxMoveDuration = 3f;
    [Tooltip("Minimum duration for a pause while wandering.")]
    public float wanderMinPauseDuration = 0.5f;
    [Tooltip("Maximum duration for a pause while wandering.")]
    public float wanderMaxPauseDuration = 2f;
    private bool isWanderPaused = false;
    private float wanderStateTimer = 0f;

    [Header("Pooping Settings")]
    [Tooltip("Minimum delay after eating before the animal poops.")]
    public float minPoopDelay = 5f;
    [Tooltip("Maximum delay after eating before the animal poops.")]
    public float maxPoopDelay = 10f;
    [Tooltip("Duration (in seconds) the animal spends pooping (not moving).")]
    public float poopDuration = 1f;
    [Tooltip("List of poop prefabs for random selection.")]
    public List<GameObject> poopPrefabs;
    [Tooltip("Maximum amount to vary each color channel (0-1) for the poop sprite.")]
    public float poopColorVariation = 0.1f;

    // Internal pooping state variables
    private bool isPooping = false;
    private float poopTimer = 0f;      // For the pooping phase duration
    private float poopDelayTimer = 0f; // Delay before pooping after eating
    private bool hasPooped = false;    // True if the animal has already pooped after the last eating cycle

    public void Initialize(AnimalDefinition def)
    {
        definition = def;
        currentHealth = definition.maxHealth;
        currentHunger = 0f;
        speciesName = definition.animalName; // e.g., "Bunny"
        // Start with no pending poop (already pooped)
        hasPooped = true;
        poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);
    }

    private void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        if (!spriteRenderer)
            spriteRenderer = GetComponentInChildren<SpriteRenderer>();
    }

    private void Update()
    {
        if (definition == null)
        {
            Debug.LogWarning("[AnimalController] 'definition' is null. Did you call Initialize()?");
            return;
        }

        // Decrement thought bubble cooldown timer
        thoughtCooldownTimer -= Time.deltaTime;

        // Increase hunger over time
        currentHunger += definition.hungerDecayRate * Time.deltaTime;

        // Process pooping only if not eating and hasn't already pooped in this cycle
        if (!isEating && !hasPooped)
        {
            poopDelayTimer -= Time.deltaTime;
            if (!isPooping && poopDelayTimer <= 0f)
            {
                // Start pooping phase
                isPooping = true;
                poopTimer = poopDuration;
                ShowThought(ThoughtTrigger.Pooping);
                moveDirection = Vector2.zero; // Stop moving during pooping
            }
            if (isPooping)
            {
                poopTimer -= Time.deltaTime;
                if (poopTimer <= 0f)
                {
                    SpawnPoop();
                    isPooping = false;
                    hasPooped = true; // Mark that we've pooped this cycle
                }
            }
        }

        // If in eating state, update timer and exit early
        if (isEating)
        {
            eatTimer -= Time.deltaTime;
            if (eatTimer <= 0f)
            {
                isEating = false;
                FinishEatingLeaf();
            }
            return;
        }

        // Behavior based on hunger:
        if (currentHunger >= definition.hungerThreshold)
        {
            Debug.Log($"{speciesName} is hungry! (Hunger: {currentHunger:0.00}/{definition.hungerThreshold})");
            if (thoughtCooldownTimer <= 0f)
            {
                ShowThought(ThoughtTrigger.Hungry);
                thoughtCooldownTimer = thoughtCooldownTime;
            }
            if (currentTargetLeaf == null)
                currentTargetLeaf = FindNearestLeaf();
            if (currentTargetLeaf != null)
                MoveTowardLeaf(currentTargetLeaf);
            else
                Wander();
        }
        else
        {
            Wander();
            currentTargetLeaf = null;
        }

        FlipSpriteBasedOnDirection(moveDirection);
    }

    private void FixedUpdate()
    {
        if (isEating || rb == null)
            return;
        Vector2 newPos = rb.position + moveDirection * definition.movementSpeed * Time.fixedDeltaTime;
        newPos.x = Mathf.Clamp(newPos.x, minBounds.x, maxBounds.x);
        newPos.y = Mathf.Clamp(newPos.y, minBounds.y, maxBounds.y);
        rb.MovePosition(newPos);
    }

    // Wander behavior: alternate between moving and pausing with random durations.
    private void Wander()
    {
        if (wanderStateTimer <= 0f)
        {
            if (isWanderPaused)
            {
                isWanderPaused = false;
                float angle = Random.Range(0f, 360f);
                moveDirection = new Vector2(Mathf.Cos(angle), Mathf.Sin(angle));
                wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration);
            }
            else
            {
                if (Random.value < wanderPauseIntensity)
                {
                    isWanderPaused = true;
                    moveDirection = Vector2.zero;
                    wanderStateTimer = Random.Range(wanderMinPauseDuration, wanderMaxPauseDuration);
                }
                else
                {
                    float angle = Random.Range(0f, 360f);
                    moveDirection = new Vector2(Mathf.Cos(angle), Mathf.Sin(angle));
                    wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration);
                }
            }
        }
        else
        {
            wanderStateTimer -= Time.deltaTime;
        }
    }

    private void MoveTowardLeaf(GameObject leafObj)
    {
        if (isEating)
            return; // Avoid re-triggering if already eating
        if (!leafObj)
        {
            currentTargetLeaf = null;
            return;
        }
        Vector2 leafPos = leafObj.transform.position;
        Vector2 myPos = transform.position;
        float distance = Vector2.Distance(myPos, leafPos);
        if (distance <= eatDistance)
        {
            isEating = true;
            eatTimer = eatDuration;
            ShowThought(ThoughtTrigger.Eating);
        }
        else
        {
            moveDirection = (leafPos - myPos).normalized;
        }
    }

    private void FinishEatingLeaf()
    {
        if (currentTargetLeaf)
        {
            Destroy(currentTargetLeaf);
            currentTargetLeaf = null;
        }
        currentHunger -= definition.eatAmount;
        if (currentHunger < 0f)
            currentHunger = 0f;
        // Reset pooping state for this eating cycle.
        hasPooped = false;
        poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);
    }

    private GameObject FindNearestLeaf()
    {
        GameObject[] leaves = GameObject.FindGameObjectsWithTag("Leaf");
        if (leaves.Length == 0)
            return null;
        Vector2 myPos = transform.position;
        GameObject nearest = null;
        float nearestDist = float.MaxValue;
        foreach (var leaf in leaves)
        {
            float dist = Vector2.Distance(myPos, leaf.transform.position);
            if (dist < nearestDist)
            {
                nearestDist = dist;
                nearest = leaf;
            }
        }
        return nearest;
    }

    // Thought bubble logic: spawn a bubble as a child of bubbleSpawnTransform.
    private void ShowThought(ThoughtTrigger trigger)
    {
        if (!thoughtLibrary || !thoughtBubblePrefab)
        {
            Debug.LogWarning($"[{speciesName}] Missing thought library or bubble prefab!");
            return;
        }
        if (string.IsNullOrEmpty(speciesName))
            return;
        var matchingEntries = thoughtLibrary.allThoughts
            .Where(t => t.speciesName == speciesName && t.trigger == trigger)
            .ToList();
        if (matchingEntries.Count == 0)
        {
            Debug.Log($"[{speciesName}] No thought lines for trigger {trigger}.");
            return;
        }
        var chosenEntry = matchingEntries[Random.Range(0, matchingEntries.Count)];
        if (chosenEntry.lines == null || chosenEntry.lines.Count == 0)
        {
            Debug.Log($"[{speciesName}] Thought entry for trigger {trigger} has no lines.");
            return;
        }
        string randomLine = chosenEntry.lines[Random.Range(0, chosenEntry.lines.Count)];
        Debug.Log($"[{speciesName}] Spawning thought bubble: {randomLine}");
        Transform spawnParent = bubbleSpawnTransform ? bubbleSpawnTransform : transform;
        GameObject bubbleObj = Instantiate(thoughtBubblePrefab, spawnParent.position, Quaternion.identity, spawnParent);
        bubbleObj.transform.localPosition = Vector3.zero;
        ThoughtBubbleController bubble = bubbleObj.GetComponent<ThoughtBubbleController>();
        if (bubble != null)
            bubble.Initialize(randomLine, spawnParent, 2f);
        else
            Debug.LogWarning($"[{speciesName}] ThoughtBubblePrefab is missing ThoughtBubbleController!");
    }

    // Spawn a poop object at the mouthTransform (or fallback to self)
    private void SpawnPoop()
    {
        if (poopPrefabs != null && poopPrefabs.Count > 0)
        {
            int index = Random.Range(0, poopPrefabs.Count);
            GameObject selectedPrefab = poopPrefabs[index];
            Transform spawnPoint = mouthTransform ? mouthTransform : transform;
            GameObject poopObj = Instantiate(selectedPrefab, spawnPoint.position, Quaternion.identity);
            // Random flip and color variation as before.
            SpriteRenderer sr = poopObj.GetComponent<SpriteRenderer>();
            if (sr != null)
            {
                sr.flipX = (Random.value > 0.5f);
                Color originalColor = sr.color;
                float variation = poopColorVariation;
                float newR = Mathf.Clamp01(originalColor.r + Random.Range(-variation, variation));
                float newG = Mathf.Clamp01(originalColor.g + Random.Range(-variation, variation));
                float newB = Mathf.Clamp01(originalColor.b + Random.Range(-variation, variation));
                sr.color = new Color(newR, newG, newB, originalColor.a);
            }
            // Attach PoopController if not present.
            PoopController pc = poopObj.GetComponent<PoopController>();
            if (pc == null)
            {
                pc = poopObj.AddComponent<PoopController>();
            }
            // Initialize PoopController using its Inspector settings (no lifetime passed).
            pc.Initialize();
        }
        else
        {
            Debug.LogWarning($"[{speciesName}] No poopPrefabs assigned!");
        }
    }

    // Sprite flipping based on horizontal movement direction.
    private void FlipSpriteBasedOnDirection(Vector2 direction)
    {
        if (!spriteRenderer)
            return;
        if (direction.x < -0.01f)
            spriteRenderer.flipX = true;
        else if (direction.x > 0.01f)
            spriteRenderer.flipX = false;
    }

    // Public setter for movement bounds (called from FaunaManager)
    public void SetMovementBounds(Vector2 min, Vector2 max)
    {
        minBounds = min;
        maxBounds = max;
    }

    // Public method to compare species name (used by FaunaManager)
    public bool SpeciesNameEquals(string other)
    {
        return speciesName == other;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalSpawnData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[System.Serializable]
public class AnimalSpawnData {
    public AnimalDefinition animalDefinition;
    [Range(0f, 1f)]
    [Tooltip("Spawn rate multiplier (0 = no spawn; lower values = less frequent spawns).")]
    public float spawnRateMultiplier = 1f;
    [Tooltip("Maximum number of this animal type allowed to be spawned (0 = no limit).")]
    public int maximumSpawned = 0;
    
    [HideInInspector]
    public float spawnTimer = 0f;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalThoughtLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "AnimalThoughtLibrary", menuName = "Ecosystem/Animal Thought Library")]
public class AnimalThoughtLibrary : ScriptableObject
{
    public List<AnimalThoughtLine> allThoughts;
}

[System.Serializable]
public class AnimalThoughtLine
{
    [Header("Which Animal?")]
    public string speciesName; // e.g. "Bunny", "Fox", "Bird"

    [Header("Trigger Condition")]
    public ThoughtTrigger trigger;

    [Header("Possible Lines to Randomly Choose From")]
    public List<string> lines;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\EcosystemManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class EcosystemManager : MonoBehaviour
{
    public static EcosystemManager Instance { get; private set; }

    [Header("Parent Transforms")]
    public Transform animalParent;   // e.g., an empty GameObject "SpawnedEcosystem/Animals"
    public Transform plantParent;    // e.g., an empty GameObject "SpawnedEcosystem/Plants"

    [Header("Sorting Options")]
    public bool sortAnimalsBySpecies = true;
    public bool sortPlantsBySpecies = true;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FaunaManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

public class FaunaManager : MonoBehaviour
{
    [Header("Animal Spawn Settings")]
    public List<AnimalSpawnData> animalsToSpawn;
    public float globalSpawnCooldown = 5f;
    public float spawnRadius = 3f;
    public bool continuousSpawn = true;
    public Vector2 spawnCenter = Vector2.zero;

    [Header("Ecosystem Parent Settings")]
    public Transform ecosystemParent; // e.g., "SpawnedEcosystem/Animals"

    [Header("Global Movement Bounds for Animals")]
    public Vector2 animalMinBounds = new Vector2(-10f, -5f);
    public Vector2 animalMaxBounds = new Vector2(10f, 5f);

    private void Start()
    {
        // Initialize each spawn entry's timer to its effective cooldown.
        foreach (var spawnData in animalsToSpawn)
        {
            if (spawnData.spawnRateMultiplier > 0f)
                spawnData.spawnTimer = globalSpawnCooldown / spawnData.spawnRateMultiplier;
            else
                spawnData.spawnTimer = Mathf.Infinity; // won't spawn if 0
        }
    }

    private void Update()
    {
        if (continuousSpawn)
        {
            foreach (var spawnData in animalsToSpawn)
            {
                if (spawnData.spawnRateMultiplier <= 0f)
                    continue;

                // Check current count for this species.
                int currentCount = 0;
                if (ecosystemParent != null && spawnData.animalDefinition != null && !string.IsNullOrEmpty(spawnData.animalDefinition.animalName))
                {
                    Transform speciesParent = ecosystemParent.Find(spawnData.animalDefinition.animalName);
                    if (speciesParent != null)
                        currentCount = speciesParent.childCount;
                }
                else
                {
                    AnimalController[] allAnimals = FindObjectsOfType<AnimalController>();
                    currentCount = 0;
                    foreach (var a in allAnimals)
                    {
                        if (a != null && a.SpeciesNameEquals(spawnData.animalDefinition.animalName))
                            currentCount++;
                    }
                }
                // If maximum is set (>0) and current count is reached, skip spawn.
                if (spawnData.maximumSpawned > 0 && currentCount >= spawnData.maximumSpawned)
                    continue;

                // Decrement spawn timer and spawn if ready.
                spawnData.spawnTimer -= Time.deltaTime;
                if (spawnData.spawnTimer <= 0f)
                {
                    float effectiveCooldown = globalSpawnCooldown / spawnData.spawnRateMultiplier;
                    Vector2 randomOffset = Random.insideUnitCircle * spawnRadius;
                    SpawnAnimal(spawnData.animalDefinition, spawnCenter + randomOffset);
                    spawnData.spawnTimer = effectiveCooldown;
                }
            }
        }
    }

    public GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position)
    {
        if (definition == null || definition.prefab == null)
        {
            Debug.LogWarning("[FaunaManager] Invalid animal definition or missing prefab!");
            return null;
        }

        GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

        // Parent the animal under ecosystemParent with species grouping.
        if (ecosystemParent != null)
        {
            Transform speciesParent = ecosystemParent;
            if (!string.IsNullOrEmpty(definition.animalName))
            {
                speciesParent = ecosystemParent.Find(definition.animalName);
                if (speciesParent == null)
                {
                    GameObject subParent = new GameObject(definition.animalName);
                    subParent.transform.SetParent(ecosystemParent);
                    speciesParent = subParent.transform;
                }
            }
            animalObj.transform.SetParent(speciesParent);
        }

        // Get the existing AnimalController on the prefab.
        AnimalController controller = animalObj.GetComponent<AnimalController>();
        if (!controller)
        {
            Debug.LogWarning("[FaunaManager] Prefab missing AnimalController. Adding one dynamically.");
            controller = animalObj.AddComponent<AnimalController>();
        }
        controller.Initialize(definition);
        controller.SetMovementBounds(animalMinBounds, animalMaxBounds);
        return animalObj;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\PoopController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class PoopController : MonoBehaviour
{
    [Tooltip("Total lifetime of this poop (in seconds) before disappearing.")]
    public float lifetime = 10f;
    [Tooltip("Duration at the end of the lifetime during which the poop fades out.")]
    public float fadeDuration = 2f;
    [Tooltip("Fadeout curve to control the alpha during fade-out. X axis goes from 0 (start of fade) to 1 (end of fade).")]
    public AnimationCurve fadeCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);

    private SpriteRenderer sr;
    private float timer = 0f;
    private Color initialColor;

    private void Awake()
    {
        sr = GetComponent<SpriteRenderer>();
        if (sr != null)
        {
            initialColor = sr.color;
        }
    }

    private void Update()
    {
        timer += Time.deltaTime;
        if (timer >= lifetime)
        {
            Destroy(gameObject);
            return;
        }

        // If within fadeDuration at the end, apply fade-out using the fadeCurve.
        float remaining = lifetime - timer;
        if (remaining < fadeDuration && sr != null)
        {
            // Normalize fade time (0 = start, 1 = end)
            float t = 1f - (remaining / fadeDuration);
            float alphaMultiplier = fadeCurve.Evaluate(t);
            Color newColor = initialColor;
            newColor.a = alphaMultiplier;
            sr.color = newColor;
        }
    }

    // Initialize with default parameters if none are provided.
    public void Initialize(float lifetimeValue = -1f, float fadeDurationValue = -1f)
    {
        if (lifetimeValue > 0f)
            lifetime = lifetimeValue;
        if (fadeDurationValue > 0f)
            fadeDuration = fadeDurationValue;
        timer = 0f;
        if (sr != null)
            initialColor = sr.color;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtBubbleController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class ThoughtBubbleController : MonoBehaviour
{
    public TMP_Text messageText;
    public float lifetime = 2f;

    private Transform followTarget;

    public void Initialize(string message, Transform target, float duration = 2f)
    {
        if (messageText != null)
            messageText.text = message;
        followTarget = target;
        lifetime = duration;
    }

    private void Update()
    {
        lifetime -= Time.deltaTime;
        if (lifetime <= 0f)
            Destroy(gameObject);

        // Follow the target if needed (optional if already a child)
        if (followTarget != null)
        {
            transform.position = followTarget.position;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtTrigger.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public enum ThoughtTrigger
{
    Hungry,
    Eating,
    HealthLow,
    Fleeing,
    Pooping,
    // Add more triggers as needed
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\HexCoords.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[System.Serializable]
public struct HexCoords
{
    public int q; // axial coordinate (column)
    public int r; // axial coordinate (row)

    public HexCoords(int q, int r)
    {
        this.q = q;
        this.r = r;
    }

    // Flat top conversion from axial to world coordinates.
    // Using the formula:
    // x = hexSize * (3/2 * q)
    // y = hexSize * ( (sqrt(3)/2 * q) + (sqrt(3) * r) )
    public Vector2 HexToWorld(float hexSize)
    {
        float x = hexSize * (3f / 2f * q);
        float y = hexSize * ((Mathf.Sqrt(3f) / 2f * q) + (Mathf.Sqrt(3f) * r));
        return new Vector2(x, y);
    }

    // Converts a world (UI) position to axial coordinates.
    // Inverse formulas:
    // q = (2/3 * x)/hexSize
    // r = ((-1/3 * x) + (sqrt(3)/3 * y)) / hexSize
    public static HexCoords WorldToHex(Vector2 pos, float hexSize)
    {
        float qf = (2f / 3f * pos.x) / hexSize;
        float rf = ((-1f / 3f * pos.x) + (Mathf.Sqrt(3f) / 3f * pos.y)) / hexSize;
        return RoundAxial(qf, rf);
    }

    public static HexCoords RoundAxial(float qf, float rf)
    {
        float sf = -qf - rf;
        int qi = Mathf.RoundToInt(qf);
        int ri = Mathf.RoundToInt(rf);
        int si = Mathf.RoundToInt(sf);

        float qDiff = Mathf.Abs(qi - qf);
        float rDiff = Mathf.Abs(ri - rf);
        float sDiff = Mathf.Abs(si - sf);

        if (qDiff > rDiff && qDiff > sDiff)
            qi = -ri - si;
        else if (rDiff > sDiff)
            ri = -qi - si;
        return new HexCoords(qi, ri);
    }

    // Fixed neighbor offsets (axial) for flat top grid.
    private static readonly HexCoords[] AxialNeighbors = new HexCoords[] {
        new HexCoords(+1, 0),   // Side1
        new HexCoords(0, -1),   // Side2
        new HexCoords(-1, -1),  // Side3
        new HexCoords(-1, 0),   // Side4
        new HexCoords(0, +1),   // Side5
        new HexCoords(+1, +1)   // Side6
    };

    // Returns the neighbor hex coordinate for a given side index (0 to 5)
    public static HexCoords GetNeighbor(HexCoords origin, int sideIndex)
    {
        return new HexCoords(origin.q + AxialNeighbors[sideIndex].q,
                             origin.r + AxialNeighbors[sideIndex].r);
    }

    public static int OppositeSideIndex(int sideIndex)
    {
        return (sideIndex + 3) % 6;
    }

    public override bool Equals(object obj)
    {
        if (!(obj is HexCoords))
            return false;
        HexCoords other = (HexCoords)obj;
        return this.q == other.q && this.r == other.r;
    }

    public override int GetHashCode()
    {
        unchecked { return (q * 397) ^ r; }
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\HexGridManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class HexGridManager : MonoBehaviour
{
    public float hexSize = 50f;
    public float pinRadiusMultiplier = 1.0f; // Pin radius = hexSize * multiplier

    // Flat top hexagon grid only – no orientation toggle needed.
    public static HexGridManager Instance { get; private set; }
    
    private void Awake()
    {
        Instance = this;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\HexGridRenderer.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

[RequireComponent(typeof(CanvasRenderer))]
public class HexGridRenderer : MaskableGraphic
{
    public bool showGrid = true;
    public Color gridColor = Color.white;
    public float lineThickness = 1f;

    private float HexSize {
        get { return (HexGridManager.Instance != null) ? HexGridManager.Instance.hexSize : 50f; }
    }

    protected override void OnPopulateMesh(VertexHelper vh)
    {
        vh.Clear();
        if (!showGrid)
            return;

        Rect rect = rectTransform.rect;
        Vector2 origin = rect.center;

        int cols = Mathf.CeilToInt(rect.width / (HexSize * Mathf.Sqrt(3))) + 2;
        int rows = Mathf.CeilToInt(rect.height / (HexSize * 1.5f)) + 2;

        List<Vector2> linePoints = new List<Vector2>();

        for (int q = -cols; q <= cols; q++)
        {
            for (int r = -rows; r <= rows; r++)
            {
                HexCoords hex = new HexCoords(q, r);
                Vector2 hexCenter = hex.HexToWorld(HexSize) + origin;
                List<Vector2> corners = new List<Vector2>();
                // For flat top, use corners at angles 0, 60, 120, 180, 240, 300.
                for (int i = 0; i < 6; i++)
                {
                    float angle = i * 60f;
                    float rad = angle * Mathf.Deg2Rad;
                    Vector2 offset = new Vector2(HexSize * Mathf.Cos(rad), HexSize * Mathf.Sin(rad));
                    corners.Add(hexCenter + offset);
                }
                for (int i = 0; i < 6; i++)
                {
                    int next = (i + 1) % 6;
                    linePoints.Add(corners[i]);
                    linePoints.Add(corners[next]);
                }
            }
        }
        for (int i = 0; i < linePoints.Count; i += 2)
        {
            AddLineQuad(vh, linePoints[i], linePoints[i + 1], lineThickness, gridColor);
        }
    }

    private void AddLineQuad(VertexHelper vh, Vector2 start, Vector2 end, float thickness, Color col)
    {
        Vector2 direction = (end - start).normalized;
        Vector2 normal = new Vector2(-direction.y, direction.x);
        Vector2 offset = normal * (thickness * 0.5f);

        int idx = vh.currentVertCount;
        vh.AddVert(start + offset, col, Vector2.zero);
        vh.AddVert(start - offset, col, Vector2.zero);
        vh.AddVert(end - offset, col, Vector2.zero);
        vh.AddVert(end + offset, col, Vector2.zero);
        vh.AddTriangle(idx, idx + 1, idx + 2);
        vh.AddTriangle(idx, idx + 2, idx + 3);
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public Vector2 editorPosition; // For UI positioning
    public HexCoords coords;       // Hex-based position
    public Color backgroundColor = Color.gray;
    public string description = "";
    public List<NodePort> ports;   // Up to 6 ports (max 1 per side)
    public List<NodeEffectData> effects;

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
        ports = new List<NodePort>();
        effects = new List<NodeEffectData>();
        coords = new HexCoords(0, 0);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    public string displayName;
    public Color backgroundColor = Color.gray;
    [TextArea] public string description;
    public List<PortDefinition> ports;
    public List<NodeEffectData> effects = new List<NodeEffectData>();

#if UNITY_EDITOR
    private void OnValidate()
    {
        if (string.IsNullOrEmpty(displayName))
        {
            string path = UnityEditor.AssetDatabase.GetAssetPath(this);
            string fileName = System.IO.Path.GetFileNameWithoutExtension(path);
            string[] parts = fileName.Split('_');
            if (parts.Length >= 3)
                displayName = string.Join("_", parts.Skip(2).ToArray());
        }
    }
#endif

    private void OnEnable()
    {
        if (ports == null || ports.Count == 0)
        {
            ports = new List<PortDefinition>();
            // Default: one input on Top and one output on Three (opposite for flat-top)
            ports.Add(new PortDefinition { isInput = true, portType = PortType.General, side = HexSideFlat.Top });
            ports.Add(new PortDefinition { isInput = false, portType = PortType.General, side = HexSideFlat.Three });
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    public List<NodeDefinition> definitions;
    // New: List of nodes to auto-spawn at game start.
    public List<NodeDefinition> autoSpawnNodes;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;

    // For Seed:
    // effectValue     = stemMinLength
    // secondaryValue  = stemMaxLength
    // extra1          = growthSpeed
    // extra2          = leafGap
    public float effectValue;
    public float secondaryValue;
    public float extra1;
    public float extra2;

    // Two brand-new fields:
    public int leafPattern = 0;       // 0=Parallel, 1=Alternating
    public float growthRandomness = 0f; // Range [0..2]
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿public enum NodeEffectType
{
    ManaCost,
    Damage,
    ManaStorage,
    ManaRechargeRate,
    EnergyStorage,
    EnergyPhotosynthesis,
    Output,
    AimSpread,    // formerly Accuracy
    Burning,
    Piercing,
    FriendlyFire,
    // Replaced Seed with more granular effects
    SeedSpawn,        // Base effect to spawn a plant
    StemLength,       // Min/Max stem length
    GrowthSpeed,      // Controls growth speed
    LeafGap,          // Spacing between leaves
    LeafPattern,      // Parallel or alternating pattern
    StemRandomness    // Randomness of stem growth
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodePort.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

public enum PortType { General, Mana, Condition }

public enum HexSideFlat { Top, One, Two, Three, Four, Five }

[Serializable]
public class NodePort
{
    public bool isInput;
    public PortType portType;
    public HexSideFlat side;

    public NodePort(bool isInput, PortType portType, HexSideFlat side)
    {
        this.isInput = isInput;
        this.portType = portType;
        this.side = side;
    }

    public NodePort() { }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\OutputNodeEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Linq;

/// <summary>
/// Attach this to the NodeView prefab if the node has Output effect,
/// or have BFS call it directly. 
/// It calls WizardController to spawn a projectile/spell.
/// </summary>
public class OutputNodeEffect : MonoBehaviour
{
    /// <summary>
    /// This method is invoked by NodeExecutor when BFS processes an 'Output' node.
    /// You can pass any parameters (damage, aim, etc.) or just do a test projectile.
    /// </summary>
    public void Activate()
    {
        Debug.Log("[OutputNodeEffect] Activate() called. Spawning projectile or calling wizard cast.");

        

        
        
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\PortDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

[Serializable]
public class PortDefinition
{
    public bool isInput;
    public PortType portType;
    public HexSideFlat side;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro;

public class NodeExecutor : MonoBehaviour
{
    [SerializeField] private NodeGraph currentGraph;
    [Header("Debug Settings")]
    public float waitTimeBetweenNodes = 0.5f;
    public TMP_Text debugOutput;

    [Header("Plant Prefab (assigned in inspector)")]
    public GameObject plantPrefab;  // Assign your PlantPrefab here

    private Dictionary<HexCoords, NodeData> coordsMap;
    private HashSet<string> visited;

    // For accumulating energy info from the BFS chain:
    private float accumulatedEnergyStorage  = 0f;
    private float accumulatedPhotosynthesis = 0f;

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
            ExecuteGraph();
    }

    public void SetGraph(NodeGraph graph)
    {
        currentGraph = graph;
        Debug.Log("[NodeExecutor] Graph set. Node count=" + (graph != null ? graph.nodes.Count : 0));
    }

    public NodeGraph GetGraph() => currentGraph;

    public void ExecuteGraph()
    {
        if (currentGraph == null || currentGraph.nodes.Count == 0)
        {
            LogDebug("[NodeExecutor] No graph or no nodes to execute!");
            return;
        }
        StopAllCoroutines();
        ClearDebug();
        BuildCoordsMap();
        visited = new HashSet<string>();

        // Reset accumulators in case we want a fresh sum each time.
        accumulatedEnergyStorage  = 0f;
        accumulatedPhotosynthesis = 0f;

        List<NodeData> startNodes = FindStartNodes();
        if (startNodes.Count == 0)
        {
            LogDebug("[NodeExecutor] No start nodes found. Aborting BFS.");
            return;
        }
        foreach (var startNode in startNodes)
            StartCoroutine(RunChainBFS(startNode));
    }

    private void BuildCoordsMap()
    {
        coordsMap = new Dictionary<HexCoords, NodeData>();
        foreach (var node in currentGraph.nodes)
            coordsMap[node.coords] = node;
    }

    private List<NodeData> FindStartNodes()
    {
        List<NodeData> result = new List<NodeData>();
        foreach (var node in currentGraph.nodes)
        {
            if (!HasInbound(node))
                result.Add(node);
        }
        return result;
    }

    private bool HasInbound(NodeData node)
    {
        foreach (var port in node.ports)
        {
            if (!port.isInput) continue;

            int sideIndex = (int)port.side;
            int oppSide   = (sideIndex + 3) % 6;
            HexCoords neighborCoords = HexCoords.GetNeighbor(node.coords, oppSide);
            if (!coordsMap.ContainsKey(neighborCoords)) 
                continue;

            var neighborNode = coordsMap[neighborCoords];
            bool hasOutputMatch = neighborNode.ports.Any(p => !p.isInput && (int)p.side == oppSide);
            if (hasOutputMatch)
                return true;
        }
        return false;
    }

    private IEnumerator RunChainBFS(NodeData startNode)
    {
        Queue<HexCoords> queue = new Queue<HexCoords>();
        queue.Enqueue(startNode.coords);

        while (queue.Count > 0)
        {
            HexCoords coords = queue.Dequeue();
            if (!coordsMap.ContainsKey(coords)) 
                continue;

            NodeData node = coordsMap[coords];
            if (visited.Contains(node.nodeId)) 
                continue;

            visited.Add(node.nodeId);

            yield return new WaitForSeconds(waitTimeBetweenNodes);
            ProcessNode(node);

            // Follow output sides
            foreach (var port in node.ports)
            {
                if (!port.isInput)
                {
                    int sIndex = (int)port.side;
                    HexCoords neighborCoords = HexCoords.GetNeighbor(coords, sIndex);
                    if (!coordsMap.ContainsKey(neighborCoords)) 
                        continue;

                    var neighborNode = coordsMap[neighborCoords];
                    int oppIndex = (sIndex + 3) % 6;
                    bool hasInputMatch = neighborNode.ports.Any(p => p.isInput && (int)p.side == oppIndex);
                    if (hasInputMatch && !visited.Contains(neighborNode.nodeId))
                        queue.Enqueue(neighborCoords);
                }
            }
        }
        LogDebug("[NodeExecutor] BFS from start node completed.");
    }

    private void ProcessNode(NodeData node)
    {
        LogDebug($"[NodeExecutor] Processing node '{node.nodeDisplayName}' at coords ({node.coords.q}, {node.coords.r}).");

        // Accumulate Energy Storage and Photosynthesis from ANY node effect 
        // in the BFS chain.
        foreach (var eff in node.effects)
        {
            if (eff.effectType == NodeEffectType.EnergyStorage)
            {
                accumulatedEnergyStorage += eff.effectValue;
            }
            else if (eff.effectType == NodeEffectType.EnergyPhotosynthesis)
            {
                accumulatedPhotosynthesis += eff.effectValue;
            }
        }

        // If it's a SeedSpawn node, spawn the plant now using the BFS accumulators and collect plant parameters
        var seedSpawnEffect = node.effects.FirstOrDefault(e => e.effectType == NodeEffectType.SeedSpawn);
        if (seedSpawnEffect != null)
        {
            SpawnPlant(node);
        }
    }

    private void SpawnPlant(NodeData node)
{
    if (plantPrefab == null)
    {
        LogDebug("[NodeExecutor] plantPrefab is not assigned in the inspector!");
        return;
    }
    var gardener = FindObjectOfType<GardenerController>();
    if (gardener == null)
    {
        LogDebug("[NodeExecutor] No GardenerController found. Can't spawn plant.");
        return;
    }

    // Step A: Collect all relevant effect data from node
    float minStem = 3f;
    float maxStem = 6f;
    float speed = 1f;            // Growth speed
    float gap = 1f;              // Leaf gap
    float pattern = 0f;          // Leaf pattern
    float randomness = 0f;       // Stem randomness

    // We parse each effect to see if it matches the known effect types
    foreach (var eff in node.effects)
    {
        switch (eff.effectType)
        {
            case NodeEffectType.StemLength:
                minStem = eff.effectValue;
                maxStem = eff.secondaryValue;
                break;
            case NodeEffectType.GrowthSpeed:
                speed = eff.effectValue;
                break;
            case NodeEffectType.LeafGap:
                gap = eff.effectValue;
                break;
            case NodeEffectType.LeafPattern:
                pattern = eff.effectValue;
                break;
            case NodeEffectType.StemRandomness:
                randomness = eff.effectValue;
                break;
            default:
                // Possibly ignore or handle other effect types here
                break;
        }
    }

    // Step B: Actually spawn the plant
    Vector2 spawnPos = gardener.GetPlantingPosition();
    GameObject plantObj = Instantiate(plantPrefab, spawnPos, Quaternion.identity);

    // Step C: Parent the plant using EcosystemManager
    if (EcosystemManager.Instance != null && EcosystemManager.Instance.plantParent != null)
    {
        if (EcosystemManager.Instance.sortPlantsBySpecies)
        {
            // For plants, assume a "Plant" subfolder
            Transform speciesParent = EcosystemManager.Instance.plantParent.Find("Plant");
            if (speciesParent == null)
            {
                GameObject subParent = new GameObject("Plant");
                subParent.transform.SetParent(EcosystemManager.Instance.plantParent);
                speciesParent = subParent.transform;
            }
            plantObj.transform.SetParent(speciesParent);
        }
        else
        {
            plantObj.transform.SetParent(EcosystemManager.Instance.plantParent);
        }
    }

    // Step D: Apply the BFS accumulations and effect data to PlantGrowth
    PlantGrowth growth = plantObj.GetComponent<PlantGrowth>();
    if (growth != null)
    {
        // Convert to int if needed
        growth.stemMinLength = Mathf.RoundToInt(minStem);
        growth.stemMaxLength = Mathf.RoundToInt(maxStem);
        growth.growthSpeed   = speed;
        growth.leafGap       = Mathf.RoundToInt(gap);
        growth.leafPattern   = Mathf.RoundToInt(pattern);
        
        // Our BFS accumulations: pass them in
        growth.growthRandomness = randomness;
        growth.maxEnergy        = accumulatedEnergyStorage;   // BFS sum from ProcessNode
        growth.basePhotosynthesis = accumulatedPhotosynthesis; // BFS sum from ProcessNode
    }
    else
    {
        LogDebug("[NodeExecutor] PlantGrowth missing on plantPrefab.");
    }

    // Step E: Reset BFS sums or continue to accumulate for multi-seed spawns
    // accumulatedEnergyStorage = 0f;
    // accumulatedPhotosynthesis = 0f;
}



    private void ClearDebug()
    {
        if (debugOutput)
            debugOutput.text = "";
    }

    private void LogDebug(string msg)
    {
        Debug.Log(msg);
        if (debugOutput)
            debugOutput.text += msg + "\n";
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes;

    public NodeGraph()
    {
        nodes = new List<NodeData>();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\ColorExtensions.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public static class ColorExtensions
{
    public static Color WithAlpha(this Color c, float alpha)
    {
        return new Color(c.r, c.g, c.b, alpha);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeEditorController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Linq;

public class NodeEditorController : MonoBehaviour, IScrollHandler, IDragHandler
{
    [Header("Window & Content Setup")]
    [SerializeField] private RectTransform windowRect; // Panel with RectMask2D
    [SerializeField] private RectTransform contentRect; // Panel that holds nodes

    [Header("Prefabs")]
    [SerializeField] private GameObject nodeViewPrefab; // Must have NodeView component

    [Header("Node Definitions")]
    [SerializeField] private NodeDefinitionLibrary definitionLibrary;

    [Header("Runtime Graph Reference")]
    [SerializeField] private NodeGraph currentGraph;
    
    [Header("Startup Settings")]
    [Tooltip("Should the node editor be visible when the game starts?")]
    
    [Header("Zoom and Panning")]
    [SerializeField] private float startingZoomMultiplier = 1f; // Default zoom at start
    [SerializeField] private float contentMargin = 20f;         // Margin around nodes

    public bool startVisible = true;
    private bool showContextMenu = false;
    private Vector2 contextMenuPosition;
    private List<NodeView> spawnedNodeViews = new List<NodeView>();
    private CanvasGroup canvasGroup;
    public RectTransform ContentRect => contentRect;


    private void Awake()
    {
        if (windowRect == null)
            windowRect = GetComponent<RectTransform>();

        canvasGroup = GetComponent<CanvasGroup>();
        if (canvasGroup == null)
            canvasGroup = gameObject.AddComponent<CanvasGroup>();

        Image bg = GetComponent<Image>();
        if (bg == null)
        {
            bg = gameObject.AddComponent<Image>();
            bg.color = new Color(1, 1, 1, 0);
            bg.raycastTarget = true;
        }
    }

    private void Start()
    {
        if (currentGraph == null)
            currentGraph = new NodeGraph();

        // Set initial zoom.
        contentRect.localScale = Vector3.one * startingZoomMultiplier;
        EnsureContentPanelSize();
    
        // Set initial visibility based on the flag
        if (!startVisible)
        {
            canvasGroup.alpha = 0;
            canvasGroup.interactable = false;
            canvasGroup.blocksRaycasts = false;
        }
    }

    private void Update()
    {
        // Hide context menu on left-click if outside.
        if (Input.GetMouseButtonDown(0))
        {
            if (showContextMenu && definitionLibrary != null && definitionLibrary.definitions != null)
            {
                Vector2 guiPos = new Vector2(contextMenuPosition.x, Screen.height - contextMenuPosition.y);
                float menuHeight = 20 + (definitionLibrary.definitions.Count * 25);
                Rect menuRect = new Rect(guiPos.x, guiPos.y, 180, menuHeight);

                Vector2 mousePos = Input.mousePosition;
                mousePos.y = Screen.height - mousePos.y;
                if (!menuRect.Contains(mousePos))
                    showContextMenu = false;
            }
        }
        if (Input.GetKeyDown(KeyCode.Tab))
            ToggleVisibility();
        if (Input.GetKeyDown(KeyCode.Delete))
        {
            if (NodeSelectable.CurrentSelected != null)
                DeleteSelectedNode();
        }
        if (Input.GetMouseButtonDown(1))
        {
            showContextMenu = true;
            contextMenuPosition = Input.mousePosition;
        }
    }

    private void ToggleVisibility()
    {
        if (canvasGroup.alpha > 0)
        {
            canvasGroup.alpha = 0;
            canvasGroup.interactable = false;
            canvasGroup.blocksRaycasts = false;
        }
        else
        {
            canvasGroup.alpha = 1;
            canvasGroup.interactable = true;
            canvasGroup.blocksRaycasts = true;
        }
    }

    private void OnGUI()
    {
        if (showContextMenu && definitionLibrary != null && definitionLibrary.definitions.Count > 0)
        {
            Vector2 guiPos = new Vector2(contextMenuPosition.x, Screen.height - contextMenuPosition.y);
            float menuHeight = 20 + (definitionLibrary.definitions.Count * 25);
            Rect menuRect = new Rect(guiPos.x, guiPos.y, 180, menuHeight);

            if (Event.current.type == EventType.MouseDown && Event.current.button == 0)
            {
                if (!menuRect.Contains(Event.current.mousePosition))
                    showContextMenu = false;
            }

            GUI.Box(menuRect, "Add Node");
            float yOffset = 20f;
            foreach (NodeDefinition def in definitionLibrary.definitions)
            {
                Rect itemRect = new Rect(menuRect.x, menuRect.y + yOffset, 180, 25);
                if (GUI.Button(itemRect, def.displayName))
                {
                    CreateNodeAtMouse(def);
                    showContextMenu = false;
                }
                yOffset += 25f;
            }
        }
    }

    
        private void CreateNodeAtMouse(NodeDefinition definition)
{
    // 1. Convert screen coords → local coords in contentRect
    Vector2 localPos;
    RectTransformUtility.ScreenPointToLocalPointInRectangle(
        contentRect, Input.mousePosition, null, out localPos);

    // 2. Convert local coords → hex coords (flat-top style)
    float hexSizeValue = (HexGridManager.Instance != null) 
        ? HexGridManager.Instance.hexSize 
        : 50f;

    // If your HexCoords.WorldToHex expects localPos to be the same coordinate space 
    // as used in your HexCoords logic, we can feed localPos directly:
    HexCoords hc = HexCoords.WorldToHex(localPos, hexSizeValue);

    // 3. Convert hex coords → local snapped coords
    Vector2 snappedLocal = hc.HexToWorld(hexSizeValue);

    // 4. Create the new node data
    NodeData newNode = new NodeData
    {
        nodeDisplayName = definition.displayName,
        backgroundColor = definition.backgroundColor,
        description = definition.description,
        coords = hc,
        editorPosition = snappedLocal // This is the local position inside contentRect
    };

    // Copy the definition’s effects & ports
    foreach (var defEffect in definition.effects)
    {
        NodeEffectData effectCopy = new NodeEffectData
        {
            effectType = defEffect.effectType,
            effectValue = defEffect.effectValue,
            secondaryValue = defEffect.secondaryValue,
            extra1 = defEffect.extra1,
            extra2 = defEffect.extra2,
            leafPattern = defEffect.leafPattern,         // NEW: copy leafPattern
            growthRandomness = defEffect.growthRandomness    // NEW: copy growthRandomness
        };
        newNode.effects.Add(effectCopy);
    }

    foreach (var portDef in definition.ports)
    {
        NodePort nodePort = new NodePort
        {
            isInput  = portDef.isInput,
            portType = portDef.portType,
            side     = portDef.side
        };
        newNode.ports.Add(nodePort);
    }

    // 5. Add node to graph and spawn the node view
    currentGraph.nodes.Add(newNode);
    CreateNodeView(newNode);
    EnsureContentPanelSize();
}




    public NodeView CreateNodeView(NodeData data)
    {
        if (nodeViewPrefab == null)
        {
            Debug.LogError("[NodeEditorController] nodeViewPrefab is not assigned!");
            return null;
        }
        GameObject nodeObj = Instantiate(nodeViewPrefab, contentRect);
        NodeView view = nodeObj.GetComponent<NodeView>();
        if (view == null)
        {
            Debug.LogError("[NodeEditorController] The instantiated node prefab does not have a NodeView component!");
            return null;
        }
        view.Initialize(data, data.backgroundColor, data.nodeDisplayName);
        RectTransform rt = nodeObj.GetComponent<RectTransform>();
        rt.anchoredPosition = data.editorPosition;
        view.GeneratePins(data.ports);

        // If node has an Output effect, attach the OutputNodeEffect script
        if (data.effects.Any(e => e.effectType == NodeEffectType.Output))
        {
            if (nodeObj.GetComponent<OutputNodeEffect>() == null)
                nodeObj.AddComponent<OutputNodeEffect>();
        }

        spawnedNodeViews.Add(view);
        return view;
    }


    private void DeleteSelectedNode()
    {
        NodeView selectedView = NodeSelectable.CurrentSelected.GetComponent<NodeView>();
        if (selectedView == null)
            return;
        string nodeId = selectedView.GetNodeData().nodeId;
        currentGraph.nodes.RemoveAll(n => n.nodeId == nodeId);
        Destroy(NodeSelectable.CurrentSelected);
        NodeSelectable.CurrentSelected = null;
    }

    public void OnScroll(PointerEventData eventData)
    {
        float scrollDelta = eventData.scrollDelta.y;
        float newScale = contentRect.localScale.x + scrollDelta * 0.05f;
        newScale = Mathf.Clamp(newScale, 0.5f, 2f);
        contentRect.localScale = Vector3.one * newScale;
        EnsureContentPanelSize();
    }

    public void OnDrag(PointerEventData eventData)
    {
        contentRect.anchoredPosition += eventData.delta;
        EnsureContentPanelSize();
    }

    private void EnsureContentPanelSize()
    {
        if (windowRect == null || contentRect == null)
            return;

        // Remove null entries from spawnedNodeViews
        spawnedNodeViews = spawnedNodeViews.Where(v => v != null).ToList();

        Vector2 windowSize = windowRect.rect.size;
        Vector2 minSize = windowSize + new Vector2(contentMargin * 2, contentMargin * 2);

        if (spawnedNodeViews.Count > 0)
        {
            Vector2 minPos = new Vector2(float.MaxValue, float.MaxValue);
            Vector2 maxPos = new Vector2(float.MinValue, float.MinValue);
            foreach (var view in spawnedNodeViews)
            {
                if (view == null)
                    continue;

                RectTransform rt = view.GetComponent<RectTransform>();
                Vector2 pos = rt.anchoredPosition;
                Vector2 size = rt.rect.size;
                minPos = Vector2.Min(minPos, pos - size * 0.5f);
                maxPos = Vector2.Max(maxPos, pos + size * 0.5f);
            }
            Vector2 bounds = maxPos - minPos;
            minSize = Vector2.Max(minSize, bounds + new Vector2(contentMargin * 2, contentMargin * 2));
        }

        Vector2 currSize = contentRect.sizeDelta;
        float newW = Mathf.Max(currSize.x, minSize.x);
        float newH = Mathf.Max(currSize.y, minSize.y);
        contentRect.sizeDelta = new Vector2(newW, newH);
    }


    public NodeGraph CurrentGraph => currentGraph;

    private void ClearExistingViews()
    {
        foreach (var view in spawnedNodeViews)
        {
            if (view != null)
                Destroy(view.gameObject);
        }
        spawnedNodeViews.Clear();
    }

    public void LoadGraph(NodeGraph graph)
    {
        currentGraph = graph;
        ClearExistingViews();
        if (currentGraph == null) return;
        foreach (var nd in currentGraph.nodes)
            CreateNodeView(nd);
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeHexDraggable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

public class NodeHexDraggable : MonoBehaviour, IPointerDownHandler, IDragHandler, IPointerUpHandler
{
    private RectTransform nodeRect;
    private RectTransform parentRect;
    private Vector2 pointerOffset;
    private NodeView nodeView;
    private float hexSize;

    private void Awake()
    {
        nodeRect = GetComponent<RectTransform>();
        parentRect = nodeRect.parent as RectTransform;
        nodeView = GetComponent<NodeView>();
        hexSize = (HexGridManager.Instance != null) ? HexGridManager.Instance.hexSize : 50f;
    }

    public void OnPointerDown(PointerEventData eventData)
    {
        Vector2 localPoint;
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRect, eventData.position, eventData.pressEventCamera, out localPoint))
        {
            pointerOffset = nodeRect.anchoredPosition - localPoint;
        }
        eventData.Use();
    }

    public void OnDrag(PointerEventData eventData)
    {
        Vector2 localPoint;
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRect, eventData.position, eventData.pressEventCamera, out localPoint))
        {
            nodeRect.anchoredPosition = localPoint + pointerOffset;
        }
        eventData.Use();
    }

    public void OnPointerUp(PointerEventData eventData)
    {
        Vector2 currentPos = nodeRect.anchoredPosition;
        float hexSizeValue = hexSize;
        HexCoords coords = HexCoords.WorldToHex(currentPos, hexSizeValue);
        Vector2 snappedPos = coords.HexToWorld(hexSizeValue);
        nodeRect.anchoredPosition = snappedPos;
        if (nodeView != null)
        {
            nodeView.GetNodeData().coords = coords;
            nodeView.GetNodeData().editorPosition = snappedPos;
        }
        eventData.Use();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeSelectable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class NodeSelectable : MonoBehaviour, IPointerClickHandler
{
    // Public static property to hold the currently selected node.
    public static GameObject CurrentSelected { get; set; }

    [SerializeField] private Outline outline;

    private void Awake()
    {
        if (outline != null)
            outline.enabled = false;
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        Select(gameObject);
    }

    public static void Select(GameObject node)
    {
        if (CurrentSelected != null && CurrentSelected != node)
        {
            // Disable outline on previously selected node.
            var prevOutline = CurrentSelected.GetComponent<Outline>();
            if (prevOutline != null)
                prevOutline.enabled = false;
        }
        CurrentSelected = node;
        var outlineComp = node.GetComponent<Outline>();
        if (outlineComp != null)
            outlineComp.enabled = true;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeTestInitializer.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class NodeTestInitializer : MonoBehaviour
{
    [SerializeField] private NodeEditorController editorController;
    [SerializeField] private NodeExecutor nodeExecutor;
    [SerializeField] private NodeDefinitionLibrary definitionLibrary; // Ensure this is assigned.

    private NodeGraph testGraph;

    private void Start()
    {
        // Create a new graph.
        testGraph = new NodeGraph();

        // Load the graph into the editor.
        if (editorController != null)
        {
            editorController.LoadGraph(testGraph);
        }
        else
        {
            Debug.LogWarning("[NodeTestInitializer] Missing NodeEditorController reference.");
        }

        // ============================
        // AUTO-SPAWN NODES FROM LIBRARY
        // ============================
        if (definitionLibrary != null && definitionLibrary.autoSpawnNodes != null)
        {
            foreach (var nodeDef in definitionLibrary.autoSpawnNodes)
            {
                // We use a simple offset logic: each node is placed 100 units to the right/down from the previous.
                Vector2 spawnPos = new Vector2(100 * testGraph.nodes.Count, 100 * testGraph.nodes.Count);

                // -----------------
                // CREATE THE NODE
                // -----------------
                NodeData newNode = new NodeData();
                newNode.nodeDisplayName = nodeDef.displayName;
                newNode.backgroundColor = nodeDef.backgroundColor;
                newNode.description = nodeDef.description;

                // Copy NodeDefinition effects => newNode.effects
                foreach (var defEffect in nodeDef.effects)
                {
                    NodeEffectData effectCopy = new NodeEffectData
                    {
                        effectType = defEffect.effectType,
                        effectValue = defEffect.effectValue,
                        secondaryValue = defEffect.secondaryValue,
                        extra1 = defEffect.extra1,
                        extra2 = defEffect.extra2
                    };
                    
                    // Add the effect to the node
                    newNode.effects.Add(effectCopy);
                }

                // Copy NodeDefinition ports => newNode.ports
                foreach (var portDef in nodeDef.ports)
                {
                    NodePort nodePort = new NodePort
                    {
                        isInput  = portDef.isInput,
                        portType = portDef.portType,
                        side     = portDef.side
                    };
                    newNode.ports.Add(nodePort);
                }

                // Snap position based on current contentRect from the editor.
                float hexSizeValue = (HexGridManager.Instance != null) 
                    ? HexGridManager.Instance.hexSize 
                    : 50f;

                // Adjust spawnPos relative to content center.
                Vector2 adjustedSpawn = spawnPos - editorController.ContentRect.rect.center;
                HexCoords hc = HexCoords.WorldToHex(adjustedSpawn, hexSizeValue);
                newNode.coords = hc;
                Vector2 snappedPos = hc.HexToWorld(hexSizeValue) + editorController.ContentRect.rect.center;
                newNode.editorPosition = snappedPos;

                // Add the newly created node to the graph.
                testGraph.nodes.Add(newNode);

                // Create the NodeView in the editor UI.
                editorController.CreateNodeView(newNode);
            }
        }
        else
        {
            Debug.LogWarning("[NodeTestInitializer] No autoSpawnNodes defined in NodeDefinitionLibrary.");
        }

        // Pass the same graph to the executor.
        if (nodeExecutor != null)
        {
            nodeExecutor.SetGraph(testGraph);
        }
        else
        {
            Debug.LogWarning("[NodeTestInitializer] Missing NodeExecutor reference.");
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeView.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;
using System.Linq;

public class NodeView : MonoBehaviour
{
    [Header("Text Components")]
    [SerializeField] private TMP_Text nodeTitleText;
    [SerializeField] private Image backgroundImage;

    [Header("Node Info Display")]
    [SerializeField] private TMP_Text manaStorageText;
    [SerializeField] private TMP_Text effectsText;
    [SerializeField] private TMP_Text descriptionText;

    [Header("Pins Settings")]
    [SerializeField] private float pinRadius = 60f; // Distance from node center to pin (auto-updated from HexGridManager if available)
    [SerializeField] private Transform pinContainer; // Parent container for spawned pins

    [Header("Pin Customization")]
    public Sprite manaPinSprite;
    public Color manaPinColor = Color.cyan;
    public Sprite conditionPinSprite;
    public Color conditionPinColor = new Color(1f, 0.65f, 0f);
    public Sprite generalPinSprite;
    public Color generalPinColor = Color.blue;
    [Tooltip("Uniform additional rotation (in degrees) applied to port sprites.")]
    public float portSpriteRotationOffset = 0f;

    [Header("Pin Scale Settings")]
    [Tooltip("General multiplier applied to all port sprites.")]
    public float portSpriteScaleMultiplier = 1.0f;
    [Tooltip("Multiplier for input port sprites.")]
    public float inputPortScaleMultiplier = 1.0f;
    [Tooltip("Multiplier for output port sprites.")]
    public float outputPortScaleMultiplier = 1.0f;

    private NodeData nodeData;

    private void Awake()
    {
        if (pinContainer == null)
            pinContainer = this.transform;
        if (HexGridManager.Instance != null)
            pinRadius = HexGridManager.Instance.hexSize * HexGridManager.Instance.pinRadiusMultiplier;
    }

    private void Update()
    {
        var manaEff = nodeData.effects.FirstOrDefault(e => e.effectType == NodeEffectType.ManaStorage);
        if (manaEff != null && manaStorageText != null)
        {
            float cap = Mathf.Floor(manaEff.effectValue);
            float cur = Mathf.Floor(manaEff.secondaryValue);
            manaStorageText.text = $"Mana: {cur}/{cap}";
        }
    }

    public void Initialize(NodeData data, Color color, string displayName)
    {
        nodeData = data;
        if (nodeTitleText)
            nodeTitleText.text = displayName;
        if (backgroundImage)
            backgroundImage.color = color;

        if (effectsText != null)
        {
            if (nodeData.effects.Count == 0)
                effectsText.text = "No Effects";
            else
            {
                string str = "";              //"Effects:\n";
                foreach (var eff in nodeData.effects)
                    str += $"- {eff.effectType} ({eff.effectValue})\n";
                effectsText.text = str;
            }
        }

        if (descriptionText != null)
            descriptionText.text = nodeData.description;

        var manaEff = nodeData.effects.FirstOrDefault(e => e.effectType == NodeEffectType.ManaStorage);
        if (manaEff != null && manaStorageText != null)
            manaStorageText.text = $"Mana: {manaEff.secondaryValue}/{manaEff.effectValue}";
    }

    // Generate pins for each port in the node.
    public void GeneratePins(List<NodePort> ports)
    {
        foreach (Transform child in pinContainer)
            Destroy(child.gameObject);
        foreach (var port in ports)
            CreatePin(port);
    }

    private void CreatePin(NodePort port)
    {
        GameObject pinObj = new GameObject(port.isInput ? "InputPin" : "OutputPin", typeof(RectTransform));
        pinObj.transform.SetParent(pinContainer, false);
        RectTransform rt = pinObj.GetComponent<RectTransform>();

        // Calculate scale multiplier based on port type.
        float scaleMultiplier = portSpriteScaleMultiplier * (port.isInput ? inputPortScaleMultiplier : outputPortScaleMultiplier);
        rt.sizeDelta = new Vector2(20, 20) * scaleMultiplier;

        // For flat-top hexagons, pins should be centered on each side.
        // Mapping: Top = 90°, One = 30°, Two = -30°, Three = -90°, Four = -150°, Five = -210°.
        int sideIndex = (int)port.side; // Top=0, One=1, ..., Five=5.
        float posAngle = 90f - sideIndex * 60f; // This yields: Top:90, One:30, Two:-30, Three:-90, Four:-150, Five:-210.
        float posRad = posAngle * Mathf.Deg2Rad;
        float x = pinRadius * Mathf.Cos(posRad);
        float y = pinRadius * Mathf.Sin(posRad);
        rt.anchoredPosition = new Vector2(x, y);

        // Set sprite rotation: for outputs, arrow points out; for inputs, arrow points in (add 180°).
        float spriteAngle = posAngle;
        if (port.isInput)
            spriteAngle += 180f;
        spriteAngle += portSpriteRotationOffset;
        rt.localRotation = Quaternion.Euler(0, 0, spriteAngle);

        Image img = pinObj.AddComponent<Image>();
        switch (port.portType)
        {
            case PortType.Mana:
                img.sprite = manaPinSprite;
                img.color = manaPinColor;
                break;
            case PortType.Condition:
                img.sprite = conditionPinSprite;
                img.color = conditionPinColor;
                break;
            default:
                img.sprite = generalPinSprite;
                img.color = generalPinColor;
                break;
        }
        img.type = Image.Type.Simple;
        img.preserveAspect = true;
    }

    public NodeData GetNodeData() => nodeData;
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Player\GardenerController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class GardenerController : MonoBehaviour
{
    [Header("Movement Settings")]
    public float moveSpeed = 5f;
    
    [Header("Planting Settings")]
    public Vector2 seedPlantingOffset = new Vector2(0f, -0.5f); // Configurable offset for seed planting

    [Header("Visual Settings")]
    [Tooltip("If true, the sprite will be flipped when moving left")]
    public bool flipSpriteWhenMovingLeft = true;
    [Tooltip("If true, the character will face the opposite direction when flipped")]
    public bool flipHorizontalDirection = true;

    [Header("Animation Settings")]
    [Tooltip("Set to false to disable animations")]
    public bool useAnimations = true;
    public string runningParameterName = "isRunning";
    public string plantingParameterName = "isPlanting";
    [Tooltip("Should match your planting animation length exactly")]
    public float plantingDuration = 0.25f; // UPDATED to match your 0.25s animation


    
    // Private references
    private Rigidbody2D rb;
    private Vector2 movement;
    private SortableEntity sortableEntity;
    private SpriteRenderer spriteRenderer;
    private Animator animator;
    // Private variables
    private bool isPlanting = false;
    private float plantingTimer = 0f;
    private bool wasMovingBeforePlanting = false;

    private void Awake()
    {
        // Get required components
        rb = GetComponent<Rigidbody2D>();
        sortableEntity = GetComponent<SortableEntity>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        animator = GetComponent<Animator>();
        
        // Add SortableEntity if not already present
        if (sortableEntity == null)
            sortableEntity = gameObject.AddComponent<SortableEntity>();
            
        // Warn if sprite renderer is missing
        if (spriteRenderer == null)
            Debug.LogWarning("GardenerController: SpriteRenderer component not found. Sprite flipping won't work.");
            
        // Warn if animator is missing but animations are enabled
        if (animator == null && useAnimations)
            Debug.LogWarning("GardenerController: Animator component not found but useAnimations is true.");
    }

    private void Update()
    {
        // Handle movement input and planting action
        if (!isPlanting)
        {
            movement.x = Input.GetAxisRaw("Horizontal");
            movement.y = Input.GetAxisRaw("Vertical");
        
            // Check if we're moving (store for later)
            bool isMoving = movement.sqrMagnitude > 0.01f;
        
            // Handle planting action
            if (Input.GetKeyDown(KeyCode.Space))
            {
                // Store movement state before planting
                wasMovingBeforePlanting = isMoving;
                StartPlantingAnimation();
            }
        }
        else
        {
            // When planting, we don't accept movement input
            movement = Vector2.zero;
        
            // Handle planting timer
            plantingTimer -= Time.deltaTime;
            if (plantingTimer <= 0)
            {
                EndPlantingAnimation();
            }
        }
    
        // Update animations after all state changes are processed
        UpdateAnimations();
    
        // Handle sprite flipping based on movement direction
        UpdateSpriteDirection();
    }

    private void FixedUpdate()
    {
        // Only move if not planting
        if (!isPlanting)
        {
            rb.MovePosition(rb.position + movement.normalized * moveSpeed * Time.fixedDeltaTime);
        }
    }
    
    // Update character animations based on state
    private void UpdateAnimations()
    {
        if (!useAnimations || animator == null) return;
    
        // Set running animation parameter
        bool isMoving = movement.sqrMagnitude > 0.01f;
        animator.SetBool(runningParameterName, isMoving);
    }
    
    // Update sprite direction based on movement
    private void UpdateSpriteDirection()
    {
        if (spriteRenderer == null || !flipSpriteWhenMovingLeft) return;
        
        if (movement.x != 0)
        {
            // Only flip if moving horizontally
            bool shouldFlip = (movement.x < 0);
            
            // Apply flipping logic based on settings
            if (flipHorizontalDirection)
            {
                spriteRenderer.flipX = shouldFlip;
            }
            else
            {
                // Alternative approach: flip the entire transform
                // This is useful if the sprite is already facing left initially
                Vector3 scale = transform.localScale;
                scale.x = shouldFlip ? -Mathf.Abs(scale.x) : Mathf.Abs(scale.x);
                transform.localScale = scale;
            }
        }
    }
    
    // Start planting animation and process
    public void StartPlantingAnimation()
    {
        if (!useAnimations || isPlanting) return;
    
        isPlanting = true;
        plantingTimer = plantingDuration;
    
        // Set animation parameters
        if (animator != null)
        {
            // Set planting to true and ensure running is false
            animator.SetBool(plantingParameterName, true);
            animator.SetBool(runningParameterName, false);
        }
    }
    
    // End planting animation and resume normal control
    
    private void EndPlantingAnimation()
    {
        // Reset planting state
        isPlanting = false;
    
        // Reset animation parameters
        if (animator != null)
        {
            animator.SetBool(plantingParameterName, false);
        
            // Important: don't immediately set isRunning based on current movement
            // because movement is zero during planting. Instead:
            if (wasMovingBeforePlanting && (Input.GetAxisRaw("Horizontal") != 0 || Input.GetAxisRaw("Vertical") != 0))
            {
                // Only resume running if we were running before AND still have directional input
                animator.SetBool(runningParameterName, true);
            }
        }
    
        // Now update movement based on current input
        movement.x = Input.GetAxisRaw("Horizontal");
        movement.y = Input.GetAxisRaw("Vertical");
    }
    
    // Returns the position used for planting seeds, now with configurable offset
    public Vector2 GetPlantingPosition()
    {
        return (Vector2)transform.position + seedPlantingOffset;
    }
    
    // Public method to set planting animation duration
    public void SetPlantingDuration(float duration)
    {
        plantingDuration = Mathf.Max(0.1f, duration); // Ensure minimum duration
    }
    
    // Public method to trigger planting animation from other scripts
    public void Plant()
    {
        StartPlantingAnimation();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\NightColorPostProcess.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class NightColorPostProcess : MonoBehaviour
{
    [Header("References")]
    public WeatherManager weatherManager;        // Assign your existing WeatherManager
    public Volume globalVolume;                  // The Volume with the Color Adjustments override

    private ColorAdjustments colorAdjustments;   // We'll read/write color filter, post exposure, and saturation

    [Header("Color Settings")]
    [Tooltip("The color filter at full day (sunIntensity = 1).")]
    public Color dayColorFilter = Color.white;
    [Tooltip("The color filter at full night (sunIntensity ~ 0).")]
    public Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);

    [Tooltip("Daytime Post-Exposure (e.g. 0). Higher = brighter.")]
    public float dayPostExposure = 0f;
    [Tooltip("Nighttime Post-Exposure (e.g. -0.5). Lower = darker.")]
    public float nightPostExposure = -0.5f;

    [Header("Saturation Settings")]
    [Tooltip("Saturation at full day (0 means no change).")]
    public float daySaturation = 0f;
    [Tooltip("Saturation at full night (e.g. -50 for more desaturation at night).")]
    public float nightSaturation = -50f;

    private void Start()
    {
        if (!globalVolume)
        {
            Debug.LogWarning("[NightColorPostProcess] No globalVolume assigned!");
            return;
        }

        // Try to get the ColorAdjustments override from the volume's profile
        if (globalVolume.profile.TryGet<ColorAdjustments>(out var colorAdj))
        {
            colorAdjustments = colorAdj;
        }
        else
        {
            Debug.LogWarning("[NightColorPostProcess] No ColorAdjustments override found in the Volume profile!");
        }
    }

    private void Update()
    {
        if (!weatherManager || colorAdjustments == null)
            return;
        
        // Get the sun intensity (0 = night, 1 = day)
        float sun = Mathf.Clamp01(weatherManager.sunIntensity);
        float t = 1f - sun;  // t=0 at day, t=1 at night
        
        // Lerp the color filter
        Color finalFilter = Color.Lerp(dayColorFilter, nightColorFilter, t);
        colorAdjustments.colorFilter.value = finalFilter;
        
        // Lerp post exposure
        float finalExposure = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
        colorAdjustments.postExposure.value = finalExposure;
        
        // Lerp saturation
        float finalSaturation = Mathf.Lerp(daySaturation, nightSaturation, t);
        colorAdjustments.saturation.value = finalSaturation;
    }
}



