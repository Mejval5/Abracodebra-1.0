This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-03-25 00:47:25
================================================================================

DIRECTORY STRUCTURE
--------------------------------------------------------------------------------
Assets
├── DefaultVolumeProfile.asset
├── Editor
│   ├── HexGridRendererEditor.cs
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   ├── NodeEffectDataDrawer.cs
│   └── WizardControllerStatusEditor.cs
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
├── Prefabs
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   ├── PixelLeaf.prefab
│   │   ├── PixelSeed.prefab
│   │   ├── PixelStem.prefab
│   │   ├── PlantPrefab.prefab
│   │   ├── Projectile_Basic_Pixel.prefab
│   │   └── WizardPrefab.prefab
│   ├── Node Presets
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_AimSpread.asset
│   │   ├── Node_002_Piercing.asset
│   │   ├── Node_003_Output.asset
│   │   ├── Node_004_ManaSource.asset
│   │   ├── Node_005_DamageNode.asset
│   │   ├── Node_006_Burn.asset
│   │   └── Node_007_FriendlyFire.asset
│   ├── UI
│   │   └── NodeView.prefab
│   └── Wizard Presets
│       ├── Wizard_Basic.asset
│       └── Wizard_Dummy.asset
├── Scenes
│   ├── MainScene.unity
│   └── SampleScene.unity
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── HexCoords.cs
│   │   │   ├── HexGridManager.cs
│   │   │   ├── HexGridRenderer.cs
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   ├── NodePort.cs
│   │   │   ├── OutputNodeEffect.cs
│   │   │   └── PortDefinition.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── NodeEditorController.cs
│   │       ├── NodeHexDraggable.cs
│   │       ├── NodeSelectable.cs
│   │       ├── NodeTestInitializer.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── UI
│   └── Wizards
│       ├── WizardController.cs
│       └── WizardPreset.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Test
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\HexGridRendererEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(HexGridRenderer))]
public class HexGridRendererEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            HexGridRenderer grid = (HexGridRenderer)target;
            grid.SetVerticesDirty();
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionAutoAdder.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionAutoAdder : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets,
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string folderPath = Path.GetDirectoryName(assetPath);
                string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
                if (libraryFiles.Length > 0)
                {
                    NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
                    if (library != null && !library.definitions.Contains(nodeDef))
                    {
                        library.definitions.Add(nodeDef);
                        EditorUtility.SetDirty(library);
                        AssetDatabase.SaveAssets();
                    }
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionCreator.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;

public static class NodeDefinitionCreator
{
    private const string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

    [MenuItem(MenuPath, false, 50)]
    public static void CreateNodeDefinition()
    {
        // Figure out which folder the user is in, or use Assets/
        string folder = GetSelectedPathOrFallback();

        // Determine the next numeric index for "Node_XXX_"
        int nextNumber = GetNextNodeNumber(folder);

        // e.g., "Node_007_"
        string newName = $"Node_{nextNumber:D3}_";
        string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

        // Create the NodeDefinition
        NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
        AssetDatabase.CreateAsset(nodeDef, newPath);
        
        // Save and refresh, but DO NOT select or focus the ProjectWindow.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        Debug.Log($"Created NodeDefinition at: {newPath}");
        // Notice we don't call Selection.activeObject = nodeDef
        // or EditorUtility.FocusProjectWindow()
        // or ProjectWindowUtil.ShowCreatedAsset(nodeDef)
        // thus we avoid changing the user's folder.
    }

    // (Optional) Validate the menu item so it’s disabled if the game is running
    [MenuItem(MenuPath, true)]
    private static bool ValidateCreateNodeDefinition()
    {
        return !Application.isPlaying;
    }

    private static string GetSelectedPathOrFallback()
    {
        // Attempt to get the folder the user has selected in the Project window
        string path = "Assets";
        foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets))
        {
            path = AssetDatabase.GetAssetPath(obj);
            if (!string.IsNullOrEmpty(path))
            {
                // If it's a file, get its parent folder
                if (File.Exists(path))
                {
                    path = Path.GetDirectoryName(path);
                }
                break;
            }
        }
        return path;
    }

    private static int GetNextNodeNumber(string folderPath)
    {
        int nextNumber = 1;
        // Look for existing Node_XXX_ files
        string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
        foreach (var file in files)
        {
            string fName = Path.GetFileNameWithoutExtension(file);
            if (fName.StartsWith("Node_") && fName.Length >= 8)
            {
                // extract the 3-digit number from Node_000_
                string numberPart = fName.Substring(5, 3);
                if (int.TryParse(numberPart, out int num) && num >= nextNumber)
                {
                    nextNumber = num + 1;
                }
            }
        }
        return nextNumber;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionLibraryEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;

[CustomEditor(typeof(NodeDefinitionLibrary))]
public class NodeDefinitionLibraryEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            UpdateLibrary();
        }
    }

    private void UpdateLibrary()
    {
        NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

        // Get the folder of the current library asset.
        string libraryPath = AssetDatabase.GetAssetPath(library);
        string folderPath = Path.GetDirectoryName(libraryPath);

        // Find all .asset files in the folder.
        string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

        // Load NodeDefinition assets from that folder.
        List<NodeDefinition> defs = new List<NodeDefinition>();
        foreach (string file in assetFiles)
        {
            // Ignore the library asset itself.
            if (file == libraryPath)
                continue;

            NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
            if (def != null)
                defs.Add(def);
        }

        // Sort definitions by the numeric portion in the file name (assumes "Node_XXX_...").
        defs = defs.OrderBy(d => {
            string name = d.name;
            if (name.StartsWith("Node_") && name.Length >= 8)
            {
                string numStr = name.Substring(5, 3);
                if (int.TryParse(numStr, out int num))
                    return num;
            }
            return int.MaxValue; // if no number is found, sort last.
        }).ToList();

        library.definitions = defs;
        EditorUtility.SetDirty(library);
        AssetDatabase.SaveAssets();
        Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionPostprocessor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionPostprocessor : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, 
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string fileName = Path.GetFileNameWithoutExtension(assetPath);
                // Check if file name already starts with "Node_"
                if (!fileName.StartsWith("Node_"))
                {
                    string folderPath = Path.GetDirectoryName(assetPath);
                    // Get all files in folder that start with "Node_"
                    var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
                    int nextNumber = 1;
                    foreach (var file in files)
                    {
                        string fName = Path.GetFileNameWithoutExtension(file);
                        string[] parts = fName.Split('_');
                        if (parts.Length >= 2 && int.TryParse(parts[1], out int num))
                        {
                            if (num >= nextNumber)
                                nextNumber = num + 1;
                        }
                    }
                    string newName = $"Node_{nextNumber:D3}_";
                    AssetDatabase.RenameAsset(assetPath, newName);
                    AssetDatabase.SaveAssets();
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeEffectDataDrawer.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;

[CustomPropertyDrawer(typeof(NodeEffectData))]
public class NodeEffectDataDrawer : PropertyDrawer
{
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        SerializedProperty typeProp        = property.FindPropertyRelative("effectType");
        SerializedProperty valueProp       = property.FindPropertyRelative("effectValue");
        SerializedProperty secondaryProp   = property.FindPropertyRelative("secondaryValue");
        SerializedProperty extra1Prop      = property.FindPropertyRelative("extra1");
        SerializedProperty extra2Prop      = property.FindPropertyRelative("extra2");

        // New ones.
        SerializedProperty leafPatternProp      = property.FindPropertyRelative("leafPattern");
        SerializedProperty growthRandomnessProp = property.FindPropertyRelative("growthRandomness");

        // Draw effectType
        Rect typeRect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);
        EditorGUI.PropertyField(typeRect, typeProp, new GUIContent("Effect Type"));
        NodeEffectType effectType = (NodeEffectType)typeProp.enumValueIndex;
        float yOffset = typeRect.yMax + EditorGUIUtility.standardVerticalSpacing;

        Rect NextLineRect()
        {
            Rect r = new Rect(position.x, yOffset, position.width, EditorGUIUtility.singleLineHeight);
            yOffset += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;
            return r;
        }

        // Draw fields based on effectType
        switch (effectType)
        {
            case NodeEffectType.ManaCost:
            {
                GUIContent content = new GUIContent("Mana Cost", "Amount of mana required to process this node.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.Damage:
            {
                GUIContent content = new GUIContent("Damage", "Damage value contributed by this node.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.Output:
            {
                GUIContent content = new GUIContent("Output", "This node outputs the final chain result (no parameters).");
                Rect line = NextLineRect();
                EditorGUI.LabelField(line, content);
                break;
            }
            case NodeEffectType.Burning:
            {
                // Fire DPS in value, Duration in secondaryValue
                GUIContent contentDps = new GUIContent("Fire DPS", "Damage per second of burning.");
                Rect line1 = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line1, contentDps, valueProp.floatValue);

                GUIContent contentDur = new GUIContent("Duration", "Duration (seconds) of burning effect.");
                Rect line2 = NextLineRect();
                secondaryProp.floatValue = EditorGUI.FloatField(line2, contentDur, secondaryProp.floatValue);
                break;
            }
            case NodeEffectType.AimSpread:
            {
                GUIContent content = new GUIContent("Aim Spread Modifier", "Modifier to add to the wizard's base aim spread.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.Piercing:
            {
                GUIContent content = new GUIContent("Piercing", "Set to 1 for piercing, 0 otherwise.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.FriendlyFire:
            {
                GUIContent content = new GUIContent("Friendly Fire", "Set to 1 for friendly fire, 0 for none.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.Seed:
            {
                // Min stem length
                var line1 = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line1,
                    new GUIContent("Min Stem Length", ""), valueProp.floatValue);

                // Max stem length
                var line2 = NextLineRect();
                secondaryProp.floatValue = EditorGUI.FloatField(line2,
                    new GUIContent("Max Stem Length", ""), secondaryProp.floatValue);

                // Growth speed
                var line3 = NextLineRect();
                extra1Prop.floatValue = EditorGUI.FloatField(line3,
                    new GUIContent("Growth Speed (sec)", ""), extra1Prop.floatValue);

                // Leaf gap
                var line4 = NextLineRect();
                extra2Prop.floatValue = EditorGUI.FloatField(line4,
                    new GUIContent("Leaf Gap", ""), extra2Prop.floatValue);

                // Leaf Pattern => 0=Parallel, 1=Alternating
                var line5 = NextLineRect();
                leafPatternProp.intValue = EditorGUI.IntSlider(line5,
                    new GUIContent("Leaf Pattern", "(0=parallel,1=alt)"), leafPatternProp.intValue, 0, 1);

                // Growth Randomness => [0..2]
                var line6 = NextLineRect();
                growthRandomnessProp.floatValue = EditorGUI.Slider(line6,
                    new GUIContent("Growth Randomness", "0=straight, 0.5=random, 0.5=always diagonal"), growthRandomnessProp.floatValue, 0f, 1f);
                break;
            }
            default:
            {
                // Fallback for unrecognized effect
                GUIContent content = new GUIContent("Value", "");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
        }
    }

    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
    {
        SerializedProperty typeProp = property.FindPropertyRelative("effectType");
        NodeEffectType effectType = (NodeEffectType)typeProp.enumValueIndex;

        float lineHeight = EditorGUIUtility.singleLineHeight;
        float spacing = EditorGUIUtility.standardVerticalSpacing;

        // Start with 1 line for the effectType + spacing
        float totalHeight = lineHeight + spacing;

        switch (effectType)
        {
            case NodeEffectType.ManaCost:
            case NodeEffectType.Damage:
            case NodeEffectType.AimSpread:
            case NodeEffectType.Piercing:
            case NodeEffectType.FriendlyFire:
                // +1 line
                totalHeight += (lineHeight + spacing);
                break;

            case NodeEffectType.Output:
                // +1 line
                totalHeight += (lineHeight + spacing);
                break;

            case NodeEffectType.Burning:
                // +2 lines
                totalHeight += (lineHeight + spacing) * 2;
                break;

            case NodeEffectType.Seed:
                // min length + max length + growth speed + leaf gap + leaf pattern + randomness => 6 lines
                totalHeight += (lineHeight + spacing) * 6;
                break;

            default:
                // fallback +1 line
                totalHeight += (lineHeight + spacing);
                break;
        }
        return totalHeight;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\WizardControllerStatusEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(WizardController))]
public class WizardControllerStatusEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        WizardController wizard = (WizardController)target;
        EditorGUILayout.Space();
        EditorGUILayout.LabelField("Active Status Effects", EditorStyles.boldLabel);
        if (wizard.activeStatusEffects != null && wizard.activeStatusEffects.Count > 0)
        {
            foreach (var effect in wizard.activeStatusEffects)
            {
                EditorGUILayout.LabelField($"{effect.GetType().Name}: {effect.damagePerSecond} DPS, {effect.duration - effect.Elapsed:F1}s remaining");
            }
        }
        else
        {
            EditorGUILayout.LabelField("None");
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro;

public enum PlantCellType
{
    Seed,
    Stem,
    Leaf,
    Flower,
    Fruit
}

public class PlantGrowth : MonoBehaviour
{
    [Header("Seed Gene Parameters (set via Seed node effect)")]
    public int stemMinLength = 3;            // Minimum stem length (cells)
    public int stemMaxLength = 6;            // Maximum stem length (cells)
    public float growthSpeed = 1f;           // Seconds per growth step
    [Tooltip("Leaf Gap: 0 = leaves on every stem cell; 1 = leaves on every 2nd stem cell; etc.")]
    public int leafGap = 1;
    public int leafPattern = 0;              // 0 = Parallel, 1 = Alternating
    public float growthRandomness = 0f;      // [0..1]: 0=always up; 1=always diagonal

    [Header("Energy System")]
    [Tooltip("Max energy available from all Energy Storage nodes in BFS.")]
    public float maxEnergy = 0f;
    [Tooltip("Current energy accumulated.")]
    public float currentEnergy = 0f;
    [Tooltip("Base photosynthesis rate from Energy Photosynthesis nodes in BFS.")]
    public float basePhotosynthesis = 0f;

    [Header("Cell Prefabs")]
    public GameObject seedCellPrefab;
    public GameObject stemCellPrefab;
    public GameObject leafCellPrefab;

    [Header("Cell Grid Settings")]
    [Tooltip("Distance (in game units) between adjacent cells.")]
    public float cellSpacing = 8f; 

    [Header("UI")]
    [Tooltip("TextMeshProUGUI displaying current energy and max energy below the plant.")]
    public TMP_Text energyText;

    private Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
    private bool growing = true;
    private int currentStemCount = 0;
    private int targetStemLength = 0;
    private bool leftSideNext = true;

    private void Start()
    {
        targetStemLength = Random.Range(stemMinLength, stemMaxLength + 1);
        Debug.Log($"[PlantGrowth] Target stem length: {targetStemLength}");

        cells[new Vector2Int(0, 0)] = PlantCellType.Seed;
        SpawnCellVisual(PlantCellType.Seed, new Vector2Int(0, 0));

        StartCoroutine(GrowRoutine());
    }

    private void Update()
    {
        // Use sunIntensity from WeatherManager.
        float sunlight = (WeatherManager.Instance != null) ? WeatherManager.Instance.sunIntensity : 1f;
        float leafCount = cells.Values.Count(cell => cell == PlantCellType.Leaf);
        float deltaPhotosynthesis = basePhotosynthesis * leafCount * sunlight * Time.deltaTime;
        currentEnergy += deltaPhotosynthesis;
        if (currentEnergy > maxEnergy)
            currentEnergy = maxEnergy;

        if (energyText != null)
        {
            energyText.text = $"Energy: {Mathf.Floor(currentEnergy)}/{Mathf.Floor(maxEnergy)}";
            // Positioning remains as set in the prefab.
        }
    }

    private IEnumerator GrowRoutine()
    {
        Vector2Int currentPos = new Vector2Int(0, 0);
        while (growing)
        {
            yield return new WaitForSeconds(growthSpeed);

            if (currentStemCount < targetStemLength)
            {
                currentStemCount++;
                Vector2Int dir;
                if (currentStemCount == 1)
                {
                    // Always grow directly up for the first stem cell.
                    dir = new Vector2Int(0, 1);
                }
                else
                {
                    dir = GetStemDirection();
                }
                currentPos += dir;
                cells[currentPos] = PlantCellType.Stem;
                SpawnCellVisual(PlantCellType.Stem, currentPos);
                Debug.Log($"[PlantGrowth] Stem grown at {currentPos}");

                if ((currentStemCount % (leafGap + 1)) == 0)
                {
                    Vector2Int baseLeftPos = currentPos + new Vector2Int(-1, 0);
                    Vector2Int baseRightPos = currentPos + new Vector2Int(1, 0);

                    if (leafPattern == 0) // Parallel: spawn both leaves.
                    {
                        SpawnLeafIfEmpty(baseLeftPos);
                        SpawnLeafIfEmpty(baseRightPos);
                        Debug.Log($"[PlantGrowth] Parallel leaves at {baseLeftPos} and {baseRightPos}");
                    }
                    else // Alternating: spawn both but with one side offset.
                    {
                        if (leftSideNext)
                        {
                            Vector2Int leftAlt = baseLeftPos + new Vector2Int(0, 1);
                            SpawnLeafIfEmpty(leftAlt);
                            SpawnLeafIfEmpty(baseRightPos);
                            Debug.Log($"[PlantGrowth] Alternating leaves at {leftAlt} (offset) and {baseRightPos}");
                        }
                        else
                        {
                            Vector2Int rightAlt = baseRightPos + new Vector2Int(0, 1);
                            SpawnLeafIfEmpty(baseLeftPos);
                            SpawnLeafIfEmpty(rightAlt);
                            Debug.Log($"[PlantGrowth] Alternating leaves at {baseLeftPos} and {rightAlt} (offset)");
                        }
                        leftSideNext = !leftSideNext;
                    }
                }
            }
            else
            {
                growing = false;
                Debug.Log("[PlantGrowth] Growth complete.");
            }
        }
    }

    private Vector2Int GetStemDirection()
    {
        Vector2Int up = new Vector2Int(0, 1);
        Vector2Int leftDiag = new Vector2Int(-1, 1);
        Vector2Int rightDiag = new Vector2Int(1, 1);

        float r = Mathf.Clamp01(growthRandomness);
        float roll = Random.value;
        float threshold = 1f - r;  
        if (roll < threshold)
            return up;
        else
            return (Random.value < 0.5f) ? leftDiag : rightDiag;
    }

    private void SpawnLeafIfEmpty(Vector2Int coords)
    {
        if (!cells.ContainsKey(coords))
        {
            cells[coords] = PlantCellType.Leaf;
            SpawnCellVisual(PlantCellType.Leaf, coords);
        }
    }

    private void SpawnCellVisual(PlantCellType cellType, Vector2Int coords)
    {
        Vector2 worldPos = (Vector2)transform.position + (Vector2)coords * cellSpacing;
        GameObject prefabToUse = null;
        switch (cellType)
        {
            case PlantCellType.Seed:
                prefabToUse = seedCellPrefab;
                break;
            case PlantCellType.Stem:
                prefabToUse = stemCellPrefab;
                break;
            case PlantCellType.Leaf:
                prefabToUse = leafCellPrefab;
                break;
        }
        if (prefabToUse != null)
        {
            Instantiate(prefabToUse, worldPos, Quaternion.identity, transform);
        }
        else
        {
            Debug.LogWarning($"[PlantGrowth] No prefab assigned for cell type {cellType}");
        }
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\WeatherManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class WeatherManager : MonoBehaviour
{
    public static WeatherManager Instance { get; private set; }

    [Header("Sunlight Settings")]
    [Tooltip("Global sunlight intensity in [0..1]. This affects plant photosynthesis.")]
    [Range(0f, 1f)]
    public float sunIntensity = 1f;

    [Header("Sunlight Visualization")]
    [Tooltip("Sprite whose opacity changes with sunIntensity.")]
    public SpriteRenderer fadeSprite;
    [Tooltip("Minimum alpha when sunIntensity = 0.")]
    public float minAlpha = 0f;
    [Tooltip("Maximum alpha when sunIntensity = 1.")]
    public float maxAlpha = 1f;

    private void Awake()
    {
        // Set up singleton instance.
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    private void Update()
    {
        if (fadeSprite != null)
        {
            float alpha = Mathf.Lerp(minAlpha, maxAlpha, sunIntensity);
            Color c = fadeSprite.color;
            c.a = alpha;
            fadeSprite.color = c;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\SpellProjectile.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SpellProjectile : MonoBehaviour
{
    [Header("Projectile Stats")]
    public float damage;
    public float speed;
    [Tooltip("If true, the projectile will be destroyed upon hitting a wizard.")]
    public bool destroyOnHit = true;

    [Header("Burning Effect (optional)")]
    public float burningDamage;   // DPS
    public float burningDuration; // Duration in seconds

    [Header("Friendly Fire")]
    public bool friendlyFire = false;
    public bool casterIsEnemy = false;

    public void Initialize(float dmg, float spd)
    {
        damage = dmg;
        speed = spd;
    }

    private void Update()
    {
        transform.Translate(Vector2.up * speed * Time.deltaTime);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        WizardController wizard = collision.GetComponent<WizardController>();
        if (wizard != null)
        {
            // If friendly fire is disabled and the hit wizard is on the same team, ignore.
            if (!friendlyFire && wizard.isEnemy == casterIsEnemy)
                return;

            wizard.TakeDamage(damage);
            if (burningDamage > 0 && burningDuration > 0)
            {
                wizard.ApplyStatusEffect(new BurningStatusEffect(burningDuration, burningDamage));
            }
            if (destroyOnHit)
                Destroy(gameObject);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\BurningStatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public class BurningStatusEffect : StatusEffect
{
    public BurningStatusEffect(float d, float dps) : base(d, dps) { }

    public override void UpdateEffect(WizardController wizard, float deltaTime)
    {
        elapsed += deltaTime;
        wizard.TakeDamage(damagePerSecond * deltaTime);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\StatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public abstract class StatusEffect
{
    public float duration; // Total duration.
    public float damagePerSecond;
    protected float elapsed = 0f;

    // Public property to expose elapsed time.
    public float Elapsed { get { return elapsed; } }

    public StatusEffect(float d, float dps)
    {
        duration = d;
        damagePerSecond = dps;
    }

    public abstract void UpdateEffect(WizardController wizard, float deltaTime);
    public bool IsExpired() => elapsed >= duration;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\HexCoords.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[System.Serializable]
public struct HexCoords
{
    public int q; // axial coordinate (column)
    public int r; // axial coordinate (row)

    public HexCoords(int q, int r)
    {
        this.q = q;
        this.r = r;
    }

    // Flat top conversion from axial to world coordinates.
    // Using the formula:
    // x = hexSize * (3/2 * q)
    // y = hexSize * ( (sqrt(3)/2 * q) + (sqrt(3) * r) )
    public Vector2 HexToWorld(float hexSize)
    {
        float x = hexSize * (3f / 2f * q);
        float y = hexSize * ((Mathf.Sqrt(3f) / 2f * q) + (Mathf.Sqrt(3f) * r));
        return new Vector2(x, y);
    }

    // Converts a world (UI) position to axial coordinates.
    // Inverse formulas:
    // q = (2/3 * x)/hexSize
    // r = ((-1/3 * x) + (sqrt(3)/3 * y)) / hexSize
    public static HexCoords WorldToHex(Vector2 pos, float hexSize)
    {
        float qf = (2f / 3f * pos.x) / hexSize;
        float rf = ((-1f / 3f * pos.x) + (Mathf.Sqrt(3f) / 3f * pos.y)) / hexSize;
        return RoundAxial(qf, rf);
    }

    public static HexCoords RoundAxial(float qf, float rf)
    {
        float sf = -qf - rf;
        int qi = Mathf.RoundToInt(qf);
        int ri = Mathf.RoundToInt(rf);
        int si = Mathf.RoundToInt(sf);

        float qDiff = Mathf.Abs(qi - qf);
        float rDiff = Mathf.Abs(ri - rf);
        float sDiff = Mathf.Abs(si - sf);

        if (qDiff > rDiff && qDiff > sDiff)
            qi = -ri - si;
        else if (rDiff > sDiff)
            ri = -qi - si;
        return new HexCoords(qi, ri);
    }

    // Fixed neighbor offsets (axial) for flat top grid.
    private static readonly HexCoords[] AxialNeighbors = new HexCoords[] {
        new HexCoords(+1, 0),   // Side1
        new HexCoords(0, -1),   // Side2
        new HexCoords(-1, -1),  // Side3
        new HexCoords(-1, 0),   // Side4
        new HexCoords(0, +1),   // Side5
        new HexCoords(+1, +1)   // Side6
    };

    // Returns the neighbor hex coordinate for a given side index (0 to 5)
    public static HexCoords GetNeighbor(HexCoords origin, int sideIndex)
    {
        return new HexCoords(origin.q + AxialNeighbors[sideIndex].q,
                             origin.r + AxialNeighbors[sideIndex].r);
    }

    public static int OppositeSideIndex(int sideIndex)
    {
        return (sideIndex + 3) % 6;
    }

    public override bool Equals(object obj)
    {
        if (!(obj is HexCoords))
            return false;
        HexCoords other = (HexCoords)obj;
        return this.q == other.q && this.r == other.r;
    }

    public override int GetHashCode()
    {
        unchecked { return (q * 397) ^ r; }
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\HexGridManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class HexGridManager : MonoBehaviour
{
    public float hexSize = 50f;
    public float pinRadiusMultiplier = 1.0f; // Pin radius = hexSize * multiplier

    // Flat top hexagon grid only – no orientation toggle needed.
    public static HexGridManager Instance { get; private set; }
    
    private void Awake()
    {
        Instance = this;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\HexGridRenderer.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

[RequireComponent(typeof(CanvasRenderer))]
public class HexGridRenderer : MaskableGraphic
{
    public bool showGrid = true;
    public Color gridColor = Color.white;
    public float lineThickness = 1f;

    private float HexSize {
        get { return (HexGridManager.Instance != null) ? HexGridManager.Instance.hexSize : 50f; }
    }

    protected override void OnPopulateMesh(VertexHelper vh)
    {
        vh.Clear();
        if (!showGrid)
            return;

        Rect rect = rectTransform.rect;
        Vector2 origin = rect.center;

        int cols = Mathf.CeilToInt(rect.width / (HexSize * Mathf.Sqrt(3))) + 2;
        int rows = Mathf.CeilToInt(rect.height / (HexSize * 1.5f)) + 2;

        List<Vector2> linePoints = new List<Vector2>();

        for (int q = -cols; q <= cols; q++)
        {
            for (int r = -rows; r <= rows; r++)
            {
                HexCoords hex = new HexCoords(q, r);
                Vector2 hexCenter = hex.HexToWorld(HexSize) + origin;
                List<Vector2> corners = new List<Vector2>();
                // For flat top, use corners at angles 0, 60, 120, 180, 240, 300.
                for (int i = 0; i < 6; i++)
                {
                    float angle = i * 60f;
                    float rad = angle * Mathf.Deg2Rad;
                    Vector2 offset = new Vector2(HexSize * Mathf.Cos(rad), HexSize * Mathf.Sin(rad));
                    corners.Add(hexCenter + offset);
                }
                for (int i = 0; i < 6; i++)
                {
                    int next = (i + 1) % 6;
                    linePoints.Add(corners[i]);
                    linePoints.Add(corners[next]);
                }
            }
        }
        for (int i = 0; i < linePoints.Count; i += 2)
        {
            AddLineQuad(vh, linePoints[i], linePoints[i + 1], lineThickness, gridColor);
        }
    }

    private void AddLineQuad(VertexHelper vh, Vector2 start, Vector2 end, float thickness, Color col)
    {
        Vector2 direction = (end - start).normalized;
        Vector2 normal = new Vector2(-direction.y, direction.x);
        Vector2 offset = normal * (thickness * 0.5f);

        int idx = vh.currentVertCount;
        vh.AddVert(start + offset, col, Vector2.zero);
        vh.AddVert(start - offset, col, Vector2.zero);
        vh.AddVert(end - offset, col, Vector2.zero);
        vh.AddVert(end + offset, col, Vector2.zero);
        vh.AddTriangle(idx, idx + 1, idx + 2);
        vh.AddTriangle(idx, idx + 2, idx + 3);
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public Vector2 editorPosition; // For UI positioning
    public HexCoords coords;       // Hex-based position
    public Color backgroundColor = Color.gray;
    public string description = "";
    public List<NodePort> ports;   // Up to 6 ports (max 1 per side)
    public List<NodeEffectData> effects;

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
        ports = new List<NodePort>();
        effects = new List<NodeEffectData>();
        coords = new HexCoords(0, 0);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    public string displayName;
    public Color backgroundColor = Color.gray;
    [TextArea] public string description;
    public List<PortDefinition> ports;
    public List<NodeEffectData> effects = new List<NodeEffectData>();

#if UNITY_EDITOR
    private void OnValidate()
    {
        if (string.IsNullOrEmpty(displayName))
        {
            string path = UnityEditor.AssetDatabase.GetAssetPath(this);
            string fileName = System.IO.Path.GetFileNameWithoutExtension(path);
            string[] parts = fileName.Split('_');
            if (parts.Length >= 3)
                displayName = string.Join("_", parts.Skip(2).ToArray());
        }
    }
#endif

    private void OnEnable()
    {
        if (ports == null || ports.Count == 0)
        {
            ports = new List<PortDefinition>();
            // Default: one input on Top and one output on Three (opposite for flat-top)
            ports.Add(new PortDefinition { isInput = true, portType = PortType.General, side = HexSideFlat.Top });
            ports.Add(new PortDefinition { isInput = false, portType = PortType.General, side = HexSideFlat.Three });
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    public List<NodeDefinition> definitions;
    // New: List of nodes to auto-spawn at game start.
    public List<NodeDefinition> autoSpawnNodes;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;

    // For Seed:
    // effectValue     = stemMinLength
    // secondaryValue  = stemMaxLength
    // extra1          = growthSpeed
    // extra2          = leafGap
    public float effectValue;
    public float secondaryValue;
    public float extra1;
    public float extra2;

    // Two brand-new fields:
    public int leafPattern = 0;       // 0=Parallel, 1=Alternating
    public float growthRandomness = 0f; // Range [0..2]
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿public enum NodeEffectType
{
    ManaCost,
    Damage,
    ManaStorage,
    ManaRechargeRate,
    EnergyStorage,
    EnergyPhotosynthesis,
    Output,
    AimSpread,    // formerly Accuracy
    Burning,
    Piercing,
    FriendlyFire,
    Seed  // New effect type for planting a seed.
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodePort.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

public enum PortType { General, Mana, Condition }

public enum HexSideFlat { Top, One, Two, Three, Four, Five }

[Serializable]
public class NodePort
{
    public bool isInput;
    public PortType portType;
    public HexSideFlat side;

    public NodePort(bool isInput, PortType portType, HexSideFlat side)
    {
        this.isInput = isInput;
        this.portType = portType;
        this.side = side;
    }

    public NodePort() { }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\OutputNodeEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Linq;

/// <summary>
/// Attach this to the NodeView prefab if the node has Output effect,
/// or have BFS call it directly. 
/// It calls WizardController to spawn a projectile/spell.
/// </summary>
public class OutputNodeEffect : MonoBehaviour
{
    /// <summary>
    /// This method is invoked by NodeExecutor when BFS processes an 'Output' node.
    /// You can pass any parameters (damage, aim, etc.) or just do a test projectile.
    /// </summary>
    public void Activate()
    {
        Debug.Log("[OutputNodeEffect] Activate() called. Spawning projectile or calling wizard cast.");

        // For example, find the local (player) wizard and cast a test projectile:
        WizardController playerWiz = FindObjectsOfType<WizardController>()
            .FirstOrDefault(w => !w.isEnemy);

        if (playerWiz)
        {
            // Just an example. The real logic might pass finalDamage, aimSpread, etc.
            playerWiz.CastSpell(finalDamage: 10f, finalAimSpread: 5f,
                burningDamage: 0f, burningDuration: 0f,
                piercing: false, friendlyFire: false);
            Debug.Log("[OutputNodeEffect] Called player's CastSpell with sample values.");
        }
        else
        {
            Debug.LogWarning("[OutputNodeEffect] No friendly wizard found in scene.");
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\PortDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

[Serializable]
public class PortDefinition
{
    public bool isInput;
    public PortType portType;
    public HexSideFlat side;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro;

public class NodeExecutor : MonoBehaviour
{
    [SerializeField] private NodeGraph currentGraph;
    [Header("Debug Settings")]
    public float waitTimeBetweenNodes = 0.5f;
    public TMP_Text debugOutput;

    [Header("Plant Prefab (assigned in inspector)")]
    public GameObject plantPrefab;  // Assign your PlantPrefab here

    private Dictionary<HexCoords, NodeData> coordsMap;
    private HashSet<string> visited;

    // For accumulating energy info from the BFS chain:
    private float accumulatedEnergyStorage  = 0f;
    private float accumulatedPhotosynthesis = 0f;

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
            ExecuteGraph();
    }

    public void SetGraph(NodeGraph graph)
    {
        currentGraph = graph;
        Debug.Log("[NodeExecutor] Graph set. Node count=" + (graph != null ? graph.nodes.Count : 0));
    }

    public NodeGraph GetGraph() => currentGraph;

    public void ExecuteGraph()
    {
        if (currentGraph == null || currentGraph.nodes.Count == 0)
        {
            LogDebug("[NodeExecutor] No graph or no nodes to execute!");
            return;
        }
        StopAllCoroutines();
        ClearDebug();
        BuildCoordsMap();
        visited = new HashSet<string>();

        // Reset accumulators in case we want a fresh sum each time.
        accumulatedEnergyStorage  = 0f;
        accumulatedPhotosynthesis = 0f;

        List<NodeData> startNodes = FindStartNodes();
        if (startNodes.Count == 0)
        {
            LogDebug("[NodeExecutor] No start nodes found. Aborting BFS.");
            return;
        }
        foreach (var startNode in startNodes)
            StartCoroutine(RunChainBFS(startNode));
    }

    private void BuildCoordsMap()
    {
        coordsMap = new Dictionary<HexCoords, NodeData>();
        foreach (var node in currentGraph.nodes)
            coordsMap[node.coords] = node;
    }

    private List<NodeData> FindStartNodes()
    {
        List<NodeData> result = new List<NodeData>();
        foreach (var node in currentGraph.nodes)
        {
            if (!HasInbound(node))
                result.Add(node);
        }
        return result;
    }

    private bool HasInbound(NodeData node)
    {
        foreach (var port in node.ports)
        {
            if (!port.isInput) continue;

            int sideIndex = (int)port.side;
            int oppSide   = (sideIndex + 3) % 6;
            HexCoords neighborCoords = HexCoords.GetNeighbor(node.coords, oppSide);
            if (!coordsMap.ContainsKey(neighborCoords)) 
                continue;

            var neighborNode = coordsMap[neighborCoords];
            bool hasOutputMatch = neighborNode.ports.Any(p => !p.isInput && (int)p.side == oppSide);
            if (hasOutputMatch)
                return true;
        }
        return false;
    }

    private IEnumerator RunChainBFS(NodeData startNode)
    {
        Queue<HexCoords> queue = new Queue<HexCoords>();
        queue.Enqueue(startNode.coords);

        while (queue.Count > 0)
        {
            HexCoords coords = queue.Dequeue();
            if (!coordsMap.ContainsKey(coords)) 
                continue;

            NodeData node = coordsMap[coords];
            if (visited.Contains(node.nodeId)) 
                continue;

            visited.Add(node.nodeId);

            yield return new WaitForSeconds(waitTimeBetweenNodes);
            ProcessNode(node);

            // Follow output sides
            foreach (var port in node.ports)
            {
                if (!port.isInput)
                {
                    int sIndex = (int)port.side;
                    HexCoords neighborCoords = HexCoords.GetNeighbor(coords, sIndex);
                    if (!coordsMap.ContainsKey(neighborCoords)) 
                        continue;

                    var neighborNode = coordsMap[neighborCoords];
                    int oppIndex = (sIndex + 3) % 6;
                    bool hasInputMatch = neighborNode.ports.Any(p => p.isInput && (int)p.side == oppIndex);
                    if (hasInputMatch && !visited.Contains(neighborNode.nodeId))
                        queue.Enqueue(neighborCoords);
                }
            }
        }
        LogDebug("[NodeExecutor] BFS from start node completed.");
    }

    private void ProcessNode(NodeData node)
    {
        LogDebug($"[NodeExecutor] Processing node '{node.nodeDisplayName}' at coords ({node.coords.q}, {node.coords.r}).");

        // Accumulate Energy Storage and Photosynthesis from ANY node effect 
        // in the BFS chain.
        foreach (var eff in node.effects)
        {
            if (eff.effectType == NodeEffectType.EnergyStorage)
            {
                accumulatedEnergyStorage += eff.effectValue;
            }
            else if (eff.effectType == NodeEffectType.EnergyPhotosynthesis)
            {
                accumulatedPhotosynthesis += eff.effectValue;
            }
        }

        // If it's a Seed node, spawn the plant now using the BFS accumulators.
        var seedEffect = node.effects.FirstOrDefault(e => e.effectType == NodeEffectType.Seed);
        if (seedEffect != null)
        {
            SpawnPlant(seedEffect);
        }
    }

    private void SpawnPlant(NodeEffectData seedEffect)
    {
        if (plantPrefab == null)
        {
            LogDebug("[NodeExecutor] plantPrefab is not assigned in the inspector!");
            return;
        }
        var gardener = FindObjectOfType<GardenerController>();
        if (gardener == null)
        {
            LogDebug("[NodeExecutor] No GardenerController found. Can't spawn plant.");
            return;
        }

        Vector2 spawnPos = gardener.GetPlantingPosition();
        GameObject plantObj = Instantiate(plantPrefab, spawnPos, Quaternion.identity);
        PlantGrowth growth = plantObj.GetComponent<PlantGrowth>();

        if (growth != null)
        {
            // standard seed data
            growth.stemMinLength = Mathf.RoundToInt(seedEffect.effectValue);
            growth.stemMaxLength = Mathf.RoundToInt(seedEffect.secondaryValue);
            growth.growthSpeed   = seedEffect.extra1;
            growth.leafGap       = Mathf.RoundToInt(seedEffect.extra2);
            growth.leafPattern      = seedEffect.leafPattern; 
            growth.growthRandomness = seedEffect.growthRandomness;

            // new "energy" data from BFS sums
            growth.maxEnergy       = accumulatedEnergyStorage;   // sum of all energy storages
            growth.basePhotosynthesis = accumulatedPhotosynthesis; // sum of all photosynthesis rates

            LogDebug($"[NodeExecutor] Spawned plant => " +
                     $"Seed(min={growth.stemMinLength},max={growth.stemMaxLength},spd={growth.growthSpeed},gap={growth.leafGap},pat={growth.leafPattern},rand={growth.growthRandomness}), " +
                     $"Energy(max={growth.maxEnergy}), Photosynthesis(base={growth.basePhotosynthesis})");
        }
        else
        {
            LogDebug("[NodeExecutor] PlantGrowth missing on plantPrefab.");
        }

        // If you want each new seed to get its own accumulators, 
        // reset them after spawning:
        accumulatedEnergyStorage  = 0f;
        accumulatedPhotosynthesis = 0f;
    }

    private void ClearDebug()
    {
        if (debugOutput)
            debugOutput.text = "";
    }

    private void LogDebug(string msg)
    {
        Debug.Log(msg);
        if (debugOutput)
            debugOutput.text += msg + "\n";
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes;

    public NodeGraph()
    {
        nodes = new List<NodeData>();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\ColorExtensions.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public static class ColorExtensions
{
    public static Color WithAlpha(this Color c, float alpha)
    {
        return new Color(c.r, c.g, c.b, alpha);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeEditorController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Linq;

public class NodeEditorController : MonoBehaviour, IScrollHandler, IDragHandler
{
    [Header("Window & Content Setup")]
    [SerializeField] private RectTransform windowRect; // Panel with RectMask2D
    [SerializeField] private RectTransform contentRect; // Panel that holds nodes

    [Header("Prefabs")]
    [SerializeField] private GameObject nodeViewPrefab; // Must have NodeView component

    [Header("Node Definitions")]
    [SerializeField] private NodeDefinitionLibrary definitionLibrary;

    [Header("Runtime Graph Reference")]
    [SerializeField] private NodeGraph currentGraph;

    [Header("Zoom and Panning")]
    [SerializeField] private float startingZoomMultiplier = 1f; // Default zoom at start
    [SerializeField] private float contentMargin = 20f;         // Margin around nodes

    private bool showContextMenu = false;
    private Vector2 contextMenuPosition;
    private List<NodeView> spawnedNodeViews = new List<NodeView>();
    private CanvasGroup canvasGroup;
    public RectTransform ContentRect => contentRect;


    private void Awake()
    {
        if (windowRect == null)
            windowRect = GetComponent<RectTransform>();

        canvasGroup = GetComponent<CanvasGroup>();
        if (canvasGroup == null)
            canvasGroup = gameObject.AddComponent<CanvasGroup>();

        Image bg = GetComponent<Image>();
        if (bg == null)
        {
            bg = gameObject.AddComponent<Image>();
            bg.color = new Color(1, 1, 1, 0);
            bg.raycastTarget = true;
        }
    }

    private void Start()
    {
        if (currentGraph == null)
            currentGraph = new NodeGraph();

        // Set initial zoom.
        contentRect.localScale = Vector3.one * startingZoomMultiplier;
        EnsureContentPanelSize();
    }

    private void Update()
    {
        // Hide context menu on left-click if outside.
        if (Input.GetMouseButtonDown(0))
        {
            if (showContextMenu && definitionLibrary != null && definitionLibrary.definitions != null)
            {
                Vector2 guiPos = new Vector2(contextMenuPosition.x, Screen.height - contextMenuPosition.y);
                float menuHeight = 20 + (definitionLibrary.definitions.Count * 25);
                Rect menuRect = new Rect(guiPos.x, guiPos.y, 180, menuHeight);

                Vector2 mousePos = Input.mousePosition;
                mousePos.y = Screen.height - mousePos.y;
                if (!menuRect.Contains(mousePos))
                    showContextMenu = false;
            }
        }
        if (Input.GetKeyDown(KeyCode.Tab))
            ToggleVisibility();
        if (Input.GetKeyDown(KeyCode.Delete))
        {
            if (NodeSelectable.CurrentSelected != null)
                DeleteSelectedNode();
        }
        if (Input.GetMouseButtonDown(1))
        {
            showContextMenu = true;
            contextMenuPosition = Input.mousePosition;
        }
    }

    private void ToggleVisibility()
    {
        if (canvasGroup.alpha > 0)
        {
            canvasGroup.alpha = 0;
            canvasGroup.interactable = false;
            canvasGroup.blocksRaycasts = false;
        }
        else
        {
            canvasGroup.alpha = 1;
            canvasGroup.interactable = true;
            canvasGroup.blocksRaycasts = true;
        }
    }

    private void OnGUI()
    {
        if (showContextMenu && definitionLibrary != null && definitionLibrary.definitions.Count > 0)
        {
            Vector2 guiPos = new Vector2(contextMenuPosition.x, Screen.height - contextMenuPosition.y);
            float menuHeight = 20 + (definitionLibrary.definitions.Count * 25);
            Rect menuRect = new Rect(guiPos.x, guiPos.y, 180, menuHeight);

            if (Event.current.type == EventType.MouseDown && Event.current.button == 0)
            {
                if (!menuRect.Contains(Event.current.mousePosition))
                    showContextMenu = false;
            }

            GUI.Box(menuRect, "Add Node");
            float yOffset = 20f;
            foreach (NodeDefinition def in definitionLibrary.definitions)
            {
                Rect itemRect = new Rect(menuRect.x, menuRect.y + yOffset, 180, 25);
                if (GUI.Button(itemRect, def.displayName))
                {
                    CreateNodeAtMouse(def);
                    showContextMenu = false;
                }
                yOffset += 25f;
            }
        }
    }

    
        private void CreateNodeAtMouse(NodeDefinition definition)
{
    // 1. Convert screen coords → local coords in contentRect
    Vector2 localPos;
    RectTransformUtility.ScreenPointToLocalPointInRectangle(
        contentRect, Input.mousePosition, null, out localPos);

    // 2. Convert local coords → hex coords (flat-top style)
    float hexSizeValue = (HexGridManager.Instance != null) 
        ? HexGridManager.Instance.hexSize 
        : 50f;

    // If your HexCoords.WorldToHex expects localPos to be the same coordinate space 
    // as used in your HexCoords logic, we can feed localPos directly:
    HexCoords hc = HexCoords.WorldToHex(localPos, hexSizeValue);

    // 3. Convert hex coords → local snapped coords
    Vector2 snappedLocal = hc.HexToWorld(hexSizeValue);

    // 4. Create the new node data
    NodeData newNode = new NodeData
    {
        nodeDisplayName = definition.displayName,
        backgroundColor = definition.backgroundColor,
        description = definition.description,
        coords = hc,
        editorPosition = snappedLocal // This is the local position inside contentRect
    };

    // Copy the definition’s effects & ports
    foreach (var defEffect in definition.effects)
    {
        NodeEffectData effectCopy = new NodeEffectData
        {
            effectType = defEffect.effectType,
            effectValue = defEffect.effectValue,
            secondaryValue = defEffect.secondaryValue,
            extra1 = defEffect.extra1,
            extra2 = defEffect.extra2,
            leafPattern = defEffect.leafPattern,         // NEW: copy leafPattern
            growthRandomness = defEffect.growthRandomness    // NEW: copy growthRandomness
        };
        newNode.effects.Add(effectCopy);
    }

    foreach (var portDef in definition.ports)
    {
        NodePort nodePort = new NodePort
        {
            isInput  = portDef.isInput,
            portType = portDef.portType,
            side     = portDef.side
        };
        newNode.ports.Add(nodePort);
    }

    // 5. Add node to graph and spawn the node view
    currentGraph.nodes.Add(newNode);
    CreateNodeView(newNode);
    EnsureContentPanelSize();
}




    public NodeView CreateNodeView(NodeData data)
    {
        if (nodeViewPrefab == null)
        {
            Debug.LogError("[NodeEditorController] nodeViewPrefab is not assigned!");
            return null;
        }
        GameObject nodeObj = Instantiate(nodeViewPrefab, contentRect);
        NodeView view = nodeObj.GetComponent<NodeView>();
        if (view == null)
        {
            Debug.LogError("[NodeEditorController] The instantiated node prefab does not have a NodeView component!");
            return null;
        }
        view.Initialize(data, data.backgroundColor, data.nodeDisplayName);
        RectTransform rt = nodeObj.GetComponent<RectTransform>();
        rt.anchoredPosition = data.editorPosition;
        view.GeneratePins(data.ports);

        // If node has an Output effect, attach the OutputNodeEffect script
        if (data.effects.Any(e => e.effectType == NodeEffectType.Output))
        {
            if (nodeObj.GetComponent<OutputNodeEffect>() == null)
                nodeObj.AddComponent<OutputNodeEffect>();
        }

        spawnedNodeViews.Add(view);
        return view;
    }


    private void DeleteSelectedNode()
    {
        NodeView selectedView = NodeSelectable.CurrentSelected.GetComponent<NodeView>();
        if (selectedView == null)
            return;
        string nodeId = selectedView.GetNodeData().nodeId;
        currentGraph.nodes.RemoveAll(n => n.nodeId == nodeId);
        Destroy(NodeSelectable.CurrentSelected);
        NodeSelectable.CurrentSelected = null;
    }

    public void OnScroll(PointerEventData eventData)
    {
        float scrollDelta = eventData.scrollDelta.y;
        float newScale = contentRect.localScale.x + scrollDelta * 0.05f;
        newScale = Mathf.Clamp(newScale, 0.5f, 2f);
        contentRect.localScale = Vector3.one * newScale;
        EnsureContentPanelSize();
    }

    public void OnDrag(PointerEventData eventData)
    {
        contentRect.anchoredPosition += eventData.delta;
        EnsureContentPanelSize();
    }

    private void EnsureContentPanelSize()
    {
        if (windowRect == null || contentRect == null)
            return;

        // Remove null entries from spawnedNodeViews
        spawnedNodeViews = spawnedNodeViews.Where(v => v != null).ToList();

        Vector2 windowSize = windowRect.rect.size;
        Vector2 minSize = windowSize + new Vector2(contentMargin * 2, contentMargin * 2);

        if (spawnedNodeViews.Count > 0)
        {
            Vector2 minPos = new Vector2(float.MaxValue, float.MaxValue);
            Vector2 maxPos = new Vector2(float.MinValue, float.MinValue);
            foreach (var view in spawnedNodeViews)
            {
                if (view == null)
                    continue;

                RectTransform rt = view.GetComponent<RectTransform>();
                Vector2 pos = rt.anchoredPosition;
                Vector2 size = rt.rect.size;
                minPos = Vector2.Min(minPos, pos - size * 0.5f);
                maxPos = Vector2.Max(maxPos, pos + size * 0.5f);
            }
            Vector2 bounds = maxPos - minPos;
            minSize = Vector2.Max(minSize, bounds + new Vector2(contentMargin * 2, contentMargin * 2));
        }

        Vector2 currSize = contentRect.sizeDelta;
        float newW = Mathf.Max(currSize.x, minSize.x);
        float newH = Mathf.Max(currSize.y, minSize.y);
        contentRect.sizeDelta = new Vector2(newW, newH);
    }


    public NodeGraph CurrentGraph => currentGraph;

    private void ClearExistingViews()
    {
        foreach (var view in spawnedNodeViews)
        {
            if (view != null)
                Destroy(view.gameObject);
        }
        spawnedNodeViews.Clear();
    }

    public void LoadGraph(NodeGraph graph)
    {
        currentGraph = graph;
        ClearExistingViews();
        if (currentGraph == null) return;
        foreach (var nd in currentGraph.nodes)
            CreateNodeView(nd);
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeHexDraggable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

public class NodeHexDraggable : MonoBehaviour, IPointerDownHandler, IDragHandler, IPointerUpHandler
{
    private RectTransform nodeRect;
    private RectTransform parentRect;
    private Vector2 pointerOffset;
    private NodeView nodeView;
    private float hexSize;

    private void Awake()
    {
        nodeRect = GetComponent<RectTransform>();
        parentRect = nodeRect.parent as RectTransform;
        nodeView = GetComponent<NodeView>();
        hexSize = (HexGridManager.Instance != null) ? HexGridManager.Instance.hexSize : 50f;
    }

    public void OnPointerDown(PointerEventData eventData)
    {
        Vector2 localPoint;
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRect, eventData.position, eventData.pressEventCamera, out localPoint))
        {
            pointerOffset = nodeRect.anchoredPosition - localPoint;
        }
        eventData.Use();
    }

    public void OnDrag(PointerEventData eventData)
    {
        Vector2 localPoint;
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRect, eventData.position, eventData.pressEventCamera, out localPoint))
        {
            nodeRect.anchoredPosition = localPoint + pointerOffset;
        }
        eventData.Use();
    }

    public void OnPointerUp(PointerEventData eventData)
    {
        Vector2 currentPos = nodeRect.anchoredPosition;
        float hexSizeValue = hexSize;
        HexCoords coords = HexCoords.WorldToHex(currentPos, hexSizeValue);
        Vector2 snappedPos = coords.HexToWorld(hexSizeValue);
        nodeRect.anchoredPosition = snappedPos;
        if (nodeView != null)
        {
            nodeView.GetNodeData().coords = coords;
            nodeView.GetNodeData().editorPosition = snappedPos;
        }
        eventData.Use();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeSelectable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class NodeSelectable : MonoBehaviour, IPointerClickHandler
{
    // Public static property to hold the currently selected node.
    public static GameObject CurrentSelected { get; set; }

    [SerializeField] private Outline outline;

    private void Awake()
    {
        if (outline != null)
            outline.enabled = false;
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        Select(gameObject);
    }

    public static void Select(GameObject node)
    {
        if (CurrentSelected != null && CurrentSelected != node)
        {
            // Disable outline on previously selected node.
            var prevOutline = CurrentSelected.GetComponent<Outline>();
            if (prevOutline != null)
                prevOutline.enabled = false;
        }
        CurrentSelected = node;
        var outlineComp = node.GetComponent<Outline>();
        if (outlineComp != null)
            outlineComp.enabled = true;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeTestInitializer.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class NodeTestInitializer : MonoBehaviour
{
    [SerializeField] private NodeEditorController editorController;
    [SerializeField] private NodeExecutor nodeExecutor;
    [SerializeField] private NodeDefinitionLibrary definitionLibrary; // Ensure this is assigned.

    private NodeGraph testGraph;

    private void Start()
    {
        // Create a new graph.
        testGraph = new NodeGraph();

        // Load the graph into the editor.
        if (editorController != null)
        {
            editorController.LoadGraph(testGraph);
        }
        else
        {
            Debug.LogWarning("[NodeTestInitializer] Missing NodeEditorController reference.");
        }

        // ============================
        // AUTO-SPAWN NODES FROM LIBRARY
        // ============================
        if (definitionLibrary != null && definitionLibrary.autoSpawnNodes != null)
        {
            foreach (var nodeDef in definitionLibrary.autoSpawnNodes)
            {
                // We use a simple offset logic: each node is placed 100 units to the right/down from the previous.
                Vector2 spawnPos = new Vector2(100 * testGraph.nodes.Count, 100 * testGraph.nodes.Count);

                // -----------------
                // CREATE THE NODE
                // -----------------
                NodeData newNode = new NodeData();
                newNode.nodeDisplayName = nodeDef.displayName;
                newNode.backgroundColor = nodeDef.backgroundColor;
                newNode.description = nodeDef.description;

                // Copy NodeDefinition effects => newNode.effects
                foreach (var defEffect in nodeDef.effects)
                {
                    NodeEffectData effectCopy = new NodeEffectData
                    {
                        effectType       = defEffect.effectType,
                        effectValue      = defEffect.effectValue,
                        secondaryValue   = defEffect.secondaryValue,
                        extra1           = defEffect.extra1,
                        extra2           = defEffect.extra2,
                        leafPattern      = defEffect.leafPattern,       // FIX: now copying leafPattern
                        growthRandomness = defEffect.growthRandomness   // FIX: now copying growthRandomness
                    };
                    newNode.effects.Add(effectCopy);
                }

                // Copy NodeDefinition ports => newNode.ports
                foreach (var portDef in nodeDef.ports)
                {
                    NodePort nodePort = new NodePort
                    {
                        isInput  = portDef.isInput,
                        portType = portDef.portType,
                        side     = portDef.side
                    };
                    newNode.ports.Add(nodePort);
                }

                // Snap position based on current contentRect from the editor.
                float hexSizeValue = (HexGridManager.Instance != null) 
                    ? HexGridManager.Instance.hexSize 
                    : 50f;

                // Adjust spawnPos relative to content center.
                Vector2 adjustedSpawn = spawnPos - editorController.ContentRect.rect.center;
                HexCoords hc = HexCoords.WorldToHex(adjustedSpawn, hexSizeValue);
                newNode.coords = hc;
                Vector2 snappedPos = hc.HexToWorld(hexSizeValue) + editorController.ContentRect.rect.center;
                newNode.editorPosition = snappedPos;

                // Add the newly created node to the graph.
                testGraph.nodes.Add(newNode);

                // Create the NodeView in the editor UI.
                editorController.CreateNodeView(newNode);
            }
        }
        else
        {
            Debug.LogWarning("[NodeTestInitializer] No autoSpawnNodes defined in NodeDefinitionLibrary.");
        }

        // Pass the same graph to the executor.
        if (nodeExecutor != null)
        {
            nodeExecutor.SetGraph(testGraph);
        }
        else
        {
            Debug.LogWarning("[NodeTestInitializer] Missing NodeExecutor reference.");
        }
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeView.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;
using System.Linq;

public class NodeView : MonoBehaviour
{
    [Header("Text Components")]
    [SerializeField] private TMP_Text nodeTitleText;
    [SerializeField] private Image backgroundImage;

    [Header("Node Info Display")]
    [SerializeField] private TMP_Text manaStorageText;
    [SerializeField] private TMP_Text effectsText;
    [SerializeField] private TMP_Text descriptionText;

    [Header("Pins Settings")]
    [SerializeField] private float pinRadius = 60f; // Distance from node center to pin (auto-updated from HexGridManager if available)
    [SerializeField] private Transform pinContainer; // Parent container for spawned pins

    [Header("Pin Customization")]
    public Sprite manaPinSprite;
    public Color manaPinColor = Color.cyan;
    public Sprite conditionPinSprite;
    public Color conditionPinColor = new Color(1f, 0.65f, 0f);
    public Sprite generalPinSprite;
    public Color generalPinColor = Color.blue;
    [Tooltip("Uniform additional rotation (in degrees) applied to port sprites.")]
    public float portSpriteRotationOffset = 0f;

    [Header("Pin Scale Settings")]
    [Tooltip("General multiplier applied to all port sprites.")]
    public float portSpriteScaleMultiplier = 1.0f;
    [Tooltip("Multiplier for input port sprites.")]
    public float inputPortScaleMultiplier = 1.0f;
    [Tooltip("Multiplier for output port sprites.")]
    public float outputPortScaleMultiplier = 1.0f;

    private NodeData nodeData;

    private void Awake()
    {
        if (pinContainer == null)
            pinContainer = this.transform;
        if (HexGridManager.Instance != null)
            pinRadius = HexGridManager.Instance.hexSize * HexGridManager.Instance.pinRadiusMultiplier;
    }

    private void Update()
    {
        var manaEff = nodeData.effects.FirstOrDefault(e => e.effectType == NodeEffectType.ManaStorage);
        if (manaEff != null && manaStorageText != null)
        {
            float cap = Mathf.Floor(manaEff.effectValue);
            float cur = Mathf.Floor(manaEff.secondaryValue);
            manaStorageText.text = $"Mana: {cur}/{cap}";
        }
    }

    public void Initialize(NodeData data, Color color, string displayName)
    {
        nodeData = data;
        if (nodeTitleText)
            nodeTitleText.text = displayName;
        if (backgroundImage)
            backgroundImage.color = color;

        if (effectsText != null)
        {
            if (nodeData.effects.Count == 0)
                effectsText.text = "No Effects";
            else
            {
                string str = "";              //"Effects:\n";
                foreach (var eff in nodeData.effects)
                    str += $"- {eff.effectType} ({eff.effectValue})\n";
                effectsText.text = str;
            }
        }

        if (descriptionText != null)
            descriptionText.text = nodeData.description;

        var manaEff = nodeData.effects.FirstOrDefault(e => e.effectType == NodeEffectType.ManaStorage);
        if (manaEff != null && manaStorageText != null)
            manaStorageText.text = $"Mana: {manaEff.secondaryValue}/{manaEff.effectValue}";
    }

    // Generate pins for each port in the node.
    public void GeneratePins(List<NodePort> ports)
    {
        foreach (Transform child in pinContainer)
            Destroy(child.gameObject);
        foreach (var port in ports)
            CreatePin(port);
    }

    private void CreatePin(NodePort port)
    {
        GameObject pinObj = new GameObject(port.isInput ? "InputPin" : "OutputPin", typeof(RectTransform));
        pinObj.transform.SetParent(pinContainer, false);
        RectTransform rt = pinObj.GetComponent<RectTransform>();

        // Calculate scale multiplier based on port type.
        float scaleMultiplier = portSpriteScaleMultiplier * (port.isInput ? inputPortScaleMultiplier : outputPortScaleMultiplier);
        rt.sizeDelta = new Vector2(20, 20) * scaleMultiplier;

        // For flat-top hexagons, pins should be centered on each side.
        // Mapping: Top = 90°, One = 30°, Two = -30°, Three = -90°, Four = -150°, Five = -210°.
        int sideIndex = (int)port.side; // Top=0, One=1, ..., Five=5.
        float posAngle = 90f - sideIndex * 60f; // This yields: Top:90, One:30, Two:-30, Three:-90, Four:-150, Five:-210.
        float posRad = posAngle * Mathf.Deg2Rad;
        float x = pinRadius * Mathf.Cos(posRad);
        float y = pinRadius * Mathf.Sin(posRad);
        rt.anchoredPosition = new Vector2(x, y);

        // Set sprite rotation: for outputs, arrow points out; for inputs, arrow points in (add 180°).
        float spriteAngle = posAngle;
        if (port.isInput)
            spriteAngle += 180f;
        spriteAngle += portSpriteRotationOffset;
        rt.localRotation = Quaternion.Euler(0, 0, spriteAngle);

        Image img = pinObj.AddComponent<Image>();
        switch (port.portType)
        {
            case PortType.Mana:
                img.sprite = manaPinSprite;
                img.color = manaPinColor;
                break;
            case PortType.Condition:
                img.sprite = conditionPinSprite;
                img.color = conditionPinColor;
                break;
            default:
                img.sprite = generalPinSprite;
                img.color = generalPinColor;
                break;
        }
        img.type = Image.Type.Simple;
        img.preserveAspect = true;
    }

    public NodeData GetNodeData() => nodeData;
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Player\GardenerController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class GardenerController : MonoBehaviour
{
    public float moveSpeed = 5f;
    private Rigidbody2D rb;
    private Vector2 movement;

    private void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
    }

    private void Update()
    {
        movement.x = Input.GetAxisRaw("Horizontal");
        movement.y = Input.GetAxisRaw("Vertical");
    }

    private void FixedUpdate()
    {
        rb.MovePosition(rb.position + movement.normalized * moveSpeed * Time.fixedDeltaTime);
    }
    
    // Returns the current position used for planting seeds.
    public Vector2 GetPlantingPosition()
    {
        return transform.position;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Wizards\WizardController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;
using System.Collections.Generic;

public enum FiringDirection
{
    Up,
    Down
}

public class WizardController : MonoBehaviour
{
    [Header("Wizard Configuration")]
    public bool isEnemy = false;

    [Header("Wizard Stats")]
    public float maxHP = 100f;
    public float currentHP;
    [Tooltip("Base aim spread in degrees; higher values mean a wider spread.")]
    public float baseAimSpread = 5f;

    [Header("Firing Settings")]
    [Tooltip("Determines if the wizard fires upward (default) or downward.")]
    public FiringDirection firingDirection = FiringDirection.Up;
    [Tooltip("The transform where spells are spawned. Its original Y value is used as reference.")]
    public Transform spellSpawnPoint;
    [Tooltip("Projectile prefab to be cast.")]
    public GameObject spellProjectilePrefab;
    public float projectileSpeed = 10f;
    [Tooltip("Enable friendly fire (projectile can damage friendlies)")]
    public bool friendlyFireEnabled = false;

    [Header("UI")]
    public TMP_Text hpText;

    private float originalSpawnY = 0f;
    public List<StatusEffect> activeStatusEffects = new List<StatusEffect>();

    private void Awake()
    {
        currentHP = maxHP;
        UpdateHPUI();

#if UNITY_EDITOR
        // Store the original Y value if not already stored.
        if (spellSpawnPoint != null && originalSpawnY == 0f)
            originalSpawnY = spellSpawnPoint.localPosition.y;
#endif
    }

#if UNITY_EDITOR
    private void OnValidate()
    {
        // When the firing direction changes, update spellSpawnPoint's Y coordinate.
        if (spellSpawnPoint != null)
        {
            // Ensure we have stored the original Y value.
            if (originalSpawnY == 0f)
                originalSpawnY = spellSpawnPoint.localPosition.y;

            Vector2 pos = spellSpawnPoint.localPosition;
            if (firingDirection == FiringDirection.Down)
                pos.y = -Mathf.Abs(originalSpawnY);
            else
                pos.y = Mathf.Abs(originalSpawnY);
            spellSpawnPoint.localPosition = pos;
        }
    }
#endif

    public void TakeDamage(float damage)
    {
        currentHP -= damage;
        if (currentHP < 0)
            currentHP = 0;
        UpdateHPUI();
        if (currentHP <= 0)
        {
            Debug.Log($"{gameObject.name} has been defeated.");
            // Add additional death logic if needed.
        }
    }

    private void UpdateHPUI()
    {
        if (hpText != null)
            hpText.text = $"HP: {Mathf.Floor(currentHP)}/{maxHP}";
    }

    /// <summary>
    /// Casts a spell. The projectile is spawned at spellSpawnPoint.
    /// The projectile's rotation is based on firingDirection and a random deviation within ±finalAimSpread.
    /// Also passes burning and friendly-fire parameters.
    /// </summary>
    public void CastSpell(float finalDamage, float finalAimSpread, float burningDamage, float burningDuration, bool piercing, bool friendlyFire)
    {
        if (isEnemy)
            return; // Enemies do not cast spells via node chain.

        if (spellProjectilePrefab == null || spellSpawnPoint == null)
        {
            Debug.LogWarning("Spell projectile prefab or spawn point not set.");
            return;
        }

        // Base rotation: for Up, identity; for Down, flip 180°.
        Quaternion baseRotation = (firingDirection == FiringDirection.Up) ? Quaternion.identity : Quaternion.Euler(0, 0, 180);
        float deviation = Random.Range(-finalAimSpread, finalAimSpread);
        Quaternion finalRotation = baseRotation * Quaternion.Euler(0, 0, deviation);

        GameObject projObj = Instantiate(spellProjectilePrefab, spellSpawnPoint.position, finalRotation);
        SpellProjectile projectile = projObj.GetComponent<SpellProjectile>();
        if (projectile != null)
        {
            projectile.Initialize(finalDamage, projectileSpeed);
            projectile.burningDamage = burningDamage;
            projectile.burningDuration = burningDuration;
            projectile.destroyOnHit = !piercing; // If piercing is true, do not destroy.
            projectile.friendlyFire = friendlyFire;
            projectile.casterIsEnemy = isEnemy;
        }
    }

    private void Update()
    {
        float delta = Time.deltaTime;
        for (int i = activeStatusEffects.Count - 1; i >= 0; i--)
        {
            activeStatusEffects[i].UpdateEffect(this, delta);
            if (activeStatusEffects[i].IsExpired())
                activeStatusEffects.RemoveAt(i);
        }
    }

    public void ApplyStatusEffect(StatusEffect effect)
    {
        activeStatusEffects.Add(effect);
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Wizards\WizardPreset.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;


[CreateAssetMenu(fileName = "WizardPreset", menuName = "Wizards/WizardPreset")]
public class WizardPreset : ScriptableObject
{
    public string presetName;
    public float maxHP = 100f;
    public float accuracy = 5f;      // In degrees: how much the projectile can deviate.
    public float critChance = 0f;    // Future use.
    public FiringDirection baseFiringDirection = FiringDirection.Up;
    // Add additional stats as needed.
}

