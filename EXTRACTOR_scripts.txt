This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-03-19 21:11:28
================================================================================

DIRECTORY STRUCTURE
--------------------------------------------------------------------------------
Assets
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   ├── NodeEffectDataDrawer.cs
│   └── WizardControllerStatusEditor.cs
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
│   └── BezierCurvesAntialiasing.renderTexture
├── Prefabs
│   ├── General
│   │   ├── Projectile_Basic_Pixel.prefab
│   │   └── WizardPrefab.prefab
│   ├── Node Presets
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_001_AimSpread.asset
│   │   ├── Node_002_Piercing.asset
│   │   ├── Node_003_Output.asset
│   │   ├── Node_004_ManaSource.asset
│   │   ├── Node_005_DamageNode.asset
│   │   ├── Node_006_Burn.asset
│   │   └── Node_007_FriendlyFire.asset
│   ├── UI
│   │   ├── NodeConnectionView.prefab
│   │   └── NodeView.prefab
│   └── Wizard Presets
│       ├── Wizard_Basic.asset
│       └── Wizard_Dummy.asset
├── Scenes
│   ├── MainScene.unity
│   └── SampleScene.unity
├── Scripts
│   ├── Battle
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   ├── NodePort.cs
│   │   │   ├── OutputNodeEffect.cs
│   │   │   └── PortDefinition.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── NodeConnectionView.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorController.cs
│   │       ├── NodeSelectable.cs
│   │       ├── NodeTestInitializer.cs
│   │       ├── NodeView.cs
│   │       ├── PinView.cs
│   │       └── UICubicBezier.cs
│   ├── UI
│   └── Wizards
│       ├── WizardController.cs
│       └── WizardPreset.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Sprites
│   ├── Clouds
│   │   ├── Clouds 1
│   │   │   ├── 1.png
│   │   │   ├── 2.png
│   │   │   ├── 3.png
│   │   │   └── 4.png
│   │   ├── Clouds 2
│   │   │   ├── 1.png
│   │   │   ├── 2.png
│   │   │   ├── 3.png
│   │   │   └── 4.png
│   │   ├── Clouds 3
│   │   │   ├── 1.png
│   │   │   ├── 2.png
│   │   │   ├── 3.png
│   │   │   └── 4.png
│   │   ├── Clouds 4
│   │   │   ├── 1.png
│   │   │   ├── 2.png
│   │   │   ├── 3.png
│   │   │   └── 4.png
│   │   ├── Clouds 5
│   │   │   ├── 1.png
│   │   │   ├── 2.png
│   │   │   ├── 3.png
│   │   │   ├── 4.png
│   │   │   └── 5.png
│   │   ├── Clouds 6
│   │   │   ├── 1.png
│   │   │   ├── 2.png
│   │   │   ├── 3.png
│   │   │   ├── 4.png
│   │   │   ├── 5.png
│   │   │   └── 6.png
│   │   ├── Clouds 7
│   │   │   ├── 1.png
│   │   │   ├── 2.png
│   │   │   ├── 3.png
│   │   │   └── 4.png
│   │   └── Clouds 8
│   │       ├── 1.png
│   │       ├── 2.png
│   │       ├── 3.png
│   │       ├── 4.png
│   │       ├── 5.png
│   │       └── 6.png
│   ├── Free Pixel Effects Pack
│   │   ├── 10_weaponhit_spritesheet.png
│   │   ├── 11_fire_spritesheet.png
│   │   ├── 12_nebula_spritesheet.png
│   │   ├── 13_vortex_spritesheet.png
│   │   ├── 14_phantom_spritesheet.png
│   │   ├── 15_loading_spritesheet.png
│   │   ├── 16_sunburn_spritesheet.png
│   │   ├── 17_felspell_spritesheet.png
│   │   ├── 18_midnight_spritesheet.png
│   │   ├── 19_freezing_spritesheet.png
│   │   ├── 1_magicspell_spritesheet.png
│   │   ├── 20_magicbubbles_spritesheet.png
│   │   ├── 2_magic8_spritesheet.png
│   │   ├── 3_bluefire_spritesheet.png
│   │   ├── 4_casting_spritesheet.png
│   │   ├── 5_magickahit_spritesheet.png
│   │   ├── 6_flamelash_spritesheet.png
│   │   ├── 7_firespin_spritesheet.png
│   │   ├── 8_protectioncircle_spritesheet.png
│   │   ├── 9_brightfire_spritesheet.png
│   │   ├── README.txt
│   │   └── cover.png
│   ├── MR-Platformer-v1
│   │   ├── Backgrounds
│   │   │   ├── merged-full-background.png
│   │   │   ├── parallax-background-mountains.png
│   │   │   ├── parallax-background-sky.png
│   │   │   ├── parallax-forest-trees-01.png
│   │   │   └── parallax-forest-trees-02.png
│   │   ├── Enemies
│   │   │   ├── Enemy-Bat-Fly-32x32.png
│   │   │   ├── Enemy-Boss-Golem-Idle-48x48.png
│   │   │   ├── Enemy-Dark-Guard-Idle-39x49.png
│   │   │   ├── Enemy-Forest-Goblin-Hog-Idle-32x32.png
│   │   │   ├── Enemy-Forest-Goblin-Idle-32x32.png
│   │   │   ├── Enemy-Frog-Attack-24x24.png
│   │   │   ├── Enemy-Frog-Idle-24x24.png
│   │   │   ├── Enemy-Frog-Tongue-Attack-72x24.png
│   │   │   ├── Enemy-Mushroom-Walk-24x24.png
│   │   │   ├── Enemy-Necromancer-Idle-32x32.png
│   │   │   ├── Enemy-Plant-Mutant-Idle-Attack-46x32.png
│   │   │   ├── Enemy-Skull-Slime-Idle-32x24.png
│   │   │   ├── Enemy-Snail-Attack-24x24.png
│   │   │   └── Enemy-Snail-Walk-24x24.png
│   │   ├── Misc
│   │   │   ├── Bridge-Support.png
│   │   │   ├── Bridge-handle-01.png
│   │   │   ├── Bridge-handle-02.png
│   │   │   ├── Bridge.png
│   │   │   ├── Bush-Background.png
│   │   │   ├── Bush-Green-Foreground.png
│   │   │   ├── Bush-Purple-Foreground.png
│   │   │   ├── Cave-Background-Hole-01.png
│   │   │   ├── Cave-Background-Rocks-01.png
│   │   │   ├── Cave-Background-Rocks-02.png
│   │   │   ├── Cave-Background.png
│   │   │   ├── Cave-Entrance.png
│   │   │   ├── Grass-Green-Foreground.png
│   │   │   ├── Grass-Purple-Foreground.png
│   │   │   ├── House-01.png
│   │   │   ├── House-02.png
│   │   │   ├── House-Background-01.png
│   │   │   ├── House-Background-02
│   │   │   ├── Lamp-Off.png
│   │   │   ├── Lamp-On.png
│   │   │   └── Mushrooms.png
│   │   ├── NPC
│   │   │   ├── NPC-Alchemist-Idle-24x24.png
│   │   │   ├── NPC-Blacksmith-Idle-48x48.png
│   │   │   ├── NPC-Builder-01-Working-24x24.png
│   │   │   ├── NPC-Builder-02-Working-24x24.png
│   │   │   ├── NPC-Chick-Idle-16x16.png
│   │   │   ├── NPC-Miner-Idle-24x24.png
│   │   │   ├── NPC-Old-Shaman-Idle-24x24.png
│   │   │   ├── NPC-Puppy-Idle-24x24.png
│   │   │   ├── NPC-Village-Guard-Idle-32x32.png
│   │   │   ├── NPC-Village-Lady-01-Talk-24x24.png
│   │   │   └── NPC-Village-Lady-02-Idle-24x24.png
│   │   ├── Objects
│   │   │   ├── Obj-Arrow-Idle-12x12.png
│   │   │   ├── Obj-Arrow-Stuck-12x12.png
│   │   │   ├── Obj-Axe-Wood.png
│   │   │   ├── Obj-Barrel.png
│   │   │   ├── Obj-Big-Wood-Platform-01.png
│   │   │   ├── Obj-Big-Wood-Platform-02.png
│   │   │   ├── Obj-Blue-Mineral.png
│   │   │   ├── Obj-Boxes.png
│   │   │   ├── Obj-Cage.png
│   │   │   ├── Obj-Checkpoint-Off.png
│   │   │   ├── Obj-Checkpoint-On.png
│   │   │   ├── Obj-Chest-Closed-24x24.png
│   │   │   ├── Obj-Chest-Opening-24x24.png
│   │   │   ├── Obj-Crystal-Idle-32x32.png
│   │   │   ├── Obj-Crystal-Open-32x32.png
│   │   │   ├── Obj-Dreamcatcher-01.png
│   │   │   ├── Obj-Dreamcatcher-02.png
│   │   │   ├── Obj-Dreamcatcher-03.png
│   │   │   ├── Obj-Fence.png
│   │   │   ├── Obj-Flag-Hanging-01.png
│   │   │   ├── Obj-Gate-Hold.png
│   │   │   ├── Obj-Gate-Pillar.png
│   │   │   ├── Obj-Green-Mineral.png
│   │   │   ├── Obj-Hanging-Flag-01.png
│   │   │   ├── Obj-Hanging-Flag-02.png
│   │   │   ├── Obj-Hanging-Flag-Medium.png
│   │   │   ├── Obj-Idol.png
│   │   │   ├── Obj-Key.png
│   │   │   ├── Obj-Lamp-On.png
│   │   │   ├── Obj-Light-01.png
│   │   │   ├── Obj-Mine-Carriage.png
│   │   │   ├── Obj-Moving-Platform-Idle-48x28.png
│   │   │   ├── Obj-Orange-Mineral.png
│   │   │   ├── Obj-Pickaxe.png
│   │   │   ├── Obj-Roof-Hanging.png
│   │   │   ├── Obj-Short-Roof.png
│   │   │   ├── Obj-Stairs.png
│   │   │   ├── Obj-Statue.png
│   │   │   ├── Obj-Village-Gate-Top.png
│   │   │   ├── Obj-Wood-Pillar-01.png
│   │   │   ├── Obj-Wood-Platform-01.png
│   │   │   ├── Obj-Wood-Platform-02.png
│   │   │   ├── Obj-Wood-Platform-Tall-02.png
│   │   │   ├── Obj-Wood-Platform-Tall.png
│   │   │   ├── Obj-Wood-Platform-Top.png
│   │   │   └── Obj-Wood.png
│   │   ├── Player
│   │   │   ├── Player-Attack-24x24.png
│   │   │   ├── Player-Fall-24x24.png
│   │   │   ├── Player-Idle-24x24.png
│   │   │   ├── Player-Jump-24x24.png
│   │   │   └── Player-Run-24x24.png
│   │   ├── Tiles
│   │   │   ├── Cave-Under-Tile.png
│   │   │   ├── Tile-01.png
│   │   │   ├── Tile-02.png
│   │   │   ├── Tile-03.png
│   │   │   ├── Tile-04.png
│   │   │   ├── Tile-05.png
│   │   │   ├── Tile-06.png
│   │   │   ├── Tile-07.png
│   │   │   ├── Tile-08.png
│   │   │   ├── Tile-09.png
│   │   │   ├── Tile-10.png
│   │   │   ├── Tile-11.png
│   │   │   ├── Tile-12.png
│   │   │   ├── Tile-13.png
│   │   │   ├── Tile-14.png
│   │   │   ├── Tile-15.png
│   │   │   ├── Tile-16.png
│   │   │   ├── Tile-17.png
│   │   │   ├── Tile-18.png
│   │   │   ├── Tile-19.png
│   │   │   ├── Tile-20.png
│   │   │   ├── Tile-21.png
│   │   │   ├── Tile-22.png
│   │   │   ├── Tile-23.png
│   │   │   ├── Tile-24.png
│   │   │   ├── Tile-25.png
│   │   │   ├── Tile-26.png
│   │   │   ├── Tile-27.png
│   │   │   ├── Tile-28.png
│   │   │   ├── Tile-29.png
│   │   │   ├── Tile-30.png
│   │   │   ├── Tile-31.png
│   │   │   ├── Tile-32.png
│   │   │   ├── Tile-33.png
│   │   │   ├── Tile-34.png
│   │   │   ├── Tile-35.png
│   │   │   ├── Tile-36.png
│   │   │   ├── Tile-37.png
│   │   │   ├── Tree-Trunk-01.png
│   │   │   └── Tree-Trunk-02.png
│   │   └── UI
│   │       ├── Quest-Mark-Idle-16x16.png
│   │       ├── UI-Boss-Icon.png
│   │       ├── UI-Lives.png
│   │       ├── UI-Menu-Button-Active.png
│   │       ├── UI-Menu-Button-Default.png
│   │       └── UI-Menu-Popup-Background.png
│   ├── PixelWhite.png
│   ├── Shikashi's Fantasy Icons Pack v2
│   │   ├── #1 - Transparent Icons.png
│   │   ├── #2 - Transparent Icons & Drop Shadow.png
│   │   ├── BG 10.png
│   │   ├── BG 11.png
│   │   ├── BG 3a.png
│   │   ├── BG 3b.png
│   │   ├── BG 3c.png
│   │   ├── BG 4a.png
│   │   ├── BG 4b.png
│   │   ├── BG 5.png
│   │   ├── BG 6.png
│   │   ├── BG 7.png
│   │   ├── BG 8.png
│   │   ├── BG 9.png
│   │   ├── Background 1a.png
│   │   ├── Background 1b.png
│   │   ├── Background 2.png
│   │   └── Shikashi's Fantasy Icons Pack.txt
│   ├── Tiny RPG Character Asset Pack v1.03 -Free Soldier&Orc
│   │   ├── Arrow(Projectile)
│   │   │   ├── Arrow01(100x100).png
│   │   │   └── Arrow01(32x32).png
│   │   ├── Aseprite file
│   │   │   ├── Orc.aseprite
│   │   │   └── Soldier.aseprite
│   │   └── Characters(100x100)
│   │       ├── Orc
│   │       │   ├── Orc
│   │       │   │   ├── Orc-Attack01.png
│   │       │   │   ├── Orc-Attack02.png
│   │       │   │   ├── Orc-Death.png
│   │       │   │   ├── Orc-Hurt.png
│   │       │   │   ├── Orc-Idle-Anim.anim
│   │       │   │   ├── Orc-Idle.png
│   │       │   │   ├── Orc-Idle_0.controller
│   │       │   │   ├── Orc-Walk.png
│   │       │   │   ├── Orc.png
│   │       │   │   └── Shadow sprites
│   │       │   │       ├── Orc-shadow.png
│   │       │   │       ├── Orc-shadow_attack02.png
│   │       │   │       └── Orc-shadow_death.png
│   │       │   ├── Orc with shadows
│   │       │   │   ├── Orc-Attack01.png
│   │       │   │   ├── Orc-Attack02.png
│   │       │   │   ├── Orc-Death.png
│   │       │   │   ├── Orc-Hurt.png
│   │       │   │   ├── Orc-Idle.png
│   │       │   │   ├── Orc-Walk.png
│   │       │   │   └── Orc.png
│   │       │   └── Orc(Split Effects)
│   │       │       ├── Orc-attack01_Effect.png
│   │       │       ├── Orc-attack02_Effect.png
│   │       │       └── Orc.png
│   │       └── Soldier
│   │           ├── Arrow(projectile)
│   │           │   ├── Arrow01(100x100).png
│   │           │   └── Arrow01(32x32).png
│   │           ├── Soldier
│   │           │   ├── Shadow sprites
│   │           │   │   ├── Soldier-Shadow.png
│   │           │   │   └── Soldier-Shadow_death.png
│   │           │   ├── Soldier-Attack01.png
│   │           │   ├── Soldier-Attack02.png
│   │           │   ├── Soldier-Attack03.png
│   │           │   ├── Soldier-Death.png
│   │           │   ├── Soldier-Hurt.png
│   │           │   ├── Soldier-Idle.png
│   │           │   ├── Soldier-Shadow_attack2.png
│   │           │   ├── Soldier-Walk.png
│   │           │   └── Soldier.png
│   │           ├── Soldier with shadows
│   │           │   ├── Soldier-Attack01.png
│   │           │   ├── Soldier-Attack02.png
│   │           │   ├── Soldier-Attack03.png
│   │           │   ├── Soldier-Death.png
│   │           │   ├── Soldier-Hurt.png
│   │           │   ├── Soldier-Idle-Anim.anim
│   │           │   ├── Soldier-Idle.png
│   │           │   ├── Soldier-Idle_0.controller
│   │           │   ├── Soldier-Walk.png
│   │           │   ├── Soldier.png
│   │           │   └── WizardPrefab.controller
│   │           └── Soldier(Split Effects)
│   │               ├── Soldier-Attack01_Effect.png
│   │               ├── Soldier-Attack02_Effect.png
│   │               ├── Soldier-Attack03_Effect.png
│   │               └── Soldier.png
│   └── Wizard Pack
│       ├── Attack1.png
│       ├── Attack2.png
│       ├── Death.png
│       ├── Fall.png
│       ├── Hit.png
│       ├── Idle.png
│       ├── Jump.png
│       └── Run.png
├── Test
├── TextMesh Pro
│   ├── Examples & Extras
│   │   ├── Fonts
│   │   │   ├── Anton OFL.txt
│   │   │   ├── Anton.ttf
│   │   │   ├── Bangers - OFL.txt
│   │   │   ├── Bangers.ttf
│   │   │   ├── Electronic Highway Sign.TTF
│   │   │   ├── Oswald-Bold - OFL.txt
│   │   │   ├── Oswald-Bold.ttf
│   │   │   ├── Roboto-Bold - AFL.txt
│   │   │   ├── Roboto-Bold - License.txt
│   │   │   ├── Roboto-Bold.ttf
│   │   │   ├── Unity - OFL.txt
│   │   │   └── Unity.ttf
│   │   ├── Materials
│   │   │   ├── Crate - Surface Shader Scene.mat
│   │   │   ├── Crate - URP.mat
│   │   │   ├── Ground - Logo Scene.mat
│   │   │   ├── Ground - Surface Shader Scene.mat
│   │   │   ├── Ground - URP.mat
│   │   │   └── Small Crate_diffuse.mat
│   │   ├── Prefabs
│   │   │   ├── Text Popup.prefab
│   │   │   ├── TextMeshPro - Prefab 1.prefab
│   │   │   └── TextMeshPro - Prefab 2.prefab
│   │   ├── Resources
│   │   │   ├── Color Gradient Presets
│   │   │   │   ├── Blue to Purple - Vertical.asset
│   │   │   │   ├── Dark to Light Green - Vertical.asset
│   │   │   │   ├── Light to Dark Green - Vertical.asset
│   │   │   │   └── Yellow to Orange - Vertical.asset
│   │   │   ├── Fonts & Materials
│   │   │   │   ├── Anton SDF - Drop Shadow.mat
│   │   │   │   ├── Anton SDF - Outline.mat
│   │   │   │   ├── Anton SDF - Sunny Days.mat
│   │   │   │   ├── Anton SDF.asset
│   │   │   │   ├── Bangers SDF - Drop Shadow - 2 Pass.mat
│   │   │   │   ├── Bangers SDF - Drop Shadow.mat
│   │   │   │   ├── Bangers SDF - Outline.mat
│   │   │   │   ├── Bangers SDF Glow.mat
│   │   │   │   ├── Bangers SDF Logo - URP.mat
│   │   │   │   ├── Bangers SDF Logo.mat
│   │   │   │   ├── Bangers SDF.asset
│   │   │   │   ├── Electronic Highway Sign SDF.asset
│   │   │   │   ├── LiberationSans SDF - Metalic Green.mat
│   │   │   │   ├── LiberationSans SDF - Overlay.mat
│   │   │   │   ├── LiberationSans SDF - Soft Mask.mat
│   │   │   │   ├── Oswald Bold SDF.asset
│   │   │   │   ├── Roboto-Bold SDF - Drop Shadow.mat
│   │   │   │   ├── Roboto-Bold SDF - HDRP Unlit.mat
│   │   │   │   ├── Roboto-Bold SDF - Surface.mat
│   │   │   │   ├── Roboto-Bold SDF - URP.mat
│   │   │   │   ├── Roboto-Bold SDF.asset
│   │   │   │   ├── Unity SDF - HDRP LIT - Bloom.mat
│   │   │   │   ├── Unity SDF - HDRP LIT - Outline.mat
│   │   │   │   └── Unity SDF.asset
│   │   │   └── Sprite Assets
│   │   │       ├── Default Sprite Asset.asset
│   │   │       └── DropCap Numbers.asset
│   │   ├── Scenes
│   │   │   ├── 01-  Single Line TextMesh Pro.unity
│   │   │   ├── 02 - Multi-line TextMesh Pro.unity
│   │   │   ├── 03 - Line Justification.unity
│   │   │   ├── 04 - Word Wrapping.unity
│   │   │   ├── 05 - Style Tags.unity
│   │   │   ├── 06 - Extra Rich Text Examples.unity
│   │   │   ├── 07 - Superscript & Subscript Example.unity
│   │   │   ├── 08 - Improved Text Alignment.unity
│   │   │   ├── 09 - Margin Tag Example.unity
│   │   │   ├── 10 - Bullets & Numbered List Example.unity
│   │   │   ├── 11 - The Style Tag.unity
│   │   │   ├── 12 - Link Example.unity
│   │   │   ├── 12a - Text Interactions.unity
│   │   │   ├── 13 - Soft Hyphenation.unity
│   │   │   ├── 14 - Multi Font & Sprites.unity
│   │   │   ├── 15 - Inline Graphics & Sprites.unity
│   │   │   ├── 16 - Linked text overflow mode example.unity
│   │   │   ├── 17 - Old Computer Terminal.unity
│   │   │   ├── 18 - ScrollRect & Masking & Layout.unity
│   │   │   ├── 19 - Masking Texture & Soft Mask.unity
│   │   │   ├── 20 - Input Field with Scrollbar.unity
│   │   │   ├── 21 - Script Example.unity
│   │   │   ├── 22 - Basic Scripting Example.unity
│   │   │   ├── 23 - Animating Vertex Attributes.unity
│   │   │   ├── 24 - Surface Shader Example URP.unity
│   │   │   ├── 24 - Surface Shader Example.unity
│   │   │   ├── 25 - Sunny Days Example.unity
│   │   │   ├── 26 - Dropdown Placeholder Example.unity
│   │   │   ├── 27 - Double Pass Shader Example.unity
│   │   │   ├── 28 - HDRP Shader Example
│   │   │   │   └── Sky and Fog Volume Profile.asset
│   │   │   ├── 28 - HDRP Shader Example.unity
│   │   │   └── Benchmark (Floating Text).unity
│   │   ├── Scripts
│   │   │   ├── Benchmark01.cs
│   │   │   ├── Benchmark01_UGUI.cs
│   │   │   ├── Benchmark02.cs
│   │   │   ├── Benchmark03.cs
│   │   │   ├── Benchmark04.cs
│   │   │   ├── CameraController.cs
│   │   │   ├── ChatController.cs
│   │   │   ├── DropdownSample.cs
│   │   │   ├── EnvMapAnimator.cs
│   │   │   ├── ObjectSpin.cs
│   │   │   ├── ShaderPropAnimator.cs
│   │   │   ├── SimpleScript.cs
│   │   │   ├── SkewTextExample.cs
│   │   │   ├── TMP_DigitValidator.cs
│   │   │   ├── TMP_ExampleScript_01.cs
│   │   │   ├── TMP_FrameRateCounter.cs
│   │   │   ├── TMP_PhoneNumberValidator.cs
│   │   │   ├── TMP_TextEventCheck.cs
│   │   │   ├── TMP_TextEventHandler.cs
│   │   │   ├── TMP_TextInfoDebugTool.cs
│   │   │   ├── TMP_TextSelector_A.cs
│   │   │   ├── TMP_TextSelector_B.cs
│   │   │   ├── TMP_UiFrameRateCounter.cs
│   │   │   ├── TMPro_InstructionOverlay.cs
│   │   │   ├── TeleType.cs
│   │   │   ├── TextConsoleSimulator.cs
│   │   │   ├── TextMeshProFloatingText.cs
│   │   │   ├── TextMeshSpawner.cs
│   │   │   ├── VertexColorCycler.cs
│   │   │   ├── VertexJitter.cs
│   │   │   ├── VertexShakeA.cs
│   │   │   ├── VertexShakeB.cs
│   │   │   ├── VertexZoom.cs
│   │   │   └── WarpTextExample.cs
│   │   ├── Sprites
│   │   │   ├── Default Sprites.png
│   │   │   └── DropCap Numbers.psd
│   │   └── Textures
│   │       ├── Brushed Metal 3.jpg
│   │       ├── Floor Cement.jpg
│   │       ├── Floor Tiles 1 - diffuse.jpg
│   │       ├── Fruit Jelly (B&W).jpg
│   │       ├── Gradient Diagonal (Color).jpg
│   │       ├── Gradient Horizontal (Color).jpg
│   │       ├── Gradient Vertical (Color).jpg
│   │       ├── Mask Zig-n-Zag.psd
│   │       ├── Small Crate_diffuse.jpg
│   │       ├── Small Crate_normal.jpg
│   │       ├── Sunny Days - Seamless.jpg
│   │       ├── Text Overflow - Linked Text Image 1.png
│   │       ├── Text Overflow - Linked Text UI Screenshot.png
│   │       ├── Wipe Pattern - Circle.psd
│   │       ├── Wipe Pattern - Diagonal.psd
│   │       ├── Wipe Pattern - Radial Double.psd
│   │       └── Wipe Pattern - Radial Quad.psd
│   ├── Fonts
│   │   ├── LiberationSans - OFL.txt
│   │   └── LiberationSans.ttf
│   ├── Resources
│   │   ├── Fonts & Materials
│   │   │   ├── LiberationSans SDF - Drop Shadow.mat
│   │   │   ├── LiberationSans SDF - Fallback.asset
│   │   │   ├── LiberationSans SDF - Outline.mat
│   │   │   └── LiberationSans SDF.asset
│   │   ├── LineBreaking Following Characters.txt
│   │   ├── LineBreaking Leading Characters.txt
│   │   ├── Sprite Assets
│   │   │   └── EmojiOne.asset
│   │   ├── Style Sheets
│   │   │   └── Default Style Sheet.asset
│   │   └── TMP Settings.asset
│   ├── Shaders
│   │   ├── SDFFunctions.hlsl
│   │   ├── TMP_Bitmap-Custom-Atlas.shader
│   │   ├── TMP_Bitmap-Mobile.shader
│   │   ├── TMP_Bitmap.shader
│   │   ├── TMP_SDF Overlay.shader
│   │   ├── TMP_SDF SSD.shader
│   │   ├── TMP_SDF-HDRP LIT.shadergraph
│   │   ├── TMP_SDF-HDRP UNLIT.shadergraph
│   │   ├── TMP_SDF-Mobile Masking.shader
│   │   ├── TMP_SDF-Mobile Overlay.shader
│   │   ├── TMP_SDF-Mobile SSD.shader
│   │   ├── TMP_SDF-Mobile-2-Pass.shader
│   │   ├── TMP_SDF-Mobile.shader
│   │   ├── TMP_SDF-Surface-Mobile.shader
│   │   ├── TMP_SDF-Surface.shader
│   │   ├── TMP_SDF-URP Lit.shadergraph
│   │   ├── TMP_SDF-URP Unlit.shadergraph
│   │   ├── TMP_SDF.shader
│   │   ├── TMP_Sprite.shader
│   │   ├── TMPro.cginc
│   │   ├── TMPro_Mobile.cginc
│   │   ├── TMPro_Properties.cginc
│   │   └── TMPro_Surface.cginc
│   └── Sprites
│       ├── EmojiOne Attribution.txt
│       ├── EmojiOne.json
│       └── EmojiOne.png
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\SpellProjectile.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SpellProjectile : MonoBehaviour
{
    [Header("Projectile Stats")]
    public float damage;
    public float speed;
    [Tooltip("If true, the projectile will be destroyed upon hitting a wizard.")]
    public bool destroyOnHit = true;

    [Header("Burning Effect (optional)")]
    public float burningDamage;   // DPS
    public float burningDuration; // Duration in seconds

    [Header("Friendly Fire")]
    public bool friendlyFire = false;
    public bool casterIsEnemy = false;

    public void Initialize(float dmg, float spd)
    {
        damage = dmg;
        speed = spd;
    }

    private void Update()
    {
        transform.Translate(Vector2.up * speed * Time.deltaTime);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        WizardController wizard = collision.GetComponent<WizardController>();
        if (wizard != null)
        {
            // If friendly fire is disabled and the hit wizard is on the same team, ignore.
            if (!friendlyFire && wizard.isEnemy == casterIsEnemy)
                return;

            wizard.TakeDamage(damage);
            if (burningDamage > 0 && burningDuration > 0)
            {
                wizard.ApplyStatusEffect(new BurningStatusEffect(burningDuration, burningDamage));
            }
            if (destroyOnHit)
                Destroy(gameObject);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\BurningStatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public class BurningStatusEffect : StatusEffect
{
    public BurningStatusEffect(float d, float dps) : base(d, dps) { }

    public override void UpdateEffect(WizardController wizard, float deltaTime)
    {
        elapsed += deltaTime;
        wizard.TakeDamage(damagePerSecond * deltaTime);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\StatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public abstract class StatusEffect
{
    public float duration; // Total duration.
    public float damagePerSecond;
    protected float elapsed = 0f;

    // Public property to expose elapsed time.
    public float Elapsed { get { return elapsed; } }

    public StatusEffect(float d, float dps)
    {
        duration = d;
        damagePerSecond = dps;
    }

    public abstract void UpdateEffect(WizardController wizard, float deltaTime);
    public bool IsExpired() => elapsed >= duration;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public Vector2 editorPosition;
    
    public Color backgroundColor = Color.gray;
    public string description = ""; // Ensure this field exists.

    public List<NodePort> inputs;
    public List<NodePort> outputs;
    public List<NodeEffectData> effects;

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
        inputs = new List<NodePort>();
        outputs = new List<NodePort>();
        effects = new List<NodeEffectData>();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;

// [CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    public string displayName;
    public Color backgroundColor = Color.gray;
    [TextArea] public string description;
    public List<PortDefinition> ports;
    public List<NodeEffectData> effects = new List<NodeEffectData>();

#if UNITY_EDITOR
    private void OnValidate()
    {
        if (string.IsNullOrEmpty(displayName))
        {
            string path = UnityEditor.AssetDatabase.GetAssetPath(this);
            string fileName = System.IO.Path.GetFileNameWithoutExtension(path);
            string[] parts = fileName.Split('_');
            if (parts.Length >= 3)
            {
                displayName = string.Join("_", parts.Skip(2).ToArray());
            }
        }
    }
#endif

    private void OnEnable()
    {
        // Auto-add default General ports if none exist.
        if (ports == null || ports.Count == 0)
        {
            ports = new List<PortDefinition>();
            PortDefinition inputPort = new PortDefinition { portName = "Input", portType = PortType.General, isInput = true };
            PortDefinition outputPort = new PortDefinition { portName = "Output", portType = PortType.General, isInput = false };
            ports.Add(inputPort);
            ports.Add(outputPort);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿// Assets/Scripts/Nodes/Core/NodeDefinitionLibrary.cs
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    public List<NodeDefinition> definitions;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿// Assets/Scripts/Nodes/Core/NodeEffectData.cs
using System;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;  
    public float effectValue;       // For ManaStorage => capacity
    public float secondaryValue;    // For ManaStorage => current / starting
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿public enum NodeEffectType
{
    ManaCost,
    Damage,
    ManaStorage,
    ManaRechargeRate,
    Output,
    AimSpread,    // formerly Accuracy
    Burning,
    Piercing,
    FriendlyFire
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodePort.cs
////////////////////////////////////////////////////////////////////////////////
﻿/* Assets/Scripts/Nodes/Core/NodePort.cs
   Represents a single port on a NodeData (input or output). */

using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodePort
{
    public string portId;
    public string portName;
    public PortType portType;
    public List<string> connectedPortIds;

    public NodePort()
    {
        portId = Guid.NewGuid().ToString();
        connectedPortIds = new List<string>();
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\OutputNodeEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Linq;

public class OutputNodeEffect : MonoBehaviour
{
    public void Activate(float finalDamage, float aimSpreadModifier, float burningDamage, float burningDuration, bool piercing, bool friendlyFire)
    {
        // Use FindObjectsByType
        WizardController[] allWizards = Object.FindObjectsByType<WizardController>(FindObjectsSortMode.None);
        WizardController wizard = allWizards.FirstOrDefault(w => !w.isEnemy);

        if (wizard != null)
        {
            float finalAimSpread = Mathf.Clamp(wizard.baseAimSpread + aimSpreadModifier, 0f, 180f);
            wizard.CastSpell(finalDamage, finalAimSpread, burningDamage, burningDuration, piercing, friendlyFire);
            Debug.Log($"[OutputNodeEffect] Spell cast with damage: {finalDamage}, final aim spread: {finalAimSpread}, burning: {burningDamage} DPS for {burningDuration}s, piercing: {piercing}, friendlyFire: {friendlyFire}");
        }
        else
        {
            Debug.LogWarning("[OutputNodeEffect] No player WizardController found!");
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\PortDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// Assets/Scripts/Nodes/Core/PortDefinition.cs
using System;
using UnityEngine;

public enum PortType
{
    General,
    Mana,
    Condition
}

[Serializable]
public class PortDefinition
{
    public string portName;
    public PortType portType;
    public bool isInput;
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro;

public class NodeExecutor : MonoBehaviour
{
    [SerializeField] private NodeGraph currentGraph;

    [Header("Debug Settings")]
    public float waitTimeBetweenNodes = 0.5f;
    public TMP_Text debugOutput;

    private float totalDamage = 0f;
    private float totalManaCost = 0f;
    private List<string> skippedNodes = new List<string>();

    private void Update()
    {
        RechargeNodesOverTime();

        if (Input.GetKeyDown(KeyCode.Space))
            ExecuteGraph();
    }

    private void RechargeNodesOverTime()
    {
        if (currentGraph == null) return;

        foreach (var node in currentGraph.nodes)
        {
            var storage = node.effects.FirstOrDefault(e => e.effectType == NodeEffectType.ManaStorage);
            if (storage != null)
            {
                float cap = storage.effectValue;
                float cur = storage.secondaryValue;
                var rateEff = node.effects.FirstOrDefault(e => e.effectType == NodeEffectType.ManaRechargeRate);
                float rate = (rateEff != null) ? rateEff.effectValue : 0f;
                cur += rate * Time.deltaTime;
                if (cur > cap) cur = cap;
                storage.secondaryValue = cur;
            }
        }
    }

    public void SetGraph(NodeGraph graph)
    {
        currentGraph = graph;
    }

    public NodeGraph GetGraph() => currentGraph;

    public void ExecuteGraph()
    {
        if (currentGraph == null || currentGraph.nodes.Count == 0)
        {
            Debug.LogWarning("[NodeExecutor] No graph or no nodes to execute!");
            return;
        }

        totalDamage = 0f;
        totalManaCost = 0f;
        skippedNodes.Clear();

        StopAllCoroutines();
        StartCoroutine(RunChainCoroutine());
    }

    private IEnumerator RunChainCoroutine()
    {
        ClearDebugOutput();
        Dictionary<string, int> inboundCount = BuildInboundCount();
        List<NodeData> startNodes = currentGraph.nodes.Where(n => inboundCount[n.nodeId] == 0).ToList();
        if (startNodes.Count == 0)
        {
            LogDebug("[NodeExecutor] No start nodes found. Aborting run.");
            yield break;
        }

        Queue<NodeData> queue = new Queue<NodeData>();
        HashSet<string> visited = new HashSet<string>();
        foreach (var s in startNodes)
            queue.Enqueue(s);

        List<NodeData> chain = new List<NodeData>();
        while (queue.Count > 0)
        {
            NodeData curr = queue.Dequeue();
            if (visited.Contains(curr.nodeId))
                continue;
            visited.Add(curr.nodeId);
            chain.Add(curr);

            if (currentGraph.adjacency != null && currentGraph.adjacency.ContainsKey(curr.nodeId))
            {
                foreach (var childId in currentGraph.adjacency[curr.nodeId])
                {
                    inboundCount[childId]--;
                    if (inboundCount[childId] <= 0)
                    {
                        NodeData child = currentGraph.nodes.FirstOrDefault(n => n.nodeId == childId);
                        if (child != null)
                            queue.Enqueue(child);
                    }
                }
            }
        }

        string chainLog = string.Join(" -> ", chain.Select(n => n.nodeDisplayName));
        LogDebug("[NodeExecutor] Chain: " + chainLog);

        float accumulatedAimSpreadModifier = 0f;
        float accumulatedBurningDamage = 0f;
        float accumulatedBurningDuration = 0f;
        bool accumulatedPiercing = false;
        bool accumulatedFriendlyFire = false;

        foreach (var node in chain)
        {
            yield return new WaitForSeconds(waitTimeBetweenNodes);
            bool executed = false;
            float cost = node.effects.Where(e => e.effectType == NodeEffectType.ManaCost).Sum(e => e.effectValue);

            if (cost > 0f && (!currentGraph.manaConnections.ContainsKey(node.nodeId) ||
                              string.IsNullOrEmpty(currentGraph.manaConnections[node.nodeId])))
            {
                LogDebug($"[NodeExecutor] Skipping '{node.nodeDisplayName}' - no valid mana source connected.");
                skippedNodes.Add(node.nodeDisplayName);
                continue;
            }

            if (cost <= 0f)
            {
                float dmg = node.effects.Where(e => e.effectType == NodeEffectType.Damage).Sum(e => e.effectValue);
                totalDamage += dmg;
                executed = true;
                LogDebug($"[NodeExecutor] Executed '{node.nodeDisplayName}' with no cost, damage={Mathf.Floor(dmg)}");
            }
            else
            {
                string sourceId = currentGraph.manaConnections[node.nodeId];
                NodeData sourceNode = currentGraph.nodes.FirstOrDefault(n => n.nodeId == sourceId);
                if (sourceNode == null)
                {
                    LogDebug($"[NodeExecutor] Skipping '{node.nodeDisplayName}' - upstream mana node not found.");
                    skippedNodes.Add(node.nodeDisplayName);
                    continue;
                }

                var storageEff = sourceNode.effects.FirstOrDefault(e => e.effectType == NodeEffectType.ManaStorage);
                if (storageEff == null)
                {
                    LogDebug($"[NodeExecutor] Skipping '{node.nodeDisplayName}' - source node '{sourceNode.nodeDisplayName}' has no ManaStorage.");
                    skippedNodes.Add(node.nodeDisplayName);
                    continue;
                }

                float cap = storageEff.effectValue;
                float cur = storageEff.secondaryValue;

                if (cur < cost)
                {
                    LogDebug($"[NodeExecutor] Skipping '{node.nodeDisplayName}' (insufficient mana in '{sourceNode.nodeDisplayName}': {Mathf.Floor(cur)}/{cost}).");
                    skippedNodes.Add(node.nodeDisplayName);
                    continue;
                }
                else
                {
                    cur -= cost;
                    storageEff.secondaryValue = cur;
                    totalManaCost += cost;

                    float dmg = node.effects.Where(e => e.effectType == NodeEffectType.Damage).Sum(e => e.effectValue);
                    totalDamage += dmg;
                    executed = true;
                    LogDebug($"[NodeExecutor] '{node.nodeDisplayName}' executed: cost={Mathf.Floor(cost)}, damage={Mathf.Floor(dmg)}, source='{sourceNode.nodeDisplayName}', leftoverMana={Mathf.Floor(cur)}/{Mathf.Floor(cap)}");
                }
            }

            if (executed)
            {
                foreach (var eff in node.effects)
                {
                    if (eff.effectType == NodeEffectType.AimSpread)
                        accumulatedAimSpreadModifier += eff.effectValue;
                    else if (eff.effectType == NodeEffectType.Burning)
                    {
                        accumulatedBurningDamage += eff.effectValue;
                        accumulatedBurningDuration += eff.secondaryValue;
                    }
                    else if (eff.effectType == NodeEffectType.Piercing)
                        accumulatedPiercing = true;
                    else if (eff.effectType == NodeEffectType.FriendlyFire)
                        accumulatedFriendlyFire = true;
                }
            }

            bool isOutput = node.effects.Any(e => e.effectType == NodeEffectType.Output);
            if (isOutput)
            {
                LogDebug($"[NodeExecutor] Output node '{node.nodeDisplayName}' reached.");
                LogDebug($"[NodeExecutor] Total mana cost: {Mathf.Floor(totalManaCost)}");
                string skipStr = (skippedNodes.Count > 0) ? string.Join(", ", skippedNodes) : "None";
                LogDebug($"[NodeExecutor] Skipped nodes: {skipStr}");
                LogDebug($"[NodeExecutor] Final damage: {Mathf.Floor(totalDamage)}");

                NodeView outputView = FindNodeViewById(node.nodeId);
                if (outputView != null)
                {
                    OutputNodeEffect outputEffect = outputView.GetComponent<OutputNodeEffect>();
                    if (outputEffect != null)
                    {
                        outputEffect.Activate(totalDamage, accumulatedAimSpreadModifier, accumulatedBurningDamage, accumulatedBurningDuration, accumulatedPiercing, accumulatedFriendlyFire);
                    }
                    else
                    {
                        Debug.LogWarning("[NodeExecutor] Output node effect not found on NodeView.");
                    }
                }
            }
        }

        LogDebug("[NodeExecutor] BFS execution complete.");
    }

    private NodeView FindNodeViewById(string nodeId)
    {
        // Use FindObjectsByType
        NodeView[] views = Object.FindObjectsByType<NodeView>(FindObjectsSortMode.None);
        foreach (var view in views)
        {
            if (view.GetNodeData().nodeId == nodeId)
                return view;
        }
        return null;
    }

    private Dictionary<string, int> BuildInboundCount()
    {
        Dictionary<string, int> inboundCount = new Dictionary<string, int>();
        foreach (var node in currentGraph.nodes)
            inboundCount[node.nodeId] = 0;

        if (currentGraph.adjacency != null)
        {
            foreach (var kvp in currentGraph.adjacency)
            {
                foreach (var childId in kvp.Value)
                {
                    inboundCount[childId]++;
                }
            }
        }
        return inboundCount;
    }

    private void ClearDebugOutput()
    {
        if (debugOutput)
            debugOutput.text = "";
    }

    private void LogDebug(string msg)
    {
        Debug.Log(msg);
        if (debugOutput)
            debugOutput.text += msg + "\n";
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes;
    [NonSerialized] public Dictionary<string, List<string>> adjacency;
    [NonSerialized] public Dictionary<string, string> manaConnections;

    public NodeGraph()
    {
        nodes = new List<NodeData>();
        adjacency = new Dictionary<string, List<string>>();
        manaConnections = new Dictionary<string, string>();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\ColorExtensions.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public static class ColorExtensions
{
    public static Color WithAlpha(this Color c, float alpha)
    {
        return new Color(c.r, c.g, c.b, alpha);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeConnectionView.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

[RequireComponent(typeof(RectTransform))]
public class NodeConnectionView : MonoBehaviour, IPointerClickHandler
{
    [SerializeField] private RectTransform startRect;
    [SerializeField] private RectTransform endRect;

    public PinView sourcePin;
    public PinView targetPin;

    private UICubicBezier bezier;
    private RectTransform ownRect;

    private bool isPreviewing = false;
    private bool isFinalized = false;

    private void Awake()
    {
        ownRect = GetComponent<RectTransform>();
        bezier  = GetComponent<UICubicBezier>();
    }

    private void Update()
    {
        // If finalized and either pin is missing, destroy self.
        if (isFinalized && (sourcePin == null || targetPin == null))
        {
            Destroy(gameObject);
            return;
        }

        if (bezier == null || startRect == null)
            return;

        Vector2 localStart;
        RectTransformUtility.ScreenPointToLocalPointInRectangle(ownRect, startRect.position, null, out localStart);

        Vector2 localEnd;
        if (!isPreviewing && endRect != null)
        {
            RectTransformUtility.ScreenPointToLocalPointInRectangle(ownRect, endRect.position, null, out localEnd);
        }
        else
        {
            RectTransformUtility.ScreenPointToLocalPointInRectangle(ownRect, Input.mousePosition, null, out localEnd);
        }

        bezier.UpdateCurve(localStart, localEnd);
    }

    public void StartPreview(RectTransform source)
    {
        startRect = source;
        endRect = null;
        isPreviewing = true;
    }

    public void FinalizeConnection(RectTransform end)
    {
        endRect = end;
        isPreviewing = false;
        isFinalized = true;
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        if (eventData.button == PointerEventData.InputButton.Right)
        {
            Debug.Log("[NodeConnectionView] Deleting connection");
            // Clear references to help garbage collection.
            sourcePin = null;
            targetPin = null;
            Destroy(gameObject);
        }
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeDraggable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

/// <summary>
/// Drags a node in its parent's local space, correctly handling parent scaling & panning.
/// Attach this to each node (NodeView prefab).
/// </summary>
[RequireComponent(typeof(RectTransform))]
public class NodeDraggable : MonoBehaviour, IPointerDownHandler, IDragHandler
{
    private RectTransform nodeRect;      // The node's own RectTransform
    private RectTransform parentRect;    // The parent panel's RectTransform
    private Vector2 pointerOffset;       // Offset between pointer & node's anchoredPosition

    private void Awake()
    {
        nodeRect = GetComponent<RectTransform>();
        parentRect = nodeRect.parent as RectTransform;
        if (parentRect == null)
        {
            Debug.LogError("[NodeDraggable] No parent RectTransform found! Dragging won't work.");
        }
    }

    public void OnPointerDown(PointerEventData eventData)
    {
        // Convert the pointer's screen position to the parent's local coordinates.
        Vector2 localPointerPos;
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(
                parentRect, eventData.position, eventData.pressEventCamera, out localPointerPos))
        {
            // The offset is (nodePosition - pointerPosition) in parent's local space.
            pointerOffset = nodeRect.anchoredPosition - localPointerPos;
        }
    }

    public void OnDrag(PointerEventData eventData)
    {
        Vector2 localPointerPos;
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(
                parentRect, eventData.position, eventData.pressEventCamera, out localPointerPos))
        {
            // On drag, update the node's anchoredPosition so it follows the pointer + offset.
            nodeRect.anchoredPosition = localPointerPos + pointerOffset;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeEditorController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Linq;

public class NodeEditorController : MonoBehaviour, IScrollHandler, IDragHandler
{
    [Header("Window & Content Setup")]
    [Tooltip("The fixed window (NodeEditorWindow) with RectMask2D & CanvasGroup.")]
    [SerializeField] private RectTransform windowRect; // Parent window panel

    [Tooltip("The inner content panel where nodes and connections are spawned.")]
    [SerializeField] private RectTransform contentRect; // Child container for nodes

    [Header("Prefabs")]
    [SerializeField] private GameObject nodeViewPrefab; // Prefab for NodeView
    [SerializeField] private GameObject connectionViewPrefab; // Prefab for connection (with UICubicBezier)

    [Header("Node Definitions")]
    [SerializeField] private NodeDefinitionLibrary definitionLibrary; // For context menu

    [Header("Runtime Graph Reference")]
    [SerializeField] private NodeGraph currentGraph; // Contains nodes, adjacency, manaConnections

    [Header("Optional")]
    [SerializeField] private NodeExecutor executor; // Optional: updates graph

    [Header("Panning/Zoom Settings")]
    [SerializeField] private float contentMargin = 20f; // Minimum margin for content panel

    // For connection dragging:
    private NodeConnectionView draggingLine;
    private PinView sourcePin;

    // Context menu variables:
    private bool showContextMenu = false;
    private Vector2 contextMenuPosition;

    private List<NodeView> spawnedNodeViews = new List<NodeView>();

    private CanvasGroup canvasGroup;

    private void Awake()
    {
        if (windowRect == null)
            windowRect = GetComponent<RectTransform>();

        canvasGroup = GetComponent<CanvasGroup>();
        if (canvasGroup == null)
            canvasGroup = gameObject.AddComponent<CanvasGroup>();

        Image bg = GetComponent<Image>();
        if (bg == null)
        {
            bg = gameObject.AddComponent<Image>();
            bg.color = new Color(1, 1, 1, 0);
            bg.raycastTarget = true;
        }
    }

    private void Start()
    {
        if (currentGraph == null)
            currentGraph = new NodeGraph();

        if (executor == null)
        {
            executor = GameObject.FindFirstObjectByType<NodeExecutor>();
            if (executor != null)
                executor.SetGraph(currentGraph);
            else
                Debug.LogWarning("[NodeEditorController] No NodeExecutor found in scene.");
        }

        EnsureContentPanelSize();
    }

    private void Update()
    {
        // Hide context menu on left-click if outside its bounds.
        if (Input.GetMouseButtonDown(0))
        {
            if (showContextMenu && definitionLibrary != null && definitionLibrary.definitions != null)
            {
                Vector2 guiPos = new Vector2(contextMenuPosition.x, Screen.height - contextMenuPosition.y);
                float menuHeight = 20 + (definitionLibrary.definitions.Count * 25);
                Rect menuRect = new Rect(guiPos.x, guiPos.y, 180, menuHeight);

                // Convert Input.mousePosition to the same coordinate space as 'menuRect'.
                // 'menuRect' is in GUI coords => top-left(0,0), so let's do:
                Vector2 mousePos = Input.mousePosition;
                mousePos.y = Screen.height - mousePos.y; 
                // Now 'mousePos' matches the coordinate space of 'menuRect'.

                if (!menuRect.Contains(mousePos))
                    showContextMenu = false;
            }
        }


        if (Input.GetKeyDown(KeyCode.Tab))
            ToggleVisibility();

        if (Input.GetKeyDown(KeyCode.Delete))
        {
            if (NodeSelectable.CurrentSelected != null)
                DeleteSelectedNode();
        }

        if (Input.GetMouseButtonDown(1))
        {
            showContextMenu = true;
            contextMenuPosition = Input.mousePosition;
        }
    }

    private void ToggleVisibility()
    {
        if (canvasGroup.alpha > 0)
        {
            canvasGroup.alpha = 0;
            canvasGroup.interactable = false;
            canvasGroup.blocksRaycasts = false;
        }
        else
        {
            canvasGroup.alpha = 1;
            canvasGroup.interactable = true;
            canvasGroup.blocksRaycasts = true;
        }
    }

    private void OnGUI()
    {
        if (showContextMenu && definitionLibrary != null && definitionLibrary.definitions.Count > 0)
        {
            Vector2 guiPos = new Vector2(contextMenuPosition.x, Screen.height - contextMenuPosition.y);
            float menuHeight = 20 + (definitionLibrary.definitions.Count * 25);
            Rect menuRect = new Rect(guiPos.x, guiPos.y, 180, menuHeight);

            // If a left-click occurs outside the menu, hide it.
            if (Event.current.type == EventType.MouseDown && Event.current.button == 0)
            {
                if (!menuRect.Contains(Event.current.mousePosition))
                {
                    showContextMenu = false;
                }
            }

            GUI.Box(menuRect, "Add Node");

            float yOffset = 20f;
            foreach (NodeDefinition def in definitionLibrary.definitions)
            {
                Rect itemRect = new Rect(menuRect.x, menuRect.y + yOffset, 180, 25);
                if (GUI.Button(itemRect, def.displayName))
                {
                    CreateNodeAtMouse(def);
                    showContextMenu = false;
                }
                yOffset += 25f;
            }
        }
    }

    private void CreateNodeAtMouse(NodeDefinition definition)
    {
        Vector2 localPos;
        RectTransformUtility.ScreenPointToLocalPointInRectangle(contentRect, Input.mousePosition, null, out localPos);

        NodeData newNode = new NodeData();
        newNode.nodeDisplayName = definition.displayName;
        newNode.editorPosition = localPos;
        newNode.backgroundColor = definition.backgroundColor;
        newNode.description = definition.description; // Copy description from preset

        foreach (var defEffect in definition.effects)
        {
            NodeEffectData effectCopy = new NodeEffectData
            {
                effectType = defEffect.effectType,
                effectValue = defEffect.effectValue,
                secondaryValue = defEffect.secondaryValue
            };
            newNode.effects.Add(effectCopy);
        }

        foreach (var portDef in definition.ports)
        {
            NodePort nodePort = new NodePort
            {
                portName = portDef.portName,
                portType = portDef.portType
            };

            if (portDef.isInput)
                newNode.inputs.Add(nodePort);
            else
                newNode.outputs.Add(nodePort);
        }

        currentGraph.nodes.Add(newNode);
        CreateNodeView(newNode);
        EnsureContentPanelSize();

        if (executor != null)
            executor.SetGraph(currentGraph);
    }

    private NodeView CreateNodeView(NodeData data)
    {
        GameObject nodeObj = Instantiate(nodeViewPrefab, contentRect);
        NodeView view = nodeObj.GetComponent<NodeView>();

        view.Initialize(data, data.backgroundColor, data.nodeDisplayName);

        RectTransform rt = nodeObj.GetComponent<RectTransform>();
        rt.anchoredPosition = data.editorPosition;

        view.GeneratePins(data.inputs, data.outputs);

        if (data.effects.Any(e => e.effectType == NodeEffectType.Output))
        {
            if (nodeObj.GetComponent<OutputNodeEffect>() == null)
                nodeObj.AddComponent<OutputNodeEffect>();
        }

        spawnedNodeViews.Add(view);
        return view;
    }

    // --- Deletion Logic ---
    private void DeleteSelectedNode()
    {
        NodeView selectedView = NodeSelectable.CurrentSelected.GetComponent<NodeView>();
        if (selectedView == null)
            return;

        string nodeId = selectedView.GetNodeData().nodeId;
        currentGraph.nodes.RemoveAll(n => n.nodeId == nodeId);

        if (currentGraph.adjacency != null)
        {
            currentGraph.adjacency.Remove(nodeId);
            foreach (var kvp in currentGraph.adjacency)
            {
                kvp.Value.RemoveAll(childId => childId == nodeId);
            }
        }

        if (currentGraph.manaConnections != null)
        {
            List<string> keysToRemove = new List<string>();
            foreach (var kvp in currentGraph.manaConnections)
            {
                if (kvp.Key == nodeId || kvp.Value == nodeId)
                    keysToRemove.Add(kvp.Key);
            }
            foreach (var key in keysToRemove)
                currentGraph.manaConnections.Remove(key);
        }

        // Use FindObjectsByType instead of FindObjectsOfType
        NodeConnectionView[] allLines = Object.FindObjectsByType<NodeConnectionView>(FindObjectsSortMode.None);
        foreach (var line in allLines)
        {
            if (line.sourcePin != null)
            {
                NodeView srcView = line.sourcePin.GetComponentInParent<NodeView>();
                if (srcView == null || srcView.GetNodeData().nodeId == nodeId)
                {
                    Destroy(line.gameObject);
                    continue;
                }
            }
            if (line.targetPin != null)
            {
                NodeView tgtView = line.targetPin.GetComponentInParent<NodeView>();
                if (tgtView == null || tgtView.GetNodeData().nodeId == nodeId)
                {
                    Destroy(line.gameObject);
                    continue;
                }
            }
        }

        Destroy(NodeSelectable.CurrentSelected);
        NodeSelectable.CurrentSelected = null;
    }

    // --- Connection Dragging Methods ---
    public void StartConnectionDrag(PinView source, PointerEventData eventData)
    {
        Debug.Log("[NodeEditor] StartConnectionDrag called!");
        sourcePin = source;

        GameObject lineObj = Instantiate(connectionViewPrefab, contentRect);
        draggingLine = lineObj.GetComponent<NodeConnectionView>();

        RectTransform sourceRect = source.GetComponent<RectTransform>();
        draggingLine.sourcePin = source;
        draggingLine.StartPreview(sourceRect);
    }

    public void UpdateConnectionDrag(PinView draggingPin, PointerEventData eventData)
    {
        // Preview updated within NodeConnectionView.
    }

    public void EndConnectionDrag(PinView draggingPin, PointerEventData eventData)
    {
        if (draggingLine == null)
            return;

        List<RaycastResult> results = new List<RaycastResult>();
        EventSystem.current.RaycastAll(eventData, results);
        PinView targetPin = null;
        foreach (var r in results)
        {
            targetPin = r.gameObject.GetComponent<PinView>();
            if (targetPin != null && targetPin.isInput)
                break;
            else
                targetPin = null;
        }

        if (targetPin != null)
        {
            RectTransform targetRect = targetPin.GetComponent<RectTransform>();
            draggingLine.targetPin = targetPin;
            draggingLine.FinalizeConnection(targetRect);

            if (sourcePin.port.portType == PortType.Mana && targetPin.port.portType == PortType.Mana)
            {
                string sourceId = GetNodeIdFromPin(sourcePin);
                string targetId = GetNodeIdFromPin(targetPin);
                if (currentGraph.manaConnections == null)
                    currentGraph.manaConnections = new Dictionary<string, string>();
                currentGraph.manaConnections[targetId] = sourceId;
            }
            else if (sourcePin.port.portType == PortType.General && targetPin.port.portType == PortType.General)
            {
                string sourceId = GetNodeIdFromPin(sourcePin);
                string targetId = GetNodeIdFromPin(targetPin);
                if (currentGraph.adjacency == null)
                    currentGraph.adjacency = new Dictionary<string, List<string>>();
                if (!currentGraph.adjacency.ContainsKey(sourceId))
                    currentGraph.adjacency[sourceId] = new List<string>();
                if (!currentGraph.adjacency[sourceId].Contains(targetId))
                    currentGraph.adjacency[sourceId].Add(targetId);
            }

            Debug.Log("[NodeEditor] Connection finalized.");
        }
        else
        {
            Debug.Log("[NodeEditor] Connection canceled.");
            Destroy(draggingLine.gameObject);
        }

        draggingLine = null;
        sourcePin = null;
    }

    // --- Zooming & Panning ---
    public void OnScroll(PointerEventData eventData)
    {
        Debug.Log($"[NodeEditor] OnScroll: {eventData.scrollDelta}");
        float scrollDelta = eventData.scrollDelta.y;
        float newScale = contentRect.localScale.x + scrollDelta * 0.05f;
        newScale = Mathf.Clamp(newScale, 0.5f, 2f);
        contentRect.localScale = Vector3.one * newScale;
        EnsureContentPanelSize();
    }

    public void OnDrag(PointerEventData eventData)
    {
        Debug.Log($"[NodeEditor] OnDrag: {eventData.delta}");
        contentRect.anchoredPosition += eventData.delta;
        EnsureContentPanelSize();
    }

    private void EnsureContentPanelSize()
    {
        if (windowRect == null || contentRect == null)
            return;

        Vector2 windowSize = windowRect.rect.size;
        Vector2 minSize = windowSize + new Vector2(contentMargin * 2, contentMargin * 2);

        if (spawnedNodeViews.Count > 0)
        {
            Vector2 minPos = new Vector2(float.MaxValue, float.MaxValue);
            Vector2 maxPos = new Vector2(float.MinValue, float.MinValue);
            foreach (var view in spawnedNodeViews)
            {
                RectTransform rt = view.GetComponent<RectTransform>();
                Vector2 pos = rt.anchoredPosition;
                Vector2 size = rt.rect.size;
                minPos = Vector2.Min(minPos, pos - size * 0.5f);
                maxPos = Vector2.Max(maxPos, pos + size * 0.5f);
            }
            Vector2 nodesBounds = maxPos - minPos;
            minSize = Vector2.Max(minSize, nodesBounds + new Vector2(contentMargin * 2, contentMargin * 2));
        }

        Vector2 currentSize = contentRect.sizeDelta;
        float newWidth = Mathf.Max(currentSize.x, minSize.x);
        float newHeight = Mathf.Max(currentSize.y, minSize.y);
        contentRect.sizeDelta = new Vector2(newWidth, newHeight);
    }

    // --- Load Graph ---
    public void LoadGraph(NodeGraph graph)
    {
        currentGraph = graph;
        ClearExistingViews();
        if (currentGraph == null) return;

        foreach (var node in currentGraph.nodes)
        {
            CreateNodeView(node);
        }

        if (executor != null)
            executor.SetGraph(currentGraph);
    }

    // --- Helper Methods ---
    public string GetNodeIdFromPin(PinView pin)
    {
        NodeView view = pin.GetComponentInParent<NodeView>();
        return view.GetNodeData().nodeId;
    }

    public NodeGraph CurrentGraph => currentGraph;

    private void ClearExistingViews()
    {
        foreach (var view in spawnedNodeViews)
        {
            if (view != null)
                Destroy(view.gameObject);
        }
        spawnedNodeViews.Clear();
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeSelectable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class NodeSelectable : MonoBehaviour, IPointerClickHandler
{
    // Public static property to hold the currently selected node.
    public static GameObject CurrentSelected { get; set; }

    [SerializeField] private Outline outline;

    private void Awake()
    {
        if (outline != null)
            outline.enabled = false;
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        Select(gameObject);
    }

    public static void Select(GameObject node)
    {
        if (CurrentSelected != null && CurrentSelected != node)
        {
            // Disable outline on previously selected node.
            var prevOutline = CurrentSelected.GetComponent<Outline>();
            if (prevOutline != null)
                prevOutline.enabled = false;
        }
        CurrentSelected = node;
        var outlineComp = node.GetComponent<Outline>();
        if (outlineComp != null)
            outlineComp.enabled = true;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeTestInitializer.cs
////////////////////////////////////////////////////////////////////////////////
﻿// Assets/Scripts/Nodes/Testing/NodeTestInitializer.cs
using UnityEngine;
// If NodeEditorController is in a specific namespace, include it, e.g.:
// using YourProject.Nodes.UI;

public class NodeTestInitializer : MonoBehaviour
{
    [SerializeField] private NodeEditorController editorController;

    private NodeGraph testGraph;

    void Start()
    {
        testGraph = new NodeGraph();
        // Load the empty graph into the editor
        editorController.LoadGraph(testGraph);
    }
    
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeView.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;
using System.Linq;

public class NodeView : MonoBehaviour
{
    [SerializeField] private TMP_Text nodeTitleText;
    [SerializeField] private Image backgroundImage;

    [Header("Pin Containers")]
    [SerializeField] private Transform inputPinsContainer;
    [SerializeField] private Transform outputPinsContainer;

    [Header("Node Info Display")]
    [SerializeField] private TMP_Text manaStorageText;
    [SerializeField] private TMP_Text effectsText;
    [SerializeField] private TMP_Text descriptionText; // Separate text field for description

    private NodeData nodeData;

    private void Update()
    {
        var manaEff = nodeData.effects.FirstOrDefault(e => e.effectType == NodeEffectType.ManaStorage);
        if (manaEff != null && manaStorageText != null)
        {
            float cap = Mathf.Floor(manaEff.effectValue);
            float cur = Mathf.Floor(manaEff.secondaryValue);
            manaStorageText.text = $"Mana: {cur}/{cap}";
        }
    }

    public void Initialize(NodeData data, Color color, string displayName)
    {
        nodeData = data;
        if (nodeTitleText) 
            nodeTitleText.text = displayName;
        if (backgroundImage) 
            backgroundImage.color = color;

        // Build effects text.
        if (effectsText)
        {
            if (nodeData.effects.Count == 0)
                effectsText.text = "No Effects";
            else
            {
                string str = "Effects:\n";
                foreach (var eff in nodeData.effects)
                    str += $"- {eff.effectType} ({eff.effectValue})\n";
                effectsText.text = str;
            }
        }

        // Display description in cursive using <i> tags.
        if (descriptionText)
            descriptionText.text = $"{nodeData.description}";

        // If node has a ManaStorage effect, update manaStorageText.
        var manaEff = nodeData.effects.FirstOrDefault(e => e.effectType == NodeEffectType.ManaStorage);
        if (manaEff != null && manaStorageText != null)
            manaStorageText.text = $"Mana: {manaEff.secondaryValue}/{manaEff.effectValue}";
    }

    public void GeneratePins(List<NodePort> inputs, List<NodePort> outputs)
    {
        foreach (Transform child in inputPinsContainer)
            Destroy(child.gameObject);
        foreach (Transform child in outputPinsContainer)
            Destroy(child.gameObject);

        foreach (var input in inputs)
            CreatePin(inputPinsContainer, input, true);
        foreach (var output in outputs)
            CreatePin(outputPinsContainer, output, false);
    }

    private void CreatePin(Transform parent, NodePort port, bool isInput)
    {
        GameObject pinObj = new GameObject(isInput ? "InputPin" : "OutputPin", typeof(RectTransform));
        pinObj.transform.SetParent(parent, false);
        RectTransform rt = pinObj.GetComponent<RectTransform>();
        rt.sizeDelta = new Vector2(20, 20);
        Image img = pinObj.AddComponent<Image>();
        switch (port.portType)
        {
            case PortType.Mana:
                img.color = Color.cyan;
                break;
            case PortType.Condition:
                img.color = new Color(1f, 0.65f, 0f);
                break;
            default:
                img.color = Color.blue;
                break;
        }
        PinView pinView = pinObj.AddComponent<PinView>();
        NodeEditorController controller = UnityEngine.Object.FindFirstObjectByType<NodeEditorController>();
        pinView.Initialize(port, isInput, controller);
    }

    public NodeData GetNodeData() => nodeData;
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\PinView.cs
////////////////////////////////////////////////////////////////////////////////
﻿// Assets/Scripts/Nodes/UI/PinView.cs
using UnityEngine;
using UnityEngine.EventSystems;

public class PinView : MonoBehaviour, IPointerDownHandler, IDragHandler, IPointerUpHandler
{
    public NodePort port;
    public bool isInput;
    private NodeEditorController nodeEditor;

    public void Initialize(NodePort nodePort, bool isInputPin, NodeEditorController editor)
    {
        port = nodePort;
        isInput = isInputPin;
        nodeEditor = editor;
    }

    public void OnPointerDown(PointerEventData eventData)
    {
        Debug.Log($"[PinView] Clicked on {(isInput ? "Input" : "Output")} port of node: {port.portName}");

        if (!isInput && nodeEditor != null)
        {
            Debug.Log("[PinView] Starting connection drag...");
            nodeEditor.StartConnectionDrag(this, eventData);
        }
        else
        {
            Debug.LogWarning("[PinView] Attempted to start a connection from an input pin.");
        }
    }

    public void OnDrag(PointerEventData eventData)
    {
        if (nodeEditor != null)
        {
            nodeEditor.UpdateConnectionDrag(this, eventData);
        }
    }

    public void OnPointerUp(PointerEventData eventData)
    {
        if (nodeEditor != null)
        {
            nodeEditor.EndConnectionDrag(this, eventData);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\UICubicBezier.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

[RequireComponent(typeof(CanvasRenderer))]
public class UICubicBezier : MaskableGraphic
{
    [Range(2, 100)] public int segments = 30;
    public float lineThickness = 4f;

    [Header("Positions in local space")]
    public Vector2 startPos;
    public Vector2 endPos;

    private List<Vector2> sampledPoints = new List<Vector2>();

    protected override void Awake()
    {
        base.Awake();
        // With MaskableGraphic, the property "maskable" is available.
        this.maskable = true;
    }

    protected override void OnPopulateMesh(VertexHelper vh)
{
    vh.Clear();
    sampledPoints.Clear();

    if ((startPos - endPos).sqrMagnitude < 1f)
        return;

    // Create control points (S-curve style)
    float dx = (endPos.x - startPos.x) * 0.5f;
    Vector2 ctrl1 = startPos + new Vector2(dx, 0f);
    Vector2 ctrl2 = endPos - new Vector2(dx, 0f);

    // Sample the curve
    for (int i = 0; i <= segments; i++)
    {
        float t = i / (float)segments;
        Vector2 p = CubicBezier(startPos, ctrl1, ctrl2, endPos, t);
        sampledPoints.Add(p);
    }

    // We define an "outer ring" (alpha=0) and an "inner ring" (alpha=1)
    // so we can fade out the edges.
    float outerThickness = lineThickness * 0.5f;
    float innerThickness = outerThickness - 1f; // 1px fade region

    for (int i = 0; i < sampledPoints.Count - 1; i++)
    {
        Vector2 p0 = sampledPoints[i];
        Vector2 p1 = sampledPoints[i + 1];

        Vector2 dir = (p1 - p0).normalized;
        Vector2 normal = new Vector2(-dir.y, dir.x);

        // Outer ring (alpha=0)
        Vector2 v0 = p0 + normal * outerThickness;
        Vector2 v1 = p0 - normal * outerThickness;
        Vector2 v2 = p1 - normal * outerThickness;
        Vector2 v3 = p1 + normal * outerThickness;

        // Inner ring (alpha=1)
        Vector2 v0i = p0 + normal * innerThickness;
        Vector2 v1i = p0 - normal * innerThickness;
        Vector2 v2i = p1 - normal * innerThickness;
        Vector2 v3i = p1 + normal * innerThickness;

        int idx = vh.currentVertCount;

        // Add 8 vertices (outer ring + inner ring)
        vh.AddVert(v0, new Color(color.r, color.g, color.b, 0), Vector2.zero);
        vh.AddVert(v1, new Color(color.r, color.g, color.b, 0), Vector2.zero);
        vh.AddVert(v2, new Color(color.r, color.g, color.b, 0), Vector2.zero);
        vh.AddVert(v3, new Color(color.r, color.g, color.b, 0), Vector2.zero);

        vh.AddVert(v0i, new Color(color.r, color.g, color.b, 1), Vector2.zero);
        vh.AddVert(v1i, new Color(color.r, color.g, color.b, 1), Vector2.zero);
        vh.AddVert(v2i, new Color(color.r, color.g, color.b, 1), Vector2.zero);
        vh.AddVert(v3i, new Color(color.r, color.g, color.b, 1), Vector2.zero);

        // Bridge the outer ring (alpha=0) to the inner ring (alpha=1)
        vh.AddTriangle(idx,   idx+4, idx+5);
        vh.AddTriangle(idx,   idx+5, idx+1);

        vh.AddTriangle(idx+1, idx+5, idx+6);
        vh.AddTriangle(idx+1, idx+6, idx+2);

        vh.AddTriangle(idx+2, idx+6, idx+7);
        vh.AddTriangle(idx+2, idx+7, idx+3);

        vh.AddTriangle(idx+3, idx+7, idx+4);
        vh.AddTriangle(idx+3, idx+4, idx);

        // **Fill the center** (the inner ring) so we don't just get an outline
        vh.AddTriangle(idx+4, idx+5, idx+6);
        vh.AddTriangle(idx+4, idx+6, idx+7);
    }
}



    private Vector2 CubicBezier(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, float t)
    {
        float u = 1f - t;
        float tt = t * t;
        float uu = u * u;
        float uuu = uu * u;
        float ttt = tt * t;

        Vector2 p = uuu * p0;
        p += 3f * uu * t * p1;
        p += 3f * u * tt * p2;
        p += ttt * p3;
        return p;
    }

    private void AddQuad(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, VertexHelper vh)
    {
        int idx = vh.currentVertCount;

        // Vertices on the "edge" get alpha = 0, center vertices get alpha = 1
        Color edgeColor = new Color(color.r, color.g, color.b, 0);
        Color centerColor = new Color(color.r, color.g, color.b, 1);

        vh.AddVert(v0, edgeColor, Vector2.zero);
        vh.AddVert(v1, edgeColor, Vector2.zero);
        vh.AddVert(v2, edgeColor, Vector2.zero);
        vh.AddVert(v3, edgeColor, Vector2.zero);

        // Two triangles
        vh.AddTriangle(idx, idx + 1, idx + 2);
        vh.AddTriangle(idx, idx + 2, idx + 3);
    }


    /// <summary>
    /// Updates the curve’s start and end positions in local coordinates and forces a redraw.
    /// </summary>
    public void UpdateCurve(Vector2 startLocal, Vector2 endLocal)
    {
        startPos = startLocal;
        endPos = endLocal;
        SetVerticesDirty();
    }

    /// <summary>
    /// Custom Raycast so that pointer events only register if the pointer is near the line.
    /// </summary>
    public override bool Raycast(Vector2 sp, Camera eventCamera)
    {
        Vector2 localPos;
        if (!RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, sp, eventCamera, out localPos))
            return false;

        if (sampledPoints.Count < 2)
            return false;

        float maxDist = lineThickness * 0.5f + 2f;
        float minDistance = float.MaxValue;

        for (int i = 0; i < sampledPoints.Count - 1; i++)
        {
            Vector2 segStart = sampledPoints[i];
            Vector2 segEnd = sampledPoints[i + 1];
            float dist = DistanceToSegment(localPos, segStart, segEnd);
            if (dist < minDistance)
                minDistance = dist;
            if (minDistance < maxDist)
                return true;
        }
        return false;
    }

    private float DistanceToSegment(Vector2 p, Vector2 a, Vector2 b)
    {
        Vector2 ap = p - a;
        Vector2 ab = b - a;
        float abSqr = ab.sqrMagnitude;
        float dot = Vector2.Dot(ap, ab) / abSqr;
        dot = Mathf.Clamp01(dot);
        Vector2 proj = a + ab * dot;
        return (p - proj).magnitude;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Wizards\WizardController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;
using System.Collections.Generic;

public enum FiringDirection
{
    Up,
    Down
}

public class WizardController : MonoBehaviour
{
    [Header("Wizard Configuration")]
    public bool isEnemy = false;

    [Header("Wizard Stats")]
    public float maxHP = 100f;
    public float currentHP;
    [Tooltip("Base aim spread in degrees; higher values mean a wider spread.")]
    public float baseAimSpread = 5f;

    [Header("Firing Settings")]
    [Tooltip("Determines if the wizard fires upward (default) or downward.")]
    public FiringDirection firingDirection = FiringDirection.Up;
    [Tooltip("The transform where spells are spawned. Its original Y value is used as reference.")]
    public Transform spellSpawnPoint;
    [Tooltip("Projectile prefab to be cast.")]
    public GameObject spellProjectilePrefab;
    public float projectileSpeed = 10f;
    [Tooltip("Enable friendly fire (projectile can damage friendlies)")]
    public bool friendlyFireEnabled = false;

    [Header("UI")]
    public TMP_Text hpText;

    private float originalSpawnY = 0f;
    public List<StatusEffect> activeStatusEffects = new List<StatusEffect>();

    private void Awake()
    {
        currentHP = maxHP;
        UpdateHPUI();

#if UNITY_EDITOR
        // Store the original Y value if not already stored.
        if (spellSpawnPoint != null && originalSpawnY == 0f)
            originalSpawnY = spellSpawnPoint.localPosition.y;
#endif
    }

#if UNITY_EDITOR
    private void OnValidate()
    {
        // When the firing direction changes, update spellSpawnPoint's Y coordinate.
        if (spellSpawnPoint != null)
        {
            // Ensure we have stored the original Y value.
            if (originalSpawnY == 0f)
                originalSpawnY = spellSpawnPoint.localPosition.y;

            Vector2 pos = spellSpawnPoint.localPosition;
            if (firingDirection == FiringDirection.Down)
                pos.y = -Mathf.Abs(originalSpawnY);
            else
                pos.y = Mathf.Abs(originalSpawnY);
            spellSpawnPoint.localPosition = pos;
        }
    }
#endif

    public void TakeDamage(float damage)
    {
        currentHP -= damage;
        if (currentHP < 0)
            currentHP = 0;
        UpdateHPUI();
        if (currentHP <= 0)
        {
            Debug.Log($"{gameObject.name} has been defeated.");
            // Add additional death logic if needed.
        }
    }

    private void UpdateHPUI()
    {
        if (hpText != null)
            hpText.text = $"HP: {Mathf.Floor(currentHP)}/{maxHP}";
    }

    /// <summary>
    /// Casts a spell. The projectile is spawned at spellSpawnPoint.
    /// The projectile's rotation is based on firingDirection and a random deviation within ±finalAimSpread.
    /// Also passes burning and friendly-fire parameters.
    /// </summary>
    public void CastSpell(float finalDamage, float finalAimSpread, float burningDamage, float burningDuration, bool piercing, bool friendlyFire)
    {
        if (isEnemy)
            return; // Enemies do not cast spells via node chain.

        if (spellProjectilePrefab == null || spellSpawnPoint == null)
        {
            Debug.LogWarning("Spell projectile prefab or spawn point not set.");
            return;
        }

        // Base rotation: for Up, identity; for Down, flip 180°.
        Quaternion baseRotation = (firingDirection == FiringDirection.Up) ? Quaternion.identity : Quaternion.Euler(0, 0, 180);
        float deviation = Random.Range(-finalAimSpread, finalAimSpread);
        Quaternion finalRotation = baseRotation * Quaternion.Euler(0, 0, deviation);

        GameObject projObj = Instantiate(spellProjectilePrefab, spellSpawnPoint.position, finalRotation);
        SpellProjectile projectile = projObj.GetComponent<SpellProjectile>();
        if (projectile != null)
        {
            projectile.Initialize(finalDamage, projectileSpeed);
            projectile.burningDamage = burningDamage;
            projectile.burningDuration = burningDuration;
            projectile.destroyOnHit = !piercing; // If piercing is true, do not destroy.
            projectile.friendlyFire = friendlyFire;
            projectile.casterIsEnemy = isEnemy;
        }
    }

    private void Update()
    {
        float delta = Time.deltaTime;
        for (int i = activeStatusEffects.Count - 1; i >= 0; i--)
        {
            activeStatusEffects[i].UpdateEffect(this, delta);
            if (activeStatusEffects[i].IsExpired())
                activeStatusEffects.RemoveAt(i);
        }
    }

    public void ApplyStatusEffect(StatusEffect effect)
    {
        activeStatusEffects.Add(effect);
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Wizards\WizardPreset.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;


[CreateAssetMenu(fileName = "WizardPreset", menuName = "Wizards/WizardPreset")]
public class WizardPreset : ScriptableObject
{
    public string presetName;
    public float maxHP = 100f;
    public float accuracy = 5f;      // In degrees: how much the projectile can deviate.
    public float critChance = 0f;    // Future use.
    public FiringDirection baseFiringDirection = FiringDirection.Up;
    // Add additional stats as needed.
}

