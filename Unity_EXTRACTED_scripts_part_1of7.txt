This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-05-26 16:14:09
PART 1 OF 7
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantOutline.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           ├── DualGridRuleTile_Grass.asset
│           └── DualGridRuleTile_Water.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_PoopFertilizer.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       ├── Wave_001.asset
│       └── Wave_002.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── LeafData.cs
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.Cell.cs
│   │   │   ├── PlantGrowth.Growth.cs
│   │   │   ├── PlantGrowth.NodeExecution.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── SlowdownZone.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManagement.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── OutlinePartController.cs
│       ├── PlantOutlineController.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       └── ShadowPartController.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Sprite-Lit-Advanced_Overlay_Base.mat
│   ├── Sprite-Lit-Default_OverlayAdvanced.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   ├── SpriteEmissiveUnlit.shader
│   └── WaterReflection.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionAutoAdder.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionAutoAdder : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets,
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string folderPath = Path.GetDirectoryName(assetPath);
                string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
                if (libraryFiles.Length > 0)
                {
                    NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
                    if (library != null && !library.definitions.Contains(nodeDef))
                    {
                        library.definitions.Add(nodeDef);
                        EditorUtility.SetDirty(library);
                        AssetDatabase.SaveAssets();
                    }
                }
            }
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionCreator.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;

public static class NodeDefinitionCreator
{
    private const string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

    [MenuItem(MenuPath, false, 50)]
    public static void CreateNodeDefinition()
    {
        // Figure out which folder the user is in, or use Assets/
        string folder = GetSelectedPathOrFallback();

        // Determine the next numeric index for "Node_XXX_"
        int nextNumber = GetNextNodeNumber(folder);

        // e.g., "Node_007_"
        string newName = $"Node_{nextNumber:D3}_";
        string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

        // Create the NodeDefinition
        NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
        AssetDatabase.CreateAsset(nodeDef, newPath);
        
        // Save and refresh, but DO NOT select or focus the ProjectWindow.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        Debug.Log($"Created NodeDefinition at: {newPath}");
        // Notice we don't call Selection.activeObject = nodeDef
        // or EditorUtility.FocusProjectWindow()
        // or ProjectWindowUtil.ShowCreatedAsset(nodeDef)
        // thus we avoid changing the user's folder.
    }

    // (Optional) Validate the menu item so it’s disabled if the game is running
    [MenuItem(MenuPath, true)]
    private static bool ValidateCreateNodeDefinition()
    {
        return !Application.isPlaying;
    }

    private static string GetSelectedPathOrFallback()
    {
        // Attempt to get the folder the user has selected in the Project window
        string path = "Assets";
        foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets))
        {
            path = AssetDatabase.GetAssetPath(obj);
            if (!string.IsNullOrEmpty(path))
            {
                // If it's a file, get its parent folder
                if (File.Exists(path))
                {
                    path = Path.GetDirectoryName(path);
                }
                break;
            }
        }
        return path;
    }

    private static int GetNextNodeNumber(string folderPath)
    {
        int nextNumber = 1;
        // Look for existing Node_XXX_ files
        string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
        foreach (var file in files)
        {
            string fName = Path.GetFileNameWithoutExtension(file);
            if (fName.StartsWith("Node_") && fName.Length >= 8)
            {
                // extract the 3-digit number from Node_000_
                string numberPart = fName.Substring(5, 3);
                if (int.TryParse(numberPart, out int num) && num >= nextNumber)
                {
                    nextNumber = num + 1;
                }
            }
        }
        return nextNumber;
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(NodeDefinition))]
public class NodeDefinitionEditor : Editor
{
    // Serialized properties for all the fields in NodeDefinition
    SerializedProperty displayName;
    SerializedProperty description;
    SerializedProperty thumbnail;
    SerializedProperty thumbnailTintColor;
    SerializedProperty backgroundColor;
    SerializedProperty nodeViewPrefab;
    SerializedProperty effects;

    private void OnEnable()
    {
        displayName = serializedObject.FindProperty("displayName");
        description = serializedObject.FindProperty("description");
        thumbnail = serializedObject.FindProperty("thumbnail");
        thumbnailTintColor = serializedObject.FindProperty("thumbnailTintColor");
        backgroundColor = serializedObject.FindProperty("backgroundColor");
        nodeViewPrefab = serializedObject.FindProperty("nodeViewPrefab");
        effects = serializedObject.FindProperty("effects");
    }

    public override void OnInspectorGUI()
    {
        serializedObject.Update();

        // "Display" section
        EditorGUILayout.LabelField("Display", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(displayName);
        EditorGUILayout.PropertyField(description);
        EditorGUILayout.PropertyField(thumbnail);
        EditorGUILayout.PropertyField(thumbnailTintColor);
        EditorGUILayout.PropertyField(backgroundColor);

        EditorGUILayout.Space();

        // "Prefab & Effects" section
        EditorGUILayout.LabelField("Prefab & Effects", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(nodeViewPrefab);

        // Draw the effects field with a minimum height
        EditorGUILayout.PropertyField(effects, new GUIContent("Effects"), true, GUILayout.MinHeight(1300f));

        serializedObject.ApplyModifiedProperties();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionLibraryEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;

[CustomEditor(typeof(NodeDefinitionLibrary))]
public class NodeDefinitionLibraryEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            UpdateLibrary();
        }
    }

    private void UpdateLibrary()
    {
        NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

        // Get the folder of the current library asset.
        string libraryPath = AssetDatabase.GetAssetPath(library);
        string folderPath = Path.GetDirectoryName(libraryPath);

        // Find all .asset files in the folder.
        string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

        // Load NodeDefinition assets from that folder.
        List<NodeDefinition> defs = new List<NodeDefinition>();
        foreach (string file in assetFiles)
        {
            // Ignore the library asset itself.
            if (file == libraryPath)
                continue;

            NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
            if (def != null)
                defs.Add(def);
        }

        // Sort definitions by the numeric portion in the file name (assumes "Node_XXX_...").
        defs = defs.OrderBy(d => {
            string name = d.name;
            if (name.StartsWith("Node_") && name.Length >= 8)
            {
                string numStr = name.Substring(5, 3);
                if (int.TryParse(numStr, out int num))
                    return num;
            }
            return int.MaxValue; // if no number is found, sort last.
        }).ToList();

        library.definitions = defs;
        EditorUtility.SetDirty(library);
        AssetDatabase.SaveAssets();
        Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionPostprocessor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionPostprocessor : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, 
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string fileName = Path.GetFileNameWithoutExtension(assetPath);
                // Check if file name already starts with "Node_"
                if (!fileName.StartsWith("Node_"))
                {
                    string folderPath = Path.GetDirectoryName(assetPath);
                    // Get all files in folder that start with "Node_"
                    var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
                    int nextNumber = 1;
                    foreach (var file in files)
                    {
                        string fName = Path.GetFileNameWithoutExtension(file);
                        string[] parts = fName.Split('_');
                        if (parts.Length >= 2 && int.TryParse(parts[1], out int num))
                        {
                            if (num >= nextNumber)
                                nextNumber = num + 1;
                        }
                    }
                    string newName = $"Node_{nextNumber:D3}_";
                    AssetDatabase.RenameAsset(assetPath, newName);
                    AssetDatabase.SaveAssets();
                }
            }
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeEffectDrawer.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Editor/NodeEffectDrawer.cs
using UnityEngine;
using UnityEditor;

[CustomPropertyDrawer(typeof(NodeEffectData))]
public class NodeEffectDrawer : PropertyDrawer
{
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        EditorGUI.BeginProperty(position, label, property);

        // Get properties
        var effectTypeProp = property.FindPropertyRelative("effectType");
        var primaryValueProp = property.FindPropertyRelative("primaryValue");
        var secondaryValueProp = property.FindPropertyRelative("secondaryValue");
        var isPassiveProp = property.FindPropertyRelative("isPassive");
        // var scentIdentifierProp = property.FindPropertyRelative("scentIdentifier"); // REMOVED
        var scentDefRefProp = property.FindPropertyRelative("scentDefinitionReference"); // ADDED

        // Calculate rects - basic vertical layout
        Rect typeRect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);
        Rect passiveRect = new Rect(position.x, typeRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight);
        Rect primaryRect = new Rect(position.x, passiveRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight);
        Rect secondaryRect = new Rect(position.x, primaryRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight);
        Rect scentRect = new Rect(position.x, secondaryRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight); // Reuse rect position

        // Draw fields
        EditorGUI.PropertyField(typeRect, effectTypeProp);
        EditorGUI.PropertyField(passiveRect, isPassiveProp);

        // Determine labels based on type
        GUIContent primaryLabel = new GUIContent(primaryValueProp.displayName);
        GUIContent secondaryLabel = new GUIContent(secondaryValueProp.displayName);

        NodeEffectType currentType = (NodeEffectType)effectTypeProp.enumValueIndex;

        bool showScentField = false;
        switch (currentType)
        {
            case NodeEffectType.ScentModifier:
                primaryLabel.text = "Radius Bonus"; // Contextual label
                secondaryLabel.text = "Strength Bonus"; // Contextual label
                showScentField = true;
                break;
            case NodeEffectType.Damage:
                primaryLabel.text = "Damage Multiplier Add";
                break;
             // Add other cases...
            default:
                break;
        }

        EditorGUI.PropertyField(primaryRect, primaryValueProp, primaryLabel);
        EditorGUI.PropertyField(secondaryRect, secondaryValueProp, secondaryLabel);

        // Conditionally draw scent definition Object Field
        if (showScentField)
        {
            // Draw Object Field restricted to ScentDefinition type
            EditorGUI.ObjectField(scentRect, scentDefRefProp, typeof(ScentDefinition), new GUIContent("Scent Definition")); // Use correct label
        }

        EditorGUI.EndProperty();
    }

    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
    {
        float height = EditorGUIUtility.singleLineHeight; // Type
        height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Passive
        height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Primary
        height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Secondary

        // Add height for scent field only if needed
        var effectTypeProp = property.FindPropertyRelative("effectType");
        NodeEffectType currentType = (NodeEffectType)effectTypeProp.enumValueIndex;
        if (currentType == NodeEffectType.ScentModifier)
        {
            height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Scent Definition Reference
        }

        return height;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\LeafData.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/LeafData.cs
using UnityEngine;

/// <summary>
/// Class to store information about leaves for regrowth tracking
/// </summary>
[System.Serializable]
public class LeafData
{
    public Vector2Int GridCoord;
    public bool IsActive; // True if the leaf exists, false if it was eaten
    
    public LeafData(Vector2Int coord, bool isActive = true)
    {
        GridCoord = coord;
        IsActive = isActive;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantCell.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantCell.cs (Fix Leaf Tracking)

using UnityEngine;

// Define the enum here if it's closely tied to PlantCell,
// or move it to a separate file (e.g., PlantEnums.cs) for better organization.
public enum PlantCellType { Seed, Stem, Leaf, Flower, Fruit } // <<< ADDED ENUM DEFINITION

public class PlantCell : MonoBehaviour
{
    // Set these references when the cell is spawned by PlantGrowth
    [HideInInspector] public PlantGrowth ParentPlantGrowth;
    [HideInInspector] public Vector2Int GridCoord;
    [HideInInspector] public PlantCellType CellType; // Uses the enum defined above

    // Called automatically by Unity when this GameObject is destroyed
    private void OnDestroy()
    {
        // Notify the parent plant that this cell is gone, if the parent still exists
        if (ParentPlantGrowth != null)
        {
            // If it's a leaf being destroyed, ensure it's marked as inactive for potential regrowth
            if (CellType == PlantCellType.Leaf)
            {
                // Call the plant growth to let it know this is a leaf being destroyed
                // This helps ensure we mark it as inactive for regrowth
                if (Debug.isDebugBuild)
                    Debug.Log($"[PlantCell OnDestroy] Leaf at {GridCoord} is being destroyed - notifying parent plant", gameObject);
            }
            
            // Notify parent to update tracking and handle removal
            ParentPlantGrowth.ReportCellDestroyed(GridCoord);
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.Cell.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.Cell.cs
using System.Collections.Generic;
using System.Linq; // Added this namespace for OrderBy()
using UnityEngine;

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- CELL MANAGEMENT METHODS ---
    // ------------------------------------------------

    public void ReportCellDestroyed(Vector2Int coord)
    {
        if (cells.ContainsKey(coord))
        {
            // Check what type of cell is being destroyed
            PlantCellType cellType = cells[coord];
        
            // If it's a leaf, mark it as inactive for potential regrowth
            if (cellType == PlantCellType.Leaf)
            {
                // Find and update the leaf data
                for (int i = 0; i < leafDataList.Count; i++)
                {
                    if (leafDataList[i].GridCoord == coord)
                    {
                        LeafData updatedData = leafDataList[i];
                        updatedData.IsActive = false; // Mark as eaten/missing
                        leafDataList[i] = updatedData;
                    
                        if (Debug.isDebugBuild)
                            Debug.Log($"[{gameObject.name}] Leaf at {coord} marked as missing for potential regrowth via ReportCellDestroyed.");
                    
                        break;
                    }
                }
            }
        
            cells.Remove(coord);
            // Assume RemovePlantCell(GameObject) will be called externally for proper cleanup
            // We still need to clean the GO list if destruction happened unexpectedly
            activeCellGameObjects.RemoveAll(go => go == null || (go.GetComponent<PlantCell>()?.GridCoord == coord));

            // Trigger outline update after internal state change
            if (enableOutline && outlineController != null)
            {
                outlineController.OnPlantCellRemoved(coord);
            }
        }
    }

    // RemovePlantCell (Handles shadow AND outline unregistration)
    public void RemovePlantCell(GameObject cellToRemove)
    {
        if (cellToRemove == null) return;

        PlantCell cellComp = cellToRemove.GetComponent<PlantCell>();
        if (cellComp == null) { Destroy(cellToRemove); return; } // Destroy if no component

        Vector2Int coord = cellComp.GridCoord;
        
        // NEW: Check if this is a leaf and mark it as inactive in our leaf data list
        if (cellComp.CellType == PlantCellType.Leaf)
        {
            // Find matching leaf data and mark as inactive (missing)
            for (int i = 0; i < leafDataList.Count; i++)
            {
                if (leafDataList[i].GridCoord == coord)
                {
                    LeafData updatedData = leafDataList[i];
                    updatedData.IsActive = false; // Mark as eaten/missing
                    leafDataList[i] = updatedData;
                    
                    if (Debug.isDebugBuild)
                        Debug.Log($"[{gameObject.name}] Leaf at {coord} marked as missing for potential regrowth.");
                    
                    break;
                }
            }
        }

        // --- Unregister Visuals FIRST ---
        // Shadow
        SpriteRenderer partRenderer = cellToRemove.GetComponentInChildren<SpriteRenderer>(); // More robust check
        if (shadowController != null && partRenderer != null) {
            shadowController.UnregisterPlantPart(partRenderer);
        }

        // Outline (this now triggers the update based on internal state)
        // No direct call to outlineController needed here, ReportCellDestroyed handles it.

        // --- Remove from internal tracking ---
        if (cells.ContainsKey(coord)) {
            cells.Remove(coord);
        }
        activeCellGameObjects.Remove(cellToRemove);

        // --- Destroy the GameObject ---
        Destroy(cellToRemove);

        // --- Trigger Outline Update AFTER internal state reflects the removal ---
        // Moved notification to ReportCellDestroyed which should be called by PlantCell OnDestroy
        // If called directly, ensure ReportCellDestroyed is also called or call the outline update here:
        // if (enableOutline && outlineController != null) {
        //     outlineController.OnPlantCellRemoved(coord);
        // }
    }


    // ClearAllVisuals (Combined cleanup helper for Shadows and Outlines)
    private void ClearAllVisuals()
    {
        // Create a copy because RemovePlantCell modifies the list
        List<GameObject> cellsToClear = new List<GameObject>(activeCellGameObjects);
        foreach (GameObject cellGO in cellsToClear) {
            if (cellGO != null) {
                // Directly destroy, OnDestroy in PlantCell calls ReportCellDestroyed -> Outline Update
                Destroy(cellGO);
            }
        }
        // Ensure lists/dicts are clear after iteration
        activeCellGameObjects.Clear();
        cells.Clear();

        // Also clear any outlines that might be orphaned
        if (outlineController != null) {
             // This assumes OutlineController has a method to clear all its parts
             // outlineController.ClearAllOutlineParts();
             // Or simply destroy/recreate the outline controller if simpler
        }

        rootCellInstance = null;
    }


    // SpawnCellVisual - Creates a cell visual GameObject
    private GameObject SpawnCellVisual(PlantCellType cellType, Vector2Int coords,
                                 Dictionary<ScentDefinition, float> accumulatedScentRadiusBonus = null,
                                 Dictionary<ScentDefinition, float> accumulatedScentStrengthBonus = null)
    {
        if (cells.ContainsKey(coords)) {
             Debug.LogWarning($"[{gameObject.name}] Trying to spawn {cellType} at occupied coord {coords}.");
            return null;
        }

        GameObject prefab = null;
        switch (cellType) {
            case PlantCellType.Seed: prefab = seedCellPrefab; break;
            case PlantCellType.Stem: prefab = stemCellPrefab; break;
            case PlantCellType.Leaf: prefab = leafCellPrefab; break;
            case PlantCellType.Fruit: prefab = berryCellPrefab; break;
        }

        if (prefab == null) {
            Debug.LogError($"[{gameObject.name}] Prefab for PlantCellType.{cellType} is null!");
            return null;
        }

        // Create visual cell
        Vector2 worldPos = (Vector2)transform.position + ((Vector2)coords * cellSpacing);
        GameObject instance = Instantiate(prefab, worldPos, Quaternion.identity, transform);
        instance.name = $"{gameObject.name}_{cellType}_{coords.x}_{coords.y}";

        // Set up PlantCell component
        PlantCell cellComp = instance.GetComponent<PlantCell>() ?? instance.AddComponent<PlantCell>();
        cellComp.ParentPlantGrowth = this;
        cellComp.GridCoord = coords;
        cellComp.CellType = cellType;

        // Add to tracking
        cells[coords] = cellType;
        activeCellGameObjects.Add(instance);

        // Set up SortableEntity
        SortableEntity sorter = instance.GetComponent<SortableEntity>() ?? instance.AddComponent<SortableEntity>();
        if (cellType == PlantCellType.Seed) {
            sorter.SetUseParentYCoordinate(false);
        } else {
            sorter.SetUseParentYCoordinate(true);
        }

        // Apply scent data if it's a fruit
        if (cellType == PlantCellType.Fruit) {
            ApplyScentDataToObject(instance, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
        }

        // Register visual effects
        RegisterShadowForCell(instance, cellType.ToString());
        // Outline registration now happens via OnPlantCellAdded call
        if (enableOutline && outlineController != null)
        {
             outlineController.OnPlantCellAdded(coords, instance);
        }

        return instance;
    }

    // --- Helper Methods for Shadow & Outline Integration ---
    private void RegisterShadowForCell(GameObject cellInstance, string cellTypeName)
    {
        if (shadowController == null || shadowPartPrefab == null || cellInstance == null) return;

        SpriteRenderer partRenderer = cellInstance.GetComponentInChildren<SpriteRenderer>(); // More robust
        if (partRenderer != null) {
            shadowController.RegisterPlantPart(partRenderer, shadowPartPrefab);
        } else {
            Debug.LogWarning($"Plant '{gameObject.name}': {cellTypeName} missing SpriteRenderer. No shadow.", cellInstance);
        }
    }

    // REMOVED: RegisterOutlineForCell (Logic moved to SpawnCellVisual calling outlineController.OnPlantCellAdded)

    // --- Stat Calculation ---
    private void CalculateAndApplyStats()
    {
        // (Function body remains the same as before)
        if (nodeGraph == null) {
            Debug.LogError($"[{gameObject.name}] CalculateAndApplyStats called with null NodeGraph!");
            return;
        }

        float baseEnergyStorage = 10f;
        float basePhotosynthesisRate = 0.5f;
        int baseStemMin = 3;
        int baseStemMax = 5;
        float baseGrowthSpeedInterval = 0.5f; // Base time per step
        int baseLeafGap = 1;
        int baseLeafPattern = 0;
        float baseGrowthRandomness = 0.1f;
        float baseCooldown = 5f;
        float baseCastDelay = 0.1f;

        float accumulatedEnergyStorage = 0f;
        float accumulatedPhotosynthesis = 0f;
        int stemLengthModifier = 0;
        float growthSpeedTimeModifier = 0f;
        int leafGapModifier = 0;
        int currentLeafPattern = baseLeafPattern;
        float growthRandomnessModifier = 0f;
        float cooldownModifier = 0f;
        float castDelayModifier = 0f;
        bool seedFound = false;
        
        // Initialize poop fertilizer values to zero
        poopDetectionRadius = 0f;
        poopEnergyBonus = 0f; // Renamed from poopAbsorptionRate

        foreach (NodeData node in nodeGraph.nodes.OrderBy(n => n.orderIndex)) {
            if (node?.effects == null) continue;
            foreach (var effect in node.effects) {
                if (effect == null || !effect.isPassive) continue;
                switch (effect.effectType) {
                    case NodeEffectType.SeedSpawn:
                        seedFound = true;
                        break;
                    case NodeEffectType.EnergyStorage:
                        accumulatedEnergyStorage += effect.primaryValue;
                        break;
                    case NodeEffectType.EnergyPhotosynthesis:
                        accumulatedPhotosynthesis += effect.primaryValue;
                        break;
                    case NodeEffectType.StemLength:
                        stemLengthModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.GrowthSpeed:
                        // Modify the *time interval* per step
                        growthSpeedTimeModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.LeafGap:
                        leafGapModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.LeafPattern:
                        currentLeafPattern = Mathf.Clamp(Mathf.RoundToInt(effect.primaryValue), 0, 4); // Assuming max 4 patterns defined
                        break;
                    case NodeEffectType.StemRandomness:
                        growthRandomnessModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.Cooldown:
                        cooldownModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.CastDelay:
                        castDelayModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.PoopFertilizer:
                        poopDetectionRadius = Mathf.Max(0f, effect.primaryValue);
                        poopEnergyBonus = Mathf.Max(0f, effect.secondaryValue); // Renamed from poopAbsorptionRate
                        break;
                        // Add other passive effects here if needed
                }
            }
        }

        finalMaxEnergy = Mathf.Max(1f, baseEnergyStorage + accumulatedEnergyStorage);
        finalPhotosynthesisRate = Mathf.Max(0f, basePhotosynthesisRate + accumulatedPhotosynthesis);
        int finalStemMin = Mathf.Max(1, baseStemMin + stemLengthModifier);
        int finalStemMax = Mathf.Max(finalStemMin, baseStemMax + stemLengthModifier);
        finalGrowthSpeed = Mathf.Max(0.01f, baseGrowthSpeedInterval + growthSpeedTimeModifier); // This is now TIME PER STEP
        finalLeafGap = Mathf.Max(0, baseLeafGap + leafGapModifier);
        finalLeafPattern = currentLeafPattern;
        finalGrowthRandomness = Mathf.Clamp01(baseGrowthRandomness + growthRandomnessModifier);
        cycleCooldown = Mathf.Max(0.1f, baseCooldown + cooldownModifier);
        nodeCastDelay = Mathf.Max(0.01f, baseCastDelay + castDelayModifier);

        targetStemLength = seedFound ? Random.Range(finalStemMin, finalStemMax + 1) : 0;
        // REMOVED: totalGrowthDuration calculation (less relevant)

        if (!seedFound) {
            Debug.LogWarning($"[{gameObject.name}] NodeGraph lacks SeedSpawn effect. Growth aborted.", gameObject);
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.Growth.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.Growth.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq; // Keep for OrderBy

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- TIME-BASED GROWTH SYSTEM ---                // <<< NEW SYSTEM
    // ------------------------------------------------

    // Helper class to store pre-calculated growth steps (same as before)
    private class GrowthStep
    {
        public PlantCellType CellType;
        public Vector2Int Position;
        public int StemIndex; // Track which stem this belongs to (for percentage)
    }

    // --- GrowthCoroutine_TimeBased ---              // <<< FIXED COROUTINE
    private IEnumerator GrowthCoroutine_TimeBased()
    {
        if (targetStemLength <= 0)
        {
            currentState = PlantState.GrowthComplete;
            growthCoroutine = null;
            yield break;
        }

        List<GrowthStep> growthPlan = PreCalculateGrowthPlan();
        
        // Reset all growth tracking variables
        totalPlannedSteps = growthPlan.Count;
        stepsCompleted = 0;
        actualGrowthProgress = 0f;
        
        if (totalPlannedSteps == 0)
        {
            currentState = PlantState.GrowthComplete;
            growthCoroutine = null;
            yield break;
        }

        // --- Count stem steps for better time estimation ---
        int stemStepsCount = growthPlan.Count(step => step.CellType == PlantCellType.Stem);
        if (stemStepsCount == 0) stemStepsCount = 1; // Safety check

        // --- Initialize Time Variables ---
        currentGrowthElapsedTime = 0f; // Reset elapsed time for this growth cycle
        float baseTimePerStep = finalGrowthSpeed;
        if (baseTimePerStep <= 0.001f) baseTimePerStep = 0.01f;

        // --- Calculate Initial Estimated Total Time (for continuous mode) ---
        float initialTileMultiplier = 1.0f;
        if (PlantGrowthModifierManager.Instance != null)
        {
            initialTileMultiplier = PlantGrowthModifierManager.Instance.GetGrowthSpeedMultiplier(this);
            initialTileMultiplier = Mathf.Clamp(initialTileMultiplier, 0.1f, 10.0f);
        }
        float initialEffectiveTimePerStep = baseTimePerStep / initialTileMultiplier;
        if (initialEffectiveTimePerStep < 0.001f) initialEffectiveTimePerStep = 0.001f;
        
        // --- Use stem count for time estimate, not total steps ---
        estimatedTotalGrowthTime = stemStepsCount * initialEffectiveTimePerStep;
        // Ensure estimated time is at least a small positive value
        if (estimatedTotalGrowthTime < 0.01f) estimatedTotalGrowthTime = 0.01f;

        float lastUpdateTime = Time.time;
        float updateProgressInterval = 0.1f; // Update progress at least every 0.1 seconds

        // --- Track actual progress toward next step ---
        float progressTowardNextStep = 0f;

        // --- Growth Loop ---
        while (stepsCompleted < totalPlannedSteps && currentState == PlantState.Growing)
        {
            // 1. Get Current Frame's Delta Time
            float frameDeltaTime = Time.deltaTime;
            currentGrowthElapsedTime += frameDeltaTime;

            // 2. Get Current Tile Modifier
            float currentTileMultiplier = 1.0f;
            if (PlantGrowthModifierManager.Instance != null)
            {
                currentTileMultiplier = PlantGrowthModifierManager.Instance.GetGrowthSpeedMultiplier(this);
                currentTileMultiplier = Mathf.Clamp(currentTileMultiplier, 0.1f, 10.0f);
            }

            // 3. Calculate current effective time per step
            float currentEffectiveTimePerStep = baseTimePerStep / currentTileMultiplier;
            if (currentEffectiveTimePerStep < 0.001f) currentEffectiveTimePerStep = 0.001f;

            // 4. FIXED: Calculate progress rate - how quickly we accumulate progress relative to base rate
            //    When growth speed increases, we accumulate progress faster proportionally
            float progressRate = initialEffectiveTimePerStep / currentEffectiveTimePerStep;
            
            // 5. Add progress toward next step based on adjusted progress rate
            progressTowardNextStep += frameDeltaTime * progressRate;
            
            // 6. Calculate partial progress (0-1) toward next step for UI smoothness
            actualGrowthProgress = Mathf.Clamp01(progressTowardNextStep / initialEffectiveTimePerStep);
            
            // 7. Check if we've accumulated enough progress for one or more steps
            int stepsToProcessThisFrame = 0;
            
            while (progressTowardNextStep >= initialEffectiveTimePerStep && stepsCompleted < totalPlannedSteps) 
            {
                stepsToProcessThisFrame++;
                progressTowardNextStep -= initialEffectiveTimePerStep;
                
                // Limit steps per frame to prevent lag
                if (stepsToProcessThisFrame >= 3) break;
            }

            // 8. Process the steps
            if (stepsToProcessThisFrame > 0)
            {
                for (int i = 0; i < stepsToProcessThisFrame; i++)
                {
                    int currentPlanIndex = stepsCompleted;
                    if (currentPlanIndex >= totalPlannedSteps) break;

                    GrowthStep step = growthPlan[currentPlanIndex];
                    GameObject spawnedCell = SpawnCellVisual(step.CellType, step.Position, null, null);

                    // Update stem count for discrete percentage display
                    if (step.CellType == PlantCellType.Stem)
                    {
                        currentStemCount = step.StemIndex;
                        if (!continuousIncrement) // Only update UI from here if discrete
                        {
                             UpdateGrowthPercentageUI();
                        }
                    }
                    
                    stepsCompleted++;
                }
                
                lastUpdateTime = Time.time;
                
                // Update partial progress after steps
                actualGrowthProgress = Mathf.Clamp01(progressTowardNextStep / initialEffectiveTimePerStep);
            }
            
            // 9. Update UI based on time interval regardless of steps processed
            if (Time.time - lastUpdateTime > updateProgressInterval)
            {
                if (continuousIncrement)
                {
                    UpdateGrowthPercentageUI();
                }
                lastUpdateTime = Time.time;
            }

            // 10. Yield
            yield return null;
        }

        // Final update to ensure we reach 100%
        currentState = PlantState.GrowthComplete;
        stepsCompleted = totalPlannedSteps;
        actualGrowthProgress = 1.0f;
        growthCoroutine = null;
    }


    // --- PreCalculateGrowthPlan ---                     // <<< NEW HELPER
    /// <summary>
    /// Generates the full sequence of stem and leaf placements based on calculated stats.
    /// </summary>
    /// <returns>A list of GrowthStep objects defining the growth sequence.</returns>
    private List<GrowthStep> PreCalculateGrowthPlan()
    {
        List<GrowthStep> plan = new List<GrowthStep>();
        Vector2Int currentPos = Vector2Int.zero; // Start relative to the seed
        int spiralDir = 1; // Used for spiral pattern
        int patternCount = 0; // Used for alternating patterns

        // Simulate the growth stem by stem
        for (int stemIndex = 1; stemIndex <= targetStemLength; stemIndex++)
        {
            // Determine growth direction for this stem
            Vector2Int growthDir = GetStemDirection(); // Use the randomness calculated in stats
            Vector2Int nextStemPos = currentPos + growthDir;

            // Add stem step to the plan
            plan.Add(new GrowthStep {
                CellType = PlantCellType.Stem,
                Position = nextStemPos,
                StemIndex = stemIndex
            });

            currentPos = nextStemPos; // Update position for leaf calculation

            // Check if leaves should be added for this stem segment
            if ((finalLeafGap >= 0) && (stemIndex % (finalLeafGap + 1)) == 0)
            {
                patternCount++;

                // Base positions for leaves relative to the *new* stem position
                Vector2Int leftBase = currentPos + Vector2Int.left;
                Vector2Int rightBase = currentPos + Vector2Int.right;

                // Calculate leaf positions based on the chosen pattern
                List<Vector2Int> leafPositions = CalculateLeafPositions(
                    currentPos, // Current stem position
                    leftBase,   // Potential left leaf position
                    rightBase,  // Potential right leaf position
                    patternCount, // Counter for alternating patterns
                    ref spiralDir // Ref for spiral direction state
                );

                // Add leaf steps to the plan
                foreach (Vector2Int leafPos in leafPositions)
                {
                    plan.Add(new GrowthStep {
                        CellType = PlantCellType.Leaf,
                        Position = leafPos,
                        StemIndex = stemIndex // Associate leaf with the stem it grew from
                    });
                }
            }
        }
        
        // Track all leaf positions for potential regrowth
        foreach (GrowthStep step in plan)
        {
            if (step.CellType == PlantCellType.Leaf)
            {
                leafDataList.Add(new LeafData(step.Position, true));
            }
        }
        
        return plan;
    }


    // --- GetStemDirection - Determines the next stem growth direction ---
    // (Logic remains the same, uses finalGrowthRandomness)
    private Vector2Int GetStemDirection()
    {
        // Use pre-calculated randomness factor
        if (Random.value < finalGrowthRandomness) // Check against the final calculated value
        {
            // Randomly choose left-up or right-up diagonal
            return (Random.value < 0.5f) ? (Vector2Int.up + Vector2Int.left) : (Vector2Int.up + Vector2Int.right);
        }
        // Default to straight up
        return Vector2Int.up;
    }

    // --- CalculateLeafPositions - Calculates leaf positions based on pattern ---
    // (Logic remains the same, uses finalLeafPattern)
    private List<Vector2Int> CalculateLeafPositions(
        Vector2Int stemPos, Vector2Int leftBase, Vector2Int rightBase, int counter, ref int spiralDir)
    {
        List<Vector2Int> leafPositions = new List<Vector2Int>();

        switch (finalLeafPattern) // Use the final calculated pattern
        {
            case 0: // Parallel leaves
                leafPositions.Add(leftBase);
                leafPositions.Add(rightBase);
                break;

            case 1: // Alternating Offset leaves
                 // Initialize random offset ONCE per plant growth instance
                if (offsetRightForPattern1 == null)
                    offsetRightForPattern1 = Random.value < 0.5f;

                if (offsetRightForPattern1.Value) { // Offset right leaf up
                    leafPositions.Add(leftBase);
                    leafPositions.Add(rightBase + Vector2Int.up);
                } else { // Offset left leaf up
                    leafPositions.Add(leftBase + Vector2Int.up);
                    leafPositions.Add(rightBase);
                }
                break;

            case 2: // Alternating Parallel/Offset combination
                switch (counter % 4) {
                    case 0: // Treat 0 like 2 for parallel
                    case 2: // Parallel
                        leafPositions.Add(leftBase);
                        leafPositions.Add(rightBase);
                        break;
                    case 1: // Offset left up
                        leafPositions.Add(leftBase + Vector2Int.up);
                        leafPositions.Add(rightBase);
                        break;
                    case 3: // Offset right up
                        leafPositions.Add(leftBase);
                        leafPositions.Add(rightBase + Vector2Int.up);
                        break;
                }
                break;

            case 3: // Spiral leaves
                // Place one leaf normally, offset the other based on spiral direction
                if (spiralDir > 0) { // e.g., Right leaf is higher
                    leafPositions.Add(leftBase);
                    leafPositions.Add(rightBase + Vector2Int.up);
                } else { // e.g., Left leaf is higher
                    leafPositions.Add(leftBase + Vector2Int.up);
                    leafPositions.Add(rightBase);
                }
                spiralDir *= -1; // Flip direction for next time
                break;

            case 4: // Example: Symmetric double leaves on both sides
                leafPositions.Add(leftBase);
                leafPositions.Add(leftBase + Vector2Int.up);
                leafPositions.Add(rightBase);
                leafPositions.Add(rightBase + Vector2Int.up);
                break;

             default: // Fallback to parallel
                 leafPositions.Add(leftBase);
                 leafPositions.Add(rightBase);
                 break;
        }

        return leafPositions;
    }

} // End PARTIAL Class




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.NodeExecution.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.NodeExecution.cs
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- NODE EXECUTION METHODS ---
    // ------------------------------------------------

    private IEnumerator ExecuteMatureCycle()
    {
        if (nodeGraph?.nodes == null || nodeGraph.nodes.Count == 0) {
             Debug.LogError($"[{gameObject.name}] NodeGraph missing or empty!", gameObject);
             currentState = PlantState.Mature_Idle;
             cycleTimer = cycleCooldown; // Reset timer even on error
             yield break;
        }

        // --- Accumulation Phase ---
        float damageMultiplier = 1.0f;
        Dictionary<ScentDefinition, float> accumulatedScentRadiusBonus = new Dictionary<ScentDefinition, float>();
        Dictionary<ScentDefinition, float> accumulatedScentStrengthBonus = new Dictionary<ScentDefinition, float>();
        float totalEnergyCostForCycle = 0f;

        // Process all nodes to accumulate effects
        foreach (var node in nodeGraph.nodes.OrderBy(n => n.orderIndex))
        {
            if (node?.effects == null || node.effects.Count == 0) continue;

            foreach (var effect in node.effects)
            {
                 if (effect == null || effect.isPassive) continue; // Skip passive effects

                 // Accumulate specific non-passive effects
                 switch (effect.effectType)
                 {
                    case NodeEffectType.EnergyCost:
                         totalEnergyCostForCycle += Mathf.Max(0f, effect.primaryValue);
                         break;
                    case NodeEffectType.Damage:
                         damageMultiplier = Mathf.Max(0.1f, damageMultiplier + effect.primaryValue);
                         break;
                    case NodeEffectType.ScentModifier:
                        if (effect.scentDefinitionReference != null)
                        {
                             ScentDefinition key = effect.scentDefinitionReference;
                             // Use TryGetValue for cleaner addition
                             accumulatedScentRadiusBonus.TryGetValue(key, out float currentRad);
                             accumulatedScentRadiusBonus[key] = currentRad + effect.primaryValue;

                             accumulatedScentStrengthBonus.TryGetValue(key, out float currentStr);
                             accumulatedScentStrengthBonus[key] = currentStr + effect.secondaryValue;
                        }
                        else {
                             Debug.LogWarning($"Node '{node.nodeDisplayName ?? "Unnamed"}' has ScentModifier effect but ScentDefinition reference is NULL.");
                        }
                        break;
                    // Other accumulation effects could go here
                 }
            }
        }
        
        // --- NEW: Check for poop to absorb in this cycle ---
        if (poopDetectionRadius > 0f)
        {
            CheckForPoopAndAbsorb();
        }

        // --- Execution Phase ---
        // Check Energy Cost *before* executing actions
        if (currentEnergy < totalEnergyCostForCycle) {
             if(Debug.isDebugBuild) Debug.Log($"[{gameObject.name}] Not enough energy ({currentEnergy}/{totalEnergyCostForCycle}) for mature cycle.");
             currentState = PlantState.Mature_Idle;
             cycleTimer = cycleCooldown; // Reset timer
             yield break; // Exit if not enough energy
        }

        // Spend energy
        currentEnergy = Mathf.Max(0f, currentEnergy - totalEnergyCostForCycle);
        UpdateUI(); // Update UI after spending energy

        // Execute node effects in order
        foreach (var node in nodeGraph.nodes.OrderBy(n => n.orderIndex))
        {
            if (node?.effects == null || node.effects.Count == 0) continue;

            // Check if this node contains any *active* effects that require a delay
            bool hasActionEffectInNode = node.effects.Any(eff => eff != null && !eff.isPassive &&
                                            eff.effectType != NodeEffectType.EnergyCost && // Don't delay for cost
                                            eff.effectType != NodeEffectType.Damage &&   // Don't delay for damage mod
                                            eff.effectType != NodeEffectType.ScentModifier); // Don't delay for scent mod

            // Apply delay BEFORE processing effects of this node if applicable
            if (hasActionEffectInNode && nodeCastDelay > 0.01f) {
                 yield return new WaitForSeconds(nodeCastDelay);
            }

            // Execute individual active effects
            foreach (var effect in node.effects)
            {
                 // Skip passive and accumulation-only effects during execution
                 if (effect == null || effect.isPassive ||
                     effect.effectType == NodeEffectType.EnergyCost ||
                     effect.effectType == NodeEffectType.Damage ||
                     effect.effectType == NodeEffectType.ScentModifier) continue;

                 // Execute the actual active effect
                 switch (effect.effectType) {
                     case NodeEffectType.Output:
                        // Find component on THIS plant root or its children
                        OutputNodeEffect outputComp = GetComponentInChildren<OutputNodeEffect>();
                        if (outputComp != null) {
                             outputComp.Activate(damageMultiplier, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
                        } else {
                             Debug.LogWarning($"[{gameObject.name}] Node requested Output effect, but no OutputNodeEffect component found.", this);
                        }
                         break;
                     case NodeEffectType.GrowBerry:
                         TrySpawnBerry(accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
                         break;
                     // Add other ACTIVE effect cases here (e.g., Heal, StatusEffect)
                 }
            }
        }

        // --- Cycle Complete ---
        // Reset timer and state after executing all nodes
        cycleTimer = cycleCooldown;
        currentState = PlantState.Mature_Idle;
    }

    // --- TrySpawnBerry - Tries to create a berry on the plant ---
    private void TrySpawnBerry(Dictionary<ScentDefinition, float> scentRadiiBonus, Dictionary<ScentDefinition, float> scentStrengthsBonus)
    {
        if (berryCellPrefab == null) {
            Debug.LogWarning($"[{gameObject.name}] Berry Prefab not assigned. Cannot spawn berry.", gameObject);
            return;
        }

        // Find potential coordinates adjacent to existing stems/leaves where berries can grow
        // Consider only coords adjacent to stems for typical berry growth
        var potentialCoords = cells
            .Where(cellKvp => cellKvp.Value == PlantCellType.Stem || cellKvp.Value == PlantCellType.Seed) // Only grow off Stem/Seed
            .SelectMany(cellKvp => {
                Vector2Int coord = cellKvp.Key;
                // Define potential relative offsets for berries (e.g., above, left, right)
                Vector2Int[] berryOffsets = { Vector2Int.up, Vector2Int.left, Vector2Int.right };
                List<Vector2Int> candidates = new List<Vector2Int>();
                foreach(var offset in berryOffsets) {
                    candidates.Add(coord + offset);
                }
                return candidates;
            })
            .Where(coord => !cells.ContainsKey(coord)) // Ensure the target coordinate is empty
            .Distinct() // Avoid duplicates if multiple stems border the same empty cell
            .ToList();

        if (potentialCoords.Count > 0) {
            // Choose a random empty valid spot
            Vector2Int chosenCoord = potentialCoords[Random.Range(0, potentialCoords.Count)];
            // Spawn the berry visual, passing accumulated scent data
            GameObject berryGO = SpawnCellVisual(PlantCellType.Fruit, chosenCoord, scentRadiiBonus, scentStrengthsBonus);
             if (berryGO == null) {
                  Debug.LogError($"[{gameObject.name}] Failed to spawn berry visual at {chosenCoord}, SpawnCellVisual returned null.");
             }
        } else {
             if(Debug.isDebugBuild) Debug.Log($"[{gameObject.name}] No valid empty adjacent locations found to spawn a berry.");
        }
    }


    // --- ApplyScentDataToObject - Applies scent to an object like a berry or projectile ---
    public void ApplyScentDataToObject(GameObject targetObject, Dictionary<ScentDefinition, float> scentRadiusBonuses, Dictionary<ScentDefinition, float> scentStrengthBonuses)
    {
        // (Function body remains the same as before)
        if (targetObject == null) {
            Debug.LogError("ApplyScentDataToObject: targetObject is null.");
            return;
        }

        if (EcosystemManager.Instance == null) {
            Debug.LogError("ApplyScentDataToObject: EcosystemManager instance not found.");
            return;
        }

        if (EcosystemManager.Instance.scentLibrary == null) {
            Debug.LogWarning("ApplyScentDataToObject: Scent Library not assigned in EcosystemManager.");
            return;
        }

        // Find the ScentDefinition with the highest accumulated strength bonus
        ScentDefinition strongestScentDef = null;
        float maxStrengthBonus = -1f; // Use -1 to correctly handle 0 bonus values

        if (scentStrengthBonuses != null && scentStrengthBonuses.Count > 0) {
            foreach (var kvp in scentStrengthBonuses) {
                if (kvp.Key != null && kvp.Value > maxStrengthBonus) {
                    maxStrengthBonus = kvp.Value;
                    strongestScentDef = kvp.Key;
                }
            }
        } else {
             // if (Debug.isDebugBuild) Debug.Log($"[{gameObject.name} ApplyScentToObject] No scent strength bonuses provided.");
        }

        // Apply the strongest scent found (if any)
        if (strongestScentDef != null) {
             // if (Debug.isDebugBuild) Debug.Log($"[{gameObject.name} ApplyScentToObject] Applying strongest scent '{strongestScentDef.displayName}' to {targetObject.name} (Str Bonus: {maxStrengthBonus})");

            ScentSource scentSource = targetObject.GetComponent<ScentSource>();
            if (scentSource == null) {
                scentSource = targetObject.AddComponent<ScentSource>();
            }

            // Configure the ScentSource component
            scentSource.definition = strongestScentDef;

            // Retrieve the corresponding bonuses (defaulting to 0 if not found)
            scentRadiusBonuses.TryGetValue(strongestScentDef, out float radiusBonus);
            scentSource.radiusModifier = radiusBonus;
            scentSource.strengthModifier = maxStrengthBonus; // Apply the max strength found

            // Instantiate particle effect if defined and not already present
            if (strongestScentDef.particleEffectPrefab != null) {
                bool particleExists = false;
                // Check immediate children for an existing particle system to avoid duplicates
                foreach(Transform child in targetObject.transform){
                    if(child.TryGetComponent<ParticleSystem>(out _)){
                        particleExists = true;
                        break;
                    }
                }
                if (!particleExists) {
                     // Instantiate under the target object
                    Instantiate(strongestScentDef.particleEffectPrefab, targetObject.transform.position, Quaternion.identity, targetObject.transform);
                }
            }
        } else {
            // if (Debug.isDebugBuild) Debug.Log($"[{gameObject.name} ApplyScentToObject] No strongest scent found to apply to {targetObject.name}.");
        }
    }

} // End PARTIAL Class





--------------------------------------------------------------------------------
This is part 1 out of 7 of script collection. 6 more parts remain.
--------------------------------------------------------------------------------