This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-03-25 00:47:25
PART 2 OF 4
================================================================================

--------------------------------------------------------------------------------
Assets
├── DefaultVolumeProfile.asset
├── Editor
│   ├── HexGridRendererEditor.cs
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   ├── NodeEffectDataDrawer.cs
│   └── WizardControllerStatusEditor.cs
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
├── Prefabs
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   ├── PixelLeaf.prefab
│   │   ├── PixelSeed.prefab
│   │   ├── PixelStem.prefab
│   │   ├── PlantPrefab.prefab
│   │   ├── Projectile_Basic_Pixel.prefab
│   │   └── WizardPrefab.prefab
│   ├── Node Presets
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_AimSpread.asset
│   │   ├── Node_002_Piercing.asset
│   │   ├── Node_003_Output.asset
│   │   ├── Node_004_ManaSource.asset
│   │   ├── Node_005_DamageNode.asset
│   │   ├── Node_006_Burn.asset
│   │   └── Node_007_FriendlyFire.asset
│   ├── UI
│   │   └── NodeView.prefab
│   └── Wizard Presets
│       ├── Wizard_Basic.asset
│       └── Wizard_Dummy.asset
├── Scenes
│   ├── MainScene.unity
│   └── SampleScene.unity
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── HexCoords.cs
│   │   │   ├── HexGridManager.cs
│   │   │   ├── HexGridRenderer.cs
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   ├── NodePort.cs
│   │   │   ├── OutputNodeEffect.cs
│   │   │   └── PortDefinition.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── NodeEditorController.cs
│   │       ├── NodeHexDraggable.cs
│   │       ├── NodeSelectable.cs
│   │       ├── NodeTestInitializer.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── UI
│   └── Wizards
│       ├── WizardController.cs
│       └── WizardPreset.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Test
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\WeatherManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class WeatherManager : MonoBehaviour
{
    public static WeatherManager Instance { get; private set; }

    [Header("Sunlight Settings")]
    [Tooltip("Global sunlight intensity in [0..1]. This affects plant photosynthesis.")]
    [Range(0f, 1f)]
    public float sunIntensity = 1f;

    [Header("Sunlight Visualization")]
    [Tooltip("Sprite whose opacity changes with sunIntensity.")]
    public SpriteRenderer fadeSprite;
    [Tooltip("Minimum alpha when sunIntensity = 0.")]
    public float minAlpha = 0f;
    [Tooltip("Maximum alpha when sunIntensity = 1.")]
    public float maxAlpha = 1f;

    private void Awake()
    {
        // Set up singleton instance.
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    private void Update()
    {
        if (fadeSprite != null)
        {
            float alpha = Mathf.Lerp(minAlpha, maxAlpha, sunIntensity);
            Color c = fadeSprite.color;
            c.a = alpha;
            fadeSprite.color = c;
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\SpellProjectile.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SpellProjectile : MonoBehaviour
{
    [Header("Projectile Stats")]
    public float damage;
    public float speed;
    [Tooltip("If true, the projectile will be destroyed upon hitting a wizard.")]
    public bool destroyOnHit = true;

    [Header("Burning Effect (optional)")]
    public float burningDamage;   // DPS
    public float burningDuration; // Duration in seconds

    [Header("Friendly Fire")]
    public bool friendlyFire = false;
    public bool casterIsEnemy = false;

    public void Initialize(float dmg, float spd)
    {
        damage = dmg;
        speed = spd;
    }

    private void Update()
    {
        transform.Translate(Vector2.up * speed * Time.deltaTime);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        WizardController wizard = collision.GetComponent<WizardController>();
        if (wizard != null)
        {
            // If friendly fire is disabled and the hit wizard is on the same team, ignore.
            if (!friendlyFire && wizard.isEnemy == casterIsEnemy)
                return;

            wizard.TakeDamage(damage);
            if (burningDamage > 0 && burningDuration > 0)
            {
                wizard.ApplyStatusEffect(new BurningStatusEffect(burningDuration, burningDamage));
            }
            if (destroyOnHit)
                Destroy(gameObject);
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\BurningStatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public class BurningStatusEffect : StatusEffect
{
    public BurningStatusEffect(float d, float dps) : base(d, dps) { }

    public override void UpdateEffect(WizardController wizard, float deltaTime)
    {
        elapsed += deltaTime;
        wizard.TakeDamage(damagePerSecond * deltaTime);
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\StatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public abstract class StatusEffect
{
    public float duration; // Total duration.
    public float damagePerSecond;
    protected float elapsed = 0f;

    // Public property to expose elapsed time.
    public float Elapsed { get { return elapsed; } }

    public StatusEffect(float d, float dps)
    {
        duration = d;
        damagePerSecond = dps;
    }

    public abstract void UpdateEffect(WizardController wizard, float deltaTime);
    public bool IsExpired() => elapsed >= duration;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\HexCoords.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[System.Serializable]
public struct HexCoords
{
    public int q; // axial coordinate (column)
    public int r; // axial coordinate (row)

    public HexCoords(int q, int r)
    {
        this.q = q;
        this.r = r;
    }

    // Flat top conversion from axial to world coordinates.
    // Using the formula:
    // x = hexSize * (3/2 * q)
    // y = hexSize * ( (sqrt(3)/2 * q) + (sqrt(3) * r) )
    public Vector2 HexToWorld(float hexSize)
    {
        float x = hexSize * (3f / 2f * q);
        float y = hexSize * ((Mathf.Sqrt(3f) / 2f * q) + (Mathf.Sqrt(3f) * r));
        return new Vector2(x, y);
    }

    // Converts a world (UI) position to axial coordinates.
    // Inverse formulas:
    // q = (2/3 * x)/hexSize
    // r = ((-1/3 * x) + (sqrt(3)/3 * y)) / hexSize
    public static HexCoords WorldToHex(Vector2 pos, float hexSize)
    {
        float qf = (2f / 3f * pos.x) / hexSize;
        float rf = ((-1f / 3f * pos.x) + (Mathf.Sqrt(3f) / 3f * pos.y)) / hexSize;
        return RoundAxial(qf, rf);
    }

    public static HexCoords RoundAxial(float qf, float rf)
    {
        float sf = -qf - rf;
        int qi = Mathf.RoundToInt(qf);
        int ri = Mathf.RoundToInt(rf);
        int si = Mathf.RoundToInt(sf);

        float qDiff = Mathf.Abs(qi - qf);
        float rDiff = Mathf.Abs(ri - rf);
        float sDiff = Mathf.Abs(si - sf);

        if (qDiff > rDiff && qDiff > sDiff)
            qi = -ri - si;
        else if (rDiff > sDiff)
            ri = -qi - si;
        return new HexCoords(qi, ri);
    }

    // Fixed neighbor offsets (axial) for flat top grid.
    private static readonly HexCoords[] AxialNeighbors = new HexCoords[] {
        new HexCoords(+1, 0),   // Side1
        new HexCoords(0, -1),   // Side2
        new HexCoords(-1, -1),  // Side3
        new HexCoords(-1, 0),   // Side4
        new HexCoords(0, +1),   // Side5
        new HexCoords(+1, +1)   // Side6
    };

    // Returns the neighbor hex coordinate for a given side index (0 to 5)
    public static HexCoords GetNeighbor(HexCoords origin, int sideIndex)
    {
        return new HexCoords(origin.q + AxialNeighbors[sideIndex].q,
                             origin.r + AxialNeighbors[sideIndex].r);
    }

    public static int OppositeSideIndex(int sideIndex)
    {
        return (sideIndex + 3) % 6;
    }

    public override bool Equals(object obj)
    {
        if (!(obj is HexCoords))
            return false;
        HexCoords other = (HexCoords)obj;
        return this.q == other.q && this.r == other.r;
    }

    public override int GetHashCode()
    {
        unchecked { return (q * 397) ^ r; }
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\HexGridManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class HexGridManager : MonoBehaviour
{
    public float hexSize = 50f;
    public float pinRadiusMultiplier = 1.0f; // Pin radius = hexSize * multiplier

    // Flat top hexagon grid only – no orientation toggle needed.
    public static HexGridManager Instance { get; private set; }
    
    private void Awake()
    {
        Instance = this;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\HexGridRenderer.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

[RequireComponent(typeof(CanvasRenderer))]
public class HexGridRenderer : MaskableGraphic
{
    public bool showGrid = true;
    public Color gridColor = Color.white;
    public float lineThickness = 1f;

    private float HexSize {
        get { return (HexGridManager.Instance != null) ? HexGridManager.Instance.hexSize : 50f; }
    }

    protected override void OnPopulateMesh(VertexHelper vh)
    {
        vh.Clear();
        if (!showGrid)
            return;

        Rect rect = rectTransform.rect;
        Vector2 origin = rect.center;

        int cols = Mathf.CeilToInt(rect.width / (HexSize * Mathf.Sqrt(3))) + 2;
        int rows = Mathf.CeilToInt(rect.height / (HexSize * 1.5f)) + 2;

        List<Vector2> linePoints = new List<Vector2>();

        for (int q = -cols; q <= cols; q++)
        {
            for (int r = -rows; r <= rows; r++)
            {
                HexCoords hex = new HexCoords(q, r);
                Vector2 hexCenter = hex.HexToWorld(HexSize) + origin;
                List<Vector2> corners = new List<Vector2>();
                // For flat top, use corners at angles 0, 60, 120, 180, 240, 300.
                for (int i = 0; i < 6; i++)
                {
                    float angle = i * 60f;
                    float rad = angle * Mathf.Deg2Rad;
                    Vector2 offset = new Vector2(HexSize * Mathf.Cos(rad), HexSize * Mathf.Sin(rad));
                    corners.Add(hexCenter + offset);
                }
                for (int i = 0; i < 6; i++)
                {
                    int next = (i + 1) % 6;
                    linePoints.Add(corners[i]);
                    linePoints.Add(corners[next]);
                }
            }
        }
        for (int i = 0; i < linePoints.Count; i += 2)
        {
            AddLineQuad(vh, linePoints[i], linePoints[i + 1], lineThickness, gridColor);
        }
    }

    private void AddLineQuad(VertexHelper vh, Vector2 start, Vector2 end, float thickness, Color col)
    {
        Vector2 direction = (end - start).normalized;
        Vector2 normal = new Vector2(-direction.y, direction.x);
        Vector2 offset = normal * (thickness * 0.5f);

        int idx = vh.currentVertCount;
        vh.AddVert(start + offset, col, Vector2.zero);
        vh.AddVert(start - offset, col, Vector2.zero);
        vh.AddVert(end - offset, col, Vector2.zero);
        vh.AddVert(end + offset, col, Vector2.zero);
        vh.AddTriangle(idx, idx + 1, idx + 2);
        vh.AddTriangle(idx, idx + 2, idx + 3);
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public Vector2 editorPosition; // For UI positioning
    public HexCoords coords;       // Hex-based position
    public Color backgroundColor = Color.gray;
    public string description = "";
    public List<NodePort> ports;   // Up to 6 ports (max 1 per side)
    public List<NodeEffectData> effects;

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
        ports = new List<NodePort>();
        effects = new List<NodeEffectData>();
        coords = new HexCoords(0, 0);
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    public string displayName;
    public Color backgroundColor = Color.gray;
    [TextArea] public string description;
    public List<PortDefinition> ports;
    public List<NodeEffectData> effects = new List<NodeEffectData>();

#if UNITY_EDITOR
    private void OnValidate()
    {
        if (string.IsNullOrEmpty(displayName))
        {
            string path = UnityEditor.AssetDatabase.GetAssetPath(this);
            string fileName = System.IO.Path.GetFileNameWithoutExtension(path);
            string[] parts = fileName.Split('_');
            if (parts.Length >= 3)
                displayName = string.Join("_", parts.Skip(2).ToArray());
        }
    }
#endif

    private void OnEnable()
    {
        if (ports == null || ports.Count == 0)
        {
            ports = new List<PortDefinition>();
            // Default: one input on Top and one output on Three (opposite for flat-top)
            ports.Add(new PortDefinition { isInput = true, portType = PortType.General, side = HexSideFlat.Top });
            ports.Add(new PortDefinition { isInput = false, portType = PortType.General, side = HexSideFlat.Three });
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    public List<NodeDefinition> definitions;
    // New: List of nodes to auto-spawn at game start.
    public List<NodeDefinition> autoSpawnNodes;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;

    // For Seed:
    // effectValue     = stemMinLength
    // secondaryValue  = stemMaxLength
    // extra1          = growthSpeed
    // extra2          = leafGap
    public float effectValue;
    public float secondaryValue;
    public float extra1;
    public float extra2;

    // Two brand-new fields:
    public int leafPattern = 0;       // 0=Parallel, 1=Alternating
    public float growthRandomness = 0f; // Range [0..2]
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿public enum NodeEffectType
{
    ManaCost,
    Damage,
    ManaStorage,
    ManaRechargeRate,
    EnergyStorage,
    EnergyPhotosynthesis,
    Output,
    AimSpread,    // formerly Accuracy
    Burning,
    Piercing,
    FriendlyFire,
    Seed  // New effect type for planting a seed.
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodePort.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

public enum PortType { General, Mana, Condition }

public enum HexSideFlat { Top, One, Two, Three, Four, Five }

[Serializable]
public class NodePort
{
    public bool isInput;
    public PortType portType;
    public HexSideFlat side;

    public NodePort(bool isInput, PortType portType, HexSideFlat side)
    {
        this.isInput = isInput;
        this.portType = portType;
        this.side = side;
    }

    public NodePort() { }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\OutputNodeEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Linq;

/// <summary>
/// Attach this to the NodeView prefab if the node has Output effect,
/// or have BFS call it directly. 
/// It calls WizardController to spawn a projectile/spell.
/// </summary>
public class OutputNodeEffect : MonoBehaviour
{
    /// <summary>
    /// This method is invoked by NodeExecutor when BFS processes an 'Output' node.
    /// You can pass any parameters (damage, aim, etc.) or just do a test projectile.
    /// </summary>
    public void Activate()
    {
        Debug.Log("[OutputNodeEffect] Activate() called. Spawning projectile or calling wizard cast.");

        // For example, find the local (player) wizard and cast a test projectile:
        WizardController playerWiz = FindObjectsOfType<WizardController>()
            .FirstOrDefault(w => !w.isEnemy);

        if (playerWiz)
        {
            // Just an example. The real logic might pass finalDamage, aimSpread, etc.
            playerWiz.CastSpell(finalDamage: 10f, finalAimSpread: 5f,
                burningDamage: 0f, burningDuration: 0f,
                piercing: false, friendlyFire: false);
            Debug.Log("[OutputNodeEffect] Called player's CastSpell with sample values.");
        }
        else
        {
            Debug.LogWarning("[OutputNodeEffect] No friendly wizard found in scene.");
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\PortDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

[Serializable]
public class PortDefinition
{
    public bool isInput;
    public PortType portType;
    public HexSideFlat side;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro;

public class NodeExecutor : MonoBehaviour
{
    [SerializeField] private NodeGraph currentGraph;
    [Header("Debug Settings")]
    public float waitTimeBetweenNodes = 0.5f;
    public TMP_Text debugOutput;

    [Header("Plant Prefab (assigned in inspector)")]
    public GameObject plantPrefab;  // Assign your PlantPrefab here

    private Dictionary<HexCoords, NodeData> coordsMap;
    private HashSet<string> visited;

    // For accumulating energy info from the BFS chain:
    private float accumulatedEnergyStorage  = 0f;
    private float accumulatedPhotosynthesis = 0f;

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
            ExecuteGraph();
    }

    public void SetGraph(NodeGraph graph)
    {
        currentGraph = graph;
        Debug.Log("[NodeExecutor] Graph set. Node count=" + (graph != null ? graph.nodes.Count : 0));
    }

    public NodeGraph GetGraph() => currentGraph;

    public void ExecuteGraph()
    {
        if (currentGraph == null || currentGraph.nodes.Count == 0)
        {
            LogDebug("[NodeExecutor] No graph or no nodes to execute!");
            return;
        }
        StopAllCoroutines();
        ClearDebug();
        BuildCoordsMap();
        visited = new HashSet<string>();

        // Reset accumulators in case we want a fresh sum each time.
        accumulatedEnergyStorage  = 0f;
        accumulatedPhotosynthesis = 0f;

        List<NodeData> startNodes = FindStartNodes();
        if (startNodes.Count == 0)
        {
            LogDebug("[NodeExecutor] No start nodes found. Aborting BFS.");
            return;
        }
        foreach (var startNode in startNodes)
            StartCoroutine(RunChainBFS(startNode));
    }

    private void BuildCoordsMap()
    {
        coordsMap = new Dictionary<HexCoords, NodeData>();
        foreach (var node in currentGraph.nodes)
            coordsMap[node.coords] = node;
    }

    private List<NodeData> FindStartNodes()
    {
        List<NodeData> result = new List<NodeData>();
        foreach (var node in currentGraph.nodes)
        {
            if (!HasInbound(node))
                result.Add(node);
        }
        return result;
    }

    private bool HasInbound(NodeData node)
    {
        foreach (var port in node.ports)
        {
            if (!port.isInput) continue;

            int sideIndex = (int)port.side;
            int oppSide   = (sideIndex + 3) % 6;
            HexCoords neighborCoords = HexCoords.GetNeighbor(node.coords, oppSide);
            if (!coordsMap.ContainsKey(neighborCoords)) 
                continue;

            var neighborNode = coordsMap[neighborCoords];
            bool hasOutputMatch = neighborNode.ports.Any(p => !p.isInput && (int)p.side == oppSide);
            if (hasOutputMatch)
                return true;
        }
        return false;
    }

    private IEnumerator RunChainBFS(NodeData startNode)
    {
        Queue<HexCoords> queue = new Queue<HexCoords>();
        queue.Enqueue(startNode.coords);

        while (queue.Count > 0)
        {
            HexCoords coords = queue.Dequeue();
            if (!coordsMap.ContainsKey(coords)) 
                continue;

            NodeData node = coordsMap[coords];
            if (visited.Contains(node.nodeId)) 
                continue;

            visited.Add(node.nodeId);

            yield return new WaitForSeconds(waitTimeBetweenNodes);
            ProcessNode(node);

            // Follow output sides
            foreach (var port in node.ports)
            {
                if (!port.isInput)
                {
                    int sIndex = (int)port.side;
                    HexCoords neighborCoords = HexCoords.GetNeighbor(coords, sIndex);
                    if (!coordsMap.ContainsKey(neighborCoords)) 
                        continue;

                    var neighborNode = coordsMap[neighborCoords];
                    int oppIndex = (sIndex + 3) % 6;
                    bool hasInputMatch = neighborNode.ports.Any(p => p.isInput && (int)p.side == oppIndex);
                    if (hasInputMatch && !visited.Contains(neighborNode.nodeId))
                        queue.Enqueue(neighborCoords);
                }
            }
        }
        LogDebug("[NodeExecutor] BFS from start node completed.");
    }

    private void ProcessNode(NodeData node)
    {
        LogDebug($"[NodeExecutor] Processing node '{node.nodeDisplayName}' at coords ({node.coords.q}, {node.coords.r}).");

        // Accumulate Energy Storage and Photosynthesis from ANY node effect 
        // in the BFS chain.
        foreach (var eff in node.effects)
        {
            if (eff.effectType == NodeEffectType.EnergyStorage)
            {
                accumulatedEnergyStorage += eff.effectValue;
            }
            else if (eff.effectType == NodeEffectType.EnergyPhotosynthesis)
            {
                accumulatedPhotosynthesis += eff.effectValue;
            }
        }

        // If it's a Seed node, spawn the plant now using the BFS accumulators.
        var seedEffect = node.effects.FirstOrDefault(e => e.effectType == NodeEffectType.Seed);
        if (seedEffect != null)
        {
            SpawnPlant(seedEffect);
        }
    }

    private void SpawnPlant(NodeEffectData seedEffect)
    {
        if (plantPrefab == null)
        {
            LogDebug("[NodeExecutor] plantPrefab is not assigned in the inspector!");
            return;
        }
        var gardener = FindObjectOfType<GardenerController>();
        if (gardener == null)
        {
            LogDebug("[NodeExecutor] No GardenerController found. Can't spawn plant.");
            return;
        }

        Vector2 spawnPos = gardener.GetPlantingPosition();
        GameObject plantObj = Instantiate(plantPrefab, spawnPos, Quaternion.identity);
        PlantGrowth growth = plantObj.GetComponent<PlantGrowth>();

        if (growth != null)
        {
            // standard seed data
            growth.stemMinLength = Mathf.RoundToInt(seedEffect.effectValue);
            growth.stemMaxLength = Mathf.RoundToInt(seedEffect.secondaryValue);
            growth.growthSpeed   = seedEffect.extra1;
            growth.leafGap       = Mathf.RoundToInt(seedEffect.extra2);
            growth.leafPattern      = seedEffect.leafPattern; 
            growth.growthRandomness = seedEffect.growthRandomness;

            // new "energy" data from BFS sums
            growth.maxEnergy       = accumulatedEnergyStorage;   // sum of all energy storages
            growth.basePhotosynthesis = accumulatedPhotosynthesis; // sum of all photosynthesis rates

            LogDebug($"[NodeExecutor] Spawned plant => " +
                     $"Seed(min={growth.stemMinLength},max={growth.stemMaxLength},spd={growth.growthSpeed},gap={growth.leafGap},pat={growth.leafPattern},rand={growth.growthRandomness}), " +
                     $"Energy(max={growth.maxEnergy}), Photosynthesis(base={growth.basePhotosynthesis})");
        }
        else
        {
            LogDebug("[NodeExecutor] PlantGrowth missing on plantPrefab.");
        }

        // If you want each new seed to get its own accumulators, 
        // reset them after spawning:
        accumulatedEnergyStorage  = 0f;
        accumulatedPhotosynthesis = 0f;
    }

    private void ClearDebug()
    {
        if (debugOutput)
            debugOutput.text = "";
    }

    private void LogDebug(string msg)
    {
        Debug.Log(msg);
        if (debugOutput)
            debugOutput.text += msg + "\n";
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes;

    public NodeGraph()
    {
        nodes = new List<NodeData>();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\ColorExtensions.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public static class ColorExtensions
{
    public static Color WithAlpha(this Color c, float alpha)
    {
        return new Color(c.r, c.g, c.b, alpha);
    }
}





--------------------------------------------------------------------------------
This is part 2 out of 4 of script collection. 2 more parts remain.
--------------------------------------------------------------------------------