This document contains extracted Unity 6 C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates. After reading all parts of the scripts, confirm that you are fully updated about state of my project and how it works and make a brief sum up so I know you are really informed well. Moreover, I'm using 3rd party package for my dual-grid wang tile system, integrating it into unity tilemap system - to ensure you understand the functionality of my grid tilemap system, I'm also enclosing guides provided by the package. 

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-04-18 13:32:33
PART 3 OF 5
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   └── PlantPrefab.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           └── DualGridRuleTile_Grass.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   └── Animal_000_Bunny.asset
│   ├── Animals Diet
│   │   └── Diet_000_Bunny.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   └── Node_002_FireflyPheromone.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   └── Tools
│       ├── ToolDefinition_000_GardeningHoe.asset
│       ├── ToolDefinition_001_WateringCan.asset
│       └── ToolDefinition_002_SeedPouch.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   └── ThoughtTrigger.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManagement.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       └── RuntimeCircleDrawer.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   └── SpriteEmissiveUnlit.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Effects\FireflyManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Effects/FireflyManager.cs

using UnityEngine;
using UnityEngine.Rendering.Universal;
using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif

public class FireflyManager : MonoBehaviour
{
    public static FireflyManager Instance { get; private set; }

    [Header("Core Dependencies")]
    [SerializeField] private WeatherManager weatherManager;
    [SerializeField] private GameObject fireflyPrefab;
    [SerializeField] private Transform fireflyParent;

    // (Keep Spawning Settings, Spawn Area, Movement Bounds, Photosynthesis Bonus)
    [Header("Spawning Settings")]
    [SerializeField] private int maxFireflies = 50;
    [SerializeField] private float spawnInterval = 0.5f;
    [SerializeField] [Range(0f, 1f)] private float nightThreshold = 0.25f;

    [Header("Spawn Area")]
    [SerializeField] private Vector2 spawnCenter = Vector2.zero;
    [SerializeField] private Vector2 spawnAreaSize = new Vector2(20f, 10f);

    [Header("Movement Bounds (for Fireflies)")]
    [SerializeField] private Vector2 movementMinBounds = new Vector2(-12f, -7f);
    [SerializeField] private Vector2 movementMaxBounds = new Vector2(12f, 7f);

    [Header("Photosynthesis Bonus Settings")]
    public float photosynthesisRadius = 3f;
    public float photosynthesisIntensityPerFly = 0.05f;
    public float maxPhotosynthesisBonus = 0.5f;


    [Header("Debugging")]
    [Tooltip("Show attraction lines in Game View during runtime.")]
    [SerializeField] private bool showAttractionLinesRuntime = false;
    [SerializeField] private Color attractionLineColorGizmo = Color.magenta; // Renamed for Gizmo
    [SerializeField] private bool logGizmoCalls = false;
    [Space] // Add space for visual separation
    [Tooltip("Prefab used to draw attraction lines at runtime.")]
    [SerializeField] private GameObject lineVisualizerPrefab; // <<< ADDED
    [Tooltip("Parent transform for instantiated line visualizers.")]
    [SerializeField] private Transform lineContainer; // <<< ADDED

    // --- Public Accessor ---
    public bool ShowAttractionLinesRuntime => showAttractionLinesRuntime;

    // --- Internal State ---
    private List<FireflyController> activeFireflies = new List<FireflyController>();
    private float spawnTimer;
    private bool isNight = false;
    
    

    // Dictionary to track line visualizers per firefly
    private Dictionary<FireflyController, LineRenderer> activeLineVisualizers = new Dictionary<FireflyController, LineRenderer>();

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;
        // Validate Core Dependencies
        if (weatherManager == null) { Debug.LogError($"[{nameof(FireflyManager)}] WeatherManager missing!", this); enabled = false; return; }
        if (fireflyPrefab == null) { Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing!", this); enabled = false; return; }
        if (fireflyPrefab.GetComponent<FireflyController>() == null) { Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing Controller script!", this); enabled = false; return; }
        if (fireflyParent == null) { fireflyParent = transform; }

        // Validate Debug Dependencies
        if (lineVisualizerPrefab == null) { Debug.LogError($"[{nameof(FireflyManager)}] Line Visualizer Prefab is not assigned!", this); }
        if (lineContainer == null) { Debug.LogError($"[{nameof(FireflyManager)}] Line Container transform is not assigned!", this); }
    }

    void Update()
    {
        isNight = weatherManager.sunIntensity <= nightThreshold;

        if (isNight) {
            spawnTimer -= Time.deltaTime;
            if (spawnTimer <= 0f) { TrySpawnFirefly(); spawnTimer = spawnInterval; }
        } else { spawnTimer = spawnInterval; }

        // Update runtime visualizers in Update
        UpdateRuntimeLineVisualizers();
    }

    void TrySpawnFirefly()
    {
        if (activeFireflies.Count >= maxFireflies) return;

        float spawnX = spawnCenter.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
        float spawnY = spawnCenter.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
        Vector2 spawnPos = new Vector2(spawnX, spawnY);

        GameObject fireflyGO = Instantiate(fireflyPrefab, spawnPos, Quaternion.identity, fireflyParent);
        FireflyController controller = fireflyGO.GetComponent<FireflyController>();

        if (controller != null) {
            controller.Initialize(this, movementMinBounds, movementMaxBounds);
            activeFireflies.Add(controller);
            // Don't create line visualizer here, do it in Update when needed
        } else { /* LogError, Destroy */ }
    }

    public void ReportFireflyDespawned(FireflyController firefly)
    {
        activeFireflies.Remove(firefly);

        // Clean up associated line visualizer
        if (activeLineVisualizers.TryGetValue(firefly, out LineRenderer line))
        {
            if (line != null) Destroy(line.gameObject); // Destroy the visualizer GO
            activeLineVisualizers.Remove(firefly);
        }
    }

    // --- Runtime Visualizer Update ---
    void UpdateRuntimeLineVisualizers()
    {
        if (!Application.isPlaying) return; // Only run in play mode

        // Check if lines should be shown globally
        bool showLines = showAttractionLinesRuntime && lineVisualizerPrefab != null && lineContainer != null;

        // --- Update existing lines and create new ones ---
        // Use a temporary list to avoid modifying dictionary while iterating
        List<FireflyController> firefliesToRemoveLine = new List<FireflyController>();

        foreach (var kvp in activeLineVisualizers)
        {
            FireflyController firefly = kvp.Key;
            LineRenderer line = kvp.Value;

            if (firefly == null || line == null) // Firefly or line destroyed unexpectedly
            {
                firefliesToRemoveLine.Add(firefly); // Mark for removal
                if(line != null) Destroy(line.gameObject); // Destroy orphan line
                continue;
            }

            Transform target = firefly.AttractionTarget;

            if (showLines && target != null) // Should be visible and has target
            {
                line.enabled = true;
                line.SetPosition(0, firefly.transform.position);
                line.SetPosition(1, target.position);
            }
            else // Should be hidden or lost target
            {
                line.enabled = false;
            }
        }

        // Remove entries whose fireflies are gone
        foreach (var firefly in firefliesToRemoveLine)
        {
            activeLineVisualizers.Remove(firefly);
        }


        // --- Add lines for fireflies that don't have one yet ---
        if (showLines)
        {
            foreach (FireflyController firefly in activeFireflies)
            {
                if (firefly == null || activeLineVisualizers.ContainsKey(firefly)) continue; // Skip nulls or those already processed

                Transform target = firefly.AttractionTarget;
                if (target != null) // Only create if it has a target AND should be shown
                {
                    GameObject lineGO = Instantiate(lineVisualizerPrefab, lineContainer); // Instantiate under container
                    LineRenderer newLine = lineGO.GetComponent<LineRenderer>();
                    if (newLine != null)
                    {
                        // Configure initial points (will be updated next frame anyway)
                        newLine.SetPosition(0, firefly.transform.position);
                        newLine.SetPosition(1, target.position);
                        newLine.enabled = true;
                        activeLineVisualizers.Add(firefly, newLine); // Add to tracking dictionary
                    }
                    else
                    {
                         Debug.LogError($"Line Visualizer Prefab '{lineVisualizerPrefab.name}' is missing LineRenderer component!", lineVisualizerPrefab);
                         Destroy(lineGO); // Destroy invalid instance
                    }
                }
            }
        }
        // --- Hide/Destroy lines if global flag turned off ---
        else if (!showLines && activeLineVisualizers.Count > 0)
        {
             // Destroy all active line visualizers if the flag is off
             foreach (var kvp in activeLineVisualizers)
             {
                 if (kvp.Value != null) Destroy(kvp.Value.gameObject);
             }
             activeLineVisualizers.Clear();
        }
    }


    // (Keep GetNearbyFireflyCount)
     public int GetNearbyFireflyCount(Vector3 position, float radius)
    {
        int count = 0; float radiusSq = radius * radius;
        for (int i = activeFireflies.Count - 1; i >= 0; i--)
        {
            if (activeFireflies[i] == null) { activeFireflies.RemoveAt(i); continue; }
            if ((activeFireflies[i].transform.position - position).sqrMagnitude <= radiusSq) { count++; }
        }
        return count;
    }

    // --- Gizmos (Editor Visualization - Unchanged) ---
    #if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.green; Gizmos.DrawWireCube(spawnCenter, spawnAreaSize);
        Gizmos.color = Color.blue;
        Vector3 boundsCenter = (movementMinBounds + movementMaxBounds) / 2f;
        Vector3 boundsSize = movementMaxBounds - movementMinBounds;
        Gizmos.DrawWireCube(boundsCenter, boundsSize);

        // Gizmo drawing for attraction lines
        if (showAttractionLinesRuntime && Application.isPlaying) {
             if (logGizmoCalls) { /*...*/ }
             bool didDrawLine = false;
             Gizmos.color = attractionLineColorGizmo; // Use Gizmo color
             foreach (FireflyController firefly in activeFireflies) {
                if (firefly == null) continue;
                Transform target = firefly.AttractionTarget;
                if (target != null) { Gizmos.DrawLine(firefly.transform.position, target.position); didDrawLine = true; }
             }
             if (logGizmoCalls && !didDrawLine && activeFireflies.Count > 0) { /*...*/ }
        }
    }
    #endif
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\AnimalDiet.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;

// Simplified Preference: Links FoodType to satiation amount and behavior priority
[System.Serializable]
public class DietPreferenceSimplified
{
    [Tooltip("The specific FoodType this preference applies to.")]
    public FoodType foodType;

    [Tooltip("How much satiation (hunger reduction) is gained when this food is eaten.")]
    public float satiationAmount = 5f;

    [Tooltip("Priority for seeking this food (higher value = higher priority). Used for choosing between nearby valid foods.")]
    [Range(0.1f, 5f)]
    public float preferencePriority = 1f;
}


// Simplified Diet: Defines hunger stats and list of preferences
[CreateAssetMenu(fileName = "Diet_", menuName = "Ecosystem/Animal Diet (Simplified)")]
public class AnimalDiet : ScriptableObject
{
    [Header("Diet Preferences")]
    [Tooltip("List of foods this animal can eat and how much they satisfy hunger.")]
    public List<DietPreferenceSimplified> acceptableFoods = new List<DietPreferenceSimplified>();

    [Header("Hunger Mechanics")]
    [Tooltip("Maximum hunger level.")]
    public float maxHunger = 20f;
    [Tooltip("Rate at which hunger increases per second.")]
    public float hungerIncreaseRate = 0.5f;
    [Tooltip("Hunger level above which the animal will actively seek food.")]
    public float hungerThreshold = 10f;

    // Removed starvation for simplicity, can be added back later if needed
    // [Header("Starvation")]
    // public float starvationDamageRate = 0.5f;

    /// <summary>
    /// Checks if a specific FoodType is included in this diet's acceptable foods.
    /// </summary>
    public bool CanEat(FoodType food)
    {
        if (food == null) return false;
        return acceptableFoods.Any(pref => pref.foodType == food);
    }

    /// <summary>
    /// Gets the DietPreferenceSimplified entry for a specific FoodType.
    /// </summary>
    public DietPreferenceSimplified GetPreference(FoodType food)
    {
         if (food == null) return null;
         return acceptableFoods.FirstOrDefault(p => p.foodType == food);
    }

    /// <summary>
    /// Gets the satiation amount provided by a specific FoodType for this diet.
    /// </summary>
    public float GetSatiationValue(FoodType food)
    {
        var pref = GetPreference(food);
        return pref != null ? pref.satiationAmount : 0f;
    }

    /// <summary>
    /// Finds the best food target from nearby colliders based on preference and distance.
    /// </summary>
    public GameObject FindBestFood(Collider2D[] nearbyColliders, Vector3 animalPosition)
    {
        GameObject bestTarget = null;
        float highestScore = -1f; // Start below any possible score

        foreach (var collider in nearbyColliders)
        {
            if (collider == null) continue;

            FoodItem foodItem = collider.GetComponent<FoodItem>();

            // Must have FoodItem and its FoodType must be edible by this diet
            if (foodItem != null && foodItem.foodType != null && CanEat(foodItem.foodType))
            {
                DietPreferenceSimplified pref = GetPreference(foodItem.foodType);
                if (pref == null) continue; // Should be caught by CanEat, but safe check

                float distance = Vector3.Distance(animalPosition, collider.transform.position);
                // Simple score: Higher preference is better, closer is better.
                // Avoid division by zero or very small distances inflating score excessively.
                float score = pref.preferencePriority / (1f + distance); // Inverse distance weighting

                if (score > highestScore)
                {
                    highestScore = score;
                    bestTarget = collider.gameObject;
                }
            }
        }
        return bestTarget;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[RequireComponent(typeof(Collider2D))] // Still need collider for detection
public class FoodItem : MonoBehaviour
{
    [Header("Food Identification")]
    [Tooltip("Reference to the ScriptableObject defining what type of food this is.")]
    public FoodType foodType;

    private void Start()
    {
        // Simple validation
        if (foodType == null)
        {
            Debug.LogWarning($"FoodItem on GameObject '{gameObject.name}' is missing its FoodType reference!", gameObject);
            // Optionally disable the collider so it can't be detected as food
            // Collider2D col = GetComponent<Collider2D>();
            // if (col != null) col.enabled = false;
            enabled = false; // Disable script if not configured
        }
        // No health, no consume logic needed here anymore.
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodType.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "FoodType_", menuName = "Ecosystem/Food Type (Simplified)")]
public class FoodType : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Identifying name for this food type (e.g., 'Leaf', 'Fruit').")]
    public string foodName = "Default Food";
    [Tooltip("Icon used in UI or debugging.")]
    public Sprite icon;

    // Keep category for potential filtering later, but not actively used by core logic yet
    public enum FoodCategory { Plant_Leaf, Plant_Fruit, Plant_Stem, Plant_Seed, Other }
    [Header("Categorization")]
    [Tooltip("General category this food falls into.")]
    public FoodCategory category = FoodCategory.Other;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Scents\ScentDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Scents/ScentDefinition.cs
using UnityEngine;

[CreateAssetMenu(fileName = "Scent_", menuName = "Ecosystem/Scent Definition")]
public class ScentDefinition : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Unique identifier used internally and potentially for node effects.")]
    public string scentID = "default_scent"; // Still useful for debugging/lookup
    [Tooltip("Display name for UI or debugging.")]
    public string displayName = "Default Scent";

    // [Header("Gameplay Properties")] - Removed scentType enum field

    [Tooltip("Base radius for this scent type if not modified by nodes.")]
    public float baseRadius = 1f;
    [Tooltip("Base strength for this scent type if not modified by nodes.")]
    public float baseStrength = 1f;

    [Header("Visuals (Optional)")]
    [Tooltip("Particle effect prefab to instantiate when this scent is active.")]
    public GameObject particleEffectPrefab;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Scents\ScentLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Scents/ScentLibrary.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "ScentLibrary", menuName = "Ecosystem/Scent Library")]
public class ScentLibrary : ScriptableObject
{
    public List<ScentDefinition> scents;

    // Helper method to find a scent by its ID (still potentially useful)
    public ScentDefinition GetScentByID(string id)
    {
        if (string.IsNullOrEmpty(id) || scents == null) return null;
        return scents.FirstOrDefault(s => s != null && s.scentID == id);
    }

    // Helper to get the actual list of definitions
    public List<ScentDefinition> GetAllDefinitions()
    {
        // Return a copy or filter out nulls
        return scents?.Where(s => s != null).ToList() ?? new List<ScentDefinition>();
    }

}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public List<NodeEffectData> effects = new List<NodeEffectData>();
    public int orderIndex;

    // Runtime flags
    [HideInInspector] // Don't show in NodeDefinition inspector, set at runtime
    public bool canBeDeleted = true; // <<< NEW FLAG (Defaults to true)

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
        // Ensure default deletability on creation
        canBeDeleted = true;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeDefinition.cs
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    [Header("Display")]
    public string displayName;
    [TextArea]
    public string description;
    public Sprite thumbnail;
    [Tooltip("Tint color applied to the thumbnail image.")]
    public Color thumbnailTintColor = Color.white;
    [Tooltip("Background color for the Node View representation.")]
    public Color backgroundColor = Color.gray;

    [Header("Prefab & Effects")]
    [Tooltip("Optional: Specific NodeView prefab for this node type. If null, the default from NodeEditorGridController is used.")]
    public GameObject nodeViewPrefab;
    [Tooltip("List of effects this node applies. Configure these effects carefully.")]
    public List<NodeEffectData> effects; // This is the list configured in the Inspector

    /// <summary>
    /// Creates a deep copy of the effects list configured in this NodeDefinition asset.
    /// This ensures that runtime NodeData instances get their own copies of effects.
    /// </summary>
    /// <returns>A new list containing copies of the NodeEffectData.</returns>
    public List<NodeEffectData> CloneEffects()
    {
        List<NodeEffectData> copy = new List<NodeEffectData>();
        if (effects == null) {
            // Debug.LogWarning($"NodeDefinition '{this.name}' has a null effects list."); // Optional warning
            return copy; // Handle null list
        }

        foreach (var originalEffect in effects)
        {
            if (originalEffect == null) {
                 Debug.LogWarning($"NodeDefinition '{this.name}' contains a null effect in its list."); // Optional warning
                 continue; // Skip null effects
            }

            // Create a new instance and copy ALL relevant fields
            NodeEffectData newEffect = new NodeEffectData()
            {
                effectType = originalEffect.effectType,
                primaryValue = originalEffect.primaryValue,
                secondaryValue = originalEffect.secondaryValue,
                isPassive = originalEffect.isPassive,
                // --- FIXED: Copy the ScentDefinition reference ---
                scentDefinitionReference = originalEffect.scentDefinitionReference
                // --------------------------------------------------
            };
            copy.Add(newEffect);
        }
        return copy;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System; // Needed for [Serializable]

// Define the configuration for a single initial node
[Serializable] // Make it visible and editable in the Inspector
public struct InitialNodeConfig
{
    [Tooltip("The Node Definition to spawn.")]
    public NodeDefinition nodeDefinition;

    [Tooltip("The zero-based index of the cell where this node should spawn (0 is the leftmost cell).")]
    [Min(0)]
    public int cellIndex;

    [Tooltip("Can the player drag this initial node to other cells?")]
    public bool canMove;

    [Tooltip("Can the player delete this initial node using the Delete key?")]
    public bool canDelete;
}


[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    [Header("Available Node Definitions")]
    [Tooltip("List of all Node Definitions available in the dropdown menu.")]
    public List<NodeDefinition> definitions; // Your existing list

    [Header("Initial Node Layout")]
    [Tooltip("Nodes to automatically spawn in specific slots when the grid initializes.")]
    public List<InitialNodeConfig> initialNodes; // <<< NEW LIST ADDED
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeEffectData.cs
using System;
using UnityEngine;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;

    [Tooltip("Primary numeric value for the effect (e.g., Amount, Duration, Radius Bonus).")] // Updated tooltip
    public float primaryValue;
    [Tooltip("Secondary numeric value for the effect (e.g., Speed, Intensity, Strength Bonus).")] // Updated tooltip
    public float secondaryValue;

    [Tooltip("If TRUE, effect runs once during growth. If FALSE, effect executes during mature cycles.")]
    public bool isPassive = false;

    // --- Scent Specific ---
    // [Tooltip("Identifier (scentID from ScentDefinition) of the scent to apply. Used only if effectType is ScentModifier.")]
    // public string scentIdentifier; // <<< REMOVED

    [Tooltip("The Scent Definition to apply/modify. Used only if effectType is ScentModifier.")]
    public ScentDefinition scentDefinitionReference; // <<< ADDED: Direct reference
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
using System;
using UnityEngine;

public enum NodeEffectType
{
    // --- Passive / Growth Phase Effects (isPassive = true) ---
    // These typically run once at the start to define the plant's structure and base stats.

    // [Tooltip("Base cost calculation (Not currently implemented in PlantGrowth execution).")]
    // ManaCost, // REMOVED
    [Tooltip("Determines the maximum energy the plant can store.")]
    EnergyStorage,
    [Tooltip("Determines the base rate of energy generation through photosynthesis per leaf.")]
    EnergyPhotosynthesis,
    [Tooltip("A required marker effect for a node chain to be spawnable as a plant.")]
    SeedSpawn,
    [Tooltip("Modifies the minimum and maximum potential length of the main stem.")]
    StemLength,
    [Tooltip("Modifies the time interval between each step of stem/leaf growth.")]
    GrowthSpeed,
    [Tooltip("Modifies the number of stem segments between leaf spawns.")]
    LeafGap,
    [Tooltip("Sets the pattern in which leaves are spawned (e.g., Parallel, Alternating).")]
    LeafPattern,
    [Tooltip("Modifies the chance for the stem to grow diagonally instead of straight up.")]
    StemRandomness,
    [Tooltip("Modifies the base time duration between Mature Phase execution cycles.")]
    Cooldown,
    [Tooltip("Modifies the base time delay between executing the effects of sequential nodes within a Mature Phase cycle.")]
    CastDelay,


    // --- Active / Mature Phase Effects (isPassive = false) ---
    // These execute periodically after the plant has finished growing.

    [Tooltip("Energy cost deducted from the plant when this node's active effects are executed during the mature cycle.")]
    EnergyCost, // <<< RENAMED/ADDED
    [Tooltip("Triggers the spawning of a projectile or other output effect (requires OutputNodeEffect component).")]
    Output,
    [Tooltip("Modifies the damage potential of subsequent 'Output' effects in the same cycle.")]
    Damage,
    [Tooltip("Causes the plant to attempt to spawn a berry in an available adjacent slot during the mature cycle.")]
    GrowBerry,
    // Add potentially more active effects: Heal, ApplyStatus, AreaEffect, etc.
    
    
    [Tooltip("Modifies the scent emitted by the next spawned carrier (Berry, Projectile). PrimaryValue=Radius Add, SecondaryValue=Strength Add.")]
    ScentModifier,
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\OutputNodeEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/OutputNodeEffect.cs
using UnityEngine;
using System.Collections.Generic; // Required for Dictionary

public class OutputNodeEffect : MonoBehaviour
{
    [Header("References")]
    [Tooltip("Prefab for the projectile to spawn.")]
    public GameObject projectilePrefab;

    [Header("Settings")]
    public Vector2 spawnOffset = Vector2.up;

    // Store reference needed to call ApplyScentDataToObject
    private PlantGrowth parentPlantGrowth;

    void Awake()
    {
        // Get reference to parent PlantGrowth to access ApplyScentDataToObject helper
        parentPlantGrowth = GetComponentInParent<PlantGrowth>();
        if (parentPlantGrowth == null)
        {
            // This is a critical error if scent application is expected
            Debug.LogError($"[{nameof(OutputNodeEffect)}] Could not find parent PlantGrowth component! Scent application will fail.", gameObject);
        }
    }

    /// <summary>
    /// Activated by PlantGrowth during the Mature Execution Cycle.
    /// Spawns a projectile and applies accumulated effects (damage, scent).
    /// </summary>
    /// <param name="damageMultiplier">Contextual damage modifier calculated from the node chain.</param>
    /// <param name="scentRadiusBonuses">Accumulated radius bonuses per ScentDefinition.</param> // <<< UPDATED PARAM TYPE
    /// <param name="scentStrengthBonuses">Accumulated strength bonuses per ScentDefinition.</param> // <<< UPDATED PARAM TYPE
    public void Activate(float damageMultiplier,
                         Dictionary<ScentDefinition, float> scentRadiusBonuses, // <<< UPDATED TYPE
                         Dictionary<ScentDefinition, float> scentStrengthBonuses) // <<< UPDATED TYPE
    {
        // --- Validations ---
        if (projectilePrefab == null) {
            Debug.LogError($"[{nameof(OutputNodeEffect)}] Projectile Prefab not assigned!", gameObject);
            return;
        }
        
         if (parentPlantGrowth == null) { // Check again in case Awake failed silently
              Debug.LogError($"[{nameof(OutputNodeEffect)}] Cannot activate, parent PlantGrowth reference is missing. Scent application will fail.", gameObject);
             // Decide if we should still spawn projectile without scent or just return
             // return; // Option: Abort if scent cannot be applied
         }

        // Debug.Log($"[OutputNodeEffect] Activate called. Damage Multiplier: {damageMultiplier}. Spawning projectile.");

        // --- Spawn Projectile ---
        Vector2 spawnPos = (Vector2)transform.position + spawnOffset;
        GameObject projGO = Instantiate(projectilePrefab, spawnPos, transform.rotation); // Use plant's rotation or aim logic

        // --- Apply Accumulated Scents to Projectile ---
        // Call the public helper method on the parent PlantGrowth instance
        if (parentPlantGrowth != null) // Check if reference exists before calling
        {
            // Debug.Log($"[{gameObject.name} Activate] Calling ApplyScentDataToObject for {projGO.name}. Passing {scentStrengthsBonuses?.Count ?? 0} scent strength entries."); /////////// here
            
             // Call the public helper with the NEW dictionaries
             parentPlantGrowth.ApplyScentDataToObject(projGO, scentRadiusBonuses, scentStrengthBonuses);
        }
        // -----------------------------------------------

        // --- Initialize Projectile Stats ---
        SpellProjectile spellProj = projGO.GetComponent<SpellProjectile>();
        if(spellProj != null)
        {
            // TODO: Get base damage/speed from effects or projectile definition?
            float baseDamage = 10f; // Example base value
            float baseSpeed = 5f; // Example base value

            float finalDamage = baseDamage * damageMultiplier; // Apply accumulated multiplier
            float finalSpeed = baseSpeed; // TODO: Apply speed modifiers if implemented

            spellProj.Initialize(finalDamage, finalSpeed);
            // Set other properties like friendly fire based on plant context?
        }
        // else { Debug.LogWarning($"[{nameof(OutputNodeEffect)}] Spawned projectile '{projGO.name}' is missing SpellProjectile component.", projGO); }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Runtime/NodeExecutor.cs
using System.Collections.Generic;
using UnityEngine;
using TMPro;
using System.Linq;

public class NodeExecutor : MonoBehaviour
{
    [Header("UI Graph Source")]
    [SerializeField] private NodeEditorGridController nodeEditorGrid;

    [Header("Plant Spawning")]
    [SerializeField] private GameObject plantPrefab;
    [SerializeField] private GardenerController gardener;

    [Header("Debugging")]
    [SerializeField] private TMP_Text debugOutput;

    private void Update()
    {
        // NOTE: Direct planting with spacebar was removed in favor of the tool-based planting system
        // Plants are now created through the PlantPlacementManager when using the SeedPouch tool
    }

    public void SpawnPlantFromUIGraph()
    {
        // --- Validations ---
        if (nodeEditorGrid == null) { DebugLogError("Node Editor Grid Controller not assigned!"); return; }
        if (plantPrefab == null) { DebugLogError("Plant prefab not assigned!"); return; }
        if (gardener == null) { DebugLogError("Gardener Controller not assigned!"); return; }

        // Get the current graph state from the UI grid
        NodeGraph graphToSpawn = nodeEditorGrid.GetCurrentUIGraph();

        if (graphToSpawn == null || graphToSpawn.nodes == null || graphToSpawn.nodes.Count == 0) {
             DebugLog("No nodes in UI graph to spawn.");
             return;
        }

        // Validate if the graph is spawnable (e.g., requires a SeedSpawn effect)
        bool seedFound = graphToSpawn.nodes.Any(node => node != null && node.effects != null && node.effects.Any(eff => eff != null && eff.effectType == NodeEffectType.SeedSpawn && eff.isPassive));
        if (!seedFound) {
            DebugLog("Cannot spawn plant: Node chain lacks a passive SeedSpawn effect.");
            return;
        }

        DebugLog($"Spawning plant from UI graph with {graphToSpawn.nodes.Count} nodes...");

        // Determine spawn position and parent
        Vector2 spawnPos = gardener.GetPlantingPosition();
        Transform plantParent = EcosystemManager.Instance?.plantParent; // Use optional chaining

        // Instantiate the plant prefab
        GameObject plantObj = Instantiate(plantPrefab, spawnPos, Quaternion.identity, plantParent); // Assign parent during instantiate

        // Get the PlantGrowth component
        PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
        if (growthComponent != null)
        {
            // --- Create a DEEP COPY of the NodeGraph ---
            // This is crucial so modifications to the UI graph don't affect running plants,
            // and vice-versa.
            NodeGraph graphCopy = new NodeGraph();
            graphCopy.nodes = new List<NodeData>(graphToSpawn.nodes.Count); // Initialize with capacity

            foreach(NodeData originalNodeData in graphToSpawn.nodes)
            {
                // Ensure original node data is not null
                if (originalNodeData == null) {
                    DebugLogWarning("Encountered null NodeData in UI graph during copy. Skipping.");
                    continue;
                }

                 // Create a new NodeData instance
                 NodeData newNodeData = new NodeData {
                    nodeId = originalNodeData.nodeId, // Copy ID (or generate new one?)
                    nodeDisplayName = originalNodeData.nodeDisplayName,
                    orderIndex = originalNodeData.orderIndex,
                    canBeDeleted = originalNodeData.canBeDeleted, // Copy runtime flags if needed
                    // Create a deep copy of the effects list using the *updated* helper method
                    effects = CloneEffectsList(originalNodeData.effects)
                };
                graphCopy.nodes.Add(newNodeData);
            }

            // Initialize the plant with the deep copy
            growthComponent.InitializeAndGrow(graphCopy);
            DebugLog("Plant spawned and initialized.");
        }
        else
        {
             // Log error and destroy invalid object if PlantGrowth is missing
             DebugLogError($"Prefab '{plantPrefab.name}' missing PlantGrowth component! Destroying spawned object.");
             Destroy(plantObj);
        }
    }

    /// <summary>
    /// Creates a deep copy of a list of NodeEffectData, including the ScentDefinition reference.
    /// </summary>
    private List<NodeEffectData> CloneEffectsList(List<NodeEffectData> originalList)
    {
        if (originalList == null) return new List<NodeEffectData>(); // Handle null input list

        List<NodeEffectData> newList = new List<NodeEffectData>(originalList.Count);
        foreach(var originalEffect in originalList)
        {
            // Ensure original effect data is not null
            if(originalEffect == null) {
                DebugLogWarning("Encountered null NodeEffectData in list during copy. Skipping.");
                continue;
            }

             // Create a new NodeEffectData instance and copy all relevant fields
             NodeEffectData newEffect = new NodeEffectData {
                 effectType = originalEffect.effectType,
                 primaryValue = originalEffect.primaryValue,
                 secondaryValue = originalEffect.secondaryValue,
                 isPassive = originalEffect.isPassive,
                 // <<< FIXED: Explicitly copy the ScentDefinition reference >>>
                 scentDefinitionReference = originalEffect.scentDefinitionReference
             };
             newList.Add(newEffect);
        }
        return newList;
    }

    // Helper methods for logging
    private void DebugLog(string msg) {
        Debug.Log($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += msg + "\n";
    }
    private void DebugLogError(string msg) {
        Debug.LogError($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += $"ERROR: {msg}\n";
    }
     private void DebugLogWarning(string msg) {
        Debug.LogWarning($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += $"WARNING: {msg}\n";
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes = new List<NodeData>();
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\ColorExtensions.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public static class ColorExtensions
{
    public static Color WithAlpha(this Color c, float alpha)
    {
        return new Color(c.r, c.g, c.b, alpha);
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\DeselectOnClickOutside.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems; // Required for IPointerClickHandler

// Add this script to an invisible, fullscreen background UI Image
// Make sure it's the first child of the Canvas to render behind everything else
public class DeselectOnClickOutside : MonoBehaviour, IPointerClickHandler
{
    public void OnPointerClick(PointerEventData eventData)
    {
        // Check if the click was with the left mouse button
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            // If the background is clicked, clear the current node selection
            // Debug.Log("Background Clicked. Clearing Node Selection.");
            NodeCell.ClearSelection();
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeCell.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
// Remove IPointerClickHandler interface from here
// Keep IDropHandler for dropping onto the cell background
public class NodeCell : MonoBehaviour, IPointerClickHandler, IDropHandler // Keep IPointerClickHandler for RIGHT click on empty
{
    public static NodeCell CurrentlySelectedCell { get; private set; }
    public int CellIndex { get; private set; }

    private NodeEditorGridController _controller;
    private NodeData _nodeData;
    private NodeView _nodeView;
    private Image _backgroundImage;

    // --- Init remains the same ---
    public void Init(int index, NodeEditorGridController gridController, Image bgImage)
    {
        CellIndex = index;
        _controller = gridController;
        _backgroundImage = bgImage;

        if (_backgroundImage != null && _controller != null)
        {
            _backgroundImage.color = _controller.EmptyCellColor;
            _backgroundImage.enabled = true;
        }
    }

    // --- HasNode, Getters remain the same ---
    public bool HasNode() => _nodeData != null && _nodeView != null;
    public NodeData GetNodeData() => _nodeData;
    public NodeView GetNodeView() => _nodeView;

    // --- AssignNode, AssignNodeView remain the same ---
     public void AssignNode(NodeDefinition def)
    {
        if (def == null || _controller == null) return;
        RemoveNode();

        _nodeData = new NodeData() { /* ... data setup ... */
            nodeId = System.Guid.NewGuid().ToString(),
            nodeDisplayName = def.displayName,
            effects = def.CloneEffects(),
            orderIndex = this.CellIndex
        };

        GameObject prefabToInstantiate = def.nodeViewPrefab != null ? def.nodeViewPrefab : _controller.NodeViewPrefab;
        if (prefabToInstantiate == null) { /* ... error handling ... */ Debug.LogError($"..."); _nodeData = null; return; }

        GameObject nodeViewGO = Instantiate(prefabToInstantiate, transform);
        _nodeView = nodeViewGO.GetComponent<NodeView>();
        if (_nodeView == null) { /* ... error handling ... */ Debug.LogError($"..."); Destroy(nodeViewGO); _nodeData = null; return; }

        _nodeView.Initialize(_nodeData, def, _controller); // Init NodeView

        NodeDraggable draggable = _nodeView.GetComponent<NodeDraggable>();
        if (draggable == null) draggable = _nodeView.gameObject.AddComponent<NodeDraggable>();
        draggable.Initialize(_controller, this); // Init Draggable

        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }
     public void AssignNodeView(NodeView view, NodeData data)
    {
         RemoveNode();
         _nodeView = view;
         _nodeData = data;
         if (_nodeView != null) {
             _nodeView.transform.SetParent(transform, false);
             if (_nodeData != null) _nodeData.orderIndex = this.CellIndex;
             // Parent ref will be updated by NodeDraggable.SnapToCell which calls NodeView.UpdateParent...
         }
         if(_backgroundImage != null) _backgroundImage.enabled = true;
    }


    // --- RemoveNode, ClearNodeReference remain the same ---
    public void RemoveNode()
    {
        bool wasSelected = (CurrentlySelectedCell == this);
        if (_nodeView != null) {
            if (wasSelected) {
                 _nodeView.Unhighlight();
                 CurrentlySelectedCell = null;
            }
            Destroy(_nodeView.gameObject);
        }
        _nodeView = null; _nodeData = null;
        if (wasSelected && CurrentlySelectedCell == this) CurrentlySelectedCell = null;
        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }
     public void ClearNodeReference()
    {
        _nodeView = null; _nodeData = null;
        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }

    // --- Selection Handling (SelectCell, ClearSelection) remains the same ---
     public static void SelectCell(NodeCell cellToSelect)
    {
        if (cellToSelect == null || !cellToSelect.HasNode()) { ClearSelection(); return; }
        if (CurrentlySelectedCell == cellToSelect) return;
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Unhighlight();
        }
        CurrentlySelectedCell = cellToSelect;
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Highlight();
        }
    }
     public static void ClearSelection()
    {
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Unhighlight();
        }
        CurrentlySelectedCell = null;
    }

    // --- Event Handlers UPDATED ---

    /// <summary>
    /// Handles clicks on the CELL BACKGROUND image.
    /// Left Click: Does nothing (NodeView handles selection).
    /// Right Click: Opens add node menu ONLY if the cell is currently empty.
    /// </summary>
    public void OnPointerClick(PointerEventData eventData)
    {
        // This click is on the NodeCell's background image

        if (eventData.button == PointerEventData.InputButton.Right)
        {
            // Right Click: Only allow opening the dropdown if the cell is currently EMPTY.
            if (!HasNode())
            {
                // Debug.Log($"NodeCell Background Clicked (Right) on Empty Cell {CellIndex}. Opening dropdown.");
                ClearSelection(); // Clear selection before showing add menu
                _controller?.OnEmptyCellRightClicked(this, eventData);
            }
            // If right-clicking the background of an occupied cell, do nothing.
        }
        // Left click on the background does nothing regarding selection now.
    }


    // --- OnDrop remains the same ---
    public void OnDrop(PointerEventData eventData)
    {
        GameObject draggedObject = eventData.pointerDrag;
        if (draggedObject != null) {
            NodeDraggable draggedNode = draggedObject.GetComponent<NodeDraggable>();
            if (draggedNode != null && _controller != null) {
                 _controller.HandleNodeDrop(draggedNode, draggedNode.OriginalCell, eventData.position);
            }
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeDraggable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
public class NodeDraggable : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
    private RectTransform _rectTransform;
    private CanvasGroup _canvasGroup;
    private Vector2 _originalAnchoredPosition;
    private Transform _originalParent;
    private NodeCell _originalCell;
    private NodeEditorGridController _gridController;
    private Canvas _rootCanvas;

    // No _isDragging flag needed if managed carefully by events

    public NodeCell OriginalCell => _originalCell;

    void Awake()
    {
        _rectTransform = GetComponent<RectTransform>();
        _canvasGroup = GetComponent<CanvasGroup>();
        if (_canvasGroup == null)
        {
            _canvasGroup = gameObject.AddComponent<CanvasGroup>();
        }
        // CRITICAL: Default state MUST allow interactions (clicks, hovers)
        _canvasGroup.blocksRaycasts = true;
        _canvasGroup.alpha = 1f; // Ensure fully visible
    }

    public void Initialize(NodeEditorGridController controller, NodeCell startingCell)
    {
        _gridController = controller;
        _originalCell = startingCell;
        _rootCanvas = GetComponentInParent<Canvas>()?.rootCanvas;
        if (_rootCanvas == null) Debug.LogError("[NodeDraggable] Could not find root Canvas!");

        // Ensure initial state after initialization
        if (_canvasGroup != null) {
             _canvasGroup.blocksRaycasts = true;
             _canvasGroup.alpha = 1f;
        }
    }

    public void OnBeginDrag(PointerEventData eventData)
    {
        if (eventData.button != PointerEventData.InputButton.Left) return;
        if (_gridController == null || _rootCanvas == null) return;

        _originalParent = transform.parent;
        _originalCell = _originalParent?.GetComponent<NodeCell>();
        _originalAnchoredPosition = _rectTransform.anchoredPosition;

        // Become transparent and STOP blocking raycasts so underlying cells can be detected
        _canvasGroup.alpha = 0.6f;
        _canvasGroup.blocksRaycasts = false;

        // Reparent for top rendering
        transform.SetParent(_rootCanvas.transform, true);
        transform.SetAsLastSibling();
         // Debug.Log($"[NodeDraggable OnBeginDrag] Started drag. blocksRaycasts: {_canvasGroup.blocksRaycasts}", gameObject);
    }

    public void OnDrag(PointerEventData eventData)
    {
        // Only process drag if it's the left button and dragging is conceptually active (raycasts blocked)
        if (eventData.button != PointerEventData.InputButton.Left || _canvasGroup == null || _canvasGroup.blocksRaycasts) return;
        if (_gridController == null || _rootCanvas == null) return;

        // Move logic (unchanged)
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
             _rootCanvas.transform as RectTransform, eventData.position,
             _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera, out Vector2 currentLocalPoint);
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
            _rootCanvas.transform as RectTransform, eventData.position - eventData.delta,
            _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera, out Vector2 previousLocalPoint);
        Vector2 localDelta = currentLocalPoint - previousLocalPoint;
        _rectTransform.localPosition += (Vector3)localDelta;
    }

    public void OnEndDrag(PointerEventData eventData)
    {
         // Debug.Log($"[NodeDraggable OnEndDrag] Drag ended. Button: {eventData.button}", gameObject);

        // Ensure visuals and raycast blocking are reset REGARDLESS of button, BEFORE handling drop
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true; // CRITICAL: Re-enable raycasts immediately
             // Debug.Log($"--> Reset alpha and blocksRaycasts to: {_canvasGroup.blocksRaycasts}");
        }

        // Only handle the drop logic if the drag was initiated by the left button
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            if (_gridController != null) {
                _gridController.HandleNodeDrop(this, _originalCell, eventData.position);
            } else {
                 // No controller, attempt reset
                 ResetPosition();
            }
        }
        else
        {
             // If drag ended via another button (unlikely but possible), ensure reset
             ResetPosition();
        }
    }

    public void ResetPosition()
    {
        // Debug.Log($"[NodeDraggable ResetPosition] Resetting {gameObject.name}", gameObject);
        // Reset parent and position
        transform.SetParent(_originalParent, false);
        _rectTransform.anchoredPosition = _originalAnchoredPosition;
        _originalCell = _originalParent?.GetComponent<NodeCell>(); // Update cell ref

        // Ensure visuals and raycasts are correct after reset
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
        }

        // Update parent cell reference on the NodeView
        NodeView view = GetComponent<NodeView>();
        view?.UpdateParentCellReference();
    }

    public void SnapToCell(NodeCell targetCell)
    {
        // Debug.Log($"[NodeDraggable SnapToCell] Snapping {gameObject.name} to Cell {targetCell?.CellIndex}", gameObject);
        if (targetCell == null) { ResetPosition(); return; }

        // Set Parent and Position
        transform.SetParent(targetCell.transform, false);
        _rectTransform.anchoredPosition = Vector2.zero;

        // Update Internal Draggable References
        _originalParent = targetCell.transform;
        _originalCell = targetCell;
        _originalAnchoredPosition = Vector2.zero;

        // Ensure visuals and raycasts are correct after snap
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
        }

        // Update the NodeView's parent reference
        NodeView view = GetComponent<NodeView>();
        view?.UpdateParentCellReference();
    }

    // OnDisable might not be strictly needed now but can be kept as safety
    void OnDisable()
    {
        // If it was disabled mid-drag (blocksRaycasts == false), reset state
        if (_canvasGroup != null && !_canvasGroup.blocksRaycasts)
        {
             Debug.LogWarning($"[NodeDraggable] Disabled while dragging {gameObject.name}. Resetting CanvasGroup.", gameObject);
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
            // Resetting position might be desired but complex here, ensure visuals are ok.
        }
    }
}





--------------------------------------------------------------------------------
This is part 3 out of 5 of script collection. 2 more parts remain.
--------------------------------------------------------------------------------