This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-05-29 10:42:16
PART 8 OF 10
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantOutline.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── Panels
│   │       │   ├── Panel_DropZone.prefab
│   │       │   ├── Panel_GeneListItem.prefab
│   │       │   ├── Panel_GeneSequenceItem.prefab
│   │       │   ├── Panel_SeedListItem.prefab
│   │       │   └── Panel_SeedSelectionButton.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   ├── PLANTOTRON_Machine.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           ├── DualGridRuleTile_Grass.asset
│           └── DualGridRuleTile_Water.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_PoopFertilizer.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Seeds
│   │   └── SeedDefinition_000_Base.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       ├── Wave_001.asset
│       └── Wave_002.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── LeafData.cs
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.Cell.cs
│   │   │   ├── PlantGrowth.Growth.cs
│   │   │   ├── PlantGrowth.NodeExecution.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── SlowdownZone.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   ├── Seeds
│   │   │   ├── PlantotronGeneItem.cs
│   │   │   ├── PlantotronGeneSequenceItem.cs
│   │   │   ├── PlantotronMachine.cs
│   │   │   ├── PlantotronSeedItem.cs
│   │   │   ├── PlantotronSequenceDropZone.cs
│   │   │   ├── PlantotronUI.cs
│   │   │   ├── PlayerGeneticsInventory.cs
│   │   │   ├── SeedDefinition.cs
│   │   │   ├── SeedInstance.cs
│   │   │   ├── SeedSelectionButton.cs
│   │   │   └── SeedSelectionUI.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManager.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── OutlinePartController.cs
│       ├── PixelPerfectSetup.cs
│       ├── PlantOutlineController.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       ├── ShadowPartController.cs
│       ├── WaterReflection.cs
│       └── WaterReflectionManager.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Custom_WaterReflectionGradient.mat
│   ├── Sprite-Lit-Advanced_Overlay_Base.mat
│   ├── Sprite-Lit-Default_OverlayAdvanced.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   ├── SpriteEmissiveUnlit.shader
│   ├── WaterReflection.shader
│   └── WaterReflectionSimple.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Player\GardenerController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Player/GardenerController.cs
using UnityEngine;
using System;
using System.Collections.Generic;

// No longer requires ToolSwitcher on the same GameObject
public class GardenerController : MonoBehaviour
{
    // --- Fields ---
    [Header("Movement Settings")]
    public float moveSpeed = 5f;
    
    [Header("Speed Modifiers")]
    [Tooltip("Current speed including all active modifiers (read-only)")]
    [SerializeField] private float currentMoveSpeed;
    private float baseMoveSpeed;
    private List<float> activeSpeedMultipliers = new List<float>();
    
    [Header("Planting Settings")]
    public Vector2 seedPlantingOffset = new Vector2(0f, -0.5f);

    [Header("Tool References")] // <<< NEW HEADER
    [Tooltip("Assign the SpriteRenderer used to display the current tool's icon.")]
    [SerializeField] private SpriteRenderer toolIconRenderer;
    [Tooltip("Assign the GameObject or Component containing the ToolSwitcher script.")] // <<< NEW TOOLTIP
    [SerializeField] private ToolSwitcher toolSwitcherInstance; // <<< CHANGED: Reference field

    [Header("Visual Settings")]
    public bool flipSpriteWhenMovingLeft = true;
    public bool flipHorizontalDirection = true;

    [Header("Animation Settings")]
    public bool useAnimations = true;
    public string runningParameterName = "isRunning";
    public string plantingParameterName = "isPlanting";
    public float plantingDuration = 0.25f;

    // Private references
    private Rigidbody2D rb;
    private Vector2 movement;
    private SortableEntity sortableEntity;
    private SpriteRenderer spriteRenderer;
    private Animator animator;
    // ToolSwitcher reference is now toolSwitcherInstance (assigned via inspector)

    // Private variables
    private bool isPlanting = false;
    private float plantingTimer = 0f;
    private bool wasMovingBeforePlanting = false;

    void Awake()
    {
        // Store original components and references
        rb = GetComponent<Rigidbody2D>();
        sortableEntity = GetComponent<SortableEntity>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        animator = GetComponent<Animator>();

        // Store base movement speed for multiplier system
        baseMoveSpeed = moveSpeed;
        currentMoveSpeed = moveSpeed;
    
        // Initialize speed multipliers list
        activeSpeedMultipliers = new List<float>();

        if (sortableEntity == null)
            sortableEntity = gameObject.AddComponent<SortableEntity>();

        // Validations for other components
        if (spriteRenderer == null)
            Debug.LogWarning("[GardenerController Awake] Main SpriteRenderer component not found.", gameObject);
    
        if (animator == null && useAnimations)
            Debug.LogWarning("[GardenerController Awake] Animator component not found but useAnimations is true.", gameObject);

        if (toolSwitcherInstance == null)
        {
            Debug.LogError("[GardenerController Awake] Tool Switcher Instance is not assigned in the Inspector! Tool switching and icon display will not function.", gameObject);
        }

        if (toolIconRenderer == null)
            Debug.LogError("[GardenerController Awake] Tool Icon Renderer is not assigned in the Inspector! Tool icons will not display.", gameObject);
        else
        {
            Debug.Log("[GardenerController Awake] Tool Icon Renderer found. Initializing as hidden.", gameObject);
            toolIconRenderer.enabled = false;
        }
    }

    private void Start()
    {
        // Subscribe ONLY if toolSwitcherInstance was assigned in the inspector
        if (toolSwitcherInstance != null)
        {
            Debug.Log("[GardenerController Start] ToolSwitcherInstance assigned. Subscribing to ToolSwitcher.OnToolChanged.", gameObject);
            toolSwitcherInstance.OnToolChanged += HandleToolChanged;

            // Manually trigger the handler once at the start
            Debug.Log("[GardenerController Start] Manually calling HandleToolChanged for initial tool.", gameObject);
            HandleToolChanged(toolSwitcherInstance.CurrentTool);
        }
        else
        {
             // Error logged in Awake, no need for more logs here.
        }
    }

    private void OnDestroy()
    {
        // Clear speed multipliers list
        activeSpeedMultipliers.Clear();
        // Unsubscribe ONLY if toolSwitcherInstance was assigned and we subscribed
        if (toolSwitcherInstance != null)
        {
            Debug.Log("[GardenerController OnDestroy] Unsubscribing from ToolSwitcher.OnToolChanged.", gameObject);
            toolSwitcherInstance.OnToolChanged -= HandleToolChanged;
        }
    }

    // --- Update, FixedUpdate, UpdateAnimations, UpdateSpriteDirection, Start/EndPlantingAnimation, GetPlantingPosition, SetPlantingDuration, Plant methods remain the same ---
    private void Update()
    {
        if (!isPlanting)
        {
            movement.x = Input.GetAxisRaw("Horizontal");
            movement.y = Input.GetAxisRaw("Vertical");
            bool isMoving = movement.sqrMagnitude > 0.01f;
            if (isMoving) wasMovingBeforePlanting = true;
        }
        else
        {
            movement = Vector2.zero;
            plantingTimer -= Time.deltaTime;
            if (plantingTimer <= 0) EndPlantingAnimation();
        }
        UpdateAnimations();
        UpdateSpriteDirection();
    }
    
    public void ApplySpeedMultiplier(float multiplier)
    {
        if (!activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Add(multiplier);
            UpdateMovementSpeed();
        
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Applied speed multiplier: {multiplier}. New speed: {currentMoveSpeed}");
            }
        }
    }
    
    private void UpdateMovementSpeed()
    {
        // Start with base speed
        float newSpeed = baseMoveSpeed;
    
        // Apply all active multipliers
        if (activeSpeedMultipliers.Count > 0)
        {
            // Use the most restrictive (lowest) multiplier
            float lowestMultiplier = 1.0f;
            foreach (float multiplier in activeSpeedMultipliers)
            {
                if (multiplier < lowestMultiplier)
                {
                    lowestMultiplier = multiplier;
                }
            }
        
            newSpeed *= lowestMultiplier;
        }
    
        // Update the current move speed
        currentMoveSpeed = newSpeed;
    }
    
    public void RemoveSpeedMultiplier(float multiplier)
    {
        if (activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Remove(multiplier);
            UpdateMovementSpeed();
        
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Removed speed multiplier: {multiplier}. New speed: {currentMoveSpeed}");
            }
        }
    }
    
    
    void FixedUpdate()
    {
        if (!isPlanting)
        {
            // Use currentMoveSpeed (with modifiers) instead of moveSpeed
            rb.MovePosition(rb.position + movement.normalized * currentMoveSpeed * Time.fixedDeltaTime);
        }
    }
    private void UpdateAnimations() { if (!useAnimations || animator == null) return; bool isMoving = movement.sqrMagnitude > 0.01f; animator.SetBool(runningParameterName, isMoving); }
    private void UpdateSpriteDirection() { if (spriteRenderer == null || !flipSpriteWhenMovingLeft) return; if (movement.x != 0) { bool shouldFlip = (movement.x < 0); if (flipHorizontalDirection) { spriteRenderer.flipX = shouldFlip; } else { Vector3 scale = transform.localScale; scale.x = shouldFlip ? -Mathf.Abs(scale.x) : Mathf.Abs(scale.x); transform.localScale = scale; } } }
    public void StartPlantingAnimation() { if (!useAnimations || isPlanting) return; isPlanting = true; plantingTimer = plantingDuration; wasMovingBeforePlanting = movement.sqrMagnitude > 0.01f; if (animator != null) { animator.SetBool(plantingParameterName, true); animator.SetBool(runningParameterName, false); } }
    private void EndPlantingAnimation() { isPlanting = false; if (animator != null) { animator.SetBool(plantingParameterName, false); movement.x = Input.GetAxisRaw("Horizontal"); movement.y = Input.GetAxisRaw("Vertical"); bool shouldResumeRunning = movement.sqrMagnitude > 0.01f; animator.SetBool(runningParameterName, shouldResumeRunning); } }
    public Vector2 GetPlantingPosition() { return (Vector2)transform.position + seedPlantingOffset; }
    public void SetPlantingDuration(float duration) { plantingDuration = Mathf.Max(0.1f, duration); }
    public void Plant() { StartPlantingAnimation(); }
    // ---------------------------------

    // --- HandleToolChanged remains the same (uses toolSwitcherInstance implicitly via Start/OnDestroy) ---
    private void HandleToolChanged(ToolDefinition newTool)
    {
        string toolName = newTool != null ? newTool.displayName : "NULL";
        Debug.Log($"[HandleToolChanged] Received tool: {toolName}", gameObject);

        if (toolIconRenderer == null)
        {
            Debug.LogError("[HandleToolChanged] toolIconRenderer is NULL. Cannot update icon.", gameObject);
            return;
        }

        if (newTool != null)
        {
            string iconName = newTool.icon != null ? newTool.icon.name : "NULL";
            Debug.Log($"[HandleToolChanged] Tool '{toolName}' has icon: {iconName}", gameObject);

            if (newTool.icon != null)
            {
                Debug.Log($"[HandleToolChanged] Assigning sprite '{newTool.icon.name}' and color '{newTool.iconTint}' to toolIconRenderer.", gameObject);
                toolIconRenderer.sprite = newTool.icon;
                toolIconRenderer.color = newTool.iconTint;
                Debug.Log($"[HandleToolChanged] Enabling toolIconRenderer. Current state before: {toolIconRenderer.enabled}", gameObject);
                toolIconRenderer.enabled = true;
                Debug.Log($"[HandleToolChanged] toolIconRenderer.enabled is now: {toolIconRenderer.enabled}", gameObject);
                Debug.Log($"[HandleToolChanged] toolIconRenderer.sprite is now: {toolIconRenderer.sprite?.name ?? "NULL"}", gameObject);
            }
            else
            {
                Debug.LogWarning($"[HandleToolChanged] Tool '{toolName}' has a NULL icon. Hiding renderer.", gameObject);
                toolIconRenderer.enabled = false;
                toolIconRenderer.sprite = null;
            }
        }
        else
        {
            Debug.Log("[HandleToolChanged] newTool is NULL. Hiding renderer.", gameObject);
            toolIconRenderer.enabled = false;
            toolIconRenderer.sprite = null;
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlantGrowthModifierManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

public class PlantGrowthModifierManager : MonoBehaviour
{
    public static PlantGrowthModifierManager Instance { get; private set; }

    [System.Serializable]
    public class TileGrowthModifier
    {
        [Tooltip("The tile definition this modifier applies to")]
        public TileDefinition tileDefinition;

        [Tooltip("Multiplier for plant growth speed when on this tile (1.0 = normal)")]
        [Range(0.1f, 3.0f)]
        public float growthSpeedMultiplier = 1.0f;

        [Tooltip("Multiplier for energy recharge speed when on this tile (1.0 = normal)")]
        [Range(0.1f, 3.0f)]
        public float energyRechargeMultiplier = 1.0f;
    }

    [Header("Default Settings")]
    [Tooltip("Default multiplier for tiles that aren't specifically configured")]
    [Range(0.1f, 3.0f)]
    public float defaultGrowthSpeedMultiplier = 1.0f;

    [Tooltip("Default multiplier for energy recharge on tiles that aren't specifically configured")]
    [Range(0.1f, 3.0f)]
    public float defaultEnergyRechargeMultiplier = 1.0f;

    [Header("Tile Update Settings")]
    [Tooltip("How often (in seconds) to check if plants are on different tiles")]
    [Range(0.5f, 5.0f)]
    public float tileUpdateInterval = 1.0f;

    [Header("Tile Growth Modifiers")]
    [Tooltip("Define growth and energy recharge multipliers for specific tiles")]
    public List<TileGrowthModifier> tileModifiers = new List<TileGrowthModifier>();

    [Header("References")]
    [SerializeField] private TileInteractionManager tileInteractionManager;

    [Header("Debug")]
    [SerializeField] private bool showDebugMessages = true;
    [SerializeField] private bool showTileChangeMessages = true;

    // Dictionary for faster lookup of modifiers by tile definition
    private Dictionary<TileDefinition, TileGrowthModifier> modifierLookup = new Dictionary<TileDefinition, TileGrowthModifier>();

    // Dictionary to track what tile each plant is on
    private Dictionary<PlantGrowth, TileDefinition> plantTiles = new Dictionary<PlantGrowth, TileDefinition>();
    
    // Timer for tile updates
    private float tileUpdateTimer = 0f;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // Build lookup dictionary for faster access
        BuildModifierLookup();
    }

    private void Start()
    {
        // Find TileInteractionManager if not assigned
        if (tileInteractionManager == null)
        {
            tileInteractionManager = TileInteractionManager.Instance;
            if (tileInteractionManager == null && showDebugMessages)
            {
                Debug.LogWarning("PlantGrowthModifierManager: TileInteractionManager not found!");
            }
        }
        
        // Start with a tile update
        tileUpdateTimer = 0f;
    }

    private void Update()
    {
        // Update timer
        tileUpdateTimer -= Time.deltaTime;
        
        // Check if it's time to update tiles
        if (tileUpdateTimer <= 0f)
        {
            UpdateAllPlantTiles();
            tileUpdateTimer = tileUpdateInterval;
        }
    }

    // Check all plants to see if their tiles have changed
    private void UpdateAllPlantTiles()
    {
        if (tileInteractionManager == null)
        {
            return;
        }
        
        // We need to copy the keys to avoid modifying the dictionary during iteration
        List<PlantGrowth> plantsToCheck = new List<PlantGrowth>(plantTiles.Keys);
        
        foreach (PlantGrowth plant in plantsToCheck)
        {
            if (plant == null)
            {
                // Plant has been destroyed, remove from dictionary
                plantTiles.Remove(plant);
                continue;
            }
            
            // Convert plant position to grid position
            Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
            
            // Get current tile definition at this position
            TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
            
            // Get previously stored tile definition
            TileDefinition previousTileDef = plantTiles[plant];
            
            // Check if tile has changed
            if (currentTileDef != previousTileDef)
            {
                // Update stored tile
                plantTiles[plant] = currentTileDef;
                
                if (showTileChangeMessages)
                {
                    string previousTileName = previousTileDef != null ? previousTileDef.displayName : "None";
                    string currentTileName = currentTileDef != null ? currentTileDef.displayName : "None";
                    Debug.Log($"Plant tile changed: {previousTileName} -> {currentTileName}");
                }
            }
        }
    }

    private void BuildModifierLookup()
    {
        modifierLookup.Clear();
        foreach (var modifier in tileModifiers)
        {
            if (modifier.tileDefinition != null && !modifierLookup.ContainsKey(modifier.tileDefinition))
            {
                modifierLookup.Add(modifier.tileDefinition, modifier);
            }
        }

        if (showDebugMessages)
        {
            Debug.Log($"PlantGrowthModifierManager: Built lookup with {modifierLookup.Count} tile modifiers");
        }
    }

    // Call this when a plant is created to register its tile
    public void RegisterPlantTile(PlantGrowth plant, TileDefinition tileDef)
    {
        if (plant == null)
            return;

        plantTiles[plant] = tileDef;

        if (showDebugMessages)
        {
            string tileName = tileDef != null ? tileDef.displayName : "Unknown Tile";
            Debug.Log($"Registered plant {plant.name} on tile {tileName}");
        }
    }

    // Call this when a plant is destroyed to clean up
    public void UnregisterPlant(PlantGrowth plant)
    {
        if (plant == null)
            return;

        if (plantTiles.ContainsKey(plant))
        {
            plantTiles.Remove(plant);
        }
    }

    // Get growth speed multiplier for a plant based on its tile
    public float GetGrowthSpeedMultiplier(PlantGrowth plant)
    {
        if (plant == null)
            return defaultGrowthSpeedMultiplier;
        
        // If plant not in dictionary, register it with its current tile
        if (!plantTiles.ContainsKey(plant))
        {
            RegisterNewPlant(plant);
        }
        
        TileDefinition tileDef = plantTiles[plant];
        if (tileDef == null)
        {
            return defaultGrowthSpeedMultiplier;
        }

        if (modifierLookup.TryGetValue(tileDef, out TileGrowthModifier modifier))
        {
            return modifier.growthSpeedMultiplier;
        }

        return defaultGrowthSpeedMultiplier;
    }

    // Get energy recharge multiplier for a plant based on its tile
    public float GetEnergyRechargeMultiplier(PlantGrowth plant)
    {
        if (plant == null)
            return defaultEnergyRechargeMultiplier;
        
        // If plant not in dictionary, register it with its current tile
        if (!plantTiles.ContainsKey(plant))
        {
            RegisterNewPlant(plant);
        }
        
        TileDefinition tileDef = plantTiles[plant];
        if (tileDef == null)
        {
            return defaultEnergyRechargeMultiplier;
        }

        if (modifierLookup.TryGetValue(tileDef, out TileGrowthModifier modifier))
        {
            return modifier.energyRechargeMultiplier;
        }

        return defaultEnergyRechargeMultiplier;
    }
    
    // Helper method to register a new plant with its current tile
    private void RegisterNewPlant(PlantGrowth plant)
    {
        if (plant == null || tileInteractionManager == null)
            return;
            
        Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
        TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
        
        plantTiles[plant] = currentTileDef;
        
        if (showDebugMessages)
        {
            string tileName = currentTileDef != null ? currentTileDef.displayName : "Unknown Tile";
            Debug.Log($"Auto-registered plant {plant.name} on tile {tileName}");
        }
    }

    // For editor support - rebuild lookup when modifiers change
    public void OnValidate()
    {
        BuildModifierLookup();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlantPlacementManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Data/PlantPlacementManager.cs (FIXED)
using System.Collections.Generic;
using UnityEngine;

public class PlantPlacementManager : MonoBehaviour
{
    public static PlantPlacementManager Instance { get; private set; }

    [Header("References")]
    [SerializeField] private GameObject plantPrefab;
    [SerializeField] private Transform plantParent;
    [SerializeField] private TileInteractionManager tileInteractionManager;
    [SerializeField] private PlantGrowthModifierManager growthModifierManager;

    [Header("Planting Settings")]
    [Tooltip("Maximum radius from cell center for random seed placement (in units)")]
    [SerializeField] private float spawnRadius = 0.25f;
    
    [Tooltip("Increment for position randomization (in pixels, for pixel-perfect placement)")]
    [SerializeField] private float spawnRadiusIncrement = 4f;

    [Header("Tile Restrictions")]
    [Tooltip("List of tiles that cannot be planted on")]
    [SerializeField] private List<TileDefinition> invalidPlantingTiles = new List<TileDefinition>();

    [Header("Debug")]
    [SerializeField] private bool showDebugMessages = true; // Changed to true for debugging
    
    // Cache for quick lookup of invalid tiles
    private HashSet<TileDefinition> invalidTilesSet = new HashSet<TileDefinition>();
    
    // Dictionary to track plant positions (using grid cell positions as keys)
    private Dictionary<Vector3Int, GameObject> plantsByGridPosition = new Dictionary<Vector3Int, GameObject>();
    
    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        
        // Build the set of invalid tiles for faster lookup
        RebuildInvalidTilesSet();
    }

    private void Start()
    {
        // Initialize references if not set in inspector
        if (plantParent == null && EcosystemManager.Instance != null)
        {
            plantParent = EcosystemManager.Instance.plantParent;
        }
        
        if (tileInteractionManager == null)
        {
            tileInteractionManager = TileInteractionManager.Instance;
        }
        
        if (growthModifierManager == null)
        {
            growthModifierManager = PlantGrowthModifierManager.Instance;
        }
    }
    
    private void RebuildInvalidTilesSet()
    {
        invalidTilesSet.Clear();
        foreach (var tile in invalidPlantingTiles)
        {
            if (tile != null)
            {
                invalidTilesSet.Add(tile);
            }
        }
        
        if (showDebugMessages)
        {
            Debug.Log($"PlantPlacementManager: Built invalid tiles set with {invalidTilesSet.Count} entries");
        }
    }
    
    private void OnValidate()
    {
        // Rebuild the set when changed in Inspector
        RebuildInvalidTilesSet();
    }

    // --- Position Management ---
    
    public bool IsPositionOccupied(Vector3Int gridPosition)
    {
        if (plantsByGridPosition.TryGetValue(gridPosition, out GameObject plant))
        {
            if (plant == null)
            {
                plantsByGridPosition.Remove(gridPosition);
                return false;
            }
            return true;
        }
        return false;
    }
    
    public bool IsTileValidForPlanting(TileDefinition tileDef)
    {
        if (tileDef == null)
            return false;
            
        return !invalidTilesSet.Contains(tileDef);
    }

    public void CleanupDestroyedPlants()
    {
        List<Vector3Int> keysToRemove = new List<Vector3Int>();
        
        foreach (var kvp in plantsByGridPosition)
        {
            if (kvp.Value == null)
            {
                keysToRemove.Add(kvp.Key);
            }
        }
        
        foreach (var key in keysToRemove)
        {
            plantsByGridPosition.Remove(key);
        }
        
        if (showDebugMessages && keysToRemove.Count > 0)
        {
            Debug.Log($"PlantPlacementManager: Removed {keysToRemove.Count} destroyed plant references.");
        }
    }

    // --- FIXED: Seed-based planting methods ---

    /// <summary>
    /// FIXED: Try to plant using seed selection system
    /// </summary>
    public void TryPlantWithSeedSelection(Vector3Int gridPosition, Vector3 worldPosition, 
        System.Action onCompleted = null)
    {
        if (showDebugMessages)
            Debug.Log($"[PlantPlacementManager] TryPlantWithSeedSelection called at {gridPosition}");
        
        // Basic validation
        if (!CanPlantAtPosition(gridPosition))
        {
            if (showDebugMessages)
                Debug.Log("[PlantPlacementManager] Cannot plant at position - validation failed");
            onCompleted?.Invoke();
            return;
        }

        // CRITICAL FIX: Ensure SeedSelectionUI instance exists and is properly initialized
        if (SeedSelectionUI.Instance == null)
        {
            Debug.LogError("[PlantPlacementManager] SeedSelectionUI.Instance is null! Make sure SeedSelectionUI exists in the scene.");
            onCompleted?.Invoke();
            return;
        }
        
        if (PlayerGeneticsInventory.Instance == null)
        {
            Debug.LogError("[PlantPlacementManager] PlayerGeneticsInventory.Instance is null!");
            onCompleted?.Invoke();
            return;
        }

        var plantableSeeds = PlayerGeneticsInventory.Instance.GetPlantableSeeds();
        
        if (showDebugMessages)
            Debug.Log($"[PlantPlacementManager] Found {plantableSeeds.Count} plantable seeds");
        
        if (plantableSeeds.Count == 0)
        {
            if (showDebugMessages)
                Debug.Log("Cannot plant: No plantable seeds available in inventory.");
            onCompleted?.Invoke();
            return;
        }
        
        if (plantableSeeds.Count == 1)
        {
            // Auto-select single seed
            if (showDebugMessages)
                Debug.Log($"[PlantPlacementManager] Auto-selecting single seed: {plantableSeeds[0].seedName}");
            TryPlantSeedInstance(plantableSeeds[0], gridPosition, worldPosition);
            onCompleted?.Invoke();
        }
        else
        {
            // Show selection UI
            if (showDebugMessages)
                Debug.Log("[PlantPlacementManager] Showing seed selection UI for multiple seeds");
            
            SeedSelectionUI.Instance.ShowSeedSelection(selectedSeed => {
                if (showDebugMessages)
                    Debug.Log($"[PlantPlacementManager] Seed selected from UI: {selectedSeed?.seedName ?? "null"}");
                if (selectedSeed != null)
                {
                    TryPlantSeedInstance(selectedSeed, gridPosition, worldPosition);
                }
                onCompleted?.Invoke();
            });
        }
    }

    /// <summary>
    /// FIXED: Plant a specific seed instance
    /// </summary>
    public bool TryPlantSeedInstance(SeedInstance seedInstance, Vector3Int gridPosition, Vector3 worldPosition)
    {
        if (showDebugMessages)
            Debug.Log($"[PlantPlacementManager] TryPlantSeedInstance called for seed: {seedInstance?.seedName ?? "null"}");
        
        if (seedInstance == null)
        {
            if (showDebugMessages)
                Debug.LogError("Cannot plant: Seed instance is null!");
            return false;
        }

        if (!seedInstance.IsValidForPlanting())
        {
            if (showDebugMessages)
                Debug.Log($"Cannot plant: Seed '{seedInstance.seedName}' is not valid for planting.");
            return false;
        }

        // Check if position is still valid
        if (!CanPlantAtPosition(gridPosition))
        {
            if (showDebugMessages)
                Debug.Log($"Cannot plant: Position {gridPosition} is not valid for planting.");
            return false;
        }

        // Calculate planting position
        Vector3 plantingPosition = GetRandomizedPlantingPosition(worldPosition);
        
        if (showDebugMessages)
            Debug.Log($"[PlantPlacementManager] Planting at position: {plantingPosition}");
        
        // Spawn the plant
        GameObject plantObj = SpawnPlantFromSeed(seedInstance, plantingPosition);
        if (plantObj != null)
        {
            // Track the plant position
            plantsByGridPosition[gridPosition] = plantObj;
            
            // Register with growth modifier manager
            RegisterPlantWithModifiers(plantObj, gridPosition);
            
            // Remove seed from inventory
            if (PlayerGeneticsInventory.Instance != null)
            {
                PlayerGeneticsInventory.Instance.RemoveSeed(seedInstance);
                if (showDebugMessages)
                    Debug.Log($"Planted and consumed seed: {seedInstance.seedName}");
            }
            
            return true;
        }
        else
        {
            if (showDebugMessages)
                Debug.LogError($"Failed to spawn plant from seed: {seedInstance.seedName}");
        }
        return false;
    }

    // --- LEGACY: Original NodeGraph-based planting (kept for compatibility) ---

    public bool TryPlantSeed(Vector3Int gridPosition, Vector3 worldPosition)
    {
        // This is the old method - now redirects to seed selection
        TryPlantWithSeedSelection(gridPosition, worldPosition);
        return true; // Always return true as the new system handles validation internally
    }

    // --- Private Helper Methods ---

    private bool CanPlantAtPosition(Vector3Int gridPosition)
    {
        // Clean up any destroyed plants first
        CleanupDestroyedPlants();
        
        // Check if position is occupied
        if (IsPositionOccupied(gridPosition))
        {
            if (showDebugMessages)
                Debug.Log($"Cannot plant: Position {gridPosition} already has a plant.");
            return false;
        }
        
        // Check tile validity
        TileDefinition tileDef = null;
        if (tileInteractionManager != null)
        {
            tileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
            
            if (!IsTileValidForPlanting(tileDef))
            {
                if (showDebugMessages)
                {
                    string tileName = tileDef != null ? tileDef.displayName : "Unknown";
                    Debug.Log($"Cannot plant: Tile {tileName} is not valid for planting.");
                }
                return false;
            }
        }

        return true;
    }

    /// <summary>
    /// FIXED: Spawn a plant from a SeedInstance
    /// </summary>
    private GameObject SpawnPlantFromSeed(SeedInstance seedInstance, Vector3 position)
    {
        if (plantPrefab == null)
        {
            Debug.LogError("Cannot spawn plant: Plant prefab not assigned.");
            return null;
        }

        if (showDebugMessages)
            Debug.Log($"SpawnPlantFromSeed called: {seedInstance.seedName} at position: {position}");
    
        // Instantiate the plant prefab
        GameObject plantObj = Instantiate(plantPrefab, position, Quaternion.identity, plantParent);
        plantObj.name = $"Plant_{seedInstance.seedName}_{System.DateTime.Now:HHmmss}";

        // Get the PlantGrowth component
        PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
        if (growthComponent != null)
        {
            // Convert seed to NodeGraph
            NodeGraph nodeGraph = seedInstance.ToNodeGraph();
            
            if (nodeGraph == null || nodeGraph.nodes == null || nodeGraph.nodes.Count == 0)
            {
                Debug.LogError($"Failed to convert seed '{seedInstance.seedName}' to NodeGraph or NodeGraph is empty!");
                Destroy(plantObj);
                return null;
            }

            if (showDebugMessages)
                Debug.Log($"Converted seed to NodeGraph with {nodeGraph.nodes.Count} nodes");

            // Initialize the plant
            growthComponent.InitializeAndGrow(nodeGraph);
            
            if (showDebugMessages)
                Debug.Log($"Plant spawned and initialized successfully: {plantObj.name}");
            
            return plantObj;
        }
        else
        {
            Debug.LogError("Plant prefab missing PlantGrowth component! Destroying spawned object.");
            Destroy(plantObj);
            return null;
        }
    }

    private void RegisterPlantWithModifiers(GameObject plantObj, Vector3Int gridPosition)
    {
        if (growthModifierManager != null && tileInteractionManager != null)
        {
            TileDefinition currentTile = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
            PlantGrowth plantGrowth = plantObj.GetComponent<PlantGrowth>();
            
            if (plantGrowth != null)
            {
                growthModifierManager.RegisterPlantTile(plantGrowth, currentTile);
                
                if (showDebugMessages)
                {
                    string tileDebugName = currentTile != null ? currentTile.displayName : "Unknown";
                    Debug.Log($"Plant registered with tile: {tileDebugName}");
                }
            }
        }
    }
    
    private Vector3 GetRandomizedPlantingPosition(Vector3 centerPosition)
    {
        if (showDebugMessages)
            Debug.Log($"Starting position randomization from center: {centerPosition}, radius: {spawnRadius}, increment: {spawnRadiusIncrement}");
    
        if (spawnRadius < 0.01f)
        {
            return centerPosition;
        }
    
        float randomAngle = Random.Range(0f, 2f * Mathf.PI);
        Vector2 direction = new Vector2(Mathf.Cos(randomAngle), Mathf.Sin(randomAngle));
        float randomDistance = Random.Range(0.05f, spawnRadius);
        
        float offsetX = direction.x * randomDistance;
        float offsetY = direction.y * randomDistance;
        
        if (spawnRadiusIncrement > 0.001f)
        {
            offsetX = Mathf.Round(offsetX / spawnRadiusIncrement) * spawnRadiusIncrement;
            offsetY = Mathf.Round(offsetY / spawnRadiusIncrement) * spawnRadiusIncrement;
        }
        
        Vector3 randomizedPosition = centerPosition + new Vector3(offsetX, offsetY, 0f);
        
        if (showDebugMessages)
            Debug.Log($"FINAL randomized position: {randomizedPosition}");
    
        return randomizedPosition;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlayerTileInteractor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[RequireComponent(typeof(ToolSwitcher))]
public class PlayerTileInteractor : MonoBehaviour
{
    private ToolSwitcher toolSwitcher;

    private void Awake()
    {
        toolSwitcher = GetComponent<ToolSwitcher>();
        if (toolSwitcher == null)
            Debug.LogError("PlayerTileInteractor: No ToolSwitcher found on this GameObject!");
    }

    private void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            if (TileInteractionManager.Instance == null)
            {
                Debug.LogError("No TileInteractionManager in scene!");
                return;
            }

            ToolDefinition currentTool = toolSwitcher.CurrentTool;
            if (currentTool == null)
            {
                Debug.Log("No tool is currently selected.");
                return;
            }

            // Attempt to apply the tool
            TileInteractionManager.Instance.ApplyToolAction(currentTool);
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Tilemaps;

[CreateAssetMenu(fileName = "TileDefinition", menuName = "Tiles/Tile Definition")]
public class TileDefinition : ScriptableObject
{
    [Header("Basic Identification")]
    [Tooltip("Display name for this tile type (used in UI and debugging)")]
    public string displayName;    // e.g. "Grass", "Dirt", "Wet Dirt"
    
    [Header("Visual Properties")]
    [Tooltip("Optional tint color to apply to the RenderTilemap")]
    public Color tintColor = Color.white;
    
    [Header("Auto-Reversion (optional)")]
    [Tooltip("If > 0, after this many seconds, the tile reverts to 'revertToTile'.")]
    public float revertAfterSeconds = 0f;

    [Tooltip("If revertAfterSeconds > 0, tile reverts to this tile definition.")]
    public TileDefinition revertToTile;

    [Header("Overlay Option")]
    [Tooltip("If true, this tile will be placed on top without removing the tile underneath ")]
    public bool keepBottomTile = false;
    
    [Header("Special Properties")]
    [Tooltip("If true, this tile will use water reflection shader")]
    public bool isWaterTile = false;

#if UNITY_EDITOR
    // This method will be called from the custom editor
    public void UpdateColor()
    {
        // Find the TileInteractionManager in the scene using the non-deprecated method
        var manager = UnityEngine.Object.FindAnyObjectByType<TileInteractionManager>();
        if (manager == null) return;

        foreach (var mapping in manager.tileDefinitionMappings)
        {
            if (mapping.tileDef == this && mapping.tilemapModule != null)
            {
                Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                if (renderTilemapTransform != null)
                {
                    Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
                    if (renderTilemap != null)
                    {
                        renderTilemap.color = tintColor;
                        UnityEditor.EditorUtility.SetDirty(renderTilemap);
                    }
                }
            }
        }
    }
#endif
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Data/TileInteractionLibrary.cs
using System.Collections.Generic;
using UnityEngine;
using System; // Needed for [Serializable]

// --- NEW: Define the structure for a refill rule ---
[Serializable] // Make it visible in the Inspector
public class ToolRefillRule
{
    [Tooltip("The tool that can be refilled.")]
    public ToolDefinition toolToRefill;

    [Tooltip("The tile that must be interacted with to trigger the refill.")]
    public TileDefinition refillSourceTile;
}
// ----------------------------------------------------

[CreateAssetMenu(fileName = "TileInteractionLibrary", menuName = "Tiles/Tile Interaction Library")]
public class TileInteractionLibrary : ScriptableObject
{
    [Header("Standard Tile Transformations")]
    [Tooltip("List of rules: (Tool, fromTile) => toTile.")]
    public List<TileInteractionRule> rules; // Existing transformation rules

    [Header("Tool Refill Rules")] // <<< NEW HEADER
    [Tooltip("List of rules defining how tools are refilled.")]
    public List<ToolRefillRule> refillRules; // <<< NEW LIST FOR REFILLS
}





--------------------------------------------------------------------------------
This is part 8 out of 10 of script collection. 2 more parts remain.
--------------------------------------------------------------------------------