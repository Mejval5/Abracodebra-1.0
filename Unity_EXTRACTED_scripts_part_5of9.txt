This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-05-28 18:59:47
PART 5 OF 9
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantOutline.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── Panels
│   │       │   ├── Panel_GeneListItem.prefab
│   │       │   ├── Panel_GeneSequenceItem.prefab
│   │       │   ├── Panel_SeedListItem.prefab
│   │       │   └── Panel_SeedSelectionButton.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   ├── PLANTOTRON_Machine.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           ├── DualGridRuleTile_Grass.asset
│           └── DualGridRuleTile_Water.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_PoopFertilizer.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Seeds
│   │   └── SeedDefinition_000_Base.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       ├── Wave_001.asset
│       └── Wave_002.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── LeafData.cs
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.Cell.cs
│   │   │   ├── PlantGrowth.Growth.cs
│   │   │   ├── PlantGrowth.NodeExecution.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── SlowdownZone.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   ├── Seeds
│   │   │   ├── PlantotronGeneItem.cs
│   │   │   ├── PlantotronGeneSequenceItem.cs
│   │   │   ├── PlantotronMachine.cs
│   │   │   ├── PlantotronSeedItem.cs
│   │   │   ├── PlantotronUI.cs
│   │   │   ├── PlayerGeneticsInventory.cs
│   │   │   ├── SeedDefinition.cs
│   │   │   ├── SeedInstance.cs
│   │   │   ├── SeedSelectionButton.cs
│   │   │   └── SeedSelectionUI.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManager.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── OutlinePartController.cs
│       ├── PixelPerfectSetup.cs
│       ├── PlantOutlineController.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       ├── ShadowPartController.cs
│       ├── WaterReflection.cs
│       └── WaterReflectionManager.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Custom_WaterReflectionGradient.mat
│   ├── Sprite-Lit-Advanced_Overlay_Base.mat
│   ├── Sprite-Lit-Default_OverlayAdvanced.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   ├── SpriteEmissiveUnlit.shader
│   ├── WaterReflection.shader
│   └── WaterReflectionSimple.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Runtime/NodeExecutor.cs (UPDATED for Seed System)
using System.Collections.Generic;
using UnityEngine;
using TMPro;
using System.Linq;

public class NodeExecutor : MonoBehaviour
{
    [Header("Plant Spawning")]
    [SerializeField] private GameObject plantPrefab;
    [SerializeField] private GardenerController gardener;

    [Header("UI References (Legacy Support)")]
    [SerializeField] private NodeEditorGridController nodeEditorGrid; // Keep for fallback

    [Header("Debugging")]
    [SerializeField] private TMP_Text debugOutput;
    [SerializeField] private bool showDebugLogs = false;

    private void Update()
    {
        // Legacy spacebar planting (now shows seed selection)
        if (Input.GetKeyDown(KeyCode.Space))
        {
            AttemptPlantingWithSeedSelection();
        }
    }

    /// <summary>
    /// NEW: Attempts to plant using seed selection system
    /// </summary>
    public void AttemptPlantingWithSeedSelection()
    {
        // Validate basic requirements
        if (!ValidateBasicPlantingRequirements())
            return;

        // Use seed selection UI
        if (SeedSelectionUI.Instance != null)
        {
            SeedSelectionUI.Instance.AttemptAutoSelection(OnSeedSelectedForPlanting);
        }
        else
        {
            DebugLogError("Seed Selection UI not found! Cannot plant with seed selection.");
            // Fallback to legacy system
            SpawnPlantFromUIGraph();
        }
    }

    /// <summary>
    /// NEW: Called when a seed is selected for planting
    /// </summary>
    private void OnSeedSelectedForPlanting(SeedInstance selectedSeed)
    {
        if (selectedSeed == null)
        {
            DebugLogError("Selected seed is null!");
            return;
        }

        bool success = SpawnPlantFromSeedInstance(selectedSeed);
        
        if (success)
        {
            // Remove the seed from inventory (it was planted)
            if (PlayerGeneticsInventory.Instance != null)
            {
                PlayerGeneticsInventory.Instance.RemoveSeed(selectedSeed);
                DebugLog($"Planted and consumed seed: {selectedSeed.seedName}");
            }
        }
    }

    /// <summary>
    /// NEW: Spawns a plant from a SeedInstance
    /// </summary>
    public bool SpawnPlantFromSeedInstance(SeedInstance seedInstance)
    {
        // Validate seed instance
        if (seedInstance == null)
        {
            DebugLogError("Cannot spawn plant: SeedInstance is null!");
            return false;
        }

        if (!seedInstance.IsValidForPlanting())
        {
            DebugLogError($"Cannot spawn plant: Seed '{seedInstance.seedName}' is not valid for planting!");
            return false;
        }

        // Validate basic requirements
        if (!ValidateBasicPlantingRequirements())
            return false;

        DebugLog($"Spawning plant from seed: {seedInstance.seedName}");

        // Convert seed to NodeGraph
        NodeGraph graphToSpawn = seedInstance.ToNodeGraph();
        
        if (graphToSpawn == null || graphToSpawn.nodes == null || graphToSpawn.nodes.Count == 0)
        {
            DebugLogError($"Failed to convert seed '{seedInstance.seedName}' to NodeGraph!");
            return false;
        }

        // Spawn the plant
        return SpawnPlantFromNodeGraph(graphToSpawn, seedInstance.seedName);
    }

    /// <summary>
    /// LEGACY: Spawns plant from UI graph (kept for backward compatibility)
    /// </summary>
    public void SpawnPlantFromUIGraph()
    {
        // --- Validations ---
        if (nodeEditorGrid == null) { DebugLogError("Node Editor Grid Controller not assigned!"); return; }
        if (!ValidateBasicPlantingRequirements()) return;

        // Get the current graph state from the UI grid
        NodeGraph graphToSpawn = nodeEditorGrid.GetCurrentUIGraph();

        if (graphToSpawn == null || graphToSpawn.nodes == null || graphToSpawn.nodes.Count == 0) {
             DebugLog("No nodes in UI graph to spawn.");
             return;
        }

        // Validate if the graph is spawnable
        bool seedFound = graphToSpawn.nodes.Any(node => node != null && node.effects != null && 
            node.effects.Any(eff => eff != null && eff.effectType == NodeEffectType.SeedSpawn && eff.isPassive));
        
        if (!seedFound) {
            DebugLog("Cannot spawn plant: Node chain lacks a passive SeedSpawn effect.");
            return;
        }

        DebugLog($"Spawning plant from UI graph with {graphToSpawn.nodes.Count} nodes...");
        SpawnPlantFromNodeGraph(graphToSpawn, "UI Graph Plant");
    }

    /// <summary>
    /// Core plant spawning logic (used by both new and legacy systems)
    /// </summary>
    private bool SpawnPlantFromNodeGraph(NodeGraph graphToSpawn, string plantName)
    {
        // Determine spawn position and parent
        Vector2 spawnPos = gardener.GetPlantingPosition();
        Transform plantParent = EcosystemManager.Instance?.plantParent;

        // Instantiate the plant prefab
        GameObject plantObj = Instantiate(plantPrefab, spawnPos, Quaternion.identity, plantParent);
        plantObj.name = $"Plant_{plantName}_{System.DateTime.Now:HHmmss}"; // Add timestamp for uniqueness

        // Get the PlantGrowth component
        PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
        if (growthComponent != null)
        {
            // Create a DEEP COPY of the NodeGraph
            NodeGraph graphCopy = CloneNodeGraph(graphToSpawn);

            // Initialize the plant with the deep copy
            growthComponent.InitializeAndGrow(graphCopy);
            DebugLog($"Plant '{plantName}' spawned and initialized successfully.");
            return true;
        }
        else
        {
            // Log error and destroy invalid object if PlantGrowth is missing
            DebugLogError($"Prefab '{plantPrefab.name}' missing PlantGrowth component! Destroying spawned object.");
            Destroy(plantObj);
            return false;
        }
    }

    /// <summary>
    /// Validates basic requirements for planting
    /// </summary>
    private bool ValidateBasicPlantingRequirements()
    {
        if (plantPrefab == null) { DebugLogError("Plant prefab not assigned!"); return false; }
        if (gardener == null) { DebugLogError("Gardener Controller not assigned!"); return false; }
        return true;
    }

    /// <summary>
    /// Creates a deep copy of a NodeGraph
    /// </summary>
    private NodeGraph CloneNodeGraph(NodeGraph original)
    {
        NodeGraph graphCopy = new NodeGraph();
        graphCopy.nodes = new List<NodeData>(original.nodes.Count);

        foreach(NodeData originalNodeData in original.nodes)
        {
            if (originalNodeData == null) {
                DebugLogWarning("Encountered null NodeData in graph during copy. Skipping.");
                continue;
            }

             // Create a new NodeData instance
             NodeData newNodeData = new NodeData {
                nodeId = originalNodeData.nodeId,
                nodeDisplayName = originalNodeData.nodeDisplayName,
                orderIndex = originalNodeData.orderIndex,
                canBeDeleted = originalNodeData.canBeDeleted,
                effects = CloneEffectsList(originalNodeData.effects)
            };
            graphCopy.nodes.Add(newNodeData);
        }

        return graphCopy;
    }

    /// <summary>
    /// Creates a deep copy of a list of NodeEffectData
    /// </summary>
    private List<NodeEffectData> CloneEffectsList(List<NodeEffectData> originalList)
    {
        if (originalList == null) return new List<NodeEffectData>();

        List<NodeEffectData> newList = new List<NodeEffectData>(originalList.Count);
        foreach(var originalEffect in originalList)
        {
            if(originalEffect == null) {
                DebugLogWarning("Encountered null NodeEffectData in list during copy. Skipping.");
                continue;
            }

             NodeEffectData newEffect = new NodeEffectData {
                 effectType = originalEffect.effectType,
                 primaryValue = originalEffect.primaryValue,
                 secondaryValue = originalEffect.secondaryValue,
                 isPassive = originalEffect.isPassive,
                 scentDefinitionReference = originalEffect.scentDefinitionReference
             };
             newList.Add(newEffect);
        }
        return newList;
    }

    // --- Helper methods for logging ---
    private void DebugLog(string msg) {
        if (showDebugLogs) Debug.Log($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += msg + "\n";
    }
    
    private void DebugLogError(string msg) {
        Debug.LogError($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += $"ERROR: {msg}\n";
    }
    
    private void DebugLogWarning(string msg) {
        if (showDebugLogs) Debug.LogWarning($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += $"WARNING: {msg}\n";
    }

    // --- Public API Methods ---

    /// <summary>
    /// Public method for external scripts to plant a specific seed
    /// </summary>
    public bool PlantSeed(SeedInstance seed)
    {
        return SpawnPlantFromSeedInstance(seed);
    }

    /// <summary>
    /// Public method to get available plantable seeds count
    /// </summary>
    public int GetPlantableSeedsCount()
    {
        if (PlayerGeneticsInventory.Instance == null)
            return 0;
            
        return PlayerGeneticsInventory.Instance.GetPlantableSeeds().Count;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes = new List<NodeData>();
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\PlantotronGeneItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Genetics/PlantotronGeneItem.cs
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using TMPro;

public class PlantotronGeneItem : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler
{
    [Header("UI References")]
    public TMP_Text geneNameText;
    public TMP_Text geneTypeText;
    public Image geneIcon;
    public Button addButton;
    public Image backgroundImage;
    
    [Header("Visual Settings")]
    public Color normalColor = Color.white;
    public Color hoverColor = Color.yellow;
    
    private NodeDefinition gene;
    private PlantotronUI parentUI;
    
    public void Initialize(NodeDefinition geneDefinition, PlantotronUI ui)
    {
        gene = geneDefinition;
        parentUI = ui;
        
        if (gene == null || parentUI == null)
        {
            Debug.LogError("[PlantotronGeneItem] Invalid initialization parameters!");
            return;
        }
        
        // Setup UI elements
        if (geneNameText != null)
            geneNameText.text = gene.displayName;
            
        if (geneTypeText != null)
        {
            // Show primary effect type
            string effectType = "Unknown";
            if (gene.effects != null && gene.effects.Count > 0 && gene.effects[0] != null)
            {
                effectType = gene.effects[0].effectType.ToString();
            }
            geneTypeText.text = effectType;
        }
        
        if (geneIcon != null)
        {
            geneIcon.sprite = gene.thumbnail;
            geneIcon.color = gene.thumbnailTintColor;
        }
        
        // Setup add button
        if (addButton != null)
        {
            addButton.onClick.RemoveAllListeners();
            addButton.onClick.AddListener(OnAddButtonClicked);
        }
        
        // Set initial background color
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
    }
    
    public void OnPointerEnter(PointerEventData eventData)
    {
        if (backgroundImage != null)
            backgroundImage.color = hoverColor;
            
        if (parentUI != null && gene != null)
            parentUI.ShowGeneDetails(gene);
    }
    
    public void OnPointerExit(PointerEventData eventData)
    {
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
    }
    
    public void OnPointerClick(PointerEventData eventData)
    {
        if (parentUI != null && gene != null)
            parentUI.OnGeneSelected(gene);
    }
    
    private void OnAddButtonClicked()
    {
        if (parentUI != null && gene != null)
            parentUI.OnGeneAddToSequence(gene);
    }
    
    void OnDestroy()
    {
        if (addButton != null)
            addButton.onClick.RemoveAllListeners();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\PlantotronGeneSequenceItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Genetics/PlantotronGeneSequenceItem.cs
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using TMPro;

public class PlantotronGeneSequenceItem : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, 
    IBeginDragHandler, IDragHandler, IEndDragHandler, IDropHandler
{
    [Header("UI References - SIMPLIFIED")]
    public TMP_Text geneNameText;
    public Image backgroundImage;
    
    [Header("Visual Settings")]
    public Color normalColor = new Color(0.9f, 0.9f, 0.9f, 1f);
    public Color hoverColor = Color.yellow;
    public Color dragColor = new Color(1f, 0.8f, 0.8f, 1f);
    
    [Header("Drag Settings")]
    public float dragAlpha = 0.8f;
    
    private NodeDefinition gene;
    private int sequenceIndex;
    private PlantotronUI parentUI;
    private bool isDragging = false;
    private Vector3 originalPosition;
    private Transform originalParent;
    private CanvasGroup canvasGroup;
    
    public void Initialize(NodeDefinition geneDefinition, int index, PlantotronUI ui)
    {
        gene = geneDefinition;
        sequenceIndex = index;
        parentUI = ui;
        
        if (gene == null || parentUI == null)
        {
            Debug.LogError("[PlantotronGeneSequenceItem] Invalid initialization parameters!");
            return;
        }
        
        // Setup canvas group for drag transparency
        canvasGroup = GetComponent<CanvasGroup>();
        if (canvasGroup == null)
            canvasGroup = gameObject.AddComponent<CanvasGroup>();
        
        // Setup UI elements - SIMPLIFIED
        if (geneNameText != null)
            geneNameText.text = $"{index + 1}. {gene.displayName}";
        
        // Set initial background color
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
            
        // Store original transform info
        originalPosition = transform.position;
        originalParent = transform.parent;
    }
    
    public void OnPointerEnter(PointerEventData eventData)
    {
        if (!isDragging && backgroundImage != null)
            backgroundImage.color = hoverColor;
            
        if (parentUI != null && gene != null)
            parentUI.ShowGeneDetails(gene);
    }
    
    public void OnPointerExit(PointerEventData eventData)
    {
        if (!isDragging && backgroundImage != null)
            backgroundImage.color = normalColor;
    }
    
    public void OnBeginDrag(PointerEventData eventData)
    {
        isDragging = true;
        if (backgroundImage != null)
            backgroundImage.color = dragColor;
            
        // Make semi-transparent during drag
        if (canvasGroup != null)
            canvasGroup.alpha = dragAlpha;
            
        // Make this item appear on top
        transform.SetAsLastSibling();
        
        Debug.Log($"[PlantotronGeneSequenceItem] Started dragging: {gene?.displayName ?? "Unknown"}");
    }
    
    public void OnDrag(PointerEventData eventData)
    {
        if (isDragging)
        {
            // Follow mouse/finger during drag
            transform.position = eventData.position;
        }
    }
    
    public void OnEndDrag(PointerEventData eventData)
    {
        isDragging = false;
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
            
        // Restore transparency
        if (canvasGroup != null)
            canvasGroup.alpha = 1f;
            
        // Reset position and parent
        transform.position = originalPosition;
        transform.SetParent(originalParent);
        
        Debug.Log($"[PlantotronGeneSequenceItem] Ended dragging: {gene?.displayName ?? "Unknown"}");
    }
    
    public void OnDrop(PointerEventData eventData)
    {
        // Handle drop from other gene sequence items
        GameObject draggedObject = eventData.pointerDrag;
        if (draggedObject != null)
        {
            PlantotronGeneSequenceItem draggedItem = draggedObject.GetComponent<PlantotronGeneSequenceItem>();
            if (draggedItem != null && draggedItem != this && parentUI != null)
            {
                Debug.Log($"[PlantotronGeneSequenceItem] Drop detected: Moving {draggedItem.gene?.displayName} to position {sequenceIndex}");
                // Swap positions in the gene sequence
                parentUI.OnGeneMovedInSequence(draggedItem.sequenceIndex, this.sequenceIndex);
            }
        }
    }
    
    // Public method to update the sequence index and display
    public void UpdateIndex(int newIndex)
    {
        sequenceIndex = newIndex;
        if (geneNameText != null && gene != null)
            geneNameText.text = $"{newIndex + 1}. {gene.displayName}";
            
        // Update original position for drag reset
        originalPosition = transform.position;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\PlantotronMachine.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Genetics/PlantotronMachine.cs
using UnityEngine;

[RequireComponent(typeof(Collider2D))]
public class PlantotronMachine : MonoBehaviour
{
    [Header("Interaction Settings")]
    [Tooltip("Maximum distance for player interaction")]
    public float interactionRange = 2f;
    
    [Tooltip("Key to press for interaction (default: E)")]
    public KeyCode interactionKey = KeyCode.E;
    
    [Header("UI References")]
    [Tooltip("The Plantotron UI panel to show/hide")]
    public PlantotronUI uiPanel;
    
    [Header("Visual Feedback")]
    [Tooltip("GameObject to show when player is in range (optional)")]
    public GameObject interactionPrompt;
    
    [Tooltip("Highlight material/effect when player is nearby (optional)")]
    public Material highlightMaterial;
    
    [Header("Audio (Optional)")]
    [Tooltip("Sound to play when machine is activated")]
    public AudioClip activationSound;
    
    [Header("Debug")]
    [SerializeField] private bool showDebugLogs = false;
    
    // Internal state
    private bool playerInRange = false;
    private Transform playerTransform;
    private SpriteRenderer machineRenderer;
    private Material originalMaterial;
    private AudioSource audioSource;
    
    // Cache for player detection
    private const string PLAYER_TAG = "Player";
    
    void Awake()
    {
        // Get components
        machineRenderer = GetComponent<SpriteRenderer>();
        audioSource = GetComponent<AudioSource>();
        
        // Ensure collider is set as trigger
        Collider2D col = GetComponent<Collider2D>();
        if (col != null && !col.isTrigger)
        {
            col.isTrigger = true;
            if (showDebugLogs)
                Debug.Log($"[PlantotronMachine] Set collider on {gameObject.name} to trigger mode");
        }
        
        // Store original material
        if (machineRenderer != null)
        {
            originalMaterial = machineRenderer.material;
        }
        
        // Ensure UI panel starts hidden
        if (uiPanel != null)
        {
            uiPanel.gameObject.SetActive(false);
        }
        else
        {
            Debug.LogError($"[PlantotronMachine] UI Panel not assigned on {gameObject.name}!", this);
        }
        
        // Hide interaction prompt initially
        if (interactionPrompt != null)
        {
            interactionPrompt.SetActive(false);
        }
    }
    
    void Update()
    {
        // Only check for interaction if player is in range
        if (playerInRange && playerTransform != null)
        {
            // Double-check distance (in case player moved quickly)
            float distance = Vector2.Distance(transform.position, playerTransform.position);
            if (distance <= interactionRange)
            {
                // Check for interaction input
                if (Input.GetKeyDown(interactionKey))
                {
                    ToggleMachine();
                }
            }
            else
            {
                // Player moved out of range
                SetPlayerInRange(false);
            }
        }
    }
    
    void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag(PLAYER_TAG))
        {
            playerTransform = other.transform;
            SetPlayerInRange(true);
            
            if (showDebugLogs)
                Debug.Log($"[PlantotronMachine] Player entered interaction range");
        }
    }
    
    void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag(PLAYER_TAG))
        {
            SetPlayerInRange(false);
            
            if (showDebugLogs)
                Debug.Log($"[PlantotronMachine] Player left interaction range");
        }
    }
    
    private void SetPlayerInRange(bool inRange)
    {
        if (playerInRange == inRange) return;
        
        playerInRange = inRange;
        
        // Update visual feedback
        if (interactionPrompt != null)
        {
            interactionPrompt.SetActive(inRange);
        }
        
        // Update highlight effect
        if (machineRenderer != null && highlightMaterial != null)
        {
            machineRenderer.material = inRange ? highlightMaterial : originalMaterial;
        }
        
        // If player left range while UI is open, close it
        if (!inRange && uiPanel != null && uiPanel.gameObject.activeSelf)
        {
            CloseMachine();
        }
        
        if (!inRange)
        {
            playerTransform = null;
        }
    }
    
    private void ToggleMachine()
    {
        if (uiPanel == null)
        {
            Debug.LogError("[PlantotronMachine] Cannot toggle - UI Panel is null!");
            return;
        }
        
        bool isCurrentlyOpen = uiPanel.gameObject.activeSelf;
        
        if (isCurrentlyOpen)
        {
            CloseMachine();
        }
        else
        {
            OpenMachine();
        }
    }
    
    private void OpenMachine()
    {
        if (uiPanel == null) return;
        
        // Check if player has genetics inventory
        if (PlayerGeneticsInventory.Instance == null)
        {
            Debug.LogError("[PlantotronMachine] Cannot open - PlayerGeneticsInventory not found!");
            return;
        }
        
        uiPanel.gameObject.SetActive(true);
        uiPanel.OpenUI();
        
        // Play activation sound
        if (audioSource != null && activationSound != null)
        {
            audioSource.PlayOneShot(activationSound);
        }
        
        // Pause the game or disable player movement if needed
        // Time.timeScale = 0f; // Uncomment if you want to pause the game
        
        if (showDebugLogs)
            Debug.Log("[PlantotronMachine] Machine opened");
    }
    
    private void CloseMachine()
    {
        if (uiPanel == null) return;
        
        uiPanel.CloseUI();
        uiPanel.gameObject.SetActive(false);
        
        // Resume the game if it was paused
        // Time.timeScale = 1f; // Uncomment if you paused the game
        
        if (showDebugLogs)
            Debug.Log("[PlantotronMachine] Machine closed");
    }
    
    // Public method for external scripts to open/close the machine
    public void SetMachineOpen(bool open)
    {
        if (open)
            OpenMachine();
        else
            CloseMachine();
    }
    
    // Public method to check if machine is currently open
    public bool IsMachineOpen()
    {
        return uiPanel != null && uiPanel.gameObject.activeSelf;
    }
    
    void OnDrawGizmosSelected()
    {
        // Draw interaction range in editor
        Gizmos.color = Color.green;
        Gizmos.DrawWireSphere(transform.position, interactionRange);
        
        // Draw a line to player if in range during play mode
        if (Application.isPlaying && playerTransform != null && playerInRange)
        {
            Gizmos.color = Color.yellow;
            Gizmos.DrawLine(transform.position, playerTransform.position);
        }
    }
    
    void OnDestroy()
    {
        // Clean up
        if (machineRenderer != null && originalMaterial != null)
        {
            machineRenderer.material = originalMaterial;
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\PlantotronSeedItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Genetics/PlantotronSeedItem.cs
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using TMPro;

public class PlantotronSeedItem : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler
{
    [Header("UI References")]
    public TMP_Text seedNameText;
    public TMP_Text seedStatusText;
    public Image seedIcon;
    public Button editButton;
    public Button deleteButton;
    public Image backgroundImage;
    
    [Header("Visual Settings")]
    public Color normalColor = Color.white;
    public Color hoverColor = Color.yellow;
    public Color modifiedColor = Color.cyan;
    public Color vanillaColor = Color.green;
    
    private SeedInstance seed;
    private PlantotronUI parentUI;
    
    public void Initialize(SeedInstance seedInstance, PlantotronUI ui)
    {
        seed = seedInstance;
        parentUI = ui;
        
        if (seed == null || parentUI == null)
        {
            Debug.LogError("[PlantotronSeedItem] Invalid initialization parameters!");
            return;
        }
        
        // Setup UI elements
        if (seedNameText != null)
            seedNameText.text = seed.seedName;
            
        if (seedStatusText != null)
        {
            string status = seed.isModified ? "Modified" : "Vanilla";
            int geneCount = seed.currentGenes?.Count ?? 0;
            seedStatusText.text = $"{status} • {geneCount} genes";
            seedStatusText.color = seed.isModified ? modifiedColor : vanillaColor;
        }
        
        if (seedIcon != null && seed.baseSeedDefinition != null)
        {
            seedIcon.sprite = seed.baseSeedDefinition.icon;
        }
        
        // Setup buttons
        if (editButton != null)
        {
            editButton.onClick.RemoveAllListeners();
            editButton.onClick.AddListener(OnEditButtonClicked);
        }
        
        if (deleteButton != null)
        {
            deleteButton.onClick.RemoveAllListeners();
            deleteButton.onClick.AddListener(OnDeleteButtonClicked);
        }
        
        // Set initial background color
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
    }
    
    public void OnPointerEnter(PointerEventData eventData)
    {
        if (backgroundImage != null)
            backgroundImage.color = hoverColor;
            
        if (parentUI != null && seed != null)
            parentUI.ShowSeedDetails(seed);
    }
    
    public void OnPointerExit(PointerEventData eventData)
    {
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
    }
    
    public void OnPointerClick(PointerEventData eventData)
    {
        if (parentUI != null && seed != null)
            parentUI.OnSeedSelected(seed);
    }
    
    private void OnEditButtonClicked()
    {
        if (parentUI != null && seed != null)
            parentUI.OnSeedLoadForEditing(seed);
    }
    
    private void OnDeleteButtonClicked()
    {
        if (seed != null && PlayerGeneticsInventory.Instance != null)
        {
            PlayerGeneticsInventory.Instance.RemoveSeed(seed);
        }
    }
    
    void OnDestroy()
    {
        if (editButton != null)
            editButton.onClick.RemoveAllListeners();
        if (deleteButton != null)
            deleteButton.onClick.RemoveAllListeners();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\PlantotronUI.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Genetics/PlantotronUI.cs
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Linq;

public class PlantotronUI : MonoBehaviour
{
    [Header("Main UI Panels")]
    public GameObject mainPanel;
    public GameObject geneDatabasePanel;
    public GameObject seedDatabasePanel;
    public GameObject geneEditorPanel;
    public GameObject detailsPanel;
    
    [Header("Gene Database UI")]
    public Transform geneListContainer;
    public GameObject geneListItemPrefab;
    public TMP_InputField geneSearchField;
    
    [Header("Seed Database UI")]
    public Transform seedListContainer;
    public GameObject seedListItemPrefab;
    public TMP_InputField seedSearchField;
    
    [Header("Gene Editor UI")]
    public TMP_Text currentSeedNameText;
    public GameObject seedSlotPanel;
    public Button seedSlotButton;
    public TMP_Text seedSlotText;
    public Transform geneSequenceContainer;
    public GameObject geneSequenceItemPrefab;
    public Button saveSeedButton;
    public Button resetSeedButton;
    public TMP_InputField seedNameInputField;
    
    [Header("Details Panel UI")]
    public TMP_Text detailsTitleText;
    public TMP_Text detailsDescriptionText;
    public ScrollRect detailsScrollRect;
    
    [Header("Control Buttons")]
    public Button closeButton;
    public Button clearAllButton;
    
    [Header("Debug")]
    [SerializeField] private bool showDebugLogs = false;
    
    // Current state
    private SeedInstance currentEditingSeed;
    private PlayerGeneticsInventory inventory;
    private List<GameObject> currentGeneListItems = new List<GameObject>();
    private List<GameObject> currentSeedListItems = new List<GameObject>();
    private List<GameObject> currentGeneSequenceItems = new List<GameObject>();
    
    // Cached references for performance
    private RectTransform geneListContainerRect;
    private RectTransform seedListContainerRect;
    private RectTransform geneSequenceContainerRect;
    
    void Awake()
    {
        // Cache rect transforms
        if (geneListContainer != null)
            geneListContainerRect = geneListContainer.GetComponent<RectTransform>();
        if (seedListContainer != null)
            seedListContainerRect = seedListContainer.GetComponent<RectTransform>();
        if (geneSequenceContainer != null)
            geneSequenceContainerRect = geneSequenceContainer.GetComponent<RectTransform>();
        
        // Setup button listeners
        if (closeButton != null)
            closeButton.onClick.AddListener(CloseUI);
        if (clearAllButton != null)
            clearAllButton.onClick.AddListener(ClearCurrentSeed);
        if (saveSeedButton != null)
            saveSeedButton.onClick.AddListener(SaveCurrentSeed);
        if (resetSeedButton != null)
            resetSeedButton.onClick.AddListener(ResetCurrentSeed);
        if (seedSlotButton != null)
            seedSlotButton.onClick.AddListener(OpenSeedSelectionPopup);
        
        // Setup search field listeners
        if (geneSearchField != null)
            geneSearchField.onValueChanged.AddListener(OnGeneSearchChanged);
        if (seedSearchField != null)
            seedSearchField.onValueChanged.AddListener(OnSeedSearchChanged);
        if (seedNameInputField != null)
            seedNameInputField.onValueChanged.AddListener(OnSeedNameChanged);
        
        // Validate required prefabs
        if (geneListItemPrefab == null)
            Debug.LogError("[PlantotronUI] Gene List Item Prefab not assigned!", this);
        if (seedListItemPrefab == null)
            Debug.LogError("[PlantotronUI] Seed List Item Prefab not assigned!", this);
        if (geneSequenceItemPrefab == null)
            Debug.LogError("[PlantotronUI] Gene Sequence Item Prefab not assigned!", this);
    }
    
    void Start()
    {
        // Get inventory reference
        inventory = PlayerGeneticsInventory.Instance;
        if (inventory == null)
        {
            Debug.LogError("[PlantotronUI] PlayerGeneticsInventory not found!", this);
            return;
        }
        
        // Subscribe to inventory events
        inventory.OnInventoryChanged += RefreshAllLists;
        
        // Ensure UI starts closed
        if (mainPanel != null)
            mainPanel.SetActive(false);
    }
    
    void OnDestroy()
    {
        // Unsubscribe from events
        if (inventory != null)
            inventory.OnInventoryChanged -= RefreshAllLists;
        
        // Clean up button listeners
        if (closeButton != null)
            closeButton.onClick.RemoveAllListeners();
        if (clearAllButton != null)
            clearAllButton.onClick.RemoveAllListeners();
        if (saveSeedButton != null)
            saveSeedButton.onClick.RemoveAllListeners();
        if (resetSeedButton != null)
            resetSeedButton.onClick.RemoveAllListeners();
        if (seedSlotButton != null)
            seedSlotButton.onClick.RemoveAllListeners();
    }
    
    // --- Main UI Control ---
    
    public void OpenUI()
    {
        if (mainPanel != null)
            mainPanel.SetActive(true);
            
        RefreshAllLists();
        ClearDetails();
        
        if (showDebugLogs)
            Debug.Log("[PlantotronUI] UI Opened");
    }
    
    public void CloseUI()
    {
        if (mainPanel != null)
            mainPanel.SetActive(false);
            
        // Clear current editing state
        SetCurrentEditingSeed(null);
        
        if (showDebugLogs)
            Debug.Log("[PlantotronUI] UI Closed");
    }
    
    // --- Gene Database ---
    
    private void RefreshGeneDatabase(string searchFilter = "")
    {
        if (inventory == null || geneListContainer == null) return;
        
        // Clear existing items
        ClearContainer(geneListContainer, currentGeneListItems);
        
        // Filter genes based on search
        var filteredGenes = inventory.AvailableGenes.Where(gene => 
            gene != null && (string.IsNullOrEmpty(searchFilter) || 
            gene.displayName.ToLower().Contains(searchFilter.ToLower()))
        ).ToList();
        
        // Create UI items for each gene
        foreach (var gene in filteredGenes)
        {
            GameObject geneItem = CreateGeneListItem(gene);
            if (geneItem != null)
                currentGeneListItems.Add(geneItem);
        }
        
        if (showDebugLogs)
            Debug.Log($"[PlantotronUI] Refreshed gene database: {filteredGenes.Count} genes");
    }
    
    private GameObject CreateGeneListItem(NodeDefinition gene)
    {
        if (geneListItemPrefab == null || geneListContainer == null || gene == null)
            return null;
            
        GameObject item = Instantiate(geneListItemPrefab, geneListContainer);
        
        // Setup the gene item component
        PlantotronGeneItem geneItemComponent = item.GetComponent<PlantotronGeneItem>();
        if (geneItemComponent == null)
            geneItemComponent = item.AddComponent<PlantotronGeneItem>();
            
        geneItemComponent.Initialize(gene, this);
        
        return item;
    }
    
    // --- Seed Database ---
    
    private void RefreshSeedDatabase(string searchFilter = "")
    {
        if (inventory == null || seedListContainer == null) return;
        
        // Clear existing items
        ClearContainer(seedListContainer, currentSeedListItems);
        
        // Filter seeds based on search
        var filteredSeeds = inventory.AvailableSeeds.Where(seed => 
            seed != null && (string.IsNullOrEmpty(searchFilter) || 
            seed.seedName.ToLower().Contains(searchFilter.ToLower()))
        ).ToList();
        
        // Create UI items for each seed
        foreach (var seed in filteredSeeds)
        {
            GameObject seedItem = CreateSeedListItem(seed);
            if (seedItem != null)
                currentSeedListItems.Add(seedItem);
        }
        
        if (showDebugLogs)
            Debug.Log($"[PlantotronUI] Refreshed seed database: {filteredSeeds.Count} seeds");
    }
    
    private GameObject CreateSeedListItem(SeedInstance seed)
    {
        if (seedListItemPrefab == null || seedListContainer == null || seed == null)
            return null;
            
        GameObject item = Instantiate(seedListItemPrefab, seedListContainer);
        
        // Setup the seed item component
        PlantotronSeedItem seedItemComponent = item.GetComponent<PlantotronSeedItem>();
        if (seedItemComponent == null)
            seedItemComponent = item.AddComponent<PlantotronSeedItem>();
            
        seedItemComponent.Initialize(seed, this);
        
        return item;
    }
    
    // --- Gene Editor ---
    
    public void SetCurrentEditingSeed(SeedInstance seed)
    {
        currentEditingSeed = seed;
        RefreshGeneEditor();
        
        if (seed != null && showDebugLogs)
            Debug.Log($"[PlantotronUI] Now editing seed: {seed.seedName}");
    }
    
    private void RefreshGeneEditor()
    {
        // Update seed slot display
        if (seedSlotText != null)
        {
            if (currentEditingSeed != null)
            {
                seedSlotText.text = currentEditingSeed.seedName;
            }
            else
            {
                seedSlotText.text = "Click to select seed...";
            }
        }
        
        // Update seed name display
        if (currentSeedNameText != null)
        {
            if (currentEditingSeed != null)
            {
                currentSeedNameText.text = currentEditingSeed.seedName;
            }
            else
            {
                currentSeedNameText.text = "No seed selected";
            }
        }
        
        // Update seed name input field
        if (seedNameInputField != null)
        {
            if (currentEditingSeed != null)
            {
                seedNameInputField.text = currentEditingSeed.seedName;
                seedNameInputField.interactable = true;
            }
            else
            {
                seedNameInputField.text = "";
                seedNameInputField.interactable = false;
            }
        }
        
        // Refresh gene sequence
        RefreshGeneSequence();
        
        // Update button states
        if (saveSeedButton != null)
            saveSeedButton.interactable = (currentEditingSeed != null);
        if (resetSeedButton != null)
            resetSeedButton.interactable = (currentEditingSeed != null);
    }
    
    private void RefreshGeneSequence()
    {
        if (geneSequenceContainer == null) return;
        
        // Clear existing items
        ClearContainer(geneSequenceContainer, currentGeneSequenceItems);
        
        if (currentEditingSeed == null || currentEditingSeed.currentGenes == null)
            return;
        
        // Create UI items for each gene in the sequence
        for (int i = 0; i < currentEditingSeed.currentGenes.Count; i++)
        {
            NodeDefinition gene = currentEditingSeed.currentGenes[i];
            if (gene != null)
            {
                GameObject sequenceItem = CreateGeneSequenceItem(gene, i);
                if (sequenceItem != null)
                    currentGeneSequenceItems.Add(sequenceItem);
            }
        }
        
        if (showDebugLogs)
            Debug.Log($"[PlantotronUI] Refreshed gene sequence: {currentEditingSeed.currentGenes.Count} genes");
    }
    
    private GameObject CreateGeneSequenceItem(NodeDefinition gene, int index)
    {
        if (geneSequenceItemPrefab == null || geneSequenceContainer == null || gene == null)
            return null;
            
        GameObject item = Instantiate(geneSequenceItemPrefab, geneSequenceContainer);
        
        // Setup the gene sequence item component
        PlantotronGeneSequenceItem sequenceItemComponent = item.GetComponent<PlantotronGeneSequenceItem>();
        if (sequenceItemComponent == null)
            sequenceItemComponent = item.AddComponent<PlantotronGeneSequenceItem>();
            
        sequenceItemComponent.Initialize(gene, index, this);
        
        return item;
    }
    
    // --- Details Panel ---
    
    public void ShowGeneDetails(NodeDefinition gene)
    {
        if (gene == null || detailsTitleText == null || detailsDescriptionText == null)
            return;
            
        detailsTitleText.text = gene.displayName;
        
        string details = !string.IsNullOrEmpty(gene.description) ? gene.description : "No description available.";
        
        // Add effect information
        if (gene.effects != null && gene.effects.Count > 0)
        {
            details += "\n\n<b>Effects:</b>";
            foreach (var effect in gene.effects)
            {
                if (effect != null)
                {
                    details += $"\n• {effect.effectType}: {effect.primaryValue}";
                    if (effect.secondaryValue != 0)
                        details += $" / {effect.secondaryValue}";
                    if (effect.isPassive)
                        details += " (Passive)";
                }
            }
        }
        
        detailsDescriptionText.text = details;
        
        // Scroll to top
        if (detailsScrollRect != null)
            detailsScrollRect.verticalNormalizedPosition = 1f;
    }
    
    public void ShowSeedDetails(SeedInstance seed)
    {
        if (seed == null || detailsTitleText == null || detailsDescriptionText == null)
            return;
            
        detailsTitleText.text = seed.seedName;
        
        string details = "";
        
        // Add basic info
        if (seed.baseSeedDefinition != null && !string.IsNullOrEmpty(seed.baseSeedDefinition.description))
        {
            details += seed.baseSeedDefinition.description + "\n\n";
        }
        
        // Add modification info
        details += $"<b>Status:</b> {(seed.isModified ? "Modified" : "Vanilla")}\n";
        details += $"<b>Genes:</b> {(seed.currentGenes?.Count ?? 0)}\n";
        details += $"<b>Plantable:</b> {(seed.IsValidForPlanting() ? "Yes" : "No")}\n\n";
        
        // Add genetic composition
        if (seed.currentGenes != null && seed.currentGenes.Count > 0)
        {
            details += "<b>Genetic Sequence:</b>\n";
            for (int i = 0; i < seed.currentGenes.Count; i++)
            {
                if (seed.currentGenes[i] != null)
                {
                    details += $"{i + 1}. {seed.currentGenes[i].displayName}\n";
                }
            }
        }
        else
        {
            details += "<b>No genes present</b>";
        }
        
        detailsDescriptionText.text = details;
        
        // Scroll to top
        if (detailsScrollRect != null)
            detailsScrollRect.verticalNormalizedPosition = 1f;
    }
    
    public void ClearDetails()
    {
        if (detailsTitleText != null)
            detailsTitleText.text = "Details";
        if (detailsDescriptionText != null)
            detailsDescriptionText.text = "Hover over or select an item to see details.";
    }
    
    // --- Event Handlers ---
    
    private void OnGeneSearchChanged(string searchText)
    {
        RefreshGeneDatabase(searchText);
    }
    
    private void OnSeedSearchChanged(string searchText)
    {
        RefreshSeedDatabase(searchText);
    }
    
    private void OnSeedNameChanged(string newName)
    {
        if (currentEditingSeed != null && !string.IsNullOrEmpty(newName))
        {
            currentEditingSeed.seedName = newName;
        }
    }
    
    private void OpenSeedSelectionPopup()
    {
        // TODO: Implement seed selection popup
        // For now, just select the first available seed
        if (inventory != null && inventory.AvailableSeeds.Count > 0)
        {
            SetCurrentEditingSeed(inventory.AvailableSeeds[0]);
        }
    }
    
    private void SaveCurrentSeed()
    {
        if (currentEditingSeed == null)
            return;
            
        // Create a new seed instance (duplicate) and add to inventory
        SeedInstance savedSeed = inventory.DuplicateSeed(currentEditingSeed);
        
        if (savedSeed != null && showDebugLogs)
            Debug.Log($"[PlantotronUI] Saved seed: {savedSeed.seedName}");
    }
    
    private void ResetCurrentSeed()
    {
        if (currentEditingSeed == null || currentEditingSeed.baseSeedDefinition == null)
            return;
            
        // Reset to original genes
        currentEditingSeed.currentGenes = currentEditingSeed.baseSeedDefinition.CloneInitialGenes();
        currentEditingSeed.UpdateModifiedStatus();
        RefreshGeneEditor();
        
        if (showDebugLogs)
            Debug.Log($"[PlantotronUI] Reset seed: {currentEditingSeed.seedName}");
    }
    
    private void ClearCurrentSeed()
    {
        SetCurrentEditingSeed(null);
        ClearDetails();
    }
    
    // --- Public Methods for Gene/Seed Items ---
    
    public void OnGeneSelected(NodeDefinition gene)
    {
        ShowGeneDetails(gene);
    }
    
    public void OnSeedSelected(SeedInstance seed)
    {
        ShowSeedDetails(seed);
    }
    
    public void OnGeneAddToSequence(NodeDefinition gene)
    {
        if (currentEditingSeed != null && gene != null)
        {
            currentEditingSeed.AddGene(gene);
            RefreshGeneSequence();
            
            if (showDebugLogs)
                Debug.Log($"[PlantotronUI] Added gene {gene.displayName} to seed");
        }
    }
    
    public void OnSeedLoadForEditing(SeedInstance seed)
    {
        if (seed != null)
        {
            // Create a working copy
            SeedInstance workingCopy = new SeedInstance(seed);
            SetCurrentEditingSeed(workingCopy);
        }
    }
    
    public void OnGeneRemovedFromSequence(int index)
    {
        if (currentEditingSeed != null && currentEditingSeed.RemoveGeneAt(index))
        {
            RefreshGeneSequence();
            
            if (showDebugLogs)
                Debug.Log($"[PlantotronUI] Removed gene at index {index}");
        }
    }
    
    public void OnGeneMovedInSequence(int fromIndex, int toIndex)
    {
        if (currentEditingSeed != null && currentEditingSeed.MoveGene(fromIndex, toIndex))
        {
            RefreshGeneSequence();
            
            if (showDebugLogs)
                Debug.Log($"[PlantotronUI] Moved gene from {fromIndex} to {toIndex}");
        }
    }
    
    // --- Utility Methods ---
    
    private void RefreshAllLists()
    {
        RefreshGeneDatabase(geneSearchField?.text ?? "");
        RefreshSeedDatabase(seedSearchField?.text ?? "");
        RefreshGeneEditor();
    }
    
    private void ClearContainer(Transform container, List<GameObject> itemList)
    {
        foreach (GameObject item in itemList)
        {
            if (item != null)
                DestroyImmediate(item);
        }
        itemList.Clear();
    }
    
    public SeedInstance GetCurrentEditingSeed()
    {
        return currentEditingSeed;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\PlayerGeneticsInventory.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Genetics/PlayerGeneticsInventory.cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System;

public class PlayerGeneticsInventory : MonoBehaviour
{
    public static PlayerGeneticsInventory Instance { get; private set; }
    
    [Header("Starting Inventory")]
    [Tooltip("Genes (NodeDefinitions) the player starts with")]
    public List<NodeDefinition> startingGenes = new List<NodeDefinition>();
    
    [Tooltip("Seeds (SeedDefinitions) the player starts with")]
    public List<SeedDefinition> startingSeedDefinitions = new List<SeedDefinition>();
    
    [Header("Current Inventory")]
    [SerializeField] private List<NodeDefinition> availableGenes = new List<NodeDefinition>();
    [SerializeField] private List<SeedInstance> availableSeeds = new List<SeedInstance>();
    
    [Header("Debug")]
    [SerializeField] private bool showDebugLogs = false;
    
    // Events for UI updates
    public event Action OnInventoryChanged;
    public event Action<NodeDefinition> OnGeneAdded;
    public event Action<SeedInstance> OnSeedAdded;
    public event Action<SeedInstance> OnSeedRemoved;
    
    // Public accessors
    public List<NodeDefinition> AvailableGenes => availableGenes;
    public List<SeedInstance> AvailableSeeds => availableSeeds;
    
    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }
    
    void Start()
    {
        InitializeStartingInventory();
    }
    
    private void InitializeStartingInventory()
    {
        // Add starting genes
        foreach (var gene in startingGenes)
        {
            if (gene != null && !availableGenes.Contains(gene))
            {
                availableGenes.Add(gene);
                if (showDebugLogs)
                    Debug.Log($"[PlayerGeneticsInventory] Added starting gene: {gene.displayName}");
            }
        }
        
        // Add starting seeds
        foreach (var seedDef in startingSeedDefinitions)
        {
            if (seedDef != null)
            {
                SeedInstance newSeed = new SeedInstance(seedDef);
                availableSeeds.Add(newSeed);
                if (showDebugLogs)
                    Debug.Log($"[PlayerGeneticsInventory] Added starting seed: {newSeed.seedName}");
            }
        }
        
        if (showDebugLogs)
            Debug.Log($"[PlayerGeneticsInventory] Initialized with {availableGenes.Count} genes and {availableSeeds.Count} seeds");
            
        OnInventoryChanged?.Invoke();
    }
    
    // --- Gene Management ---
    
    /// <summary>
    /// Adds a gene to the player's inventory if not already present
    /// </summary>
    public bool AddGene(NodeDefinition gene)
    {
        if (gene == null)
        {
            Debug.LogWarning("[PlayerGeneticsInventory] Tried to add null gene!");
            return false;
        }
        
        if (availableGenes.Contains(gene))
        {
            if (showDebugLogs)
                Debug.Log($"[PlayerGeneticsInventory] Gene '{gene.displayName}' already in inventory");
            return false;
        }
        
        availableGenes.Add(gene);
        if (showDebugLogs)
            Debug.Log($"[PlayerGeneticsInventory] Added gene: {gene.displayName}");
            
        OnGeneAdded?.Invoke(gene);
        OnInventoryChanged?.Invoke();
        return true;
    }
    
    /// <summary>
    /// Checks if the player has a specific gene
    /// </summary>
    public bool HasGene(NodeDefinition gene)
    {
        return gene != null && availableGenes.Contains(gene);
    }
    
    /// <summary>
    /// Gets all genes of a specific effect type
    /// </summary>
    public List<NodeDefinition> GetGenesWithEffectType(NodeEffectType effectType)
    {
        return availableGenes.Where(gene => 
            gene != null && gene.effects != null && 
            gene.effects.Any(effect => effect != null && effect.effectType == effectType)
        ).ToList();
    }
    
    // --- Seed Management ---
    
    /// <summary>
    /// Adds a seed instance to the player's inventory
    /// </summary>
    public bool AddSeed(SeedInstance seed)
    {
        if (seed == null)
        {
            Debug.LogWarning("[PlayerGeneticsInventory] Tried to add null seed!");
            return false;
        }
        
        availableSeeds.Add(seed);
        if (showDebugLogs)
            Debug.Log($"[PlayerGeneticsInventory] Added seed: {seed.seedName}");
            
        OnSeedAdded?.Invoke(seed);
        OnInventoryChanged?.Invoke();
        return true;
    }
    
    /// <summary>
    /// Creates and adds a new seed from a SeedDefinition
    /// </summary>
    public SeedInstance AddSeedFromDefinition(SeedDefinition seedDef)
    {
        if (seedDef == null)
        {
            Debug.LogWarning("[PlayerGeneticsInventory] Tried to add seed from null definition!");
            return null;
        }
        
        SeedInstance newSeed = new SeedInstance(seedDef);
        AddSeed(newSeed);
        return newSeed;
    }
    
    /// <summary>
    /// Removes a seed from the inventory (e.g., when planted)
    /// </summary>
    public bool RemoveSeed(SeedInstance seed)
    {
        if (seed == null || !availableSeeds.Contains(seed))
            return false;
            
        availableSeeds.Remove(seed);
        if (showDebugLogs)
            Debug.Log($"[PlayerGeneticsInventory] Removed seed: {seed.seedName}");
            
        OnSeedRemoved?.Invoke(seed);
        OnInventoryChanged?.Invoke();
        return true;
    }
    
    /// <summary>
    /// Removes a seed by its unique ID
    /// </summary>
    public bool RemoveSeedById(string seedId)
    {
        SeedInstance seed = availableSeeds.FirstOrDefault(s => s.seedId == seedId);
        return RemoveSeed(seed);
    }
    
    /// <summary>
    /// Creates a duplicate of an existing seed
    /// </summary>
    public SeedInstance DuplicateSeed(SeedInstance originalSeed)
    {
        if (originalSeed == null)
        {
            Debug.LogWarning("[PlayerGeneticsInventory] Cannot duplicate null seed!");
            return null;
        }
        
        SeedInstance duplicatedSeed = new SeedInstance(originalSeed);
        AddSeed(duplicatedSeed);
        return duplicatedSeed;
    }
    
    /// <summary>
    /// Gets seeds that are valid for planting
    /// </summary>
    public List<SeedInstance> GetPlantableSeeds()
    {
        return availableSeeds.Where(seed => seed != null && seed.IsValidForPlanting()).ToList();
    }
    
    /// <summary>
    /// Gets seeds based on whether they're modified or vanilla
    /// </summary>
    public List<SeedInstance> GetSeedsByType(bool getModified)
    {
        return availableSeeds.Where(seed => seed != null && seed.isModified == getModified).ToList();
    }
    
    // --- Utility Methods ---
    
    /// <summary>
    /// Gets inventory statistics for debugging/UI
    /// </summary>
    public string GetInventoryStats()
    {
        int vanillaSeeds = GetSeedsByType(false).Count;
        int modifiedSeeds = GetSeedsByType(true).Count;
        int plantableSeeds = GetPlantableSeeds().Count;
        
        return $"Genes: {availableGenes.Count} | Seeds: {availableSeeds.Count} " +
               $"(Vanilla: {vanillaSeeds}, Modified: {modifiedSeeds}, Plantable: {plantableSeeds})";
    }
    
    /// <summary>
    /// Validates inventory integrity (for debugging)
    /// </summary>
    public void ValidateInventory()
    {
        // Remove null entries
        availableGenes.RemoveAll(gene => gene == null);
        availableSeeds.RemoveAll(seed => seed == null);
        
        // Update modified status for all seeds
        foreach (var seed in availableSeeds)
        {
            seed.UpdateModifiedStatus();
        }
        
        if (showDebugLogs)
            Debug.Log($"[PlayerGeneticsInventory] Validated inventory: {GetInventoryStats()}");
    }
    
    // --- Save/Load (Basic Implementation) ---
    // Note: For production, you'd want a more robust save system
    
    [System.Serializable]
    private class InventorySaveData
    {
        public List<string> geneAssetNames = new List<string>();
        public List<SeedInstance> seedInstances = new List<SeedInstance>();
    }
    
    public void SaveInventory()
    {
        // Basic implementation - in production you'd use a proper save system
        if (showDebugLogs)
            Debug.Log("[PlayerGeneticsInventory] Save functionality not fully implemented yet");
    }
    
    public void LoadInventory()
    {
        // Basic implementation - in production you'd use a proper save system
        if (showDebugLogs)
            Debug.Log("[PlayerGeneticsInventory] Load functionality not fully implemented yet");
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\SeedDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Genetics/SeedDefinition.cs
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "Seed_", menuName = "Genetics/Seed Definition")]
public class SeedDefinition : ScriptableObject
{
    [Header("Basic Information")]
    [Tooltip("Display name for this seed type")]
    public string seedName = "Unknown Seed";
    
    [Tooltip("Description of this seed's characteristics")]
    [TextArea(3, 5)]
    public string description = "A mysterious seed with unknown properties.";
    
    [Tooltip("Icon for this seed type")]
    public Sprite icon;
    
    [Header("Genetic Composition")]
    [Tooltip("Starting genes (nodes) that this seed contains")]
    public List<NodeDefinition> initialGenes = new List<NodeDefinition>();
    
    [Header("Seed Properties")]
    [Tooltip("Is this a vanilla (unmodified) seed type?")]
    public bool isVanillaSeed = true;
    
    [Tooltip("Rarity level for potential future progression systems")]
    [Range(1, 5)]
    public int rarityLevel = 1;
    
    /// <summary>
    /// Creates a deep copy of the initial genes list for use in SeedInstance
    /// </summary>
    public List<NodeDefinition> CloneInitialGenes()
    {
        List<NodeDefinition> clonedGenes = new List<NodeDefinition>();
        if (initialGenes != null)
        {
            foreach (var gene in initialGenes)
            {
                if (gene != null)
                {
                    clonedGenes.Add(gene);
                }
            }
        }
        return clonedGenes;
    }
    
    /// <summary>
    /// Validates that this seed definition has the minimum required genes to grow
    /// </summary>
    public bool IsValidSeed()
    {
        if (initialGenes == null || initialGenes.Count == 0)
            return false;
            
        // Check for required SeedSpawn effect
        foreach (var gene in initialGenes)
        {
            if (gene != null && gene.effects != null)
            {
                foreach (var effect in gene.effects)
                {
                    if (effect != null && effect.effectType == NodeEffectType.SeedSpawn && effect.isPassive)
                    {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
}





--------------------------------------------------------------------------------
This is part 5 out of 9 of script collection. 4 more parts remain.
--------------------------------------------------------------------------------