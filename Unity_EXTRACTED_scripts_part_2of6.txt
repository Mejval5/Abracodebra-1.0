This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-05-01 01:40:59
PART 2 OF 6
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           └── DualGridRuleTile_Grass.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_WaterPreserver.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       └── Wave_001.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManagement.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       └── ShadowPartController.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   └── SpriteEmissiveUnlit.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/AnimalController.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using TMPro;

[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(SortableEntity))]
[RequireComponent(typeof(Collider2D))]
public class AnimalController : MonoBehaviour
{
    // --- Fields --- (No changes)
    private AnimalDefinition definition; private AnimalDiet animalDiet;
    [Header("Optional Features")] public AnimalThoughtLibrary thoughtLibrary; public GameObject thoughtBubblePrefab; public Transform bubbleSpawnTransform; public Transform poopSpawnPoint; public List<GameObject> poopPrefabs; public Animator animator;
    [Header("UI References")] [SerializeField] private TextMeshProUGUI hpText;
    [Header("Behavior Tuning")] public float searchRadius = 5f; public float eatDistance = 0.5f; public float eatDuration = 1.5f; [Range(0f, 1f)] public float wanderPauseChance = 0.3f; public float wanderMinMoveDuration = 1f; public float wanderMaxMoveDuration = 3f; public float wanderMinPauseDuration = 0.5f; public float wanderMaxPauseDuration = 2f; public float minPoopDelay = 5f; public float maxPoopDelay = 10f; public float poopDuration = 1f; public float poopColorVariation = 0.1f; public float thoughtCooldownTime = 5f; [SerializeField] private List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>(); [SerializeField] private List<ScentDefinition> repellentScentDefinitions = new List<ScentDefinition>();

    // --- Internal State --- (No changes)
    private float currentHealth; private float currentHunger; private GameObject currentTargetFood = null; private Vector2 moveDirection = Vector2.zero; private bool isEating = false; private float eatTimer = 0f; private bool isWanderPaused = false; private float wanderStateTimer = 0f; private bool isPooping = false; private float poopTimer = 0f; private float poopDelayTimer = 0f; private bool hasPooped = true; private float thoughtCooldownTimer = 0f;
    private bool isSeekingScreenCenter = false;
    private Vector2 screenCenterTarget;

    // --- Component References --- (No changes)
    private Rigidbody2D rb; private SpriteRenderer spriteRenderer; private Collider2D animalCollider;

    // --- Movement Bounds (Now Shifted Padded Screen Bounds) ---
    private Vector2 minBounds; private Vector2 maxBounds;

    // --- Public Accessors --- (No changes)
    public float CurrentHealth => currentHealth; public string SpeciesName => definition ? definition.animalName : "Uninitialized";

    // --- Initialize --- (MODIFIED center calculation only)
    public void Initialize(AnimalDefinition def, Vector2 shiftedMinBounds, Vector2 shiftedMaxBounds, bool spawnedOffscreen = false)
    {
        definition = def; if (definition == null) { Destroy(gameObject); return; }
        animalDiet = def.diet; if (animalDiet == null) { enabled = false; return; }
        rb = GetComponent<Rigidbody2D>(); spriteRenderer = GetComponentInChildren<SpriteRenderer>(); animalCollider = GetComponent<Collider2D>();
        if (animalCollider == null) { Debug.LogError($"[{gameObject.name}] Missing Collider2D!", gameObject); enabled = false; return; }

        currentHealth = definition.maxHealth; currentHunger = 0f; hasPooped = true; poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);

        // Store the SHIFTED bounds received from FaunaManager
        minBounds = shiftedMinBounds;
        maxBounds = shiftedMaxBounds;
        // Calculate the target center based on the SHIFTED bounds
        screenCenterTarget = (minBounds + maxBounds) / 2f;

        isSeekingScreenCenter = spawnedOffscreen;
        if (isSeekingScreenCenter)
        {
            // Debug now shows the shifted bounds and target
            if(Debug.isDebugBuild) Debug.Log($"[{gameObject.name} Initialize] Offscreen spawn. Seeking SHIFTED center ({screenCenterTarget}). SHIFTED Bounds: min{minBounds}, max{maxBounds}", gameObject);
            moveDirection = (screenCenterTarget - (Vector2)transform.position).normalized;
            if (moveDirection == Vector2.zero) moveDirection = Random.insideUnitCircle.normalized;
        }
        EnsureHpTextReference(); UpdateHpText(); if (spriteRenderer == null) { /* Warning */ }
    }

    // --- Update --- (MODIFIED check, uses shifted bounds)
    void Update()
    {
        if (!enabled || rb == null) return;

        if (isSeekingScreenCenter)
        {
            Vector2 currentPos = rb.position;
            // Check if center is within the SHIFTED padded bounds
            bool centerWithinBounds =
                currentPos.x >= minBounds.x && currentPos.x <= maxBounds.x &&
                currentPos.y >= minBounds.y && currentPos.y <= maxBounds.y;

            if (centerWithinBounds)
            {
                if(Debug.isDebugBuild) Debug.Log($"[{gameObject.name} Update] Center reached SHIFTED bounds! Pos: {currentPos}. MinB: {minBounds}, MaxB: {maxBounds}. Switching to normal AI.", gameObject);
                isSeekingScreenCenter = false;
                moveDirection = Vector2.zero;
            }
            else
            {
                // Seek the SHIFTED center target
                moveDirection = (screenCenterTarget - currentPos).normalized;
                 if (moveDirection == Vector2.zero) moveDirection = Random.insideUnitCircle.normalized;
                FlipSpriteBasedOnDirection(); UpdateAnimationState();
                return; // Skip normal AI
            }
        }

        // Normal AI Logic
        UpdateHunger(); HandlePooping(); UpdateThoughts();
        if (isEating) { HandleEating(); moveDirection = Vector2.zero; }
        else if (isPooping) { moveDirection = Vector2.zero; }
        else { DecideNextAction(); }

        FlipSpriteBasedOnDirection(); UpdateAnimationState();
    }

    // --- FixedUpdate --- (Uses shifted bounds for clamping)
    void FixedUpdate()
    {
        if (rb == null) return;
        if (!isEating && !isPooping && moveDirection != Vector2.zero)
        {
            Vector2 currentPos = rb.position;
            Vector2 desiredMove = moveDirection.normalized * definition.movementSpeed * Time.fixedDeltaTime;
            Vector2 nextPos = currentPos + desiredMove;

            if (!isSeekingScreenCenter) // Clamp only when NOT seeking
            {
                 // Clamp the CENTER position using the SHIFTED bounds
                 nextPos.x = Mathf.Clamp(nextPos.x, minBounds.x, maxBounds.x);
                 nextPos.y = Mathf.Clamp(nextPos.y, minBounds.y, maxBounds.y);
            }
            rb.MovePosition(nextPos);
        }
    }

    // --- Other methods (Unchanged) ---
    void UpdateHunger() { /* ... */ currentHunger += animalDiet.hungerIncreaseRate * Time.deltaTime; currentHunger = Mathf.Min(currentHunger, animalDiet.maxHunger); }
    void ApplyStarvationDamage() { /* ... */ UpdateHpText(); }
    void HandlePooping() { /* ... */ if (!isEating && !hasPooped) { poopDelayTimer -= Time.deltaTime; if (!isPooping && poopDelayTimer <= 0f) { StartPooping(); } if (isPooping) { poopTimer -= Time.deltaTime; if (poopTimer <= 0f) { FinishPooping(); } } } }
    void UpdateThoughts() { /* ... */ if (thoughtCooldownTimer > 0) { thoughtCooldownTimer -= Time.deltaTime; } }
    void DecideNextAction() { /* ... */ if (currentHunger >= animalDiet.hungerThreshold) { SeekFood(); } else { Wander(); currentTargetFood = null; } }
    void SeekFood() { /* ... */ if (CanShowThought()) ShowThought(ThoughtTrigger.Hungry); bool targetValid = currentTargetFood != null && currentTargetFood.activeInHierarchy && currentTargetFood.GetComponent<FoodItem>() != null; if (!targetValid) { currentTargetFood = FindNearestFood(); } if (currentTargetFood != null) { MoveTowardFood(currentTargetFood); } else { Wander(); } }
    GameObject FindNearestFood() { /* ... */ Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, searchRadius); return animalDiet.FindBestFood(colliders, transform.position); }
    void MoveTowardFood(GameObject foodObj) { /* ... */ if (foodObj == null) return; float distance = Vector2.Distance(transform.position, foodObj.transform.position); if (distance <= eatDistance) { StartEating(); } else { moveDirection = (foodObj.transform.position - transform.position).normalized; isWanderPaused = false; wanderStateTimer = 0f; } }
    void StartEating() { /* ... */ isEating = true; eatTimer = eatDuration; moveDirection = Vector2.zero; if (CanShowThought()) ShowThought(ThoughtTrigger.Eating); }
    void HandleEating() { /* ... */ eatTimer -= Time.deltaTime; if (eatTimer <= 0f) { isEating = false; FinishEatingAction(); } }
    void FinishEatingAction() { /* ... */ if (currentTargetFood == null) return; FoodItem foodItem = currentTargetFood.GetComponent<FoodItem>(); if (foodItem != null && foodItem.foodType != null) { float satiationGain = animalDiet.GetSatiationValue(foodItem.foodType); currentHunger -= satiationGain; currentHunger = Mathf.Max(0f, currentHunger); Destroy(currentTargetFood); hasPooped = false; poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay); currentTargetFood = null; } else { currentTargetFood = null; } }
    void StartPooping() { /* ... */ isPooping = true; poopTimer = poopDuration; moveDirection = Vector2.zero; if (CanShowThought()) ShowThought(ThoughtTrigger.Pooping); }
    void FinishPooping() { /* ... */ SpawnPoop(); isPooping = false; hasPooped = true; }
    void SpawnPoop() { /* ... */ if (poopPrefabs == null || poopPrefabs.Count == 0) return; int index = Random.Range(0, poopPrefabs.Count); GameObject prefab = poopPrefabs[index]; if (prefab == null) return; Transform spawnT = poopSpawnPoint ? poopSpawnPoint : transform; GameObject poopObj = Instantiate(prefab, spawnT.position, Quaternion.identity); SpriteRenderer sr = poopObj.GetComponent<SpriteRenderer>(); if (sr != null) { sr.flipX = Random.value > 0.5f; Color c = sr.color; float v = poopColorVariation; sr.color = new Color(Mathf.Clamp01(c.r + Random.Range(-v, v)), Mathf.Clamp01(c.g + Random.Range(-v, v)), Mathf.Clamp01(c.b + Random.Range(-v, v)), c.a); } PoopController pc = poopObj.GetComponent<PoopController>() ?? poopObj.AddComponent<PoopController>(); pc.Initialize(); }
    void Wander() { /* ... */ if (wanderStateTimer <= 0f) { if (isWanderPaused) { isWanderPaused = false; moveDirection = Random.insideUnitCircle.normalized; wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration); } else { if (Random.value < wanderPauseChance) { isWanderPaused = true; moveDirection = Vector2.zero; wanderStateTimer = Random.Range(wanderMinPauseDuration, wanderMaxPauseDuration); } else { moveDirection = Random.insideUnitCircle.normalized; wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration); } } } else { wanderStateTimer -= Time.deltaTime; } }
    void FlipSpriteBasedOnDirection() { /* ... */ if (spriteRenderer != null && Mathf.Abs(moveDirection.x) > 0.01f) { spriteRenderer.flipX = moveDirection.x < 0; } }
    void UpdateAnimationState() { /* ... */ if (animator == null) return; bool isMoving = !isEating && !isPooping && moveDirection.sqrMagnitude > 0.01f; animator.SetBool("IsMoving", isMoving); animator.SetBool("IsEating", isEating); }
    bool CanShowThought() { /* ... */ return thoughtLibrary != null && thoughtBubblePrefab != null && thoughtCooldownTimer <= 0f; }
    void ShowThought(ThoughtTrigger trigger) { /* ... */ if (thoughtLibrary == null || thoughtLibrary.allThoughts == null) return; var entry = thoughtLibrary.allThoughts.FirstOrDefault(t => t != null && t.speciesName == SpeciesName && t.trigger == trigger); if (entry != null && entry.lines != null && entry.lines.Count > 0) { string line = entry.lines[Random.Range(0, entry.lines.Count)]; Transform spawnT = bubbleSpawnTransform ? bubbleSpawnTransform : transform; GameObject bubbleGO = Instantiate(thoughtBubblePrefab, spawnT.position, Quaternion.identity, spawnT); bubbleGO.transform.localPosition = Vector3.zero; ThoughtBubbleController bubble = bubbleGO.GetComponent<ThoughtBubbleController>(); if (bubble) { bubble.Initialize(line, spawnT, 2f); thoughtCooldownTimer = thoughtCooldownTime; } else { Destroy(bubbleGO); } } }
    public enum CauseOfDeath { Unknown, Starvation, EatenByPredator }
    private void Die(CauseOfDeath cause) { /* ... */ Debug.Log($"[{SpeciesName} died: {cause}]", gameObject); Destroy(gameObject); }
    public bool SpeciesNameEquals(string other) { /* ... */ return definition != null && definition.animalName == other; }
    private void EnsureHpTextReference() { /* ... */ if (hpText == null) { hpText = GetComponentInChildren<TextMeshProUGUI>(true); } }
    private void UpdateHpText() { /* ... */ if (hpText == null || definition == null) return; hpText.text = $"HP: {Mathf.FloorToInt(currentHealth)}/{Mathf.FloorToInt(definition.maxHealth)}"; }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalSpawnData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[System.Serializable]
public class AnimalSpawnData {
    public AnimalDefinition animalDefinition;
    [Range(0f, 1f)]
    [Tooltip("Spawn rate multiplier (0 = no spawn; lower values = less frequent spawns).")]
    public float spawnRateMultiplier = 1f;
    [Tooltip("Maximum number of this animal type allowed to be spawned (0 = no limit).")]
    public int maximumSpawned = 0;
    
    [HideInInspector]
    public float spawnTimer = 0f;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalThoughtLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "AnimalThoughtLibrary", menuName = "Ecosystem/Animal Thought Library")]
public class AnimalThoughtLibrary : ScriptableObject
{
    public List<AnimalThoughtLine> allThoughts;
}

[System.Serializable]
public class AnimalThoughtLine
{
    [Header("Which Animal?")]
    public string speciesName; // e.g. "Bunny", "Fox", "Bird"

    [Header("Trigger Condition")]
    public ThoughtTrigger trigger;

    [Header("Possible Lines to Randomly Choose From")]
    public List<string> lines;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\EcosystemManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/EcosystemManager.cs
using UnityEngine;

public class EcosystemManager : MonoBehaviour
{
    public static EcosystemManager Instance { get; private set; }

    [Header("Parent Transforms")]
    public Transform animalParent;
    public Transform plantParent;

    [Header("Libraries")]
    [Tooltip("Reference to the Scent Library asset.")]
    public ScentLibrary scentLibrary; // <<< ADDED

    [Header("Sorting Options")]
    public bool sortAnimalsBySpecies = true;
    public bool sortPlantsBySpecies = true;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // Validate Library Reference
        if (scentLibrary == null)
        {
            Debug.LogWarning($"[{nameof(EcosystemManager)}] Scent Library not assigned! Scent effects will not work.", this);
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FaunaManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/FaunaManager.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class FaunaManager : MonoBehaviour
{
    [Header("Spawning Area (Global)")]
    [SerializeField] private Vector2 spawnCenter = Vector2.zero;
    [SerializeField] private Vector2 spawnAreaSize = new Vector2(20f, 10f);

    [Header("General Settings")]
    [SerializeField] private Transform ecosystemParent;
    [Tooltip("How far INSIDE the screen edge the effective animal movement bounds are.")]
    [SerializeField][Min(0f)] private float screenBoundsPadding = 0.5f;
    [Tooltip("How far OUTSIDE the screen edge the 'Offscreen' spawn area starts.")]
    [SerializeField][Min(0f)] private float offscreenSpawnMargin = 2.0f;

    [Header("Debugging")]
    [Tooltip("Show gizmos visualizing the Margin (Red) and Padding (Green) bounds.")]
    [SerializeField] private bool showBoundsGizmos = false;

    [Header("Functional Bounds Offset")] // <<< UPDATED HEADER NAME
    [Tooltip("Functional horizontal shift for gameplay bounds and spawning relative to camera view.")] // <<< UPDATED TOOLTIP
    [SerializeField][Range(-10f, 10f)] private float boundsOffsetX = 0f; // <<< RENAMED FIELD
    [Tooltip("Functional vertical shift for gameplay bounds and spawning relative to camera view.")] // <<< UPDATED TOOLTIP
    [SerializeField][Range(-10f, 10f)] private float boundsOffsetY = 0f; // <<< RENAMED FIELD

    // --- Runtime State ---
    private List<Coroutine> activeSpawnCoroutines = new List<Coroutine>();
    private Camera mainCamera;

    // --- Start, InitializeManager, Update, ExecuteSpawnWave, StopAllSpawnCoroutines, SpawnWaveEntryCoroutine (Unchanged) ---
    void Start() { InitializeManager(); }
    void InitializeManager() { activeSpawnCoroutines.Clear(); if (WaveManager.Instance != null) { mainCamera = WaveManager.Instance.GetMainCamera(); } if (mainCamera == null) { mainCamera = Camera.main; if (mainCamera == null) Debug.LogError("[FaunaManager] Cannot find Main Camera!", this); } if (ecosystemParent == null) { ecosystemParent = transform; Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned to self.", this); } }
    void Update() { /* ... */ }
    public void ExecuteSpawnWave(WaveDefinition waveDef) { if (waveDef == null) { Debug.LogError("[FaunaManager] ExecuteSpawnWave null WaveDefinition!", this); return; } if (waveDef.spawnEntries == null || waveDef.spawnEntries.Count == 0) { Debug.LogWarning($"[FaunaManager] Wave '{waveDef.waveName}' has no spawn entries.", this); return; } Debug.Log($"[FaunaManager] Executing spawn for Wave: '{waveDef.waveName}'"); foreach (WaveSpawnEntry entry in waveDef.spawnEntries) { if (entry.animalDefinition == null) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', null AnimalDefinition."); continue; } if (entry.spawnCount <= 0) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', Spawn Count <= 0."); continue; } WaveSpawnEntry currentEntry = entry; Coroutine spawnCoroutine = StartCoroutine(SpawnWaveEntryCoroutine(currentEntry)); activeSpawnCoroutines.Add(spawnCoroutine); } Debug.Log($"[FaunaManager] Started {activeSpawnCoroutines.Count} coroutine(s) for '{waveDef.waveName}'."); }
    public void StopAllSpawnCoroutines() { if (activeSpawnCoroutines.Count > 0) { Debug.Log("[FaunaManager] Stopping all spawn coroutines."); foreach (Coroutine co in activeSpawnCoroutines) { if (co != null) StopCoroutine(co); } activeSpawnCoroutines.Clear(); } }
     private IEnumerator SpawnWaveEntryCoroutine(WaveSpawnEntry entry) { if (entry.delayAfterSpawnTime > 0) { yield return new WaitForSeconds(entry.delayAfterSpawnTime); } for (int i = 0; i < entry.spawnCount; i++) { if (WaveManager.Instance != null && !WaveManager.Instance.IsRunActive) { Debug.Log($"[FaunaManager] Halting spawn '{entry.description}', run no longer active."); break; } Vector2 spawnPos = CalculateSpawnPosition(entry.spawnLocationType, entry.spawnRadius); bool isOffscreen = entry.spawnLocationType == WaveSpawnLocationType.Offscreen; GameObject spawnedAnimal = SpawnAnimal(entry.animalDefinition, spawnPos, isOffscreen); if (entry.spawnInterval > 0 && i < entry.spawnCount - 1) { yield return new WaitForSeconds(entry.spawnInterval); } } if (activeSpawnCoroutines.Count > 0) activeSpawnCoroutines.RemoveAt(0); } // Simplistic removal

    /// <summary>
    /// Calculates a spawn position based on the specified type, applying functional offset.
    /// </summary>
    private Vector2 CalculateSpawnPosition(WaveSpawnLocationType locationType, float radius) // <<< MODIFIED
    {
        if (mainCamera == null) { Debug.LogError("[FaunaManager] Missing Main Camera!"); return spawnCenter; }

        // --- Calculate the FUNCTIONAL offset ---
        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        // --- Apply offset to camera position for ALL calculations below ---
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

        Vector2 spawnPos = Vector2.zero;
        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;

        switch (locationType)
        {
            case WaveSpawnLocationType.Offscreen:
                // Use effectiveCamPos for calculations
                float marginMinX = effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin;
                float marginMaxX = effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin;
                float marginMinY = effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin;
                float marginMaxY = effectiveCamPos.y + camHeight / 2f + offscreenSpawnMargin;
                float extraOffset = 0.1f; // To spawn strictly outside the line
                int edge = Random.Range(0, 4);
                if (edge == 0) { spawnPos.x = marginMinX - extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
                else if (edge == 1) { spawnPos.x = marginMaxX + extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
                else if (edge == 2) { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMinY - extraOffset; }
                else { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMaxY + extraOffset; }
                break;

            case WaveSpawnLocationType.RandomNearPlayer:
                 Transform playerT = FindPlayerTransform();
                 if (playerT != null) {
                    // Spawn relative to player, still respecting the overall bounds offset implicitly
                    spawnPos = (Vector2)playerT.position + Random.insideUnitCircle * radius;
                 } else {
                     Debug.LogWarning("[FaunaManager] Player not found for RandomNearPlayer. Falling back to Global.");
                     goto case WaveSpawnLocationType.GlobalSpawnArea; // Fallthrough
                 }
                 break;

            case WaveSpawnLocationType.GlobalSpawnArea:
            default:
                // Use effectiveCamPos OR a fixed world space center? Let's stick to camera relative for now.
                // If you want truly fixed global spawn, use spawnCenter directly.
                // This uses the *shifted* camera center as the basis for the global area.
                spawnPos.x = effectiveCamPos.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
                spawnPos.y = effectiveCamPos.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
                break;
        }
        return spawnPos;
    }

    private Transform FindPlayerTransform() { /* Unchanged */ Transform pT = null; if (WaveManager.Instance != null) { var pI = FindObjectOfType<PlayerTileInteractor>(); if (pI != null) pT = pI.transform; } if (pT == null) { GameObject pO = GameObject.FindGameObjectWithTag("Player"); if (pO != null) pT = pO.transform; } return pT; }

    /// <summary>
    /// Instantiates and initializes an animal, passing SHIFTED screen bounds.
    /// </summary>
    private GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position, bool isOffscreenSpawn) // <<< MODIFIED
    {
        if (definition == null || definition.prefab == null) { /* Error Log */ return null; }
        if (mainCamera == null) { /* Error Log */ return null; }

        // --- Calculate SHIFTED Padded Screen Bounds ---
        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

        Vector2 minPaddedBounds, maxPaddedBounds;
        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;

        minPaddedBounds.x = effectiveCamPos.x - camWidth / 2f + screenBoundsPadding;
        maxPaddedBounds.x = effectiveCamPos.x + camWidth / 2f - screenBoundsPadding;
        minPaddedBounds.y = effectiveCamPos.y - camHeight / 2f + screenBoundsPadding;
        maxPaddedBounds.y = effectiveCamPos.y + camHeight / 2f - screenBoundsPadding;
        // ---------------------------------------------

        GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

        // Parenting (unchanged)
        if (ecosystemParent != null) { Transform sP = ecosystemParent; if (!string.IsNullOrEmpty(definition.animalName)) { sP = ecosystemParent.Find(definition.animalName); if (sP == null) { GameObject subP = new GameObject(definition.animalName); subP.transform.SetParent(ecosystemParent); sP = subP.transform; } } animalObj.transform.SetParent(sP); }

        // Initialize Controller, passing the SHIFTED bounds
        AnimalController controller = animalObj.GetComponent<AnimalController>();
        if (controller != null) {
            controller.Initialize(definition, minPaddedBounds, maxPaddedBounds, isOffscreenSpawn); // Pass shifted bounds
        } else { /* Error Log & Destroy */ Destroy(animalObj); return null; }
        return animalObj;
    }

    /// <summary>
    /// Draws debug rectangles applying the functional offset.
    /// </summary>
    void OnDrawGizmos() // <<< MODIFIED to use offset
    {
        if (!showBoundsGizmos || mainCamera == null) return;

        // --- Apply functional offset for Gizmo drawing ---
        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;
        // --------------------------------------------------

        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;

        // Calculate corners using effectiveCamPos
        Vector2 paddedMin = new Vector2(effectiveCamPos.x - camWidth / 2f + screenBoundsPadding, effectiveCamPos.y - camHeight / 2f + screenBoundsPadding);
        Vector2 paddedMax = new Vector2(effectiveCamPos.x + camWidth / 2f - screenBoundsPadding, effectiveCamPos.y + camHeight / 2f - screenBoundsPadding);
        DrawWireRectangleGizmo(paddedMin, paddedMax, Color.green);

        Vector2 marginMin = new Vector2(effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin, effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin);
        Vector2 marginMax = new Vector2(effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin, effectiveCamPos.y + camHeight / 2f + offscreenSpawnMargin);
        DrawWireRectangleGizmo(marginMin, marginMax, Color.red);
    }

    void DrawWireRectangleGizmo(Vector2 min, Vector2 max, Color color) { /* Unchanged */ Gizmos.color = color; Gizmos.DrawLine(new Vector3(min.x, min.y, 0), new Vector3(max.x, min.y, 0)); Gizmos.DrawLine(new Vector3(max.x, min.y, 0), new Vector3(max.x, max.y, 0)); Gizmos.DrawLine(new Vector3(max.x, max.y, 0), new Vector3(min.x, max.y, 0)); Gizmos.DrawLine(new Vector3(min.x, max.y, 0), new Vector3(min.x, min.y, 0)); }

} // End of class




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FloraManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/FloraManager.cs
using UnityEngine;
using System.Collections.Generic; // Added for Dictionary
#if UNITY_EDITOR
using UnityEditor;
#endif

public class FloraManager : MonoBehaviour
{
    public static FloraManager Instance { get; private set; }

    [Header("Debugging - Scents")]
    [Tooltip("Show scent radii circle renderers in Game View during runtime.")]
    [SerializeField] private bool showScentRadiiRuntime = false;
    [SerializeField] private Color scentRadiusColorRuntime = Color.yellow;
    [SerializeField] private bool logGizmoCalls = false;
    [Space]
    [Tooltip("Prefab used to draw scent circles at runtime.")]
    [SerializeField] private GameObject circleVisualizerPrefab; // <<< ADDED
    [Tooltip("Parent transform for instantiated circle visualizers.")]
    [SerializeField] private Transform circleContainer; // <<< ADDED

    // --- Public Accessors ---
    public bool ShowScentRadiiRuntime => showScentRadiiRuntime;
    public Color ScentRadiusColorRuntime => scentRadiusColorRuntime;

    // --- Internal State ---
    // Dictionary to track circle visualizers per ScentSource
    private Dictionary<ScentSource, RuntimeCircleDrawer> activeCircleVisualizers = new Dictionary<ScentSource, RuntimeCircleDrawer>();


    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Validate Debug Dependencies
        if (circleVisualizerPrefab == null) { Debug.LogError($"[{nameof(FloraManager)}] Circle Visualizer Prefab is not assigned!", this); }
        if (circleContainer == null) { Debug.LogError($"[{nameof(FloraManager)}] Circle Container transform is not assigned!", this); }
    }

     void Update() // Added Update loop
     {
         if (!Application.isPlaying) return;
         UpdateRuntimeCircleVisualizers();
     }

    void OnDestroy()
    {
        if (Instance == this) Instance = null;
        // Clean up any remaining visualizers when manager is destroyed
         foreach (var kvp in activeCircleVisualizers)
         {
             if (kvp.Value != null) Destroy(kvp.Value.gameObject);
         }
         activeCircleVisualizers.Clear();
    }


    // --- Runtime Visualizer Update ---
    void UpdateRuntimeCircleVisualizers()
    {
        bool showCircles = showScentRadiiRuntime && circleVisualizerPrefab != null && circleContainer != null;

        // Find all active ScentSources (can be slow, consider optimizing if needed)
        // If performance becomes an issue, ScentSources could register/deregister themselves with the manager.
        ScentSource[] currentSources = FindObjectsByType<ScentSource>(FindObjectsSortMode.None);
        HashSet<ScentSource> currentSourcesSet = new HashSet<ScentSource>(currentSources); // For quick lookup

        // --- Update existing circles ---
        List<ScentSource> sourcesToRemove = new List<ScentSource>();
        foreach (var kvp in activeCircleVisualizers)
        {
            ScentSource source = kvp.Key;
            RuntimeCircleDrawer drawer = kvp.Value;

            // Check if source still exists and is valid
            if (source == null || drawer == null || !source.gameObject.activeInHierarchy || !currentSourcesSet.Contains(source))
            {
                sourcesToRemove.Add(source); // Mark for removal
                if (drawer != null) Destroy(drawer.gameObject); // Destroy visualizer
                continue;
            }

            // Check if circles should be shown globally and if this source is valid
            bool shouldShowThis = showCircles && source.enabled && source.definition != null && source.EffectiveRadius > 0.01f;

            if (shouldShowThis)
            {
                 // Update drawer position to match source and update circle params
                 drawer.transform.position = source.transform.position;
                 drawer.transform.rotation = source.transform.rotation; // Match rotation? Optional.
                 drawer.UpdateCircle(source.EffectiveRadius, scentRadiusColorRuntime);
            }
            else
            {
                 drawer.HideCircle(); // Hide if shouldn't be shown
            }
        }

        // Remove entries for sources that are gone
        foreach (var source in sourcesToRemove)
        {
            activeCircleVisualizers.Remove(source);
        }

        // --- Add circles for new sources ---
        if (showCircles)
        {
            foreach (ScentSource source in currentSources)
            {
                // Skip if already has a visualizer or is invalid
                if (source == null || activeCircleVisualizers.ContainsKey(source) || !source.enabled || source.definition == null || source.EffectiveRadius <= 0.01f) continue;

                 // Create new visualizer
                 GameObject circleGO = Instantiate(circleVisualizerPrefab, source.transform.position, source.transform.rotation, circleContainer);
                 RuntimeCircleDrawer newDrawer = circleGO.GetComponent<RuntimeCircleDrawer>();

                 if (newDrawer != null)
                 {
                      newDrawer.UpdateCircle(source.EffectiveRadius, scentRadiusColorRuntime);
                      activeCircleVisualizers.Add(source, newDrawer); // Add to tracking
                 }
                 else
                 {
                    Debug.LogError($"Circle Visualizer Prefab '{circleVisualizerPrefab.name}' is missing RuntimeCircleDrawer script!", circleVisualizerPrefab);
                    Destroy(circleGO);
                 }
            }
        }
        // --- Hide/Destroy all if global flag turned off ---
        else if (!showCircles && activeCircleVisualizers.Count > 0)
        {
             foreach (var kvp in activeCircleVisualizers)
             {
                 if (kvp.Value != null) Destroy(kvp.Value.gameObject);
             }
             activeCircleVisualizers.Clear();
        }
    }


    // --- Gizmo Drawing (Editor Visualization - Unchanged) ---
    #if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        // Use the runtime flag to ALSO control the editor gizmo
        if (showScentRadiiRuntime) {
             if (logGizmoCalls) { /*...*/ }
             Gizmos.color = scentRadiusColorRuntime; // Use runtime color for gizmo too
             ScentSource[] scentSources = FindObjectsByType<ScentSource>(FindObjectsSortMode.None);
             if (logGizmoCalls) { /*...*/ }
             int drawnCount = 0;
             foreach (ScentSource source in scentSources) {
                if (source == null || !source.enabled || source.definition == null) continue;
                float radius = source.EffectiveRadius;
                if (radius > 0.01f) { Gizmos.DrawWireSphere(source.transform.position, radius); drawnCount++; }
             }
             if (logGizmoCalls && drawnCount > 0) { /*...*/ }
             else if (logGizmoCalls && scentSources.Length > 0) { /*...*/ }
        }
    }
    #endif
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\PoopController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class PoopController : MonoBehaviour
{
    [Tooltip("Total lifetime of this poop (in seconds) before disappearing.")]
    public float lifetime = 10f;
    [Tooltip("Duration at the end of the lifetime during which the poop fades out.")]
    public float fadeDuration = 2f;
    [Tooltip("Fadeout curve to control the alpha during fade-out. X axis goes from 0 (start of fade) to 1 (end of fade).")]
    public AnimationCurve fadeCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);

    private SpriteRenderer sr;
    private float timer = 0f;
    private Color initialColor;

    private void Awake()
    {
        sr = GetComponent<SpriteRenderer>();
        if (sr != null)
        {
            initialColor = sr.color;
        }
    }

    private void Update()
    {
        timer += Time.deltaTime;
        if (timer >= lifetime)
        {
            Destroy(gameObject);
            return;
        }

        // If within fadeDuration at the end, apply fade-out using the fadeCurve.
        float remaining = lifetime - timer;
        if (remaining < fadeDuration && sr != null)
        {
            // Normalize fade time (0 = start, 1 = end)
            float t = 1f - (remaining / fadeDuration);
            float alphaMultiplier = fadeCurve.Evaluate(t);
            Color newColor = initialColor;
            newColor.a = alphaMultiplier;
            sr.color = newColor;
        }
    }

    // Initialize with default parameters if none are provided.
    public void Initialize(float lifetimeValue = -1f, float fadeDurationValue = -1f)
    {
        if (lifetimeValue > 0f)
            lifetime = lifetimeValue;
        if (fadeDurationValue > 0f)
            fadeDuration = fadeDurationValue;
        timer = 0f;
        if (sr != null)
            initialColor = sr.color;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ScentSource.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/ScentSource.cs
using UnityEngine;

// No longer requires RuntimeCircleDrawer directly
// REMOVED: [RequireComponent(typeof(RuntimeCircleDrawer))]
public class ScentSource : MonoBehaviour
{
    [Header("Scent Definition")]
    [Tooltip("The base Scent Definition applied to this object.")]
    public ScentDefinition definition; // Assigned by PlantGrowth/Node effects

    [Header("Applied Modifiers")]
    [Tooltip("Bonus radius added by node effects.")]
    public float radiusModifier = 0f;
    [Tooltip("Bonus strength added by node effects.")]
    public float strengthModifier = 0f;

    // REMOVED: Debugging Reference private RuntimeCircleDrawer circleDrawer;

    // --- Calculated Effective Properties ---
    /// <summary> Gets the effective scent radius (Base Radius + Modifier), clamped >= 0. </summary>
    public float EffectiveRadius => Mathf.Max(0f, (definition != null ? definition.baseRadius : 0f) + radiusModifier);
    /// <summary> Gets the effective scent strength (Base Strength + Modifier), clamped >= 0. </summary>
    public float EffectiveStrength => Mathf.Max(0f, (definition != null ? definition.baseStrength : 0f) + strengthModifier);


    void Awake()
    {
        // No longer needs to get or manage the circle drawer component here
        // REMOVED: circleDrawer = GetComponent<RuntimeCircleDrawer>();
        // REMOVED: circleDrawer?.HideCircle();
    }

    // REMOVED: Update() method (FloraManager handles creating/updating/hiding the external visualizer)


    // Keep Gizmo for Editor visualization (runs independently of Update and runtime drawers)
    void OnDrawGizmosSelected()
    {
        float effectiveRadius = EffectiveRadius; // Calculate radius for gizmo

        if (definition != null) // Check if a definition is assigned
        {
            if (effectiveRadius > 0.01f) // Only draw if radius is meaningful
            {
                // Use definition name hash for consistent random color
                // Note: Random.InitState affects the *next* Random call globally,
                // which might be undesirable if other Gizmos rely on it.
                // A more robust way might be a custom color mapping or a simple hash function.
                // For simplicity, we'll keep Random.InitState for now.
                int prevState = Random.state.GetHashCode(); // Store previous state
                Random.InitState(definition.name.GetHashCode());
                Color gizmoColor = Random.ColorHSV(0f, 1f, 0.7f, 0.9f, 0.8f, 1f);
                gizmoColor.a = 0.3f; // Set alpha for gizmo
                Random.InitState(prevState); // Restore previous state

                Gizmos.color = gizmoColor;
                Gizmos.DrawWireSphere(transform.position, effectiveRadius);
            }
        }
        else // Draw default gray if no definition assigned yet
        {
            Gizmos.color = new Color(0.8f, 0.8f, 0.8f, 0.2f);
            Gizmos.DrawWireSphere(transform.position, 1f); // Default size for editor only
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtBubbleController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class ThoughtBubbleController : MonoBehaviour
{
    public TMP_Text messageText;
    public float lifetime = 2f;

    private Transform followTarget;

    public void Initialize(string message, Transform target, float duration = 2f)
    {
        if (messageText != null)
            messageText.text = message;
        followTarget = target;
        lifetime = duration;
    }

    private void Update()
    {
        lifetime -= Time.deltaTime;
        if (lifetime <= 0f)
            Destroy(gameObject);

        // Follow the target if needed (optional if already a child)
        if (followTarget != null)
        {
            transform.position = followTarget.position;
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtTrigger.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public enum ThoughtTrigger
{
    Hungry,
    Eating,
    HealthLow,
    Fleeing,
    Pooping,
    // Add more triggers as needed
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\WaveDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/WaveDefinition.cs
using UnityEngine;
using System.Collections.Generic;

// Enum WaveSpawnLocationType remains the same
public enum WaveSpawnLocationType
{
    GlobalSpawnArea,
    RandomNearPlayer,
    Offscreen
}

// Class WaveSpawnEntry remains the same
[System.Serializable]
public class WaveSpawnEntry
{
    [Tooltip("Optional description for this specific spawn group within the wave.")]
    public string description = "Spawn Group";
    [Tooltip("The type of animal to spawn.")]
    public AnimalDefinition animalDefinition;
    [Tooltip("How many of this animal to spawn in this specific entry.")]
    [Min(1)]
    public int spawnCount = 1;
    [Tooltip("Delay (in seconds) AFTER the designated wave spawn time (e.g. Day 50%) before *this entry* begins spawning.")] // Clarified Tooltip
    [Min(0)]
    public float delayAfterSpawnTime = 0f; // Renamed from delayAfterWaveStart
    [Tooltip("Time (in seconds) between spawning each individual animal in this entry (0 = spawn all instantly).")]
    [Min(0)]
    public float spawnInterval = 0.5f;
    [Tooltip("Where these animals should spawn.")]
    public WaveSpawnLocationType spawnLocationType = WaveSpawnLocationType.GlobalSpawnArea;
    [Tooltip("Radius used for spawning (e.g., if Spawn Location Type is RandomNearPlayer).")]
    [Min(0)]
    public float spawnRadius = 5f;
}

// WaveDefinition ScriptableObject is simplified further
[CreateAssetMenu(fileName = "Wave_", menuName = "Ecosystem/Wave Definition")]
public class WaveDefinition : ScriptableObject
{
    [Header("Wave Identification")]
    [Tooltip("Editor-only name for this wave.")]
    public string waveName = "New Wave";

    [Header("Wave Content")]
    [Tooltip("Define the groups of animals that spawn during this wave.")]
    public List<WaveSpawnEntry> spawnEntries = new List<WaveSpawnEntry>();

    // REMOVED all timing, duration, end condition, delay fields.
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\WaveManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Managers/WaveManager.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine.UI;

public enum WaveManagerState
{
    PausedBeforeRun,     // Initial state, game logic paused
    WaitingForSpawnTime, // Run started, waiting for correct time in cycle
    WaveInProgress,      // Spawning triggered for this cycle, counting down day cycles
    SequenceComplete     // All waves done
}

public class WaveManager : MonoBehaviour
{
    public static WaveManager Instance { get; private set; }

    [Header("Core Dependencies")]
    [SerializeField] private FaunaManager faunaManager;
    [SerializeField] private WeatherManager weatherManager;
    [SerializeField] private Camera mainCamera;

    [Header("Wave Sequence")]
    [SerializeField] private List<WaveDefinition> wavesSequence;

    [Header("Wave Timing & Spawning (Global)")]
    [Tooltip("How many full Day+Night cycles each wave lasts.")]
    [SerializeField][Range(1, 10)] private int waveDurationInDayCycles = 1;
    [Tooltip("The phase during which spawning should occur each cycle.")]
    [SerializeField] private WeatherManager.CyclePhase spawnStartPhase = WeatherManager.CyclePhase.Day;
    [Tooltip("The percentage progress within the Spawn Start Phase when spawning triggers (0-100).")]
    [SerializeField][Range(0f, 100f)] private float spawnStartPercentage = 50f;
    [SerializeField] private bool loopSequence = false;
    [Tooltip("If checked, animals from the previous wave are destroyed when a new wave starts.")]
    [SerializeField] private bool deletePreviousWaveAnimals = true;

    [Header("UI & Feedback")]
    [SerializeField] private TextMeshProUGUI waveStatusText;
    [SerializeField] private Button startRunButton;
    [SerializeField] private TextMeshProUGUI timeTrackerText;

    [Header("State (Read Only)")]
    [SerializeField] private WaveManagerState currentState = WaveManagerState.PausedBeforeRun;
    [SerializeField] private int currentWaveIndex = -1;

    // --- Runtime State ---
    private WaveDefinition activeWaveDefinition = null;
    private int dayCyclesRemainingForWave = 0;
    private bool hasSpawnedThisCycle = false;
    private bool isInitialPause = true; // <<< NEW: Flag for initial pause

    // --- Public Accessors ---
    public WaveManagerState CurrentState => currentState;
    public int CurrentWaveNumber => currentWaveIndex + 1;
    public int TotalWaves => wavesSequence != null ? wavesSequence.Count : 0;
    public bool IsRunActive => currentState != WaveManagerState.PausedBeforeRun && currentState != WaveManagerState.SequenceComplete;

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Validations (same as before)
        if (faunaManager == null) Debug.LogError("[WaveManager] FaunaManager missing!", this);
        if (weatherManager == null) Debug.LogError("[WaveManager] WeatherManager missing!", this);
        if (mainCamera == null) Debug.LogError("[WaveManager] Main Camera missing!", this);
        if (waveStatusText == null) Debug.LogWarning("[WaveManager] Wave Status Text missing.", this);
        if (timeTrackerText == null) Debug.LogWarning("[WaveManager] Time Tracker Text missing.", this);
        if (wavesSequence == null || wavesSequence.Count == 0) Debug.LogWarning("[WaveManager] Wave Sequence empty.", this);
        if (startRunButton == null) Debug.LogWarning("[WaveManager] Start Run Button missing.", this);
        else startRunButton.onClick.AddListener(TryStartRun);

        // <<< SET INITIAL PAUSE >>>
        Debug.Log("[WaveManager Awake] Setting initial Time.timeScale = 0");
        Time.timeScale = 0f;
        isInitialPause = true;
        // -------------------------
    }

    void Start()
    {
        if (weatherManager != null) weatherManager.OnPhaseChanged += HandleWeatherPhaseChange;
        InitializeManager(); // Sets state, updates button
    }

     void OnDestroy()
    {
        if (weatherManager != null) weatherManager.OnPhaseChanged -= HandleWeatherPhaseChange;
        if (startRunButton != null) startRunButton.onClick.RemoveListener(TryStartRun);
        // Ensure timescale is reset if manager is destroyed
        if(isInitialPause || Time.timeScale != 1f) Time.timeScale = 1f;
    }

    void InitializeManager()
    {
        currentWaveIndex = -1;
        activeWaveDefinition = null;
        dayCyclesRemainingForWave = 0;
        hasSpawnedThisCycle = false;
        // Don't set timescale here anymore, Awake handles initial pause
        SetState(WaveManagerState.PausedBeforeRun);
    }

    void Update()
    {
        // Always update UI if possible
        if (weatherManager != null) UpdateTimeTrackerUI();

        // Skip logic if paused initially OR dependencies missing
        if (isInitialPause || faunaManager == null || weatherManager == null || mainCamera == null)
        {
            // Still need to manage button state even if paused initially
             if (currentState == WaveManagerState.PausedBeforeRun && startRunButton != null)
             {
                  startRunButton.gameObject.SetActive(true);
                  startRunButton.interactable = true;
             }
             return;
        }

        // State Machine Update (only runs after initial pause is over)
        switch (currentState)
        {
            case WaveManagerState.WaitingForSpawnTime: Update_WaitingForSpawnTime(); break;
            case WaveManagerState.WaveInProgress: /* Handled by event */ break;
            case WaveManagerState.SequenceComplete: Update_IdleReady(); break;
             // PausedBeforeRun is handled above
        }
    }

    // --- Event Handler (HandleWeatherPhaseChange) --- (Unchanged)
    void HandleWeatherPhaseChange(WeatherManager.CyclePhase newPhase) { if (currentState == WaveManagerState.PausedBeforeRun || isInitialPause) return; if (newPhase == WeatherManager.CyclePhase.TransitionToDay) { if (currentState == WaveManagerState.WaveInProgress) { dayCyclesRemainingForWave--; hasSpawnedThisCycle = false; if(Debug.isDebugBuild) Debug.Log($"[WaveManager] Day cycle complete. Cycles remaining: {dayCyclesRemainingForWave}"); if (dayCyclesRemainingForWave <= 0) { EndWaveGameplay(); } else { SetState(WaveManagerState.WaitingForSpawnTime); UpdateWaveStatusText(); } } else if (currentState == WaveManagerState.WaitingForSpawnTime) { hasSpawnedThisCycle = false; } } else if (newPhase == spawnStartPhase && currentState == WaveManagerState.WaitingForSpawnTime && !hasSpawnedThisCycle) { Update_WaitingForSpawnTime(); } }


    // --- State Update Methods ---

    void Update_WaitingForSpawnTime() // (Unchanged)
    { if (hasSpawnedThisCycle || weatherManager == null) return; WeatherManager.CyclePhase currentPhase = weatherManager.CurrentPhase; float totalPhaseTime = weatherManager.CurrentTotalPhaseTime; float remainingPhaseTime = weatherManager.CurrentPhaseTimer; float progressPercent = (totalPhaseTime > 0) ? (1f - (remainingPhaseTime / totalPhaseTime)) * 100f : 0f; if (currentPhase == spawnStartPhase && progressPercent >= spawnStartPercentage) { StartWaveSpawning(); } }

    void Update_IdleReady() // (Now only manages button for looping)
    {
         if (startRunButton != null)
         {
            bool showButton = (currentState == WaveManagerState.SequenceComplete && loopSequence);
            startRunButton.gameObject.SetActive(showButton);
            startRunButton.interactable = showButton;
         }
    }

    void UpdateTimeTrackerUI() // (Unchanged)
    { if (timeTrackerText == null || weatherManager == null) return; WeatherManager.CyclePhase phase = weatherManager.CurrentPhase; float total = weatherManager.CurrentTotalPhaseTime; float remaining = weatherManager.CurrentPhaseTimer; float progressPercent = (total > 0) ? (1f - (remaining / total)) * 100f : 0f; string phaseName = phase.ToString().Replace("Transition", ""); timeTrackerText.text = $"{phaseName} [{progressPercent:F0}%]"; if (Time.timeScale == 0f && isInitialPause) timeTrackerText.text += " (Paused)"; } // Show paused during initial pause

    void UpdateWaveStatusText() // (Added PausedBeforeRun case)
    {
         if (waveStatusText == null) return;
         switch(currentState)
         {
             case WaveManagerState.PausedBeforeRun: waveStatusText.text = "Press Start Run"; break;
             case WaveManagerState.WaitingForSpawnTime: waveStatusText.text = $"Wave {CurrentWaveNumber} - Waiting..."; break;
             case WaveManagerState.WaveInProgress: waveStatusText.text = $"Wave {CurrentWaveNumber} [{dayCyclesRemainingForWave} cycles left]"; break;
            case WaveManagerState.SequenceComplete: waveStatusText.text = loopSequence ? "Sequence Done. Start Again?" : "All Waves Cleared!"; break;
             default: waveStatusText.text = ""; break;
         }
    }

    // --- State Transition and Action Methods ---

    void SetState(WaveManagerState newState) // (Removed weather pause logic)
    {
        if (currentState == newState) return;
        if(Debug.isDebugBuild) Debug.Log($"[WaveManager] State Change: {currentState} -> {newState}");
        currentState = newState;

        // Update Button State
        if (startRunButton != null)
        {
            bool showButton = (newState == WaveManagerState.PausedBeforeRun) || (newState == WaveManagerState.SequenceComplete && loopSequence);
            startRunButton.gameObject.SetActive(showButton);
            startRunButton.interactable = showButton;
        }

        // Update Status Text
        UpdateWaveStatusText();
    }

    public void TryStartRun() // <<< MODIFIED
    {
        // Only allow starting from PausedBeforeRun OR SequenceComplete if looping
        if (currentState != WaveManagerState.PausedBeforeRun && !(currentState == WaveManagerState.SequenceComplete && loopSequence))
        {
             if(Debug.isDebugBuild) Debug.Log($"[WaveManager] Cannot start run. State: {currentState}, Looping: {loopSequence}");
             return;
        }

        Debug.Log("[WaveManager] Starting Run...");

        // <<< RESUME TIME >>>
        if (isInitialPause || Time.timeScale != 1f)
        {
            Debug.Log("[WaveManager] Setting Time.timeScale = 1");
            Time.timeScale = 1f;
            isInitialPause = false; // Mark initial pause as over
        }
        // ----------------

        InitializeRun(); // Prepare first wave state
        SetState(WaveManagerState.WaitingForSpawnTime); // Transition state
    }

    void InitializeRun() // (Unchanged)
    { currentWaveIndex = 0; if (wavesSequence == null || wavesSequence.Count == 0 || wavesSequence[currentWaveIndex] == null) { Debug.LogError("[WaveManager] Cannot initialize run: Bad wave sequence!"); SetState(WaveManagerState.SequenceComplete); return; } if(deletePreviousWaveAnimals && currentState == WaveManagerState.SequenceComplete && loopSequence) { ClearAllActiveAnimals(); } activeWaveDefinition = wavesSequence[currentWaveIndex]; dayCyclesRemainingForWave = waveDurationInDayCycles; hasSpawnedThisCycle = false; Debug.Log($"[WaveManager] Run initialized. Starting Wave {CurrentWaveNumber}. Duration: {dayCyclesRemainingForWave} cycles."); }

    void StartWaveSpawning() // (Unchanged)
    { if (activeWaveDefinition == null || currentState != WaveManagerState.WaitingForSpawnTime) { return; } Debug.Log($"[WaveManager] Wave {CurrentWaveNumber} - Spawning Triggered (Phase: {spawnStartPhase} >= {spawnStartPercentage}%)"); hasSpawnedThisCycle = true; SetState(WaveManagerState.WaveInProgress); if (faunaManager != null) faunaManager.ExecuteSpawnWave(activeWaveDefinition); else Debug.LogError("[WaveManager] Cannot execute spawn wave, FaunaManager missing!"); }

    void EndWaveGameplay() // (Unchanged)
    { Debug.Log($"[WaveManager] Wave {CurrentWaveNumber} Gameplay Ended (Duration Met)."); if (faunaManager != null) faunaManager.StopAllSpawnCoroutines(); if (deletePreviousWaveAnimals) { ClearAllActiveAnimals(); } activeWaveDefinition = null; currentWaveIndex++; if (currentWaveIndex >= wavesSequence.Count) { if (loopSequence) { Debug.Log("[WaveManager] Looping back."); InitializeRun(); SetState(WaveManagerState.WaitingForSpawnTime); } else { Debug.Log("[WaveManager] Sequence complete."); SetState(WaveManagerState.SequenceComplete); } } else { if (wavesSequence[currentWaveIndex] == null) { Debug.LogError($"[WaveManager] Wave definition {currentWaveIndex} NULL!"); SetState(WaveManagerState.SequenceComplete); return; } activeWaveDefinition = wavesSequence[currentWaveIndex]; dayCyclesRemainingForWave = waveDurationInDayCycles; hasSpawnedThisCycle = false; Debug.Log($"[WaveManager] Preparing Wave {CurrentWaveNumber}. Duration: {dayCyclesRemainingForWave} cycles."); SetState(WaveManagerState.WaitingForSpawnTime); } }

    void ClearAllActiveAnimals() // (Unchanged)
    { if(Debug.isDebugBuild) Debug.Log("[WaveManager] Clearing all active animals."); AnimalController[] activeAnimals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None); int count = 0; foreach(AnimalController animal in activeAnimals) { if(animal != null) { Destroy(animal.gameObject); count++; } } if(Debug.isDebugBuild) Debug.Log($"[WaveManager] Destroyed {count} animals."); }

    public Camera GetMainCamera() { return mainCamera; } // (Unchanged)
}





--------------------------------------------------------------------------------
This is part 2 out of 6 of script collection. 4 more parts remain.
--------------------------------------------------------------------------------