This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-03-25 00:47:25
PART 1 OF 4
================================================================================

--------------------------------------------------------------------------------
Assets
├── DefaultVolumeProfile.asset
├── Editor
│   ├── HexGridRendererEditor.cs
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   ├── NodeEffectDataDrawer.cs
│   └── WizardControllerStatusEditor.cs
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
├── Prefabs
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   ├── PixelLeaf.prefab
│   │   ├── PixelSeed.prefab
│   │   ├── PixelStem.prefab
│   │   ├── PlantPrefab.prefab
│   │   ├── Projectile_Basic_Pixel.prefab
│   │   └── WizardPrefab.prefab
│   ├── Node Presets
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_AimSpread.asset
│   │   ├── Node_002_Piercing.asset
│   │   ├── Node_003_Output.asset
│   │   ├── Node_004_ManaSource.asset
│   │   ├── Node_005_DamageNode.asset
│   │   ├── Node_006_Burn.asset
│   │   └── Node_007_FriendlyFire.asset
│   ├── UI
│   │   └── NodeView.prefab
│   └── Wizard Presets
│       ├── Wizard_Basic.asset
│       └── Wizard_Dummy.asset
├── Scenes
│   ├── MainScene.unity
│   └── SampleScene.unity
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── HexCoords.cs
│   │   │   ├── HexGridManager.cs
│   │   │   ├── HexGridRenderer.cs
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   ├── NodePort.cs
│   │   │   ├── OutputNodeEffect.cs
│   │   │   └── PortDefinition.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── NodeEditorController.cs
│   │       ├── NodeHexDraggable.cs
│   │       ├── NodeSelectable.cs
│   │       ├── NodeTestInitializer.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── UI
│   └── Wizards
│       ├── WizardController.cs
│       └── WizardPreset.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Test
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\HexGridRendererEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(HexGridRenderer))]
public class HexGridRendererEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            HexGridRenderer grid = (HexGridRenderer)target;
            grid.SetVerticesDirty();
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionAutoAdder.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionAutoAdder : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets,
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string folderPath = Path.GetDirectoryName(assetPath);
                string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
                if (libraryFiles.Length > 0)
                {
                    NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
                    if (library != null && !library.definitions.Contains(nodeDef))
                    {
                        library.definitions.Add(nodeDef);
                        EditorUtility.SetDirty(library);
                        AssetDatabase.SaveAssets();
                    }
                }
            }
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionCreator.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;

public static class NodeDefinitionCreator
{
    private const string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

    [MenuItem(MenuPath, false, 50)]
    public static void CreateNodeDefinition()
    {
        // Figure out which folder the user is in, or use Assets/
        string folder = GetSelectedPathOrFallback();

        // Determine the next numeric index for "Node_XXX_"
        int nextNumber = GetNextNodeNumber(folder);

        // e.g., "Node_007_"
        string newName = $"Node_{nextNumber:D3}_";
        string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

        // Create the NodeDefinition
        NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
        AssetDatabase.CreateAsset(nodeDef, newPath);
        
        // Save and refresh, but DO NOT select or focus the ProjectWindow.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        Debug.Log($"Created NodeDefinition at: {newPath}");
        // Notice we don't call Selection.activeObject = nodeDef
        // or EditorUtility.FocusProjectWindow()
        // or ProjectWindowUtil.ShowCreatedAsset(nodeDef)
        // thus we avoid changing the user's folder.
    }

    // (Optional) Validate the menu item so it’s disabled if the game is running
    [MenuItem(MenuPath, true)]
    private static bool ValidateCreateNodeDefinition()
    {
        return !Application.isPlaying;
    }

    private static string GetSelectedPathOrFallback()
    {
        // Attempt to get the folder the user has selected in the Project window
        string path = "Assets";
        foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets))
        {
            path = AssetDatabase.GetAssetPath(obj);
            if (!string.IsNullOrEmpty(path))
            {
                // If it's a file, get its parent folder
                if (File.Exists(path))
                {
                    path = Path.GetDirectoryName(path);
                }
                break;
            }
        }
        return path;
    }

    private static int GetNextNodeNumber(string folderPath)
    {
        int nextNumber = 1;
        // Look for existing Node_XXX_ files
        string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
        foreach (var file in files)
        {
            string fName = Path.GetFileNameWithoutExtension(file);
            if (fName.StartsWith("Node_") && fName.Length >= 8)
            {
                // extract the 3-digit number from Node_000_
                string numberPart = fName.Substring(5, 3);
                if (int.TryParse(numberPart, out int num) && num >= nextNumber)
                {
                    nextNumber = num + 1;
                }
            }
        }
        return nextNumber;
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionLibraryEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;

[CustomEditor(typeof(NodeDefinitionLibrary))]
public class NodeDefinitionLibraryEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            UpdateLibrary();
        }
    }

    private void UpdateLibrary()
    {
        NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

        // Get the folder of the current library asset.
        string libraryPath = AssetDatabase.GetAssetPath(library);
        string folderPath = Path.GetDirectoryName(libraryPath);

        // Find all .asset files in the folder.
        string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

        // Load NodeDefinition assets from that folder.
        List<NodeDefinition> defs = new List<NodeDefinition>();
        foreach (string file in assetFiles)
        {
            // Ignore the library asset itself.
            if (file == libraryPath)
                continue;

            NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
            if (def != null)
                defs.Add(def);
        }

        // Sort definitions by the numeric portion in the file name (assumes "Node_XXX_...").
        defs = defs.OrderBy(d => {
            string name = d.name;
            if (name.StartsWith("Node_") && name.Length >= 8)
            {
                string numStr = name.Substring(5, 3);
                if (int.TryParse(numStr, out int num))
                    return num;
            }
            return int.MaxValue; // if no number is found, sort last.
        }).ToList();

        library.definitions = defs;
        EditorUtility.SetDirty(library);
        AssetDatabase.SaveAssets();
        Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionPostprocessor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionPostprocessor : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, 
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string fileName = Path.GetFileNameWithoutExtension(assetPath);
                // Check if file name already starts with "Node_"
                if (!fileName.StartsWith("Node_"))
                {
                    string folderPath = Path.GetDirectoryName(assetPath);
                    // Get all files in folder that start with "Node_"
                    var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
                    int nextNumber = 1;
                    foreach (var file in files)
                    {
                        string fName = Path.GetFileNameWithoutExtension(file);
                        string[] parts = fName.Split('_');
                        if (parts.Length >= 2 && int.TryParse(parts[1], out int num))
                        {
                            if (num >= nextNumber)
                                nextNumber = num + 1;
                        }
                    }
                    string newName = $"Node_{nextNumber:D3}_";
                    AssetDatabase.RenameAsset(assetPath, newName);
                    AssetDatabase.SaveAssets();
                }
            }
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeEffectDataDrawer.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;

[CustomPropertyDrawer(typeof(NodeEffectData))]
public class NodeEffectDataDrawer : PropertyDrawer
{
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        SerializedProperty typeProp        = property.FindPropertyRelative("effectType");
        SerializedProperty valueProp       = property.FindPropertyRelative("effectValue");
        SerializedProperty secondaryProp   = property.FindPropertyRelative("secondaryValue");
        SerializedProperty extra1Prop      = property.FindPropertyRelative("extra1");
        SerializedProperty extra2Prop      = property.FindPropertyRelative("extra2");

        // New ones.
        SerializedProperty leafPatternProp      = property.FindPropertyRelative("leafPattern");
        SerializedProperty growthRandomnessProp = property.FindPropertyRelative("growthRandomness");

        // Draw effectType
        Rect typeRect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);
        EditorGUI.PropertyField(typeRect, typeProp, new GUIContent("Effect Type"));
        NodeEffectType effectType = (NodeEffectType)typeProp.enumValueIndex;
        float yOffset = typeRect.yMax + EditorGUIUtility.standardVerticalSpacing;

        Rect NextLineRect()
        {
            Rect r = new Rect(position.x, yOffset, position.width, EditorGUIUtility.singleLineHeight);
            yOffset += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;
            return r;
        }

        // Draw fields based on effectType
        switch (effectType)
        {
            case NodeEffectType.ManaCost:
            {
                GUIContent content = new GUIContent("Mana Cost", "Amount of mana required to process this node.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.Damage:
            {
                GUIContent content = new GUIContent("Damage", "Damage value contributed by this node.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.Output:
            {
                GUIContent content = new GUIContent("Output", "This node outputs the final chain result (no parameters).");
                Rect line = NextLineRect();
                EditorGUI.LabelField(line, content);
                break;
            }
            case NodeEffectType.Burning:
            {
                // Fire DPS in value, Duration in secondaryValue
                GUIContent contentDps = new GUIContent("Fire DPS", "Damage per second of burning.");
                Rect line1 = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line1, contentDps, valueProp.floatValue);

                GUIContent contentDur = new GUIContent("Duration", "Duration (seconds) of burning effect.");
                Rect line2 = NextLineRect();
                secondaryProp.floatValue = EditorGUI.FloatField(line2, contentDur, secondaryProp.floatValue);
                break;
            }
            case NodeEffectType.AimSpread:
            {
                GUIContent content = new GUIContent("Aim Spread Modifier", "Modifier to add to the wizard's base aim spread.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.Piercing:
            {
                GUIContent content = new GUIContent("Piercing", "Set to 1 for piercing, 0 otherwise.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.FriendlyFire:
            {
                GUIContent content = new GUIContent("Friendly Fire", "Set to 1 for friendly fire, 0 for none.");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
            case NodeEffectType.Seed:
            {
                // Min stem length
                var line1 = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line1,
                    new GUIContent("Min Stem Length", ""), valueProp.floatValue);

                // Max stem length
                var line2 = NextLineRect();
                secondaryProp.floatValue = EditorGUI.FloatField(line2,
                    new GUIContent("Max Stem Length", ""), secondaryProp.floatValue);

                // Growth speed
                var line3 = NextLineRect();
                extra1Prop.floatValue = EditorGUI.FloatField(line3,
                    new GUIContent("Growth Speed (sec)", ""), extra1Prop.floatValue);

                // Leaf gap
                var line4 = NextLineRect();
                extra2Prop.floatValue = EditorGUI.FloatField(line4,
                    new GUIContent("Leaf Gap", ""), extra2Prop.floatValue);

                // Leaf Pattern => 0=Parallel, 1=Alternating
                var line5 = NextLineRect();
                leafPatternProp.intValue = EditorGUI.IntSlider(line5,
                    new GUIContent("Leaf Pattern", "(0=parallel,1=alt)"), leafPatternProp.intValue, 0, 1);

                // Growth Randomness => [0..2]
                var line6 = NextLineRect();
                growthRandomnessProp.floatValue = EditorGUI.Slider(line6,
                    new GUIContent("Growth Randomness", "0=straight, 0.5=random, 0.5=always diagonal"), growthRandomnessProp.floatValue, 0f, 1f);
                break;
            }
            default:
            {
                // Fallback for unrecognized effect
                GUIContent content = new GUIContent("Value", "");
                Rect line = NextLineRect();
                valueProp.floatValue = EditorGUI.FloatField(line, content, valueProp.floatValue);
                break;
            }
        }
    }

    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
    {
        SerializedProperty typeProp = property.FindPropertyRelative("effectType");
        NodeEffectType effectType = (NodeEffectType)typeProp.enumValueIndex;

        float lineHeight = EditorGUIUtility.singleLineHeight;
        float spacing = EditorGUIUtility.standardVerticalSpacing;

        // Start with 1 line for the effectType + spacing
        float totalHeight = lineHeight + spacing;

        switch (effectType)
        {
            case NodeEffectType.ManaCost:
            case NodeEffectType.Damage:
            case NodeEffectType.AimSpread:
            case NodeEffectType.Piercing:
            case NodeEffectType.FriendlyFire:
                // +1 line
                totalHeight += (lineHeight + spacing);
                break;

            case NodeEffectType.Output:
                // +1 line
                totalHeight += (lineHeight + spacing);
                break;

            case NodeEffectType.Burning:
                // +2 lines
                totalHeight += (lineHeight + spacing) * 2;
                break;

            case NodeEffectType.Seed:
                // min length + max length + growth speed + leaf gap + leaf pattern + randomness => 6 lines
                totalHeight += (lineHeight + spacing) * 6;
                break;

            default:
                // fallback +1 line
                totalHeight += (lineHeight + spacing);
                break;
        }
        return totalHeight;
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\WizardControllerStatusEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(WizardController))]
public class WizardControllerStatusEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        WizardController wizard = (WizardController)target;
        EditorGUILayout.Space();
        EditorGUILayout.LabelField("Active Status Effects", EditorStyles.boldLabel);
        if (wizard.activeStatusEffects != null && wizard.activeStatusEffects.Count > 0)
        {
            foreach (var effect in wizard.activeStatusEffects)
            {
                EditorGUILayout.LabelField($"{effect.GetType().Name}: {effect.damagePerSecond} DPS, {effect.duration - effect.Elapsed:F1}s remaining");
            }
        }
        else
        {
            EditorGUILayout.LabelField("None");
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro;

public enum PlantCellType
{
    Seed,
    Stem,
    Leaf,
    Flower,
    Fruit
}

public class PlantGrowth : MonoBehaviour
{
    [Header("Seed Gene Parameters (set via Seed node effect)")]
    public int stemMinLength = 3;            // Minimum stem length (cells)
    public int stemMaxLength = 6;            // Maximum stem length (cells)
    public float growthSpeed = 1f;           // Seconds per growth step
    [Tooltip("Leaf Gap: 0 = leaves on every stem cell; 1 = leaves on every 2nd stem cell; etc.")]
    public int leafGap = 1;
    public int leafPattern = 0;              // 0 = Parallel, 1 = Alternating
    public float growthRandomness = 0f;      // [0..1]: 0=always up; 1=always diagonal

    [Header("Energy System")]
    [Tooltip("Max energy available from all Energy Storage nodes in BFS.")]
    public float maxEnergy = 0f;
    [Tooltip("Current energy accumulated.")]
    public float currentEnergy = 0f;
    [Tooltip("Base photosynthesis rate from Energy Photosynthesis nodes in BFS.")]
    public float basePhotosynthesis = 0f;

    [Header("Cell Prefabs")]
    public GameObject seedCellPrefab;
    public GameObject stemCellPrefab;
    public GameObject leafCellPrefab;

    [Header("Cell Grid Settings")]
    [Tooltip("Distance (in game units) between adjacent cells.")]
    public float cellSpacing = 8f; 

    [Header("UI")]
    [Tooltip("TextMeshProUGUI displaying current energy and max energy below the plant.")]
    public TMP_Text energyText;

    private Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
    private bool growing = true;
    private int currentStemCount = 0;
    private int targetStemLength = 0;
    private bool leftSideNext = true;

    private void Start()
    {
        targetStemLength = Random.Range(stemMinLength, stemMaxLength + 1);
        Debug.Log($"[PlantGrowth] Target stem length: {targetStemLength}");

        cells[new Vector2Int(0, 0)] = PlantCellType.Seed;
        SpawnCellVisual(PlantCellType.Seed, new Vector2Int(0, 0));

        StartCoroutine(GrowRoutine());
    }

    private void Update()
    {
        // Use sunIntensity from WeatherManager.
        float sunlight = (WeatherManager.Instance != null) ? WeatherManager.Instance.sunIntensity : 1f;
        float leafCount = cells.Values.Count(cell => cell == PlantCellType.Leaf);
        float deltaPhotosynthesis = basePhotosynthesis * leafCount * sunlight * Time.deltaTime;
        currentEnergy += deltaPhotosynthesis;
        if (currentEnergy > maxEnergy)
            currentEnergy = maxEnergy;

        if (energyText != null)
        {
            energyText.text = $"Energy: {Mathf.Floor(currentEnergy)}/{Mathf.Floor(maxEnergy)}";
            // Positioning remains as set in the prefab.
        }
    }

    private IEnumerator GrowRoutine()
    {
        Vector2Int currentPos = new Vector2Int(0, 0);
        while (growing)
        {
            yield return new WaitForSeconds(growthSpeed);

            if (currentStemCount < targetStemLength)
            {
                currentStemCount++;
                Vector2Int dir;
                if (currentStemCount == 1)
                {
                    // Always grow directly up for the first stem cell.
                    dir = new Vector2Int(0, 1);
                }
                else
                {
                    dir = GetStemDirection();
                }
                currentPos += dir;
                cells[currentPos] = PlantCellType.Stem;
                SpawnCellVisual(PlantCellType.Stem, currentPos);
                Debug.Log($"[PlantGrowth] Stem grown at {currentPos}");

                if ((currentStemCount % (leafGap + 1)) == 0)
                {
                    Vector2Int baseLeftPos = currentPos + new Vector2Int(-1, 0);
                    Vector2Int baseRightPos = currentPos + new Vector2Int(1, 0);

                    if (leafPattern == 0) // Parallel: spawn both leaves.
                    {
                        SpawnLeafIfEmpty(baseLeftPos);
                        SpawnLeafIfEmpty(baseRightPos);
                        Debug.Log($"[PlantGrowth] Parallel leaves at {baseLeftPos} and {baseRightPos}");
                    }
                    else // Alternating: spawn both but with one side offset.
                    {
                        if (leftSideNext)
                        {
                            Vector2Int leftAlt = baseLeftPos + new Vector2Int(0, 1);
                            SpawnLeafIfEmpty(leftAlt);
                            SpawnLeafIfEmpty(baseRightPos);
                            Debug.Log($"[PlantGrowth] Alternating leaves at {leftAlt} (offset) and {baseRightPos}");
                        }
                        else
                        {
                            Vector2Int rightAlt = baseRightPos + new Vector2Int(0, 1);
                            SpawnLeafIfEmpty(baseLeftPos);
                            SpawnLeafIfEmpty(rightAlt);
                            Debug.Log($"[PlantGrowth] Alternating leaves at {baseLeftPos} and {rightAlt} (offset)");
                        }
                        leftSideNext = !leftSideNext;
                    }
                }
            }
            else
            {
                growing = false;
                Debug.Log("[PlantGrowth] Growth complete.");
            }
        }
    }

    private Vector2Int GetStemDirection()
    {
        Vector2Int up = new Vector2Int(0, 1);
        Vector2Int leftDiag = new Vector2Int(-1, 1);
        Vector2Int rightDiag = new Vector2Int(1, 1);

        float r = Mathf.Clamp01(growthRandomness);
        float roll = Random.value;
        float threshold = 1f - r;  
        if (roll < threshold)
            return up;
        else
            return (Random.value < 0.5f) ? leftDiag : rightDiag;
    }

    private void SpawnLeafIfEmpty(Vector2Int coords)
    {
        if (!cells.ContainsKey(coords))
        {
            cells[coords] = PlantCellType.Leaf;
            SpawnCellVisual(PlantCellType.Leaf, coords);
        }
    }

    private void SpawnCellVisual(PlantCellType cellType, Vector2Int coords)
    {
        Vector2 worldPos = (Vector2)transform.position + (Vector2)coords * cellSpacing;
        GameObject prefabToUse = null;
        switch (cellType)
        {
            case PlantCellType.Seed:
                prefabToUse = seedCellPrefab;
                break;
            case PlantCellType.Stem:
                prefabToUse = stemCellPrefab;
                break;
            case PlantCellType.Leaf:
                prefabToUse = leafCellPrefab;
                break;
        }
        if (prefabToUse != null)
        {
            Instantiate(prefabToUse, worldPos, Quaternion.identity, transform);
        }
        else
        {
            Debug.LogWarning($"[PlantGrowth] No prefab assigned for cell type {cellType}");
        }
    }
}






--------------------------------------------------------------------------------
This is part 1 out of 4 of script collection. 3 more parts remain.
--------------------------------------------------------------------------------