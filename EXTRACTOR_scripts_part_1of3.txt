This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-03-12 11:15:59
PART 1 OF 3
================================================================================

--------------------------------------------------------------------------------
Assets
├── DefaultVolumeProfile.asset
├── InputSystem_Actions.inputactions
├── Prefabs
│   ├── Node Presets
│   │   ├── Definition_DamageNode.asset
│   │   ├── Definition_ManaSource.asset
│   │   ├── Definition_Output.asset
│   │   └── NodeDefinitionLibrary.asset
│   └── UI
│       ├── NodeConnectionView.prefab
│       └── NodeView.prefab
├── Scenes
│   ├── MainScene.unity
│   └── SampleScene.unity
├── Scripts
│   ├── Battle
│   ├── Core
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   ├── NodePort.cs
│   │   │   └── PortDefinition.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   ├── Testing
│   │   └── UI
│   │       ├── NodeConnectionView.cs
│   │       ├── NodeEditorController.cs
│   │       ├── NodeTestInitializer.cs
│   │       ├── NodeView.cs
│   │       └── PinView.cs
│   ├── UI
│   └── Wizards
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Sprites
│   └── MR-Platformer-v1
│       ├── Backgrounds
│       │   ├── merged-full-background.png
│       │   ├── parallax-background-mountains.png
│       │   ├── parallax-background-sky.png
│       │   ├── parallax-forest-trees-01.png
│       │   └── parallax-forest-trees-02.png
│       ├── Enemies
│       │   ├── Enemy-Bat-Fly-32x32.png
│       │   ├── Enemy-Boss-Golem-Idle-48x48.png
│       │   ├── Enemy-Dark-Guard-Idle-39x49.png
│       │   ├── Enemy-Forest-Goblin-Hog-Idle-32x32.png
│       │   ├── Enemy-Forest-Goblin-Idle-32x32.png
│       │   ├── Enemy-Frog-Attack-24x24.png
│       │   ├── Enemy-Frog-Idle-24x24.png
│       │   ├── Enemy-Frog-Tongue-Attack-72x24.png
│       │   ├── Enemy-Mushroom-Walk-24x24.png
│       │   ├── Enemy-Necromancer-Idle-32x32.png
│       │   ├── Enemy-Plant-Mutant-Idle-Attack-46x32.png
│       │   ├── Enemy-Skull-Slime-Idle-32x24.png
│       │   ├── Enemy-Snail-Attack-24x24.png
│       │   └── Enemy-Snail-Walk-24x24.png
│       ├── Misc
│       │   ├── Bridge-Support.png
│       │   ├── Bridge-handle-01.png
│       │   ├── Bridge-handle-02.png
│       │   ├── Bridge.png
│       │   ├── Bush-Background.png
│       │   ├── Bush-Green-Foreground.png
│       │   ├── Bush-Purple-Foreground.png
│       │   ├── Cave-Background-Hole-01.png
│       │   ├── Cave-Background-Rocks-01.png
│       │   ├── Cave-Background-Rocks-02.png
│       │   ├── Cave-Background.png
│       │   ├── Cave-Entrance.png
│       │   ├── Grass-Green-Foreground.png
│       │   ├── Grass-Purple-Foreground.png
│       │   ├── House-01.png
│       │   ├── House-02.png
│       │   ├── House-Background-01.png
│       │   ├── House-Background-02
│       │   ├── Lamp-Off.png
│       │   ├── Lamp-On.png
│       │   └── Mushrooms.png
│       ├── NPC
│       │   ├── NPC-Alchemist-Idle-24x24.png
│       │   ├── NPC-Blacksmith-Idle-48x48.png
│       │   ├── NPC-Builder-01-Working-24x24.png
│       │   ├── NPC-Builder-02-Working-24x24.png
│       │   ├── NPC-Chick-Idle-16x16.png
│       │   ├── NPC-Miner-Idle-24x24.png
│       │   ├── NPC-Old-Shaman-Idle-24x24.png
│       │   ├── NPC-Puppy-Idle-24x24.png
│       │   ├── NPC-Village-Guard-Idle-32x32.png
│       │   ├── NPC-Village-Lady-01-Talk-24x24.png
│       │   └── NPC-Village-Lady-02-Idle-24x24.png
│       ├── Objects
│       │   ├── Obj-Arrow-Idle-12x12.png
│       │   ├── Obj-Arrow-Stuck-12x12.png
│       │   ├── Obj-Axe-Wood.png
│       │   ├── Obj-Barrel.png
│       │   ├── Obj-Big-Wood-Platform-01.png
│       │   ├── Obj-Big-Wood-Platform-02.png
│       │   ├── Obj-Blue-Mineral.png
│       │   ├── Obj-Boxes.png
│       │   ├── Obj-Cage.png
│       │   ├── Obj-Checkpoint-Off.png
│       │   ├── Obj-Checkpoint-On.png
│       │   ├── Obj-Chest-Closed-24x24.png
│       │   ├── Obj-Chest-Opening-24x24.png
│       │   ├── Obj-Crystal-Idle-32x32.png
│       │   ├── Obj-Crystal-Open-32x32.png
│       │   ├── Obj-Dreamcatcher-01.png
│       │   ├── Obj-Dreamcatcher-02.png
│       │   ├── Obj-Dreamcatcher-03.png
│       │   ├── Obj-Fence.png
│       │   ├── Obj-Flag-Hanging-01.png
│       │   ├── Obj-Gate-Hold.png
│       │   ├── Obj-Gate-Pillar.png
│       │   ├── Obj-Green-Mineral.png
│       │   ├── Obj-Hanging-Flag-01.png
│       │   ├── Obj-Hanging-Flag-02.png
│       │   ├── Obj-Hanging-Flag-Medium.png
│       │   ├── Obj-Idol.png
│       │   ├── Obj-Key.png
│       │   ├── Obj-Lamp-On.png
│       │   ├── Obj-Light-01.png
│       │   ├── Obj-Mine-Carriage.png
│       │   ├── Obj-Moving-Platform-Idle-48x28.png
│       │   ├── Obj-Orange-Mineral.png
│       │   ├── Obj-Pickaxe.png
│       │   ├── Obj-Roof-Hanging.png
│       │   ├── Obj-Short-Roof.png
│       │   ├── Obj-Stairs.png
│       │   ├── Obj-Statue.png
│       │   ├── Obj-Village-Gate-Top.png
│       │   ├── Obj-Wood-Pillar-01.png
│       │   ├── Obj-Wood-Platform-01.png
│       │   ├── Obj-Wood-Platform-02.png
│       │   ├── Obj-Wood-Platform-Tall-02.png
│       │   ├── Obj-Wood-Platform-Tall.png
│       │   ├── Obj-Wood-Platform-Top.png
│       │   └── Obj-Wood.png
│       ├── Player
│       │   ├── Player-Attack-24x24.png
│       │   ├── Player-Fall-24x24.png
│       │   ├── Player-Idle-24x24.png
│       │   ├── Player-Jump-24x24.png
│       │   └── Player-Run-24x24.png
│       ├── Tiles
│       │   ├── Cave-Under-Tile.png
│       │   ├── Tile-01.png
│       │   ├── Tile-02.png
│       │   ├── Tile-03.png
│       │   ├── Tile-04.png
│       │   ├── Tile-05.png
│       │   ├── Tile-06.png
│       │   ├── Tile-07.png
│       │   ├── Tile-08.png
│       │   ├── Tile-09.png
│       │   ├── Tile-10.png
│       │   ├── Tile-11.png
│       │   ├── Tile-12.png
│       │   ├── Tile-13.png
│       │   ├── Tile-14.png
│       │   ├── Tile-15.png
│       │   ├── Tile-16.png
│       │   ├── Tile-17.png
│       │   ├── Tile-18.png
│       │   ├── Tile-19.png
│       │   ├── Tile-20.png
│       │   ├── Tile-21.png
│       │   ├── Tile-22.png
│       │   ├── Tile-23.png
│       │   ├── Tile-24.png
│       │   ├── Tile-25.png
│       │   ├── Tile-26.png
│       │   ├── Tile-27.png
│       │   ├── Tile-28.png
│       │   ├── Tile-29.png
│       │   ├── Tile-30.png
│       │   ├── Tile-31.png
│       │   ├── Tile-32.png
│       │   ├── Tile-33.png
│       │   ├── Tile-34.png
│       │   ├── Tile-35.png
│       │   ├── Tile-36.png
│       │   ├── Tile-37.png
│       │   ├── Tree-Trunk-01.png
│       │   └── Tree-Trunk-02.png
│       └── UI
│           ├── Quest-Mark-Idle-16x16.png
│           ├── UI-Boss-Icon.png
│           ├── UI-Lives.png
│           ├── UI-Menu-Button-Active.png
│           ├── UI-Menu-Button-Default.png
│           └── UI-Menu-Popup-Background.png
├── Test
├── TextMesh Pro
│   ├── Examples & Extras
│   │   ├── Fonts
│   │   │   ├── Anton OFL.txt
│   │   │   ├── Anton.ttf
│   │   │   ├── Bangers - OFL.txt
│   │   │   ├── Bangers.ttf
│   │   │   ├── Electronic Highway Sign.TTF
│   │   │   ├── Oswald-Bold - OFL.txt
│   │   │   ├── Oswald-Bold.ttf
│   │   │   ├── Roboto-Bold - AFL.txt
│   │   │   ├── Roboto-Bold - License.txt
│   │   │   ├── Roboto-Bold.ttf
│   │   │   ├── Unity - OFL.txt
│   │   │   └── Unity.ttf
│   │   ├── Materials
│   │   │   ├── Crate - Surface Shader Scene.mat
│   │   │   ├── Crate - URP.mat
│   │   │   ├── Ground - Logo Scene.mat
│   │   │   ├── Ground - Surface Shader Scene.mat
│   │   │   ├── Ground - URP.mat
│   │   │   └── Small Crate_diffuse.mat
│   │   ├── Prefabs
│   │   │   ├── Text Popup.prefab
│   │   │   ├── TextMeshPro - Prefab 1.prefab
│   │   │   └── TextMeshPro - Prefab 2.prefab
│   │   ├── Resources
│   │   │   ├── Color Gradient Presets
│   │   │   │   ├── Blue to Purple - Vertical.asset
│   │   │   │   ├── Dark to Light Green - Vertical.asset
│   │   │   │   ├── Light to Dark Green - Vertical.asset
│   │   │   │   └── Yellow to Orange - Vertical.asset
│   │   │   ├── Fonts & Materials
│   │   │   │   ├── Anton SDF - Drop Shadow.mat
│   │   │   │   ├── Anton SDF - Outline.mat
│   │   │   │   ├── Anton SDF - Sunny Days.mat
│   │   │   │   ├── Anton SDF.asset
│   │   │   │   ├── Bangers SDF - Drop Shadow - 2 Pass.mat
│   │   │   │   ├── Bangers SDF - Drop Shadow.mat
│   │   │   │   ├── Bangers SDF - Outline.mat
│   │   │   │   ├── Bangers SDF Glow.mat
│   │   │   │   ├── Bangers SDF Logo - URP.mat
│   │   │   │   ├── Bangers SDF Logo.mat
│   │   │   │   ├── Bangers SDF.asset
│   │   │   │   ├── Electronic Highway Sign SDF.asset
│   │   │   │   ├── LiberationSans SDF - Metalic Green.mat
│   │   │   │   ├── LiberationSans SDF - Overlay.mat
│   │   │   │   ├── LiberationSans SDF - Soft Mask.mat
│   │   │   │   ├── Oswald Bold SDF.asset
│   │   │   │   ├── Roboto-Bold SDF - Drop Shadow.mat
│   │   │   │   ├── Roboto-Bold SDF - HDRP Unlit.mat
│   │   │   │   ├── Roboto-Bold SDF - Surface.mat
│   │   │   │   ├── Roboto-Bold SDF - URP.mat
│   │   │   │   ├── Roboto-Bold SDF.asset
│   │   │   │   ├── Unity SDF - HDRP LIT - Bloom.mat
│   │   │   │   ├── Unity SDF - HDRP LIT - Outline.mat
│   │   │   │   └── Unity SDF.asset
│   │   │   └── Sprite Assets
│   │   │       ├── Default Sprite Asset.asset
│   │   │       └── DropCap Numbers.asset
│   │   ├── Scenes
│   │   │   ├── 01-  Single Line TextMesh Pro.unity
│   │   │   ├── 02 - Multi-line TextMesh Pro.unity
│   │   │   ├── 03 - Line Justification.unity
│   │   │   ├── 04 - Word Wrapping.unity
│   │   │   ├── 05 - Style Tags.unity
│   │   │   ├── 06 - Extra Rich Text Examples.unity
│   │   │   ├── 07 - Superscript & Subscript Example.unity
│   │   │   ├── 08 - Improved Text Alignment.unity
│   │   │   ├── 09 - Margin Tag Example.unity
│   │   │   ├── 10 - Bullets & Numbered List Example.unity
│   │   │   ├── 11 - The Style Tag.unity
│   │   │   ├── 12 - Link Example.unity
│   │   │   ├── 12a - Text Interactions.unity
│   │   │   ├── 13 - Soft Hyphenation.unity
│   │   │   ├── 14 - Multi Font & Sprites.unity
│   │   │   ├── 15 - Inline Graphics & Sprites.unity
│   │   │   ├── 16 - Linked text overflow mode example.unity
│   │   │   ├── 17 - Old Computer Terminal.unity
│   │   │   ├── 18 - ScrollRect & Masking & Layout.unity
│   │   │   ├── 19 - Masking Texture & Soft Mask.unity
│   │   │   ├── 20 - Input Field with Scrollbar.unity
│   │   │   ├── 21 - Script Example.unity
│   │   │   ├── 22 - Basic Scripting Example.unity
│   │   │   ├── 23 - Animating Vertex Attributes.unity
│   │   │   ├── 24 - Surface Shader Example URP.unity
│   │   │   ├── 24 - Surface Shader Example.unity
│   │   │   ├── 25 - Sunny Days Example.unity
│   │   │   ├── 26 - Dropdown Placeholder Example.unity
│   │   │   ├── 27 - Double Pass Shader Example.unity
│   │   │   ├── 28 - HDRP Shader Example
│   │   │   │   └── Sky and Fog Volume Profile.asset
│   │   │   ├── 28 - HDRP Shader Example.unity
│   │   │   └── Benchmark (Floating Text).unity
│   │   ├── Scripts
│   │   │   ├── Benchmark01.cs
│   │   │   ├── Benchmark01_UGUI.cs
│   │   │   ├── Benchmark02.cs
│   │   │   ├── Benchmark03.cs
│   │   │   ├── Benchmark04.cs
│   │   │   ├── CameraController.cs
│   │   │   ├── ChatController.cs
│   │   │   ├── DropdownSample.cs
│   │   │   ├── EnvMapAnimator.cs
│   │   │   ├── ObjectSpin.cs
│   │   │   ├── ShaderPropAnimator.cs
│   │   │   ├── SimpleScript.cs
│   │   │   ├── SkewTextExample.cs
│   │   │   ├── TMP_DigitValidator.cs
│   │   │   ├── TMP_ExampleScript_01.cs
│   │   │   ├── TMP_FrameRateCounter.cs
│   │   │   ├── TMP_PhoneNumberValidator.cs
│   │   │   ├── TMP_TextEventCheck.cs
│   │   │   ├── TMP_TextEventHandler.cs
│   │   │   ├── TMP_TextInfoDebugTool.cs
│   │   │   ├── TMP_TextSelector_A.cs
│   │   │   ├── TMP_TextSelector_B.cs
│   │   │   ├── TMP_UiFrameRateCounter.cs
│   │   │   ├── TMPro_InstructionOverlay.cs
│   │   │   ├── TeleType.cs
│   │   │   ├── TextConsoleSimulator.cs
│   │   │   ├── TextMeshProFloatingText.cs
│   │   │   ├── TextMeshSpawner.cs
│   │   │   ├── VertexColorCycler.cs
│   │   │   ├── VertexJitter.cs
│   │   │   ├── VertexShakeA.cs
│   │   │   ├── VertexShakeB.cs
│   │   │   ├── VertexZoom.cs
│   │   │   └── WarpTextExample.cs
│   │   ├── Sprites
│   │   │   ├── Default Sprites.png
│   │   │   └── DropCap Numbers.psd
│   │   └── Textures
│   │       ├── Brushed Metal 3.jpg
│   │       ├── Floor Cement.jpg
│   │       ├── Floor Tiles 1 - diffuse.jpg
│   │       ├── Fruit Jelly (B&W).jpg
│   │       ├── Gradient Diagonal (Color).jpg
│   │       ├── Gradient Horizontal (Color).jpg
│   │       ├── Gradient Vertical (Color).jpg
│   │       ├── Mask Zig-n-Zag.psd
│   │       ├── Small Crate_diffuse.jpg
│   │       ├── Small Crate_normal.jpg
│   │       ├── Sunny Days - Seamless.jpg
│   │       ├── Text Overflow - Linked Text Image 1.png
│   │       ├── Text Overflow - Linked Text UI Screenshot.png
│   │       ├── Wipe Pattern - Circle.psd
│   │       ├── Wipe Pattern - Diagonal.psd
│   │       ├── Wipe Pattern - Radial Double.psd
│   │       └── Wipe Pattern - Radial Quad.psd
│   ├── Fonts
│   │   ├── LiberationSans - OFL.txt
│   │   └── LiberationSans.ttf
│   ├── Resources
│   │   ├── Fonts & Materials
│   │   │   ├── LiberationSans SDF - Drop Shadow.mat
│   │   │   ├── LiberationSans SDF - Fallback.asset
│   │   │   ├── LiberationSans SDF - Outline.mat
│   │   │   └── LiberationSans SDF.asset
│   │   ├── LineBreaking Following Characters.txt
│   │   ├── LineBreaking Leading Characters.txt
│   │   ├── Sprite Assets
│   │   │   └── EmojiOne.asset
│   │   ├── Style Sheets
│   │   │   └── Default Style Sheet.asset
│   │   └── TMP Settings.asset
│   ├── Shaders
│   │   ├── SDFFunctions.hlsl
│   │   ├── TMP_Bitmap-Custom-Atlas.shader
│   │   ├── TMP_Bitmap-Mobile.shader
│   │   ├── TMP_Bitmap.shader
│   │   ├── TMP_SDF Overlay.shader
│   │   ├── TMP_SDF SSD.shader
│   │   ├── TMP_SDF-HDRP LIT.shadergraph
│   │   ├── TMP_SDF-HDRP UNLIT.shadergraph
│   │   ├── TMP_SDF-Mobile Masking.shader
│   │   ├── TMP_SDF-Mobile Overlay.shader
│   │   ├── TMP_SDF-Mobile SSD.shader
│   │   ├── TMP_SDF-Mobile-2-Pass.shader
│   │   ├── TMP_SDF-Mobile.shader
│   │   ├── TMP_SDF-Surface-Mobile.shader
│   │   ├── TMP_SDF-Surface.shader
│   │   ├── TMP_SDF-URP Lit.shadergraph
│   │   ├── TMP_SDF-URP Unlit.shadergraph
│   │   ├── TMP_SDF.shader
│   │   ├── TMP_Sprite.shader
│   │   ├── TMPro.cginc
│   │   ├── TMPro_Mobile.cginc
│   │   ├── TMPro_Properties.cginc
│   │   └── TMPro_Surface.cginc
│   └── Sprites
│       ├── EmojiOne Attribution.txt
│       ├── EmojiOne.json
│       └── EmojiOne.png
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public Vector2 editorPosition;

    public List<NodePort> inputs;
    public List<NodePort> outputs;
    public List<NodeEffectData> effects;

    // NEW: Unique mana storage fields for nodes that provide mana.
    public float manaStorageCapacity = 0f;   // Capacity value (if this node is a mana storage node)
    public float currentManaStorage = 0f;      // Current mana stored

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
        inputs = new List<NodePort>();
        outputs = new List<NodePort>();
        effects = new List<NodeEffectData>();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// NodeDefinition.cs (unchanged except for your new effects in the list)
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    public string displayName;
    public Color backgroundColor = Color.gray;
    [TextArea] public string description;

    public List<PortDefinition> ports;
    public List<NodeEffectData> effects = new List<NodeEffectData>();
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿// Assets/Scripts/Nodes/Core/NodeDefinitionLibrary.cs
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    public List<NodeDefinition> definitions;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿// Assets/Scripts/Nodes/Core/NodeEffectData.cs
using System;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;  
    public float effectValue;          // Primary value (for ManaStorage: capacity)
    public float secondaryValue;       // Secondary value (for ManaStorage: starting mana)
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿// Assets/Scripts/Nodes/Core/NodeEffectType.cs
public enum NodeEffectType
{
    ManaCost,
    Damage,
    ManaStorage,      // effectValue = capacity, secondaryValue = starting mana
    ManaRechargeRate,
    Output
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodePort.cs
////////////////////////////////////////////////////////////////////////////////
﻿/* Assets/Scripts/Nodes/Core/NodePort.cs
   Represents a single port on a NodeData (input or output). */

using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodePort
{
    public string portId;
    public string portName;
    public PortType portType;
    public List<string> connectedPortIds;

    public NodePort()
    {
        portId = Guid.NewGuid().ToString();
        connectedPortIds = new List<string>();
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\PortDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// Assets/Scripts/Nodes/Core/PortDefinition.cs
using System;
using UnityEngine;

public enum PortType
{
    General,
    Mana,
    Condition
}

[Serializable]
public class PortDefinition
{
    public string portName;
    public PortType portType;
    public bool isInput;
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro;

public class NodeExecutor : MonoBehaviour
{
    [SerializeField] private NodeGraph currentGraph;

    [Header("Debug Settings")]
    public float waitTimeBetweenNodes = 0.5f; // Pause for step-by-step debug
    public TMP_Text debugOutput; // optional on-screen text

    private void Update()
    {
        // Press SPACE to run the chain
        if (Input.GetKeyDown(KeyCode.Space))
        {
            ExecuteGraph();
        }
    }

    public void SetGraph(NodeGraph graph)
    {
        currentGraph = graph;
    }

    public NodeGraph GetGraph() => currentGraph;

    public void ExecuteGraph()
    {
        if (currentGraph == null || currentGraph.nodes.Count == 0)
        {
            Debug.LogWarning("[NodeExecutor] No graph or no nodes to execute!");
            return;
        }

        StopAllCoroutines();
        StartCoroutine(RunChainCoroutine());
    }

    private IEnumerator RunChainCoroutine()
    {
        ClearDebugOutput();

        // 1) Find an Output node
        var outputNodes = currentGraph.nodes
            .Where(n => n.effects.Any(e => e.effectType == NodeEffectType.Output))
            .ToList();

        if (outputNodes.Count == 0)
        {
            LogDebug("[NodeExecutor] No Output node found. Aborting run.");
            yield break;
        }

        // For simplicity, pick the first output node
        NodeData outputNode = outputNodes[0];

        // 2) Gather all nodes leading to this output (including itself)
        var chain = new List<NodeData>();
        RecursiveGatherUpstream(outputNode, chain);

        if (chain.Count == 0)
        {
            LogDebug("[NodeExecutor] No chain leading to output node. Aborting run.");
            yield break;
        }

        // chain is reversed (output -> up). Let's re-reverse it (start -> ... -> output).
        chain.Reverse();

        LogDebug($"[NodeExecutor] Found {chain.Count} nodes in chain from start to output.");

        // 3) We'll keep track of a "localMana" that can be updated if we encounter a node with ManaStorage
        float localMana = 0f;
        float localCapacity = 0f;
        float totalDamage = 0f;

        // 4) Execute chain in forward order
        foreach (var node in chain)
        {
            yield return new WaitForSeconds(waitTimeBetweenNodes);

            // If this node has a ManaStorage effect, it overrides localMana
            if (node.manaStorageCapacity > 0f)
            {
                localCapacity = node.manaStorageCapacity;
                localMana = node.currentManaStorage;
                LogDebug($"[NodeExecutor] Node '{node.nodeDisplayName}' sets localMana to {localMana}/{localCapacity}");
            }

            // ManaCost
            float manaCost = node.effects
                .Where(e => e.effectType == NodeEffectType.ManaCost)
                .Sum(e => e.effectValue);

            bool canPay = (localMana >= manaCost);
            if (manaCost > 0f && !canPay)
            {
                LogDebug($"[NodeExecutor] Not enough mana for '{node.nodeDisplayName}'. Required {manaCost}, have {localMana}. Skipping node's damage but continuing chain...");
                // We do not stop the chain, just skip applying this node's damage
            }
            else
            {
                // Subtract cost
                localMana -= manaCost;

                // Damage
                float dmg = node.effects
                    .Where(e => e.effectType == NodeEffectType.Damage)
                    .Sum(e => e.effectValue);
                totalDamage += dmg;

                LogDebug($"[NodeExecutor] Node '{node.nodeDisplayName}' executed: cost={manaCost}, damage={dmg}, leftoverMana={localMana}/{localCapacity}");
            }

            // If node has Output effect, we log final result
            bool isOutput = node.effects.Any(e => e.effectType == NodeEffectType.Output);
            if (isOutput)
            {
                LogDebug($"[NodeExecutor] Output node '{node.nodeDisplayName}' reached. FinalDamage={totalDamage}, finalMana={localMana}");
                // Potentially spawn a spell effect here
            }
        }

        LogDebug("[NodeExecutor] Done executing chain.");
    }

    /// <summary>
    /// Recursively gathers all nodes that feed into 'currentNode' (via "General" ports).
    /// Each node is added once to 'chain'.
    /// </summary>
    private void RecursiveGatherUpstream(NodeData currentNode, List<NodeData> chain)
    {
        if (!chain.Contains(currentNode))
            chain.Add(currentNode);

        // For each input port of currentNode
        foreach (var inputPort in currentNode.inputs)
        {
            // If port type != General, skip
            // (Use your enum-based check here)
            if (inputPort.portType != PortType.General)
                continue;

            // Each connectedPortId is from an output port of some other node
            foreach (var connectedId in inputPort.connectedPortIds)
            {
                // Find which node has an output with this ID
                var sourceNode = currentGraph.nodes.FirstOrDefault(n =>
                    n.outputs.Any(o => o.portId == connectedId && o.portType == PortType.General));

                if (sourceNode != null && !chain.Contains(sourceNode))
                {
                    // Recurse upstream
                    RecursiveGatherUpstream(sourceNode, chain);
                }
            }
        }
    }

    private void ClearDebugOutput()
    {
        if (debugOutput) debugOutput.text = "";
    }

    private void LogDebug(string msg)
    {
        Debug.Log(msg);
        if (debugOutput)
        {
            debugOutput.text += msg + "\n";
        }
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿/* Assets/Scripts/Nodes/Runtime/NodeGraph.cs
   Holds a list of NodeData to form a single node graph. */

using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes;

    public NodeGraph()
    {
        nodes = new List<NodeData>();
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeConnectionView.cs
////////////////////////////////////////////////////////////////////////////////
﻿// Assets/Scripts/Nodes/UI/NodeConnectionView.cs
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

[RequireComponent(typeof(RectTransform), typeof(Image))]
public class NodeConnectionView : MonoBehaviour, IPointerClickHandler
{
    [SerializeField] private RectTransform startRect;
    [SerializeField] private RectTransform endRect;

    // Keep track of the source and target pins for easy disconnection.
    public PinView sourcePin;
    public PinView targetPin;

    private RectTransform lineRect;
    private Image lineImage;

    private void Awake()
    {
        lineRect = GetComponent<RectTransform>();
        lineImage = GetComponent<Image>();
    }

    private void Update()
    {
        if (startRect && endRect)
        {
            UpdateLine();
        }
    }

    public void SetStartRect(RectTransform start)
    {
        startRect = start;
    }

    public void SetEndRect(RectTransform end)
    {
        endRect = end;
    }

    public void SetEndPosition(Vector2 localPos, RectTransform parentCanvas)
    {
        if (!endRect)
        {
            GameObject endObj = new GameObject("TempEndRect", typeof(RectTransform));
            endObj.transform.SetParent(parentCanvas);
            endRect = endObj.GetComponent<RectTransform>();
            endRect.sizeDelta = Vector2.zero;
        }
        endRect.anchoredPosition = localPos;
    }

    private void UpdateLine()
    {
        Vector3 startPos = startRect.position;
        Vector3 endPos = endRect.position;
        Vector3 direction = endPos - startPos;
        float distance = direction.magnitude;

        lineRect.position = startPos + direction * 0.5f;
        lineRect.sizeDelta = new Vector2(distance, lineRect.sizeDelta.y);

        float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
        lineRect.rotation = Quaternion.Euler(0f, 0f, angle);
    }

    // ============= Right-Click to Delete the Connection =============
    public void OnPointerClick(PointerEventData eventData)
    {
        // If right-clicked
        if (eventData.button == PointerEventData.InputButton.Right)
        {
            // Remove references from source/target
            if (sourcePin != null && targetPin != null)
            {
                sourcePin.port.connectedPortIds.Remove(targetPin.port.portId);
                // If you store the reverse connection, remove that too
            }

            // Destroy this connection line
            Destroy(gameObject);
        }
    }
}






--------------------------------------------------------------------------------
This is part 1 out of 3 of script collection. 2 more parts remain.
--------------------------------------------------------------------------------