This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-04-01 04:16:33
PART 1 OF 3
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   └── NodeDefinitionPostprocessor.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   └── Animal_Fox.prefab
│   │   ├── Plants
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelFruit.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   └── PlantPrefab.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       └── ThoughtBubble.prefab
│   └── General
│       ├── GardenerPrefab.prefab
│       └── Projectile_Basic_Pixel.prefab
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   └── Animal_000_Bunny.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   └── Nodes Plant
│       ├── NodeDefinitionLibrary.asset
│       ├── Node_000_Seed.asset
│       └── Node_000_Seed_Solo.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   └── ThoughtTrigger.cs
│   │   └── Plants
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── UI
│   └── Visuals
│       └── NightColorPostProcess.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Test
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionAutoAdder.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionAutoAdder : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets,
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string folderPath = Path.GetDirectoryName(assetPath);
                string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
                if (libraryFiles.Length > 0)
                {
                    NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
                    if (library != null && !library.definitions.Contains(nodeDef))
                    {
                        library.definitions.Add(nodeDef);
                        EditorUtility.SetDirty(library);
                        AssetDatabase.SaveAssets();
                    }
                }
            }
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionCreator.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;

public static class NodeDefinitionCreator
{
    private const string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

    [MenuItem(MenuPath, false, 50)]
    public static void CreateNodeDefinition()
    {
        // Figure out which folder the user is in, or use Assets/
        string folder = GetSelectedPathOrFallback();

        // Determine the next numeric index for "Node_XXX_"
        int nextNumber = GetNextNodeNumber(folder);

        // e.g., "Node_007_"
        string newName = $"Node_{nextNumber:D3}_";
        string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

        // Create the NodeDefinition
        NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
        AssetDatabase.CreateAsset(nodeDef, newPath);
        
        // Save and refresh, but DO NOT select or focus the ProjectWindow.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        Debug.Log($"Created NodeDefinition at: {newPath}");
        // Notice we don't call Selection.activeObject = nodeDef
        // or EditorUtility.FocusProjectWindow()
        // or ProjectWindowUtil.ShowCreatedAsset(nodeDef)
        // thus we avoid changing the user's folder.
    }

    // (Optional) Validate the menu item so it’s disabled if the game is running
    [MenuItem(MenuPath, true)]
    private static bool ValidateCreateNodeDefinition()
    {
        return !Application.isPlaying;
    }

    private static string GetSelectedPathOrFallback()
    {
        // Attempt to get the folder the user has selected in the Project window
        string path = "Assets";
        foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets))
        {
            path = AssetDatabase.GetAssetPath(obj);
            if (!string.IsNullOrEmpty(path))
            {
                // If it's a file, get its parent folder
                if (File.Exists(path))
                {
                    path = Path.GetDirectoryName(path);
                }
                break;
            }
        }
        return path;
    }

    private static int GetNextNodeNumber(string folderPath)
    {
        int nextNumber = 1;
        // Look for existing Node_XXX_ files
        string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
        foreach (var file in files)
        {
            string fName = Path.GetFileNameWithoutExtension(file);
            if (fName.StartsWith("Node_") && fName.Length >= 8)
            {
                // extract the 3-digit number from Node_000_
                string numberPart = fName.Substring(5, 3);
                if (int.TryParse(numberPart, out int num) && num >= nextNumber)
                {
                    nextNumber = num + 1;
                }
            }
        }
        return nextNumber;
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(NodeDefinition))]
public class NodeDefinitionEditor : Editor
{
    // Serialized properties for all the fields in NodeDefinition
    SerializedProperty displayName;
    SerializedProperty description;
    SerializedProperty thumbnail;
    SerializedProperty thumbnailTintColor;
    SerializedProperty backgroundColor;
    SerializedProperty nodeViewPrefab;
    SerializedProperty effects;

    private void OnEnable()
    {
        displayName = serializedObject.FindProperty("displayName");
        description = serializedObject.FindProperty("description");
        thumbnail = serializedObject.FindProperty("thumbnail");
        thumbnailTintColor = serializedObject.FindProperty("thumbnailTintColor");
        backgroundColor = serializedObject.FindProperty("backgroundColor");
        nodeViewPrefab = serializedObject.FindProperty("nodeViewPrefab");
        effects = serializedObject.FindProperty("effects");
    }

    public override void OnInspectorGUI()
    {
        serializedObject.Update();

        // "Display" section
        EditorGUILayout.LabelField("Display", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(displayName);
        EditorGUILayout.PropertyField(description);
        EditorGUILayout.PropertyField(thumbnail);
        EditorGUILayout.PropertyField(thumbnailTintColor);
        EditorGUILayout.PropertyField(backgroundColor);

        EditorGUILayout.Space();

        // "Prefab & Effects" section
        EditorGUILayout.LabelField("Prefab & Effects", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(nodeViewPrefab);

        // Draw the effects field with a minimum height
        EditorGUILayout.PropertyField(effects, new GUIContent("Effects"), true, GUILayout.MinHeight(1300f));

        serializedObject.ApplyModifiedProperties();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionLibraryEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;

[CustomEditor(typeof(NodeDefinitionLibrary))]
public class NodeDefinitionLibraryEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            UpdateLibrary();
        }
    }

    private void UpdateLibrary()
    {
        NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

        // Get the folder of the current library asset.
        string libraryPath = AssetDatabase.GetAssetPath(library);
        string folderPath = Path.GetDirectoryName(libraryPath);

        // Find all .asset files in the folder.
        string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

        // Load NodeDefinition assets from that folder.
        List<NodeDefinition> defs = new List<NodeDefinition>();
        foreach (string file in assetFiles)
        {
            // Ignore the library asset itself.
            if (file == libraryPath)
                continue;

            NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
            if (def != null)
                defs.Add(def);
        }

        // Sort definitions by the numeric portion in the file name (assumes "Node_XXX_...").
        defs = defs.OrderBy(d => {
            string name = d.name;
            if (name.StartsWith("Node_") && name.Length >= 8)
            {
                string numStr = name.Substring(5, 3);
                if (int.TryParse(numStr, out int num))
                    return num;
            }
            return int.MaxValue; // if no number is found, sort last.
        }).ToList();

        library.definitions = defs;
        EditorUtility.SetDirty(library);
        AssetDatabase.SaveAssets();
        Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionPostprocessor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionPostprocessor : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, 
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string fileName = Path.GetFileNameWithoutExtension(assetPath);
                // Check if file name already starts with "Node_"
                if (!fileName.StartsWith("Node_"))
                {
                    string folderPath = Path.GetDirectoryName(assetPath);
                    // Get all files in folder that start with "Node_"
                    var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
                    int nextNumber = 1;
                    foreach (var file in files)
                    {
                        string fName = Path.GetFileNameWithoutExtension(file);
                        string[] parts = fName.Split('_');
                        if (parts.Length >= 2 && int.TryParse(parts[1], out int num))
                        {
                            if (num >= nextNumber)
                                nextNumber = num + 1;
                        }
                    }
                    string newName = $"Node_{nextNumber:D3}_";
                    AssetDatabase.RenameAsset(assetPath, newName);
                    AssetDatabase.SaveAssets();
                }
            }
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro; // If using TextMeshPro for UI later

// --- MOVED ENUM DEFINITION OUTSIDE THE CLASS ---
public enum PlantCellType
{
    Seed,
    Stem,
    Leaf,
    Flower, // Added for potential future use
    Fruit   // Added for potential future use
}
// ---------------------------------------------

// Define Plant States
public enum PlantState
{
    Initializing,
    Growing,
    Mature_Idle, // Waiting for cooldown
    Mature_Executing // Running the node chain effects
}

public class PlantGrowth : MonoBehaviour
{
    [Header("Node Graph Data")]
    // This graph will be assigned externally (e.g., by the spawner)
    private NodeGraph nodeGraph;

    [Header("Calculated Runtime Stats")]
    // Growth Stats
    private int finalStemMinLength = 3;
    private int finalStemMaxLength = 6;
    private float finalGrowthSpeed = 1f;
    private int finalLeafGap = 1;
    private int finalLeafPattern = 0;
    private float finalGrowthRandomness = 0f;
    // Energy Stats
    private float finalMaxEnergy = 10f; // Default value if no nodes provide it
    private float finalPhotosynthesisRate = 1f; // Default value
    // Mature Cycle Timing Stats
    private float cycleCooldown = 5.0f; // Default cooldown
    private float nodeCastDelay = 0.1f; // Default cast delay

    [Header("Current State")]
    public PlantState currentState = PlantState.Initializing;
    public float currentEnergy = 0f;
    private float cycleTimer = 0f; // Timer for cooldown

    [Header("Growth Visuals & Logic")]
    [SerializeField] private GameObject seedCellPrefab;
    [SerializeField] private GameObject stemCellPrefab;
    [SerializeField] private GameObject leafCellPrefab;
    [SerializeField] private float cellSpacing = 8f;
    [SerializeField] private TMP_Text energyText; // Optional UI display

    // Use the globally accessible PlantCellType
    private Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
    private int currentStemCount = 0;
    private int targetStemLength = 0;
    private bool? offsetRightForPattern1 = null; // For pattern logic

    // --- Initialization (Called externally AFTER graph is set) ---

    public void InitializeAndGrow(NodeGraph graph)
    {
        if (graph == null || graph.nodes == null)
        {
            Debug.LogError("[PlantGrowth] Cannot initialize with a null NodeGraph!", gameObject);
            Destroy(gameObject); // Destroy self if no graph provided
            return;
        }
        // Store the provided graph (it should be a copy)
        this.nodeGraph = graph;
        currentState = PlantState.Initializing;

        CalculateAndApplyStats();

        // Optional: Update any linked UI Stats Panel here
        // FindObjectOfType<PlantStatsUI>()?.UpdateStats(calculatedStats); // Example

        // Start the growth process if stats are valid
        if (targetStemLength > 0)
        {
             StartGrowthVisuals();
        }
        else
        {
            Debug.LogWarning("[PlantGrowth] Target stem length calculated as 0 or less. Plant will not grow.", gameObject);
            // Transition directly to mature state? Or destroy? For now, just idle.
            currentState = PlantState.Mature_Idle;
            cycleTimer = cycleCooldown; // Start first cooldown
        }
    }

    // --- Stat Calculation (Called once during Initialization) ---

    private void CalculateAndApplyStats()
    {
        if (nodeGraph == null) return;

        // --- Default Values ---
        float accumulatedEnergyStorage = 0f;
        float accumulatedPhotosynthesis = 0f;
        int baseStemMin = 3; // Base default if no nodes modify
        int baseStemMax = 6; // Base default
        float baseGrowthSpeed = 1f;
        int baseLeafGap = 1;
        int baseLeafPattern = 0;
        float baseGrowthRandomness = 0f;
        float baseCooldown = 5.0f;
        float baseCastDelay = 0.1f;
        // Modifiers (can be +/-)
        int stemLengthModifier = 0;
        float growthSpeedModifier = 0f;
        int leafGapModifier = 0;
        float growthRandomnessModifier = 0f;
        float cooldownModifier = 0f;
        float castDelayModifier = 0f;

        bool seedFound = false; // Still useful to check if chain is valid

        // --- Iterate through all nodes and effects ONCE ---
        foreach (NodeData node in nodeGraph.nodes.OrderBy(n => n.orderIndex))
        {
            if (node.effects == null) continue;

            foreach (NodeEffectData effect in node.effects)
            {
                // Use the renamed flag 'isPassive'
                if (!effect.isPassive) continue; // Skip ACTIVE effects for stat calculation

                // --- Apply Passive Effects ---
                switch (effect.effectType)
                {
                    case NodeEffectType.SeedSpawn:
                        seedFound = true;
                        break;
                    case NodeEffectType.EnergyStorage:
                        accumulatedEnergyStorage += effect.primaryValue;
                        break;
                    case NodeEffectType.EnergyPhotosynthesis:
                        accumulatedPhotosynthesis += effect.primaryValue;
                        break;
                    case NodeEffectType.StemLength:
                        stemLengthModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.GrowthSpeed:
                        growthSpeedModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.LeafGap:
                        leafGapModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.LeafPattern:
                        baseLeafPattern = Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.StemRandomness:
                        growthRandomnessModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.Cooldown:
                        cooldownModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.CastDelay:
                        castDelayModifier += effect.primaryValue;
                        break;
                        // Add other passive effects here...
                }
            }
        }

        // --- Finalize Calculated Stats ---
        finalMaxEnergy = Mathf.Max(1f, accumulatedEnergyStorage); // Ensure minimum energy storage
        finalPhotosynthesisRate = Mathf.Max(0f, accumulatedPhotosynthesis); // Can be zero

        finalStemMinLength = Mathf.Max(1, baseStemMin + stemLengthModifier); // Ensure min length is at least 1
        finalStemMaxLength = Mathf.Max(finalStemMinLength, baseStemMax + stemLengthModifier); // Ensure max >= min

        finalGrowthSpeed = Mathf.Max(0.1f, baseGrowthSpeed + growthSpeedModifier); // Prevent too fast/zero speed
        finalLeafGap = Mathf.Max(0, baseLeafGap + leafGapModifier); // Min gap is 0
        finalLeafPattern = Mathf.Clamp(baseLeafPattern, 0, 4); // Assuming 0-4 are valid patterns
        finalGrowthRandomness = Mathf.Clamp01(baseGrowthRandomness + growthRandomnessModifier); // Clamp between 0 and 1

        cycleCooldown = Mathf.Max(0.1f, baseCooldown + cooldownModifier); // Minimum cooldown
        nodeCastDelay = Mathf.Max(0.01f, baseCastDelay + castDelayModifier); // Minimum cast delay

        // Set the target length for the GrowRoutine
        targetStemLength = Random.Range(finalStemMinLength, finalStemMaxLength + 1);

        // --- Log Calculated Stats (Optional) ---
        // Debug.Log($"[PlantGrowth] Calculated Stats for {gameObject.name}:\n" +
        //           $"  Target Stem Length: {targetStemLength} (Range: {finalStemMinLength}-{finalStemMaxLength})\n" +
        //           $"  Growth Speed: {finalGrowthSpeed}\n" +
        //           $"  Leaf Gap: {finalLeafGap}, Pattern: {finalLeafPattern}\n" +
        //           $"  Randomness: {finalGrowthRandomness}\n" +
        //           $"  Max Energy: {finalMaxEnergy}, Photo Rate: {finalPhotosynthesisRate}\n" +
        //           $"  Cycle Cooldown: {cycleCooldown}, Cast Delay: {nodeCastDelay}");

        if (!seedFound)
        {
             Debug.LogWarning("[PlantGrowth] Node chain lacks a passive SeedSpawn effect. Plant will not grow.", gameObject);
             targetStemLength = 0; // Prevent growth if no seed marker
        }
    }

    // --- Start Visual Growth ---
    private void StartGrowthVisuals()
    {
        // Clear previous visuals if any
        foreach (Transform child in transform) { Destroy(child.gameObject); }
        cells.Clear();
        currentStemCount = 0;
        offsetRightForPattern1 = null; // Reset pattern state

        // Spawn Seed
        cells[Vector2Int.zero] = PlantCellType.Seed;
        SpawnCellVisual(PlantCellType.Seed, Vector2Int.zero);

        // Setup sorting
        SortableEntity[] cellEntities = GetComponentsInChildren<SortableEntity>();
        foreach (var cellEntity in cellEntities) {
            if (cellEntity.transform != transform) cellEntity.SetUseParentYCoordinate(true);
        }

        // Start growing coroutine
        currentState = PlantState.Growing;
        StartCoroutine(GrowRoutine());
    }


    // --- Update Loop ---
    private void Update()
    {
        switch (currentState)
        {
            case PlantState.Initializing:
                // Waiting for InitializeAndGrow call
                break;

            case PlantState.Growing:
                UpdateEnergyAndUI(); // Still accumulate energy while growing
                break;

            case PlantState.Mature_Idle:
                UpdateEnergyAndUI();
                cycleTimer -= Time.deltaTime;
                if (cycleTimer <= 0f)
                {
                    // TODO: Add energy cost check if required to start cycle
                    // if (currentEnergy >= cycleStartCost) {
                         currentState = PlantState.Mature_Executing;
                         StartCoroutine(ExecuteMatureCycle());
                    // } else { cycleTimer = cycleCooldown; } // Not enough energy, reset timer
                }
                break;

            case PlantState.Mature_Executing:
                // Coroutine is handling execution, might still update energy
                UpdateEnergyAndUI();
                break;
        }
    }

    private void UpdateEnergyAndUI()
    {
        // Accumulate energy from photosynthesis
        float sunlight = (WeatherManager.Instance != null) ? WeatherManager.Instance.sunIntensity : 1f;
        float leafCount = cells.Values.Count(c => c == PlantCellType.Leaf);
        float deltaPhotosynthesis = finalPhotosynthesisRate * leafCount * sunlight * Time.deltaTime;
        currentEnergy = Mathf.Clamp(currentEnergy + deltaPhotosynthesis, 0f, finalMaxEnergy);

        // Update UI
        if (energyText != null)
        {
            energyText.text = $"{Mathf.Floor(currentEnergy)}/{Mathf.Floor(finalMaxEnergy)}";
        }
    }

    // --- Mature Phase Execution Cycle ---

    private IEnumerator ExecuteMatureCycle()
    {
        // Debug.Log($"[{gameObject.name}] Starting Mature Execution Cycle");
        if (nodeGraph == null || nodeGraph.nodes == null)
        {
             Debug.LogError($"[{gameObject.name}] NodeGraph is missing during mature cycle execution!", gameObject);
             currentState = PlantState.Mature_Idle; // Go back to idle to prevent lockup
             cycleTimer = cycleCooldown; // Reset cooldown
             yield break; // Exit if no graph
        }

        // TODO: Deduct energy cost to start cycle if applicable
        // currentEnergy -= cycleStartCost;

        float damageMultiplier = 1.0f; // Example context, reset each cycle
        // Add other context variables needed by effects (e.g., target position, status flags)

        var sortedNodes = nodeGraph.nodes.OrderBy(n => n.orderIndex).ToList();

        foreach (NodeData node in sortedNodes)
        {
             if (node.effects == null) continue;

             // Check if this node has ANY active phase effects
             // Use the renamed flag 'isPassive'
             bool hasActiveEffect = node.effects.Any(eff => !eff.isPassive);

             if (hasActiveEffect)
             {
                 // Apply cast delay BEFORE executing the active node
                 if (nodeCastDelay > 0)
                 {
                     yield return new WaitForSeconds(nodeCastDelay);
                 }

                 // Execute all ACTIVE effects within this node
                 foreach (NodeEffectData effect in node.effects)
                 {
                     // Use the renamed flag 'isPassive'
                     if (effect.isPassive) continue; // Skip PASSIVE effects

                     // --- Execute Active Effects ---
                     // Debug.Log($"--> Executing Active Effect: {effect.effectType} from Node: {node.nodeDisplayName}");
                     switch (effect.effectType)
                     {
                         case NodeEffectType.Output:
                             // Find potential OutputNodeEffect component on a prefab or handle directly
                             OutputNodeEffect outputEffect = GetComponentInChildren<OutputNodeEffect>(); // Simple search, might need refinement
                             if(outputEffect != null) {
                                outputEffect.Activate(damageMultiplier); // Pass context
                             } else {
                                Debug.LogWarning($"[PlantGrowth] Output effect found on node '{node.nodeDisplayName}' but no OutputNodeEffect component found on plant '{gameObject.name}' or its children.", gameObject);
                             }
                             break;
                         case NodeEffectType.Damage:
                             // Usually modifies context for subsequent Output nodes
                             // damageMultiplier += effect.primaryValue;
                             break;
                          // Add cases for other active effects (Heal, Status, etc.)
                     }
                     // TODO: Add Mana/Energy cost deduction per active effect/node if applicable
                     // currentEnergy -= effectManaCost;
                     // if (currentEnergy < 0) { yield break; } // Stop cycle if out of energy
                 }
             }
             // Else: Node only had passive effects, skip cast delay and execution
        }

        // --- Cycle Complete ---
        // Debug.Log($"[{gameObject.name}] Mature Execution Cycle Complete.");
        cycleTimer = cycleCooldown; // Reset cooldown timer
        currentState = PlantState.Mature_Idle; // Go back to idle state
    }


    // --- Growth Coroutine (Uses calculated stats) ---

    private IEnumerator GrowRoutine()
    {
        Vector2Int currentPos = Vector2Int.zero;
        int spiralDirection = 1;
        int patternCounter = 0;

        while (currentState == PlantState.Growing) // Loop while growing
        {
            // Use calculated growth speed
            yield return new WaitForSeconds(finalGrowthSpeed);

            if (currentStemCount < targetStemLength)
            {
                currentStemCount++;
                Vector2Int dir = (currentStemCount == 1) ? Vector2Int.up : GetStemDirection(); // GetStemDirection uses finalGrowthRandomness
                currentPos += dir;

                // Check if position is already occupied (by leaf from complex pattern?)
                if (!cells.ContainsKey(currentPos)) {
                    cells[currentPos] = PlantCellType.Stem;
                    SpawnCellVisual(PlantCellType.Stem, currentPos);
                } else {
                     // Debug.LogWarning($"[PlantGrowth] Tried to grow Stem into occupied space {currentPos}. Skipping cell.", gameObject);
                     // Optional: Handle overlap logic
                }


                // Use calculated leaf gap and pattern
                if ((finalLeafGap >= 0) && // Ensure gap is valid before modulo
                    (currentStemCount % (finalLeafGap + 1)) == 0)
                {
                    Vector2Int baseLeftPos = currentPos + Vector2Int.left;
                    Vector2Int baseRightPos = currentPos + Vector2Int.right;
                    patternCounter++;

                    // Process according to calculated leaf pattern
                    ExecuteLeafPatternLogic(currentPos, baseLeftPos, baseRightPos, patternCounter, ref spiralDirection);
                }
            }
            else // Growth target reached
            {
                // Debug.Log($"[{gameObject.name}] Growth complete. Reached target stem length: {targetStemLength}. Transitioning to Mature_Idle.", gameObject);
                currentState = PlantState.Mature_Idle;
                cycleTimer = cycleCooldown; // Start the first cooldown timer
                // Exit the coroutine
                yield break;
            }
        }
         // Fallback exit if state changes unexpectedly
         // Debug.Log($"[{gameObject.name}] Exiting GrowRoutine due to state change.");
    }

    // Helper for leaf pattern logic (uses finalLeafPattern)
    private void ExecuteLeafPatternLogic(Vector2Int currentPos, Vector2Int baseLeftPos, Vector2Int baseRightPos, int patternCounter, ref int spiralDirection)
    {
        // This logic remains the same as before, using finalLeafPattern
        switch (finalLeafPattern)
        {
            case 0: // Parallel
                SpawnLeafIfEmpty(baseLeftPos); SpawnLeafIfEmpty(baseRightPos); break;
            case 1: // Offset-Parallel
                if (offsetRightForPattern1 == null) offsetRightForPattern1 = (Random.value < 0.5f);
                Vector2Int raisedLeft = baseLeftPos + Vector2Int.up;
                Vector2Int raisedRight = baseRightPos + Vector2Int.up;
                if (offsetRightForPattern1.Value) { SpawnLeafIfEmpty(baseLeftPos); SpawnLeafIfEmpty(raisedRight); }
                else { SpawnLeafIfEmpty(raisedLeft); SpawnLeafIfEmpty(baseRightPos); }
                break;
            case 2: // Alternating
                 Vector2Int leftPos, rightPos;
                 switch (patternCounter % 4) {
                     case 1: leftPos = baseLeftPos + Vector2Int.up; rightPos = baseRightPos; break;
                     case 2: leftPos = baseLeftPos; rightPos = baseRightPos; break;
                     case 3: leftPos = baseLeftPos; rightPos = baseRightPos + Vector2Int.up; break;
                     case 0: default: leftPos = baseLeftPos; rightPos = baseRightPos; break;
                 }
                 SpawnLeafIfEmpty(leftPos); SpawnLeafIfEmpty(rightPos);
                 break;
            case 3: // Double-Spiral
                 Vector2Int leftSpiral = baseLeftPos + new Vector2Int(0, spiralDirection > 0 ? 1 : 0);
                 Vector2Int rightSpiral = baseRightPos + new Vector2Int(0, spiralDirection > 0 ? 0 : 1);
                 SpawnLeafIfEmpty(leftSpiral); SpawnLeafIfEmpty(rightSpiral);
                 spiralDirection *= -1; // Toggle spiral
                 break;
            case 4: // One-Sided (Right side example)
                 SpawnLeafIfEmpty(baseRightPos); SpawnLeafIfEmpty(baseRightPos + Vector2Int.up); break;
            default: // Fallback
                 SpawnLeafIfEmpty(baseLeftPos); SpawnLeafIfEmpty(baseRightPos); break;
        }
    }

    // Helper for stem direction (uses finalGrowthRandomness)
    private Vector2Int GetStemDirection()
    {
        Vector2Int up = Vector2Int.up;
        Vector2Int leftDiag = new Vector2Int(-1, 1);
        Vector2Int rightDiag = new Vector2Int(1, 1);

        float r = finalGrowthRandomness; // Use calculated value
        if (Random.value < (1f - r)) return up;
        else return (Random.value < 0.5f) ? leftDiag : rightDiag;
    }

    // Helper to spawn leaves (prevent overlap)
    private void SpawnLeafIfEmpty(Vector2Int coords)
    {
        if (!cells.ContainsKey(coords))
        {
            cells[coords] = PlantCellType.Leaf;
            SpawnCellVisual(PlantCellType.Leaf, coords);
        }
        // else: Space occupied, don't spawn leaf
    }

    // Helper to spawn visuals (Uses globally defined PlantCellType)
    private void SpawnCellVisual(PlantCellType cellType, Vector2Int coords)
    {
        Vector2 worldPos = (Vector2)transform.position + (Vector2)coords * cellSpacing;
        GameObject prefabToUse = null;
        switch (cellType) {
            case PlantCellType.Seed: prefabToUse = seedCellPrefab; break;
            case PlantCellType.Stem: prefabToUse = stemCellPrefab; break;
            case PlantCellType.Leaf: prefabToUse = leafCellPrefab; break;
        }
        if (prefabToUse != null) {
            GameObject cellInstance = Instantiate(prefabToUse, worldPos, Quaternion.identity, transform);
            SortableEntity sortableEntity = cellInstance.GetComponent<SortableEntity>() ?? cellInstance.AddComponent<SortableEntity>();
            // Apply sorting only to non-seed parts if needed
            if (cellType != PlantCellType.Seed) {
                sortableEntity.SetUseParentYCoordinate(true);
            }
        } else Debug.LogWarning($"[PlantGrowth] No prefab assigned for cell type {cellType}");
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\WeatherManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class WeatherManager : MonoBehaviour
{
    public static WeatherManager Instance { get; private set; }

    [Header("Day/Night Cycle Settings")]
    public bool dayNightCycleEnabled = true;
    
    [Tooltip("Duration of full day (seconds)")]
    public float dayDuration = 20f;
    [Tooltip("Duration of full night (seconds)")]
    public float nightDuration = 20f;
    [Tooltip("Duration of transitions (seconds)")]
    public float transitionDuration = 5f;

    [Tooltip("Curve that controls the sunIntensity during transitions (X=0 start, X=1 end).")]
    public AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

    [Header("Sunlight Settings")]
    [Range(0f, 1f)]
    public float sunIntensity = 1f;  // 0=night, 1=day

    [Header("Fixed Sunlight When Cycle Off")]
    [Tooltip("If dayNightCycleEnabled is false, we use this fixed intensity.")]
    [Range(0f, 1f)]
    public float fixedSunIntensity = 1f;

    [Header("Sunlight Visualization")]
    public SpriteRenderer fadeSprite;
    public float minAlpha = 0f;
    public float maxAlpha = 1f;

    // Internals
    private enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }
    private CyclePhase currentPhase = CyclePhase.Day;
    private float phaseTimer = 0f; // counts down in each phase
    private float totalPhaseTime = 0f; // length of current phase

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    private void Start()
    {
        // Initialize to Day phase
        EnterPhase(CyclePhase.Day);
    }

    private void Update()
    {
        if (!dayNightCycleEnabled)
        {
            // If the cycle is disabled, just use the fixed sun intensity
            sunIntensity = fixedSunIntensity;
            UpdateFadeSprite();
            return;
        }

        // else dayNightCycle is enabled
        phaseTimer -= Time.deltaTime;
        if (phaseTimer <= 0f)
        {
            // move to next phase
            switch (currentPhase)
            {
                case CyclePhase.Day:
                    EnterPhase(CyclePhase.TransitionToNight);
                    break;
                case CyclePhase.TransitionToNight:
                    EnterPhase(CyclePhase.Night);
                    break;
                case CyclePhase.Night:
                    EnterPhase(CyclePhase.TransitionToDay);
                    break;
                case CyclePhase.TransitionToDay:
                    EnterPhase(CyclePhase.Day);
                    break;
            }
        }
        else
        {
            // while in the current phase, update sunIntensity accordingly
            float progress = 1f - (phaseTimer / totalPhaseTime);
            switch (currentPhase)
            {
                case CyclePhase.Day:
                    // Full day, sunIntensity = 1
                    sunIntensity = 1f;
                    break;
                case CyclePhase.TransitionToNight:
                    // 0..1 => day(1) to night(0) using transitionCurve
                    float tToNight = transitionCurve.Evaluate(progress);
                    sunIntensity = Mathf.Lerp(1f, 0f, tToNight);
                    break;
                case CyclePhase.Night:
                    // Full night, sunIntensity = 0
                    sunIntensity = 0f;
                    break;
                case CyclePhase.TransitionToDay:
                    // 0..1 => night(0) to day(1) using transitionCurve
                    float tToDay = transitionCurve.Evaluate(progress);
                    sunIntensity = Mathf.Lerp(0f, 1f, tToDay);
                    break;
            }
        }

        UpdateFadeSprite();
    }

    private void EnterPhase(CyclePhase nextPhase)
    {
        currentPhase = nextPhase;
        switch (nextPhase)
        {
            case CyclePhase.Day:
                totalPhaseTime = dayDuration;
                break;
            case CyclePhase.Night:
                totalPhaseTime = nightDuration;
                break;
            case CyclePhase.TransitionToNight:
            case CyclePhase.TransitionToDay:
                totalPhaseTime = transitionDuration;
                break;
        }
        phaseTimer = totalPhaseTime;
    }

    private void UpdateFadeSprite()
    {
        if (fadeSprite != null)
        {
            float alpha = Mathf.Lerp(minAlpha, maxAlpha, sunIntensity);
            Color c = fadeSprite.color;
            c.a = alpha;
            fadeSprite.color = c;
        }
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\SpellProjectile.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SpellProjectile : MonoBehaviour
{
    [Header("Projectile Stats")]
    public float damage;
    public float speed;
    [Tooltip("If true, the projectile will be destroyed upon hitting a wizard.")]
    public bool destroyOnHit = true;

    [Header("Burning Effect (optional)")]
    public float burningDamage;   // DPS
    public float burningDuration; // Duration in seconds

    [Header("Friendly Fire")]
    public bool friendlyFire = false;
    public bool casterIsEnemy = false;

    public void Initialize(float dmg, float spd)
    {
        damage = dmg;
        speed = spd;
    }

    private void Update()
    {
        transform.Translate(Vector2.up * speed * Time.deltaTime);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\BurningStatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public class BurningStatusEffect : StatusEffect
{
    public BurningStatusEffect(float d, float dps) : base(d, dps) { }

    
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\StatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public abstract class StatusEffect
{
    public float duration; // Total duration.
    public float damagePerSecond;
    protected float elapsed = 0f;

    // Public property to expose elapsed time.
    public float Elapsed { get { return elapsed; } }

    public StatusEffect(float d, float dps)
    {
        duration = d;
        damagePerSecond = dps;
    }

    public bool IsExpired() => elapsed >= duration;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\SortableEntity.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SortableEntity : MonoBehaviour
{
    [Header("Sorting Configuration")]
    [Tooltip("Offset added to Y position for sorting calculation")]
    [SerializeField] private float sortingLayerYOffset = 0f;

    [Tooltip("Use parent's Y coordinate for sorting")]
    [SerializeField] private bool useParentYCoordinate = false;

    [Tooltip("Debug logging for sorting")]
    public bool debugSorting = false;

    private SpriteRenderer spriteRenderer;

    private void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        // If no SpriteRenderer, try to find one in children
        if (spriteRenderer == null)
            spriteRenderer = GetComponentInChildren<SpriteRenderer>();

        // Ensure sprite renderer exists
        if (spriteRenderer == null)
        {
            Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
        }
    }

    private void Start()
    {
        UpdateSortingOrder();
    }

    private void LateUpdate()
    {
        UpdateSortingOrder();
    }

    public void UpdateSortingOrder()
    {
        if (spriteRenderer == null) return;

        // Determine Y position for sorting
        float yPositionForSorting = useParentYCoordinate && transform.parent != null 
            ? transform.parent.position.y 
            : transform.position.y;

        int sortOrder = CalculateSortOrder(yPositionForSorting);
        spriteRenderer.sortingOrder = sortOrder;

        if (debugSorting)
        {
            Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
        }
    }

    private int CalculateSortOrder(float yPosition)
    {
        // Subtract offset to effectively move the sorting position
        return Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
    }

    // Public method to get current sorting order
    public int GetCurrentSortOrder()
    {
        if (spriteRenderer == null) return 0;
        return spriteRenderer.sortingOrder;
    }

    // Public method to set sorting order directly if needed
    public void SetSortingOrder(int order)
    {
        if (spriteRenderer != null)
            spriteRenderer.sortingOrder = order;
    }

    // Public method to set the parent Y coordinate usage flag
    // This eliminates the need for reflection in other scripts
    public void SetUseParentYCoordinate(bool value)
    {
        useParentYCoordinate = value;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "AnimalDefinition", menuName = "Ecosystem/Animal Definition")]
public class AnimalDefinition : ScriptableObject
{
    [Header("Basic Stats")]
    public string animalName;
    public float maxHealth = 10f;
    public float hungerDecayRate = 0.5f;  // How quickly the animal gets hungry (units/sec)
    public float movementSpeed = 2f;

    [Header("Eating & Satiation")]
    public float hungerThreshold = 5f;    // If hunger > threshold, tries to eat
    public float eatAmount = 5f;         // How much hunger is reduced when it eats a leaf
    public float leafDamage = 1f;        // How much health (or 'life') is removed from a leaf

    [Header("Prefab/Visuals")]
    public GameObject prefab;  // The character prefab to instantiate
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "AnimalLibrary", menuName = "Ecosystem/Animal Library")]
public class AnimalLibrary : ScriptableObject
{
    public List<AnimalDefinition> animals;
}





--------------------------------------------------------------------------------
This is part 1 out of 3 of script collection. 2 more parts remain.
--------------------------------------------------------------------------------