This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-04-01 15:37:58
PART 1 OF 3
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   └── NodeDefinitionPostprocessor.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   └── Animal_Fox.prefab
│   │   ├── Plants
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelFruit.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   └── PlantPrefab.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       └── ThoughtBubble.prefab
│   └── General
│       ├── GardenerPrefab.prefab
│       └── Projectile_Basic_Pixel.prefab
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   └── Animal_000_Bunny.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   └── Nodes Plant
│       ├── NodeDefinitionLibrary.asset
│       └── Node_000_Seed.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   └── ThoughtTrigger.cs
│   │   └── Plants
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── UI
│   └── Visuals
│       └── NightColorPostProcess.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Test
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionAutoAdder.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionAutoAdder : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets,
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string folderPath = Path.GetDirectoryName(assetPath);
                string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
                if (libraryFiles.Length > 0)
                {
                    NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
                    if (library != null && !library.definitions.Contains(nodeDef))
                    {
                        library.definitions.Add(nodeDef);
                        EditorUtility.SetDirty(library);
                        AssetDatabase.SaveAssets();
                    }
                }
            }
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionCreator.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;

public static class NodeDefinitionCreator
{
    private const string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

    [MenuItem(MenuPath, false, 50)]
    public static void CreateNodeDefinition()
    {
        // Figure out which folder the user is in, or use Assets/
        string folder = GetSelectedPathOrFallback();

        // Determine the next numeric index for "Node_XXX_"
        int nextNumber = GetNextNodeNumber(folder);

        // e.g., "Node_007_"
        string newName = $"Node_{nextNumber:D3}_";
        string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

        // Create the NodeDefinition
        NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
        AssetDatabase.CreateAsset(nodeDef, newPath);
        
        // Save and refresh, but DO NOT select or focus the ProjectWindow.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        Debug.Log($"Created NodeDefinition at: {newPath}");
        // Notice we don't call Selection.activeObject = nodeDef
        // or EditorUtility.FocusProjectWindow()
        // or ProjectWindowUtil.ShowCreatedAsset(nodeDef)
        // thus we avoid changing the user's folder.
    }

    // (Optional) Validate the menu item so it’s disabled if the game is running
    [MenuItem(MenuPath, true)]
    private static bool ValidateCreateNodeDefinition()
    {
        return !Application.isPlaying;
    }

    private static string GetSelectedPathOrFallback()
    {
        // Attempt to get the folder the user has selected in the Project window
        string path = "Assets";
        foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets))
        {
            path = AssetDatabase.GetAssetPath(obj);
            if (!string.IsNullOrEmpty(path))
            {
                // If it's a file, get its parent folder
                if (File.Exists(path))
                {
                    path = Path.GetDirectoryName(path);
                }
                break;
            }
        }
        return path;
    }

    private static int GetNextNodeNumber(string folderPath)
    {
        int nextNumber = 1;
        // Look for existing Node_XXX_ files
        string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
        foreach (var file in files)
        {
            string fName = Path.GetFileNameWithoutExtension(file);
            if (fName.StartsWith("Node_") && fName.Length >= 8)
            {
                // extract the 3-digit number from Node_000_
                string numberPart = fName.Substring(5, 3);
                if (int.TryParse(numberPart, out int num) && num >= nextNumber)
                {
                    nextNumber = num + 1;
                }
            }
        }
        return nextNumber;
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(NodeDefinition))]
public class NodeDefinitionEditor : Editor
{
    // Serialized properties for all the fields in NodeDefinition
    SerializedProperty displayName;
    SerializedProperty description;
    SerializedProperty thumbnail;
    SerializedProperty thumbnailTintColor;
    SerializedProperty backgroundColor;
    SerializedProperty nodeViewPrefab;
    SerializedProperty effects;

    private void OnEnable()
    {
        displayName = serializedObject.FindProperty("displayName");
        description = serializedObject.FindProperty("description");
        thumbnail = serializedObject.FindProperty("thumbnail");
        thumbnailTintColor = serializedObject.FindProperty("thumbnailTintColor");
        backgroundColor = serializedObject.FindProperty("backgroundColor");
        nodeViewPrefab = serializedObject.FindProperty("nodeViewPrefab");
        effects = serializedObject.FindProperty("effects");
    }

    public override void OnInspectorGUI()
    {
        serializedObject.Update();

        // "Display" section
        EditorGUILayout.LabelField("Display", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(displayName);
        EditorGUILayout.PropertyField(description);
        EditorGUILayout.PropertyField(thumbnail);
        EditorGUILayout.PropertyField(thumbnailTintColor);
        EditorGUILayout.PropertyField(backgroundColor);

        EditorGUILayout.Space();

        // "Prefab & Effects" section
        EditorGUILayout.LabelField("Prefab & Effects", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(nodeViewPrefab);

        // Draw the effects field with a minimum height
        EditorGUILayout.PropertyField(effects, new GUIContent("Effects"), true, GUILayout.MinHeight(1300f));

        serializedObject.ApplyModifiedProperties();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionLibraryEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;

[CustomEditor(typeof(NodeDefinitionLibrary))]
public class NodeDefinitionLibraryEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            UpdateLibrary();
        }
    }

    private void UpdateLibrary()
    {
        NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

        // Get the folder of the current library asset.
        string libraryPath = AssetDatabase.GetAssetPath(library);
        string folderPath = Path.GetDirectoryName(libraryPath);

        // Find all .asset files in the folder.
        string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

        // Load NodeDefinition assets from that folder.
        List<NodeDefinition> defs = new List<NodeDefinition>();
        foreach (string file in assetFiles)
        {
            // Ignore the library asset itself.
            if (file == libraryPath)
                continue;

            NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
            if (def != null)
                defs.Add(def);
        }

        // Sort definitions by the numeric portion in the file name (assumes "Node_XXX_...").
        defs = defs.OrderBy(d => {
            string name = d.name;
            if (name.StartsWith("Node_") && name.Length >= 8)
            {
                string numStr = name.Substring(5, 3);
                if (int.TryParse(numStr, out int num))
                    return num;
            }
            return int.MaxValue; // if no number is found, sort last.
        }).ToList();

        library.definitions = defs;
        EditorUtility.SetDirty(library);
        AssetDatabase.SaveAssets();
        Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionPostprocessor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionPostprocessor : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, 
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string fileName = Path.GetFileNameWithoutExtension(assetPath);
                // Check if file name already starts with "Node_"
                if (!fileName.StartsWith("Node_"))
                {
                    string folderPath = Path.GetDirectoryName(assetPath);
                    // Get all files in folder that start with "Node_"
                    var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
                    int nextNumber = 1;
                    foreach (var file in files)
                    {
                        string fName = Path.GetFileNameWithoutExtension(file);
                        string[] parts = fName.Split('_');
                        if (parts.Length >= 2 && int.TryParse(parts[1], out int num))
                        {
                            if (num >= nextNumber)
                                nextNumber = num + 1;
                        }
                    }
                    string newName = $"Node_{nextNumber:D3}_";
                    AssetDatabase.RenameAsset(assetPath, newName);
                    AssetDatabase.SaveAssets();
                }
            }
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using TMPro;

public enum PlantCellType
{
    Seed,
    Stem,
    Leaf,
    Flower,
    Fruit
}

public enum PlantState
{
    Initializing,
    Growing,
    Mature_Idle,
    Mature_Executing
}

public class PlantGrowth : MonoBehaviour
{
    [Header("Node Graph Data")]
    private NodeGraph nodeGraph;

    [Header("UI Display Options")]
    [Tooltip("If enabled, shows growth percentage during growth phase instead of energy")]
    [SerializeField] private bool showGrowthPercentage = true;
    
    [Tooltip("If enabled, plant will accumulate energy during growth phase")]
    [SerializeField] private bool allowPhotosynthesisDuringGrowth = false;
    
    [Tooltip("If enabled, shows a smooth percentage counter independent of actual growth")]
    [SerializeField] private bool useSmoothPercentageCounter = true;
    
    [Tooltip("How much to increment the percentage counter each step (%)")]
    [SerializeField] [Range(1, 10)] private int percentageIncrement = 2;

    [Header("Calculated Runtime Stats")]
    // Growth Stats
    private int finalStemMinLength = 3;
    private int finalStemMaxLength = 6;
    private float finalGrowthSpeed = 1f;
    private int finalLeafGap = 1;
    private int finalLeafPattern = 0;
    private float finalGrowthRandomness = 0f;
    // Energy Stats
    private float finalMaxEnergy = 10f;
    private float finalPhotosynthesisRate = 1f;
    // Mature Cycle Timing Stats
    private float cycleCooldown = 5.0f;
    private float nodeCastDelay = 0.1f;

    [Header("Current State")]
    public PlantState currentState = PlantState.Initializing;
    public float currentEnergy = 0f;
    private float cycleTimer = 0f;
    
    // For smooth percentage counter
    private float displayedGrowthPercentage = 0f;
    private Coroutine percentageCounterCoroutine;
    private float totalGrowthDuration;

    [Header("Growth Visuals & Logic")]
    [SerializeField] private GameObject seedCellPrefab;
    [SerializeField] private GameObject stemCellPrefab;
    [SerializeField] private GameObject leafCellPrefab;
    [SerializeField] private float cellSpacing = 8f;
    [SerializeField] private TMP_Text energyText;

    private Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
    private int currentStemCount = 0;
    private int targetStemLength = 0;
    private bool? offsetRightForPattern1 = null;

    private void Awake()
    {
        EnsureUIReferences();
    }

    private void EnsureUIReferences()
    {
        if (energyText != null) return;

        // Try to find by name first
        Transform textTrans = transform.Find("Txt_Energy");
        
        // Try common parent paths if not found directly
        if (textTrans == null) textTrans = transform.Find("Canvas/Txt_Energy");
        if (textTrans == null) textTrans = transform.Find("UI/Txt_Energy");
        
        // If found by name, get the component
        if (textTrans != null)
        {
            energyText = textTrans.GetComponent<TMP_Text>();
            if (energyText != null)
            {
                Debug.Log($"[PlantGrowth] Found Energy Text by name: {textTrans.name}", gameObject);
                return;
            }
        }
        
        // If not found by name, try to find by type
        TMP_Text[] allTexts = GetComponentsInChildren<TMP_Text>(true);
        if (allTexts.Length > 0)
        {
            // Try to find one that might be for energy
            foreach (var text in allTexts)
            {
                string lowerName = text.name.ToLower();
                if (lowerName.Contains("energy") || lowerName.Contains("txt_e"))
                {
                    energyText = text;
                    Debug.Log($"[PlantGrowth] Found Energy Text by component search: {text.name}", gameObject);
                    return;
                }
            }
            
            // If no good match, just use the first one
            energyText = allTexts[0];
            Debug.Log($"[PlantGrowth] Using first TMP_Text found: {energyText.name}", gameObject);
        }
        else
        {
            Debug.LogWarning($"[PlantGrowth] No TMP_Text components found on {gameObject.name}. Energy display will not work.", gameObject);
        }
    }

    public void InitializeAndGrow(NodeGraph graph)
    {
        EnsureUIReferences();
        
        if (graph == null || graph.nodes == null)
        {
            Debug.LogError("[PlantGrowth] Cannot initialize with a null NodeGraph!", gameObject);
            Destroy(gameObject);
            return;
        }
        this.nodeGraph = graph;
        currentState = PlantState.Initializing;
        currentEnergy = 0f; // Reset energy at initialization
        
        // Reset percentage counter
        displayedGrowthPercentage = 0f;
        
        // Stop any existing percentage counter
        if (percentageCounterCoroutine != null)
        {
            StopCoroutine(percentageCounterCoroutine);
            percentageCounterCoroutine = null;
        }

        CalculateAndApplyStats();

        if (targetStemLength > 0)
        {
             StartGrowthVisuals();
        }
        else
        {
            Debug.LogWarning("[PlantGrowth] Target stem length calculated as 0 or less. Plant will not grow.", gameObject);
            currentState = PlantState.Mature_Idle;
            cycleTimer = cycleCooldown;
        }
        
        // Initialize UI based on the current state
        UpdateUI();
    }

    private void CalculateAndApplyStats()
    {
        if (nodeGraph == null) return;

        // --- Default Values ---
        float accumulatedEnergyStorage = 0f;
        float accumulatedPhotosynthesis = 0f;
        int baseStemMin = 3;
        int baseStemMax = 6;
        float baseGrowthSpeed = 1f;
        int baseLeafGap = 1;
        int baseLeafPattern = 0;
        float baseGrowthRandomness = 0f;
        float baseCooldown = 5.0f;
        float baseCastDelay = 0.1f;
        // Modifiers
        int stemLengthModifier = 0;
        float growthSpeedModifier = 0f;
        int leafGapModifier = 0;
        float growthRandomnessModifier = 0f;
        float cooldownModifier = 0f;
        float castDelayModifier = 0f;

        bool seedFound = false;

        foreach (NodeData node in nodeGraph.nodes.OrderBy(n => n.orderIndex))
        {
            if (node.effects == null) continue;

            foreach (NodeEffectData effect in node.effects)
            {
                if (!effect.isPassive) continue;

                switch (effect.effectType)
                {
                    case NodeEffectType.SeedSpawn:
                        seedFound = true;
                        break;
                    case NodeEffectType.EnergyStorage:
                        accumulatedEnergyStorage += effect.primaryValue;
                        break;
                    case NodeEffectType.EnergyPhotosynthesis:
                        accumulatedPhotosynthesis += effect.primaryValue;
                        break;
                    case NodeEffectType.StemLength:
                        stemLengthModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.GrowthSpeed:
                        growthSpeedModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.LeafGap:
                        leafGapModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.LeafPattern:
                        baseLeafPattern = Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.StemRandomness:
                        growthRandomnessModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.Cooldown:
                        cooldownModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.CastDelay:
                        castDelayModifier += effect.primaryValue;
                        break;
                }
            }
        }

        finalMaxEnergy = Mathf.Max(1f, accumulatedEnergyStorage);
        finalPhotosynthesisRate = Mathf.Max(0f, accumulatedPhotosynthesis);

        finalStemMinLength = Mathf.Max(1, baseStemMin + stemLengthModifier);
        finalStemMaxLength = Mathf.Max(finalStemMinLength, baseStemMax + stemLengthModifier);

        finalGrowthSpeed = Mathf.Max(0.1f, baseGrowthSpeed + growthSpeedModifier);
        finalLeafGap = Mathf.Max(0, baseLeafGap + leafGapModifier);
        finalLeafPattern = Mathf.Clamp(baseLeafPattern, 0, 4);
        finalGrowthRandomness = Mathf.Clamp01(baseGrowthRandomness + growthRandomnessModifier);

        cycleCooldown = Mathf.Max(0.1f, baseCooldown + cooldownModifier);
        nodeCastDelay = Mathf.Max(0.01f, baseCastDelay + castDelayModifier);

        targetStemLength = Random.Range(finalStemMinLength, finalStemMaxLength + 1);

        // Calculate total growth duration
        totalGrowthDuration = finalGrowthSpeed * targetStemLength;

        if (!seedFound)
        {
             Debug.LogWarning("[PlantGrowth] Node chain lacks a passive SeedSpawn effect. Plant will not grow.", gameObject);
             targetStemLength = 0;
        }
    }

    private void StartGrowthVisuals()
    {
        foreach (Transform child in transform) { 
            if (child.GetComponent<Canvas>() != null || child.GetComponent<TMP_Text>() != null) continue;
            if (energyText != null && energyText.transform == child) continue;
            
            Destroy(child.gameObject); 
        }
        cells.Clear();
        currentStemCount = 0;
        offsetRightForPattern1 = null;

        cells[Vector2Int.zero] = PlantCellType.Seed;
        SpawnCellVisual(PlantCellType.Seed, Vector2Int.zero);

        SortableEntity[] cellEntities = GetComponentsInChildren<SortableEntity>();
        foreach (var cellEntity in cellEntities) {
            if (cellEntity.transform != transform) cellEntity.SetUseParentYCoordinate(true);
        }

        currentState = PlantState.Growing;
        
        // Start the smooth percentage counter if enabled
        if (useSmoothPercentageCounter && showGrowthPercentage)
        {
            percentageCounterCoroutine = StartCoroutine(PercentageCounterRoutine());
        }
        
        // Start the actual growth routine
        StartCoroutine(GrowRoutine());
    }

    private IEnumerator PercentageCounterRoutine()
    {
        displayedGrowthPercentage = 0;
        UpdateUI();
        
        // Calculate time per percentage increment
        int totalSteps = 100 / percentageIncrement;
        float timePerStep = totalGrowthDuration / totalSteps;
        
        for (int step = 1; step <= totalSteps; step++)
        {
            // Wait the calculated time
            yield return new WaitForSeconds(timePerStep);
            
            // Check if we're still in growing state
            if (currentState != PlantState.Growing)
                break;
            
            // Update the percentage
            displayedGrowthPercentage = step * percentageIncrement;
            displayedGrowthPercentage = Mathf.Min(displayedGrowthPercentage, 100f); // Cap at 100%
            
            // Update the UI
            UpdateUI();
        }
        
        // Ensure we end at exactly 100%
        if (currentState == PlantState.Growing)
        {
            displayedGrowthPercentage = 100f;
            UpdateUI();
        }
    }

    private void Update()
    {
        switch (currentState)
        {
            case PlantState.Initializing:
                // Waiting for InitializeAndGrow call
                break;

            case PlantState.Growing:
                // Optionally accumulate energy during growth based on the flag
                if (allowPhotosynthesisDuringGrowth)
                {
                    AccumulateEnergy();
                    
                    // Only update UI if percentage is not shown (since percentage updates are handled by the counter)
                    if (!showGrowthPercentage)
                    {
                        UpdateUI();
                    }
                }
                break;

            case PlantState.Mature_Idle:
                // Always accumulate energy when mature
                AccumulateEnergy();
                UpdateUI();
                
                cycleTimer -= Time.deltaTime;
                if (cycleTimer <= 0f)
                {
                    currentState = PlantState.Mature_Executing;
                    StartCoroutine(ExecuteMatureCycle());
                }
                break;

            case PlantState.Mature_Executing:
                // Always accumulate energy during execution too
                AccumulateEnergy();
                UpdateUI();
                break;
        }
    }

    // Separated energy accumulation from UI updates
    private void AccumulateEnergy()
    {
        float sunlight = (WeatherManager.Instance != null) ? WeatherManager.Instance.sunIntensity : 1f;
        float leafCount = cells.Values.Count(c => c == PlantCellType.Leaf);
        float deltaPhotosynthesis = finalPhotosynthesisRate * leafCount * sunlight * Time.deltaTime;
        currentEnergy = Mathf.Clamp(currentEnergy + deltaPhotosynthesis, 0f, finalMaxEnergy);
    }

    private void UpdateUI()
    {
        if (energyText == null) EnsureUIReferences();
        if (energyText == null) return;
        
        switch (currentState)
        {
            case PlantState.Growing:
                if (showGrowthPercentage)
                {
                    // During growth phase, show the fixed-step counter if enabled, otherwise show real percentage
                    if (useSmoothPercentageCounter)
                    {
                        // Use the smooth counter value
                        int displayPercentage = Mathf.RoundToInt(displayedGrowthPercentage);
                        energyText.text = $"{displayPercentage}%";
                    }
                    else
                    {
                        // Calculate actual percentage
                        int percentage = targetStemLength <= 0 ? 0 : 
                            Mathf.RoundToInt((float)currentStemCount / targetStemLength * 100f);
                        energyText.text = $"{percentage}%";
                    }
                }
                else
                {
                    // Show energy instead of percentage if that's the preference
                    energyText.text = $"{Mathf.Floor(currentEnergy)}/{Mathf.Floor(finalMaxEnergy)}";
                }
                break;
                
            case PlantState.Mature_Idle:
            case PlantState.Mature_Executing:
                // After growth is complete, always show energy level
                energyText.text = $"{Mathf.Floor(currentEnergy)}/{Mathf.Floor(finalMaxEnergy)}";
                break;
                
            default:
                // Initializing or other states
                energyText.text = "...";
                break;
        }
    }

    private IEnumerator ExecuteMatureCycle()
    {
        if (nodeGraph == null || nodeGraph.nodes == null)
        {
             Debug.LogError($"[{gameObject.name}] NodeGraph is missing during mature cycle execution!", gameObject);
             currentState = PlantState.Mature_Idle;
             cycleTimer = cycleCooldown;
             yield break;
        }

        float damageMultiplier = 1.0f;

        var sortedNodes = nodeGraph.nodes.OrderBy(n => n.orderIndex).ToList();

        foreach (NodeData node in sortedNodes)
        {
             if (node.effects == null) continue;

             bool hasActiveEffect = node.effects.Any(eff => !eff.isPassive);

             if (hasActiveEffect)
             {
                 if (nodeCastDelay > 0)
                 {
                     yield return new WaitForSeconds(nodeCastDelay);
                 }

                 foreach (NodeEffectData effect in node.effects)
                 {
                     if (effect.isPassive) continue;

                     switch (effect.effectType)
                     {
                         case NodeEffectType.Output:
                             OutputNodeEffect outputEffect = GetComponentInChildren<OutputNodeEffect>();
                             if(outputEffect != null) {
                                outputEffect.Activate(damageMultiplier);
                             } else {
                                Debug.LogWarning($"[PlantGrowth] Output effect found on node '{node.nodeDisplayName}' but no OutputNodeEffect component found on plant '{gameObject.name}' or its children.", gameObject);
                             }
                             break;
                         case NodeEffectType.Damage:
                             damageMultiplier += effect.primaryValue;
                             break;
                     }
                 }
             }
        }

        cycleTimer = cycleCooldown;
        currentState = PlantState.Mature_Idle;
    }

    private IEnumerator GrowRoutine()
    {
        Vector2Int currentPos = Vector2Int.zero;
        int spiralDirection = 1;
        int patternCounter = 0;

        while (currentState == PlantState.Growing)
        {
            yield return new WaitForSeconds(finalGrowthSpeed);

            if (currentStemCount < targetStemLength)
            {
                currentStemCount++;
                Vector2Int dir = (currentStemCount == 1) ? Vector2Int.up : GetStemDirection();
                currentPos += dir;

                if (!cells.ContainsKey(currentPos)) {
                    cells[currentPos] = PlantCellType.Stem;
                    SpawnCellVisual(PlantCellType.Stem, currentPos);
                }

                if ((finalLeafGap >= 0) && (currentStemCount % (finalLeafGap + 1)) == 0)
                {
                    Vector2Int baseLeftPos = currentPos + Vector2Int.left;
                    Vector2Int baseRightPos = currentPos + Vector2Int.right;
                    patternCounter++;

                    ExecuteLeafPatternLogic(currentPos, baseLeftPos, baseRightPos, patternCounter, ref spiralDirection);
                }
                
                // Only update UI if we're showing actual percentage or energy
                if (showGrowthPercentage && !useSmoothPercentageCounter)
                {
                    UpdateUI();
                }
                else if (!showGrowthPercentage)
                {
                    UpdateUI();
                }
            }
            else
            {
                Debug.Log($"[{gameObject.name}] Growth complete. Transitioning to Mature_Idle state.");
                
                // Stop the percentage counter coroutine if it's running
                if (percentageCounterCoroutine != null)
                {
                    StopCoroutine(percentageCounterCoroutine);
                    percentageCounterCoroutine = null;
                }
                
                // Make sure percentage shows 100% at the end
                if (showGrowthPercentage)
                {
                    displayedGrowthPercentage = 100f;
                    UpdateUI();
                }
                
                currentState = PlantState.Mature_Idle;
                cycleTimer = cycleCooldown;
                
                // Final UI update to show energy instead of growth percentage
                UpdateUI();
                yield break;
            }
        }
    }

    private void ExecuteLeafPatternLogic(Vector2Int currentPos, Vector2Int baseLeftPos, Vector2Int baseRightPos, int patternCounter, ref int spiralDirection)
    {
        switch (finalLeafPattern)
        {
            case 0: // Parallel
                SpawnLeafIfEmpty(baseLeftPos); SpawnLeafIfEmpty(baseRightPos); break;
            case 1: // Offset-Parallel
                if (offsetRightForPattern1 == null) offsetRightForPattern1 = (Random.value < 0.5f);
                Vector2Int raisedLeft = baseLeftPos + Vector2Int.up;
                Vector2Int raisedRight = baseRightPos + Vector2Int.up;
                if (offsetRightForPattern1.Value) { SpawnLeafIfEmpty(baseLeftPos); SpawnLeafIfEmpty(raisedRight); }
                else { SpawnLeafIfEmpty(raisedLeft); SpawnLeafIfEmpty(baseRightPos); }
                break;
            case 2: // Alternating
                 Vector2Int leftPos, rightPos;
                 switch (patternCounter % 4) {
                     case 1: leftPos = baseLeftPos + Vector2Int.up; rightPos = baseRightPos; break;
                     case 2: leftPos = baseLeftPos; rightPos = baseRightPos; break;
                     case 3: leftPos = baseLeftPos; rightPos = baseRightPos + Vector2Int.up; break;
                     case 0: default: leftPos = baseLeftPos; rightPos = baseRightPos; break;
                 }
                 SpawnLeafIfEmpty(leftPos); SpawnLeafIfEmpty(rightPos);
                 break;
            case 3: // Double-Spiral
                 Vector2Int leftSpiral = baseLeftPos + new Vector2Int(0, spiralDirection > 0 ? 1 : 0);
                 Vector2Int rightSpiral = baseRightPos + new Vector2Int(0, spiralDirection > 0 ? 0 : 1);
                 SpawnLeafIfEmpty(leftSpiral); SpawnLeafIfEmpty(rightSpiral);
                 spiralDirection *= -1; // Toggle spiral
                 break;
            case 4: // One-Sided (Right side example)
                 SpawnLeafIfEmpty(baseRightPos); SpawnLeafIfEmpty(baseRightPos + Vector2Int.up); break;
            default: // Fallback
                 SpawnLeafIfEmpty(baseLeftPos); SpawnLeafIfEmpty(baseRightPos); break;
        }
    }

    private Vector2Int GetStemDirection()
    {
        Vector2Int up = Vector2Int.up;
        Vector2Int leftDiag = new Vector2Int(-1, 1);
        Vector2Int rightDiag = new Vector2Int(1, 1);

        float r = finalGrowthRandomness;
        if (Random.value < (1f - r)) return up;
        else return (Random.value < 0.5f) ? leftDiag : rightDiag;
    }

    private void SpawnLeafIfEmpty(Vector2Int coords)
    {
        if (!cells.ContainsKey(coords))
        {
            cells[coords] = PlantCellType.Leaf;
            SpawnCellVisual(PlantCellType.Leaf, coords);
        }
    }

    private void SpawnCellVisual(PlantCellType cellType, Vector2Int coords)
    {
        Vector2 worldPos = (Vector2)transform.position + (Vector2)coords * cellSpacing;
        GameObject prefabToUse = null;
        switch (cellType) {
            case PlantCellType.Seed: prefabToUse = seedCellPrefab; break;
            case PlantCellType.Stem: prefabToUse = stemCellPrefab; break;
            case PlantCellType.Leaf: prefabToUse = leafCellPrefab; break;
        }
        if (prefabToUse != null) {
            GameObject cellInstance = Instantiate(prefabToUse, worldPos, Quaternion.identity, transform);
            SortableEntity sortableEntity = cellInstance.GetComponent<SortableEntity>() ?? cellInstance.AddComponent<SortableEntity>();
            if (cellType != PlantCellType.Seed) {
                sortableEntity.SetUseParentYCoordinate(true);
            }
        } else Debug.LogWarning($"[PlantGrowth] No prefab assigned for cell type {cellType}");
    }
    
    private void OnDestroy()
    {
        // Ensure coroutines are stopped when object is destroyed
        if (percentageCounterCoroutine != null)
        {
            StopCoroutine(percentageCounterCoroutine);
            percentageCounterCoroutine = null;
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\WeatherManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class WeatherManager : MonoBehaviour
{
    public static WeatherManager Instance { get; private set; }

    [Header("Day/Night Cycle Settings")]
    public bool dayNightCycleEnabled = true;
    
    [Tooltip("Duration of full day (seconds)")]
    public float dayDuration = 20f;
    [Tooltip("Duration of full night (seconds)")]
    public float nightDuration = 20f;
    [Tooltip("Duration of transitions (seconds)")]
    public float transitionDuration = 5f;

    [Tooltip("Curve that controls the sunIntensity during transitions (X=0 start, X=1 end).")]
    public AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

    [Header("Sunlight Settings")]
    [Range(0f, 1f)]
    public float sunIntensity = 1f;  // 0=night, 1=day

    [Header("Fixed Sunlight When Cycle Off")]
    [Tooltip("If dayNightCycleEnabled is false, we use this fixed intensity.")]
    [Range(0f, 1f)]
    public float fixedSunIntensity = 1f;

    [Header("Sunlight Visualization")]
    public SpriteRenderer fadeSprite;
    public float minAlpha = 0f;
    public float maxAlpha = 1f;

    // Internals
    private enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }
    private CyclePhase currentPhase = CyclePhase.Day;
    private float phaseTimer = 0f; // counts down in each phase
    private float totalPhaseTime = 0f; // length of current phase

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    private void Start()
    {
        // Initialize to Day phase
        EnterPhase(CyclePhase.Day);
    }

    private void Update()
    {
        if (!dayNightCycleEnabled)
        {
            // If the cycle is disabled, just use the fixed sun intensity
            sunIntensity = fixedSunIntensity;
            UpdateFadeSprite();
            return;
        }

        // else dayNightCycle is enabled
        phaseTimer -= Time.deltaTime;
        if (phaseTimer <= 0f)
        {
            // move to next phase
            switch (currentPhase)
            {
                case CyclePhase.Day:
                    EnterPhase(CyclePhase.TransitionToNight);
                    break;
                case CyclePhase.TransitionToNight:
                    EnterPhase(CyclePhase.Night);
                    break;
                case CyclePhase.Night:
                    EnterPhase(CyclePhase.TransitionToDay);
                    break;
                case CyclePhase.TransitionToDay:
                    EnterPhase(CyclePhase.Day);
                    break;
            }
        }
        else
        {
            // while in the current phase, update sunIntensity accordingly
            float progress = 1f - (phaseTimer / totalPhaseTime);
            switch (currentPhase)
            {
                case CyclePhase.Day:
                    // Full day, sunIntensity = 1
                    sunIntensity = 1f;
                    break;
                case CyclePhase.TransitionToNight:
                    // 0..1 => day(1) to night(0) using transitionCurve
                    float tToNight = transitionCurve.Evaluate(progress);
                    sunIntensity = Mathf.Lerp(1f, 0f, tToNight);
                    break;
                case CyclePhase.Night:
                    // Full night, sunIntensity = 0
                    sunIntensity = 0f;
                    break;
                case CyclePhase.TransitionToDay:
                    // 0..1 => night(0) to day(1) using transitionCurve
                    float tToDay = transitionCurve.Evaluate(progress);
                    sunIntensity = Mathf.Lerp(0f, 1f, tToDay);
                    break;
            }
        }

        UpdateFadeSprite();
    }

    private void EnterPhase(CyclePhase nextPhase)
    {
        currentPhase = nextPhase;
        switch (nextPhase)
        {
            case CyclePhase.Day:
                totalPhaseTime = dayDuration;
                break;
            case CyclePhase.Night:
                totalPhaseTime = nightDuration;
                break;
            case CyclePhase.TransitionToNight:
            case CyclePhase.TransitionToDay:
                totalPhaseTime = transitionDuration;
                break;
        }
        phaseTimer = totalPhaseTime;
    }

    private void UpdateFadeSprite()
    {
        if (fadeSprite != null)
        {
            float alpha = Mathf.Lerp(minAlpha, maxAlpha, sunIntensity);
            Color c = fadeSprite.color;
            c.a = alpha;
            fadeSprite.color = c;
        }
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\SpellProjectile.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SpellProjectile : MonoBehaviour
{
    [Header("Projectile Stats")]
    public float damage;
    public float speed;
    [Tooltip("If true, the projectile will be destroyed upon hitting a wizard.")]
    public bool destroyOnHit = true;

    [Header("Burning Effect (optional)")]
    public float burningDamage;   // DPS
    public float burningDuration; // Duration in seconds

    [Header("Friendly Fire")]
    public bool friendlyFire = false;
    public bool casterIsEnemy = false;

    public void Initialize(float dmg, float spd)
    {
        damage = dmg;
        speed = spd;
    }

    private void Update()
    {
        transform.Translate(Vector2.up * speed * Time.deltaTime);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\BurningStatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public class BurningStatusEffect : StatusEffect
{
    public BurningStatusEffect(float d, float dps) : base(d, dps) { }

    
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\StatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public abstract class StatusEffect
{
    public float duration; // Total duration.
    public float damagePerSecond;
    protected float elapsed = 0f;

    // Public property to expose elapsed time.
    public float Elapsed { get { return elapsed; } }

    public StatusEffect(float d, float dps)
    {
        duration = d;
        damagePerSecond = dps;
    }

    public bool IsExpired() => elapsed >= duration;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\SortableEntity.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SortableEntity : MonoBehaviour
{
    [Header("Sorting Configuration")]
    [Tooltip("Offset added to Y position for sorting calculation")]
    [SerializeField] private float sortingLayerYOffset = 0f;

    [Tooltip("Use parent's Y coordinate for sorting")]
    [SerializeField] private bool useParentYCoordinate = false;

    [Tooltip("Debug logging for sorting")]
    public bool debugSorting = false;

    private SpriteRenderer spriteRenderer;

    private void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        // If no SpriteRenderer, try to find one in children
        if (spriteRenderer == null)
            spriteRenderer = GetComponentInChildren<SpriteRenderer>();

        // Ensure sprite renderer exists
        if (spriteRenderer == null)
        {
            Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
        }
    }

    private void Start()
    {
        UpdateSortingOrder();
    }

    private void LateUpdate()
    {
        UpdateSortingOrder();
    }

    public void UpdateSortingOrder()
    {
        if (spriteRenderer == null) return;

        // Determine Y position for sorting
        float yPositionForSorting = useParentYCoordinate && transform.parent != null 
            ? transform.parent.position.y 
            : transform.position.y;

        int sortOrder = CalculateSortOrder(yPositionForSorting);
        spriteRenderer.sortingOrder = sortOrder;

        if (debugSorting)
        {
            Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
        }
    }

    private int CalculateSortOrder(float yPosition)
    {
        // Subtract offset to effectively move the sorting position
        return Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
    }

    // Public method to get current sorting order
    public int GetCurrentSortOrder()
    {
        if (spriteRenderer == null) return 0;
        return spriteRenderer.sortingOrder;
    }

    // Public method to set sorting order directly if needed
    public void SetSortingOrder(int order)
    {
        if (spriteRenderer != null)
            spriteRenderer.sortingOrder = order;
    }

    // Public method to set the parent Y coordinate usage flag
    // This eliminates the need for reflection in other scripts
    public void SetUseParentYCoordinate(bool value)
    {
        useParentYCoordinate = value;
    }
}





--------------------------------------------------------------------------------
This is part 1 out of 3 of script collection. 2 more parts remain.
--------------------------------------------------------------------------------