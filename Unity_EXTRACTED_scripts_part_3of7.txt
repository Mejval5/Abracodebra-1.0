This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-05-24 21:05:17
PART 3 OF 7
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantOutline.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           ├── DualGridRuleTile_Grass.asset
│           └── DualGridRuleTile_Water.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_PoopFertilizer.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       ├── Wave_001.asset
│       └── Wave_002.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── LeafData.cs
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.Cell.cs
│   │   │   ├── PlantGrowth.Growth.cs
│   │   │   ├── PlantGrowth.NodeExecution.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── SlowdownZone.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManagement.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── OutlinePartController.cs
│       ├── PlantOutlineController.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       └── ShadowPartController.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   └── SpriteEmissiveUnlit.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FaunaManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/FaunaManager.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class FaunaManager : MonoBehaviour
{
    [Header("Spawning Area (Global)")]
    [SerializeField] private Vector2 spawnCenter = Vector2.zero;
    [SerializeField] private Vector2 spawnAreaSize = new Vector2(20f, 10f);

    [Header("General Settings")]
    [SerializeField] private Transform ecosystemParent;
    [Tooltip("How far INSIDE the screen edge the effective animal movement bounds are.")]
    [SerializeField][Min(0f)] private float screenBoundsPadding = 0.5f;
    [Tooltip("How far OUTSIDE the screen edge the 'Offscreen' spawn area starts.")]
    [SerializeField][Min(0f)] private float offscreenSpawnMargin = 2.0f;

    [Header("Debugging")]
    [Tooltip("Show gizmos visualizing the Margin (Red) and Padding (Green) bounds.")]
    [SerializeField] private bool showBoundsGizmos = false;

    [Header("Functional Bounds Offset")] // <<< UPDATED HEADER NAME
    [Tooltip("Functional horizontal shift for gameplay bounds and spawning relative to camera view.")] // <<< UPDATED TOOLTIP
    [SerializeField][Range(-10f, 10f)] private float boundsOffsetX = 0f; // <<< RENAMED FIELD
    [Tooltip("Functional vertical shift for gameplay bounds and spawning relative to camera view.")] // <<< UPDATED TOOLTIP
    [SerializeField][Range(-10f, 10f)] private float boundsOffsetY = 0f; // <<< RENAMED FIELD

    // --- Runtime State ---
    private List<Coroutine> activeSpawnCoroutines = new List<Coroutine>();
    private Camera mainCamera;

    // --- Start, InitializeManager, Update, ExecuteSpawnWave, StopAllSpawnCoroutines, SpawnWaveEntryCoroutine (Unchanged) ---
    void Start() { InitializeManager(); }
    void InitializeManager() { activeSpawnCoroutines.Clear(); if (WaveManager.Instance != null) { mainCamera = WaveManager.Instance.GetMainCamera(); } if (mainCamera == null) { mainCamera = Camera.main; if (mainCamera == null) Debug.LogError("[FaunaManager] Cannot find Main Camera!", this); } if (ecosystemParent == null) { ecosystemParent = transform; Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned to self.", this); } }
    void Update() { /* ... */ }
    public void ExecuteSpawnWave(WaveDefinition waveDef) { if (waveDef == null) { Debug.LogError("[FaunaManager] ExecuteSpawnWave null WaveDefinition!", this); return; } if (waveDef.spawnEntries == null || waveDef.spawnEntries.Count == 0) { Debug.LogWarning($"[FaunaManager] Wave '{waveDef.waveName}' has no spawn entries.", this); return; } Debug.Log($"[FaunaManager] Executing spawn for Wave: '{waveDef.waveName}'"); foreach (WaveSpawnEntry entry in waveDef.spawnEntries) { if (entry.animalDefinition == null) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', null AnimalDefinition."); continue; } if (entry.spawnCount <= 0) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', Spawn Count <= 0."); continue; } WaveSpawnEntry currentEntry = entry; Coroutine spawnCoroutine = StartCoroutine(SpawnWaveEntryCoroutine(currentEntry)); activeSpawnCoroutines.Add(spawnCoroutine); } Debug.Log($"[FaunaManager] Started {activeSpawnCoroutines.Count} coroutine(s) for '{waveDef.waveName}'."); }
    public void StopAllSpawnCoroutines() { if (activeSpawnCoroutines.Count > 0) { Debug.Log("[FaunaManager] Stopping all spawn coroutines."); foreach (Coroutine co in activeSpawnCoroutines) { if (co != null) StopCoroutine(co); } activeSpawnCoroutines.Clear(); } }
     private IEnumerator SpawnWaveEntryCoroutine(WaveSpawnEntry entry) { if (entry.delayAfterSpawnTime > 0) { yield return new WaitForSeconds(entry.delayAfterSpawnTime); } for (int i = 0; i < entry.spawnCount; i++) { if (WaveManager.Instance != null && !WaveManager.Instance.IsRunActive) { Debug.Log($"[FaunaManager] Halting spawn '{entry.description}', run no longer active."); break; } Vector2 spawnPos = CalculateSpawnPosition(entry.spawnLocationType, entry.spawnRadius); bool isOffscreen = entry.spawnLocationType == WaveSpawnLocationType.Offscreen; GameObject spawnedAnimal = SpawnAnimal(entry.animalDefinition, spawnPos, isOffscreen); if (entry.spawnInterval > 0 && i < entry.spawnCount - 1) { yield return new WaitForSeconds(entry.spawnInterval); } } if (activeSpawnCoroutines.Count > 0) activeSpawnCoroutines.RemoveAt(0); } // Simplistic removal

    /// <summary>
    /// Calculates a spawn position based on the specified type, applying functional offset.
    /// </summary>
    private Vector2 CalculateSpawnPosition(WaveSpawnLocationType locationType, float radius) // <<< MODIFIED
    {
        if (mainCamera == null) { Debug.LogError("[FaunaManager] Missing Main Camera!"); return spawnCenter; }

        // --- Calculate the FUNCTIONAL offset ---
        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        // --- Apply offset to camera position for ALL calculations below ---
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

        Vector2 spawnPos = Vector2.zero;
        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;

        switch (locationType)
        {
            case WaveSpawnLocationType.Offscreen:
                // Use effectiveCamPos for calculations
                float marginMinX = effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin;
                float marginMaxX = effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin;
                float marginMinY = effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin;
                float marginMaxY = effectiveCamPos.y + camHeight / 2f + offscreenSpawnMargin;
                float extraOffset = 0.1f; // To spawn strictly outside the line
                int edge = Random.Range(0, 4);
                if (edge == 0) { spawnPos.x = marginMinX - extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
                else if (edge == 1) { spawnPos.x = marginMaxX + extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
                else if (edge == 2) { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMinY - extraOffset; }
                else { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMaxY + extraOffset; }
                break;

            case WaveSpawnLocationType.RandomNearPlayer:
                 Transform playerT = FindPlayerTransform();
                 if (playerT != null) {
                    // Spawn relative to player, still respecting the overall bounds offset implicitly
                    spawnPos = (Vector2)playerT.position + Random.insideUnitCircle * radius;
                 } else {
                     Debug.LogWarning("[FaunaManager] Player not found for RandomNearPlayer. Falling back to Global.");
                     goto case WaveSpawnLocationType.GlobalSpawnArea; // Fallthrough
                 }
                 break;

            case WaveSpawnLocationType.GlobalSpawnArea:
            default:
                // Use effectiveCamPos OR a fixed world space center? Let's stick to camera relative for now.
                // If you want truly fixed global spawn, use spawnCenter directly.
                // This uses the *shifted* camera center as the basis for the global area.
                spawnPos.x = effectiveCamPos.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
                spawnPos.y = effectiveCamPos.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
                break;
        }
        return spawnPos;
    }

    private Transform FindPlayerTransform()
    {
        Transform pT = null;
        if (WaveManager.Instance != null)
        {
            var pI = FindAnyObjectByType<PlayerTileInteractor>();
            if (pI != null) pT = pI.transform;
        }
        if (pT == null)
        {
            GameObject pO = GameObject.FindGameObjectWithTag("Player");
            if (pO != null) pT = pO.transform;
        }
        return pT;
    }
    
    /// <summary>
    /// Instantiates and initializes an animal, passing SHIFTED screen bounds.
    /// </summary>
    private GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position, bool isOffscreenSpawn) // <<< MODIFIED
    {
        if (definition == null || definition.prefab == null) { /* Error Log */ return null; }
        if (mainCamera == null) { /* Error Log */ return null; }

        // --- Calculate SHIFTED Padded Screen Bounds ---
        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

        Vector2 minPaddedBounds, maxPaddedBounds;
        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;

        minPaddedBounds.x = effectiveCamPos.x - camWidth / 2f + screenBoundsPadding;
        maxPaddedBounds.x = effectiveCamPos.x + camWidth / 2f - screenBoundsPadding;
        minPaddedBounds.y = effectiveCamPos.y - camHeight / 2f + screenBoundsPadding;
        maxPaddedBounds.y = effectiveCamPos.y + camHeight / 2f - screenBoundsPadding;
        // ---------------------------------------------

        GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

        // Parenting (unchanged)
        if (ecosystemParent != null) { Transform sP = ecosystemParent; if (!string.IsNullOrEmpty(definition.animalName)) { sP = ecosystemParent.Find(definition.animalName); if (sP == null) { GameObject subP = new GameObject(definition.animalName); subP.transform.SetParent(ecosystemParent); sP = subP.transform; } } animalObj.transform.SetParent(sP); }

        // Initialize Controller, passing the SHIFTED bounds
        AnimalController controller = animalObj.GetComponent<AnimalController>();
        if (controller != null) {
            controller.Initialize(definition, minPaddedBounds, maxPaddedBounds, isOffscreenSpawn); // Pass shifted bounds
        } else { /* Error Log & Destroy */ Destroy(animalObj); return null; }
        return animalObj;
    }

    /// <summary>
    /// Draws debug rectangles applying the functional offset.
    /// </summary>
    void OnDrawGizmos() // <<< MODIFIED to use offset
    {
        if (!showBoundsGizmos || mainCamera == null) return;

        // --- Apply functional offset for Gizmo drawing ---
        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;
        // --------------------------------------------------

        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;

        // Calculate corners using effectiveCamPos
        Vector2 paddedMin = new Vector2(effectiveCamPos.x - camWidth / 2f + screenBoundsPadding, effectiveCamPos.y - camHeight / 2f + screenBoundsPadding);
        Vector2 paddedMax = new Vector2(effectiveCamPos.x + camWidth / 2f - screenBoundsPadding, effectiveCamPos.y + camHeight / 2f - screenBoundsPadding);
        DrawWireRectangleGizmo(paddedMin, paddedMax, Color.green);

        Vector2 marginMin = new Vector2(effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin, effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin);
        Vector2 marginMax = new Vector2(effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin, effectiveCamPos.y + camHeight / 2f + offscreenSpawnMargin);
        DrawWireRectangleGizmo(marginMin, marginMax, Color.red);
    }

    void DrawWireRectangleGizmo(Vector2 min, Vector2 max, Color color) { /* Unchanged */ Gizmos.color = color; Gizmos.DrawLine(new Vector3(min.x, min.y, 0), new Vector3(max.x, min.y, 0)); Gizmos.DrawLine(new Vector3(max.x, min.y, 0), new Vector3(max.x, max.y, 0)); Gizmos.DrawLine(new Vector3(max.x, max.y, 0), new Vector3(min.x, max.y, 0)); Gizmos.DrawLine(new Vector3(min.x, max.y, 0), new Vector3(min.x, min.y, 0)); }

} // End of class




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FloraManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/FloraManager.cs
using UnityEngine;
using System.Collections.Generic; // Added for Dictionary
#if UNITY_EDITOR
using UnityEditor;
#endif

public class FloraManager : MonoBehaviour
{
    public static FloraManager Instance { get; private set; }

    [Header("Debugging - Scents")]
    [Tooltip("Show scent radii circle renderers in Game View during runtime.")]
    [SerializeField] private bool showScentRadiiRuntime = false;
    [SerializeField] private Color scentRadiusColorRuntime = Color.yellow;
    [SerializeField] private bool logGizmoCalls = false;
    [Space]
    [Tooltip("Prefab used to draw scent circles at runtime.")]
    [SerializeField] private GameObject circleVisualizerPrefab; // <<< ADDED
    [Tooltip("Parent transform for instantiated circle visualizers.")]
    [SerializeField] private Transform circleContainer; // <<< ADDED

    [Header("Debugging - Poop Absorption")] // <<< NEW HEADER
    [Tooltip("Show poop absorption radii circle renderers in Game View during runtime.")]
    [SerializeField] private bool showPoopAbsorptionRadiiRuntime = false;
    [Tooltip("Color of the poop absorption radius visualization.")]
    [SerializeField] private Color poopAbsorptionRadiusColorRuntime = new Color(0.6f, 0.4f, 0.2f, 0.5f); // Brown-ish color

    // --- Public Accessors ---
    public bool ShowScentRadiiRuntime => showScentRadiiRuntime;
    public Color ScentRadiusColorRuntime => scentRadiusColorRuntime;
    // <<< NEW ACCESSORS for poop absorption radius visualization >>>
    public bool ShowPoopAbsorptionRadiiRuntime => showPoopAbsorptionRadiiRuntime;
    public Color PoopAbsorptionRadiusColorRuntime => poopAbsorptionRadiusColorRuntime;

    // Dictionary to track circle visualizers per ScentSource
    private Dictionary<ScentSource, RuntimeCircleDrawer> activeCircleVisualizers = new Dictionary<ScentSource, RuntimeCircleDrawer>();
    // NEW: Dictionary to track poop absorption circle visualizers per PlantGrowth
    private Dictionary<PlantGrowth, RuntimeCircleDrawer> activePoopAbsorptionCircleVisualizers = new Dictionary<PlantGrowth, RuntimeCircleDrawer>();


    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Validate Debug Dependencies
        if (circleVisualizerPrefab == null) { Debug.LogError($"[{nameof(FloraManager)}] Circle Visualizer Prefab is not assigned!", this); }
        if (circleContainer == null) { Debug.LogError($"[{nameof(FloraManager)}] Circle Container transform is not assigned!", this); }
    }

     void Update() // Added Update loop
     {
         if (!Application.isPlaying) return;
         UpdateRuntimeCircleVisualizers();
         // NEW: Update poop absorption radius visualizers
         UpdatePoopAbsorptionCircleVisualizers();
     }

    void OnDestroy()
    {
        if (Instance == this) Instance = null;
        // Clean up any remaining visualizers when manager is destroyed
        foreach (var kvp in activeCircleVisualizers)
        {
            if (kvp.Value != null) Destroy(kvp.Value.gameObject);
        }
        activeCircleVisualizers.Clear();
        
        // NEW: Clean up poop absorption visualizers
        foreach (var kvp in activePoopAbsorptionCircleVisualizers)
        {
            if (kvp.Value != null) Destroy(kvp.Value.gameObject);
        }
        activePoopAbsorptionCircleVisualizers.Clear();
    }
    
    // NEW: Method to update poop absorption radius visualizers
    void UpdatePoopAbsorptionCircleVisualizers()
    {
        if (!Application.isPlaying) return;
        
        // Check if visualization is enabled
        bool showCircles = showPoopAbsorptionRadiiRuntime && circleVisualizerPrefab != null && circleContainer != null;
        
        if (!showCircles)
        {
            // If visualization is disabled, clean up any existing visualizers
            foreach (var kvp in activePoopAbsorptionCircleVisualizers)
            {
                if (kvp.Value != null) Destroy(kvp.Value.gameObject);
            }
            activePoopAbsorptionCircleVisualizers.Clear();
            return;
        }
        
        // Find all plants with the poop fertilizer effect
        PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
        HashSet<PlantGrowth> currentPlantsSet = new HashSet<PlantGrowth>(plants);
        
        // Track plants to remove (no longer exist or don't have the effect)
        List<PlantGrowth> plantsToRemove = new List<PlantGrowth>();
        
        // First, update existing visualizers
        foreach (var kvp in activePoopAbsorptionCircleVisualizers)
        {
            PlantGrowth plant = kvp.Key;
            RuntimeCircleDrawer drawer = kvp.Value;
            
            if (plant == null || drawer == null || !plant.gameObject.activeInHierarchy ||
                !currentPlantsSet.Contains(plant))
            {
                plantsToRemove.Add(plant);
                if (drawer != null) Destroy(drawer.gameObject);
                continue;
            }
            
            // Check if the plant still has a valid poop detection radius
            float poopRadius = GetPlantPoopDetectionRadius(plant);
            bool shouldShowThis = showCircles && poopRadius > 0.01f;
            
            if (shouldShowThis)
            {
                // Update drawer position and radius
                drawer.transform.position = plant.transform.position;
                drawer.UpdateCircle(poopRadius, poopAbsorptionRadiusColorRuntime);
            }
            else
            {
                drawer.HideCircle();
                plantsToRemove.Add(plant); // If radius is too small or zero, remove the visualizer
            }
        }
        
        // Remove plants that no longer need visualization
        foreach (var plant in plantsToRemove)
        {
            if (activePoopAbsorptionCircleVisualizers.TryGetValue(plant, out RuntimeCircleDrawer drawer))
            {
                if (drawer != null) Destroy(drawer.gameObject);
                activePoopAbsorptionCircleVisualizers.Remove(plant);
            }
        }
        
        // Create new visualizers for plants with poop fertilizer effect
        foreach (PlantGrowth plant in plants)
        {
            if (plant == null || activePoopAbsorptionCircleVisualizers.ContainsKey(plant)) continue;
            
            float poopRadius = GetPlantPoopDetectionRadius(plant);
            if (poopRadius <= 0.01f) continue; // Skip if radius is too small
            
            // Create new visualizer
            GameObject circleGO = Instantiate(circleVisualizerPrefab, plant.transform.position, 
                                             Quaternion.identity, circleContainer);
            RuntimeCircleDrawer newDrawer = circleGO.GetComponent<RuntimeCircleDrawer>();
            
            if (newDrawer != null)
            {
                newDrawer.UpdateCircle(poopRadius, poopAbsorptionRadiusColorRuntime);
                activePoopAbsorptionCircleVisualizers.Add(plant, newDrawer);
            }
            else
            {
                Debug.LogError($"Circle Visualizer Prefab '{circleVisualizerPrefab.name}' missing RuntimeCircleDrawer script!", circleVisualizerPrefab);
                Destroy(circleGO);
            }
        }
    }
    
    // NEW: Helper method to get poop detection radius from a plant
    private float GetPlantPoopDetectionRadius(PlantGrowth plant)
    {
        if (plant == null) return 0f;
        return plant.GetPoopDetectionRadius();
    }

    // --- Runtime Visualizer Update ---
    void UpdateRuntimeCircleVisualizers()
    {
        if (!Application.isPlaying) return; // Only run in play mode

        // Check if lines should be shown globally
        bool showCircles = showScentRadiiRuntime && circleVisualizerPrefab != null && circleContainer != null;

        // --- Update existing circles and create new ones ---
        // Use a temporary list to avoid modifying dictionary while iterating
        List<ScentSource> sourcesToRemove = new List<ScentSource>();

        foreach (var kvp in activeCircleVisualizers)
        {
            ScentSource source = kvp.Key;
            RuntimeCircleDrawer line = kvp.Value;

            if (source == null || line == null || !source.gameObject.activeInHierarchy) // Source or drawer destroyed unexpectedly
            {
                sourcesToRemove.Add(source); // Mark for removal
                if(line != null) Destroy(line.gameObject); // Destroy orphan drawer
                continue;
            }

            // Check if circles should be shown globally and if this source is valid
            bool shouldShowThis = showCircles && source.enabled && source.definition != null && source.EffectiveRadius > 0.01f;

            if (shouldShowThis)
            {
                 // Update drawer position to match source and update circle params
                 line.transform.position = source.transform.position;
                 line.transform.rotation = source.transform.rotation; // Match rotation? Optional.
                 line.UpdateCircle(source.EffectiveRadius, scentRadiusColorRuntime);
            }
            else
            {
                 line.HideCircle(); // Hide if shouldn't be shown
            }
        }

        // Remove entries for sources that are gone
        foreach (var source in sourcesToRemove)
        {
            if (activeCircleVisualizers.TryGetValue(source, out RuntimeCircleDrawer drawer) && drawer != null)
                Destroy(drawer.gameObject);
            activeCircleVisualizers.Remove(source);
        }

        // --- Add circles for new sources ---
        if (showCircles)
        {
            // Find all active ScentSources
            ScentSource[] currentSources = FindObjectsByType<ScentSource>(FindObjectsSortMode.None);
            
            foreach (ScentSource source in currentSources)
            {
                // Skip if already has a visualizer or is invalid
                if (source == null || activeCircleVisualizers.ContainsKey(source) || !source.enabled || 
                    source.definition == null || source.EffectiveRadius <= 0.01f) continue;

                 // Create new visualizer
                 GameObject circleGO = Instantiate(circleVisualizerPrefab, source.transform.position, 
                                                 source.transform.rotation, circleContainer);
                 RuntimeCircleDrawer newDrawer = circleGO.GetComponent<RuntimeCircleDrawer>();

                 if (newDrawer != null)
                 {
                      newDrawer.UpdateCircle(source.EffectiveRadius, scentRadiusColorRuntime);
                      activeCircleVisualizers.Add(source, newDrawer); // Add to tracking
                 }
                 else
                 {
                    Debug.LogError($"Circle Visualizer Prefab '{circleVisualizerPrefab.name}' is missing RuntimeCircleDrawer script!", circleVisualizerPrefab);
                    Destroy(circleGO);
                 }
            }
        }
        // --- Hide/Destroy all if global flag turned off ---
        else if (!showCircles && activeCircleVisualizers.Count > 0)
        {
             foreach (var kvp in activeCircleVisualizers)
             {
                 if (kvp.Value != null) Destroy(kvp.Value.gameObject);
             }
             activeCircleVisualizers.Clear();
        }
    }


    // --- Gizmo Drawing (Editor Visualization - Unchanged) ---
    #if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        // Use the runtime flag to ALSO control the editor gizmo
        if (showScentRadiiRuntime) {
             if (logGizmoCalls) { /*...*/ }
             Gizmos.color = scentRadiusColorRuntime; // Use runtime color for gizmo too
             ScentSource[] scentSources = FindObjectsByType<ScentSource>(FindObjectsSortMode.None);
             if (logGizmoCalls) { /*...*/ }
             int drawnCount = 0;
             foreach (ScentSource source in scentSources) {
                if (source == null || !source.enabled || source.definition == null) continue;
                float radius = source.EffectiveRadius;
                if (radius > 0.01f) { Gizmos.DrawWireSphere(source.transform.position, radius); drawnCount++; }
             }
             if (logGizmoCalls && drawnCount > 0) { /*...*/ }
             else if (logGizmoCalls && scentSources.Length > 0) { /*...*/ }
        }
        
        // NEW: Draw poop absorption radius in editor
        if (showPoopAbsorptionRadiiRuntime) {
             Gizmos.color = poopAbsorptionRadiusColorRuntime;
             PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
             int drawnCount = 0;
             
             foreach (PlantGrowth plant in plants) {
                if (plant == null) continue;
                float radius = GetPlantPoopDetectionRadius(plant);
                if (radius > 0.01f) {
                    Gizmos.DrawWireSphere(plant.transform.position, radius);
                    drawnCount++;
                }
             }
             
             if (logGizmoCalls && drawnCount > 0) {
                 Debug.Log($"[FloraManager] Drew {drawnCount} poop absorption radius gizmos");
             }
        }
    }
    #endif
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\PoopController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/PoopController.cs (Ensure Collider is Added)

using UnityEngine;
using TMPro;

[RequireComponent(typeof(Collider2D))] // Add RequireComponent for Collider2D
public class PoopController : MonoBehaviour
{
    [Tooltip("Total lifetime of this poop (in seconds) before disappearing.")]
    public float lifetime = 10f;
    [Tooltip("Duration at the end of the lifetime during which the poop fades out.")]
    public float fadeDuration = 2f;
    [Tooltip("Fadeout curve to control the alpha during fade-out. X axis goes from 0 (start of fade) to 1 (end of fade).")]
    public AnimationCurve fadeCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);

    private SpriteRenderer sr;
    private float timer = 0f;
    private Color initialColor;
    private Collider2D poopCollider; // Reference to the collider

    private void Awake()
    {
        sr = GetComponent<SpriteRenderer>();
        if (sr != null)
        {
            initialColor = sr.color;
        }
        
        // Ensure there's a collider and it's properly configured
        poopCollider = GetComponent<Collider2D>();
        if (poopCollider == null)
        {
            // If no collider exists, add a CircleCollider2D
            poopCollider = gameObject.AddComponent<CircleCollider2D>();
            Debug.Log($"Added CircleCollider2D to {gameObject.name} for poop detection", gameObject);
        }
        
        // Make sure it's a trigger so it doesn't block movement
        poopCollider.isTrigger = true;
    }

    private void Update()
    {
        timer += Time.deltaTime;
        if (timer >= lifetime)
        {
            Destroy(gameObject);
            return;
        }

        // If within fadeDuration at the end, apply fade-out using the fadeCurve.
        float remaining = lifetime - timer;
        if (remaining < fadeDuration && sr != null)
        {
            // Normalize fade time (0 = start, 1 = end)
            float t = 1f - (remaining / fadeDuration);
            float alphaMultiplier = fadeCurve.Evaluate(t);
            Color newColor = initialColor;
            newColor.a = alphaMultiplier;
            sr.color = newColor;
        }
    }

    // Initialize with default parameters if none are provided.
    public void Initialize(float lifetimeValue = -1f, float fadeDurationValue = -1f)
    {
        if (lifetimeValue > 0f)
            lifetime = lifetimeValue;
        if (fadeDurationValue > 0f)
            fadeDuration = fadeDurationValue;
        timer = 0f;
        if (sr != null)
            initialColor = sr.color;
            
        // Ensure collider is configured properly
        if (poopCollider == null)
        {
            poopCollider = GetComponent<Collider2D>();
            if (poopCollider == null)
            {
                poopCollider = gameObject.AddComponent<CircleCollider2D>();
            }
            poopCollider.isTrigger = true;
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ScentSource.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/ScentSource.cs
using UnityEngine;

// No longer requires RuntimeCircleDrawer directly
// REMOVED: [RequireComponent(typeof(RuntimeCircleDrawer))]
public class ScentSource : MonoBehaviour
{
    [Header("Scent Definition")]
    [Tooltip("The base Scent Definition applied to this object.")]
    public ScentDefinition definition; // Assigned by PlantGrowth/Node effects

    [Header("Applied Modifiers")]
    [Tooltip("Bonus radius added by node effects.")]
    public float radiusModifier = 0f;
    [Tooltip("Bonus strength added by node effects.")]
    public float strengthModifier = 0f;

    // REMOVED: Debugging Reference private RuntimeCircleDrawer circleDrawer;

    // --- Calculated Effective Properties ---
    /// <summary> Gets the effective scent radius (Base Radius + Modifier), clamped >= 0. </summary>
    public float EffectiveRadius => Mathf.Max(0f, (definition != null ? definition.baseRadius : 0f) + radiusModifier);
    /// <summary> Gets the effective scent strength (Base Strength + Modifier), clamped >= 0. </summary>
    public float EffectiveStrength => Mathf.Max(0f, (definition != null ? definition.baseStrength : 0f) + strengthModifier);


    void Awake()
    {
        // No longer needs to get or manage the circle drawer component here
        // REMOVED: circleDrawer = GetComponent<RuntimeCircleDrawer>();
        // REMOVED: circleDrawer?.HideCircle();
    }

    // REMOVED: Update() method (FloraManager handles creating/updating/hiding the external visualizer)


    // Keep Gizmo for Editor visualization (runs independently of Update and runtime drawers)
    void OnDrawGizmosSelected()
    {
        float effectiveRadius = EffectiveRadius; // Calculate radius for gizmo

        if (definition != null) // Check if a definition is assigned
        {
            if (effectiveRadius > 0.01f) // Only draw if radius is meaningful
            {
                // Use definition name hash for consistent random color
                // Note: Random.InitState affects the *next* Random call globally,
                // which might be undesirable if other Gizmos rely on it.
                // A more robust way might be a custom color mapping or a simple hash function.
                // For simplicity, we'll keep Random.InitState for now.
                int prevState = Random.state.GetHashCode(); // Store previous state
                Random.InitState(definition.name.GetHashCode());
                Color gizmoColor = Random.ColorHSV(0f, 1f, 0.7f, 0.9f, 0.8f, 1f);
                gizmoColor.a = 0.3f; // Set alpha for gizmo
                Random.InitState(prevState); // Restore previous state

                Gizmos.color = gizmoColor;
                Gizmos.DrawWireSphere(transform.position, effectiveRadius);
            }
        }
        else // Draw default gray if no definition assigned yet
        {
            Gizmos.color = new Color(0.8f, 0.8f, 0.8f, 0.2f);
            Gizmos.DrawWireSphere(transform.position, 1f); // Default size for editor only
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\SlowdownZone.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

public class SlowdownZone : MonoBehaviour
{
    [Header("Slowdown Settings")]
    [Tooltip("How much to multiply movement speed by (0.5 = half speed)")]
    [Range(0.1f, 1.0f)]
    public float speedMultiplier = 0.5f;
    
    [Header("Collider Adjustment")]
    [Tooltip("How much to shrink the collider from its edges (in units)")]
    [Range(0f, 1f)]
    public float colliderShrinkAmount = 0.2f;
    
    [Header("Debug")]
    [SerializeField] private bool showDebugMessages = false;
    
    // Keep track of entities currently affected
    private Dictionary<int, AnimalController> affectedAnimals = new Dictionary<int, AnimalController>();
    private Dictionary<int, GardenerController> affectedPlayers = new Dictionary<int, GardenerController>();
    
    // Original collider properties (for shrinking)
    private Vector2 originalSize;
    private Vector2 originalOffset;
    private BoxCollider2D boxCollider;
    
    private void Awake()
    {
        // Get the collider and ensure it's a trigger
        Collider2D col = GetComponent<Collider2D>();
        if (col == null)
        {
            Debug.LogError($"SlowdownZone on '{gameObject.name}' requires a Collider2D component!", gameObject);
            enabled = false;
            return;
        }
        
        if (!col.isTrigger)
        {
            col.isTrigger = true;
            Debug.Log($"SlowdownZone on '{gameObject.name}' automatically enabled isTrigger on its collider.");
        }
        
        // Store original size for BoxCollider2D
        boxCollider = col as BoxCollider2D;
        if (boxCollider != null)
        {
            originalSize = boxCollider.size;
            originalOffset = boxCollider.offset;
            
            // Apply shrinking
            if (colliderShrinkAmount > 0)
            {
                ShrinkCollider();
            }
        }
        else
        {
            // If it's not a BoxCollider2D, log a warning
            Debug.LogWarning($"SlowdownZone on '{gameObject.name}' is using a collider type other than BoxCollider2D. " +
                             "Collider shrinking will not work.", gameObject);
        }
    }
    
    private void ShrinkCollider()
    {
        if (boxCollider == null) return;
        
        // Calculate new size by subtracting shrink amount from both dimensions
        Vector2 newSize = new Vector2(
            Mathf.Max(0.1f, originalSize.x - (colliderShrinkAmount * 2f)),
            Mathf.Max(0.1f, originalSize.y - (colliderShrinkAmount * 2f))
        );
        
        // Apply the new size
        boxCollider.size = newSize;
        
        if (showDebugMessages)
        {
            Debug.Log($"SlowdownZone: Shrunk collider from {originalSize} to {newSize}");
        }
    }
    
    private void OnValidate()
    {
        // Update collider size when values change in inspector
        if (Application.isPlaying && boxCollider != null)
        {
            ShrinkCollider();
        }
    }
    
    private void OnTriggerEnter2D(Collider2D other)
    {
        // Check if it's an animal
        AnimalController animal = other.GetComponent<AnimalController>();
        if (animal != null)
        {
            // Add to affected list
            int id = animal.GetInstanceID();
            affectedAnimals[id] = animal;
            
            // Apply slowdown effect
            animal.ApplySpeedMultiplier(speedMultiplier);
            
            if (showDebugMessages)
                Debug.Log($"SlowdownZone: '{animal.name}' entered zone, applied multiplier {speedMultiplier}");
            
            return; // Skip further checks if it's an animal
        }
        
        // Check if it's the player (gardener)
        GardenerController player = other.GetComponent<GardenerController>();
        if (player != null)
        {
            // Add to affected list
            int id = player.GetInstanceID();
            affectedPlayers[id] = player;
            
            // Apply slowdown effect
            player.ApplySpeedMultiplier(speedMultiplier);
            
            if (showDebugMessages)
                Debug.Log($"SlowdownZone: Player '{player.name}' entered zone, applied multiplier {speedMultiplier}");
        }
    }
    
    private void OnTriggerExit2D(Collider2D other)
    {
        // Check if it's an animal
        AnimalController animal = other.GetComponent<AnimalController>();
        if (animal != null)
        {
            // Remove from affected list
            int id = animal.GetInstanceID();
            if (affectedAnimals.ContainsKey(id))
            {
                affectedAnimals.Remove(id);
                
                // Remove slowdown effect
                animal.RemoveSpeedMultiplier(speedMultiplier);
                
                if (showDebugMessages)
                    Debug.Log($"SlowdownZone: '{animal.name}' exited zone, removed multiplier");
            }
            
            return; // Skip further checks if it's an animal
        }
        
        // Check if it's the player (gardener)
        GardenerController player = other.GetComponent<GardenerController>();
        if (player != null)
        {
            // Remove from affected list
            int id = player.GetInstanceID();
            if (affectedPlayers.ContainsKey(id))
            {
                affectedPlayers.Remove(id);
                
                // Remove slowdown effect
                player.RemoveSpeedMultiplier(speedMultiplier);
                
                if (showDebugMessages)
                    Debug.Log($"SlowdownZone: Player '{player.name}' exited zone, removed multiplier");
            }
        }
    }
    
    // Clean up when destroyed
    private void OnDestroy()
    {
        // Remove effects from all affected animals
        foreach (var animal in affectedAnimals.Values)
        {
            if (animal != null)
            {
                animal.RemoveSpeedMultiplier(speedMultiplier);
            }
        }
        affectedAnimals.Clear();
        
        // Remove effects from all affected players
        foreach (var player in affectedPlayers.Values)
        {
            if (player != null)
            {
                player.RemoveSpeedMultiplier(speedMultiplier);
            }
        }
        affectedPlayers.Clear();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtBubbleController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class ThoughtBubbleController : MonoBehaviour
{
    public TMP_Text messageText;
    public float lifetime = 2f;

    private Transform followTarget;

    public void Initialize(string message, Transform target, float duration = 2f)
    {
        if (messageText != null)
            messageText.text = message;
        followTarget = target;
        lifetime = duration;
    }

    private void Update()
    {
        lifetime -= Time.deltaTime;
        if (lifetime <= 0f)
            Destroy(gameObject);

        // Follow the target if needed (optional if already a child)
        if (followTarget != null)
        {
            transform.position = followTarget.position;
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtTrigger.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public enum ThoughtTrigger
{
    Hungry,
    Eating,
    HealthLow,
    Fleeing,
    Pooping,
    // Add more triggers as needed
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\WaveDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/WaveDefinition.cs
using UnityEngine;
using System.Collections.Generic;

// Enum WaveSpawnLocationType remains the same
public enum WaveSpawnLocationType
{
    GlobalSpawnArea,
    RandomNearPlayer,
    Offscreen
}

// Class WaveSpawnEntry remains the same
[System.Serializable]
public class WaveSpawnEntry
{
    [Tooltip("Optional description for this specific spawn group within the wave.")]
    public string description = "Spawn Group";
    [Tooltip("The type of animal to spawn.")]
    public AnimalDefinition animalDefinition;
    [Tooltip("How many of this animal to spawn in this specific entry.")]
    [Min(1)]
    public int spawnCount = 1;
    [Tooltip("Delay (in seconds) AFTER the designated wave spawn time (e.g. Day 50%) before *this entry* begins spawning.")] // Clarified Tooltip
    [Min(0)]
    public float delayAfterSpawnTime = 0f; // Renamed from delayAfterWaveStart
    [Tooltip("Time (in seconds) between spawning each individual animal in this entry (0 = spawn all instantly).")]
    [Min(0)]
    public float spawnInterval = 0.5f;
    [Tooltip("Where these animals should spawn.")]
    public WaveSpawnLocationType spawnLocationType = WaveSpawnLocationType.GlobalSpawnArea;
    [Tooltip("Radius used for spawning (e.g., if Spawn Location Type is RandomNearPlayer).")]
    [Min(0)]
    public float spawnRadius = 5f;
}

// WaveDefinition ScriptableObject is simplified further
[CreateAssetMenu(fileName = "Wave_", menuName = "Ecosystem/Wave Definition")]
public class WaveDefinition : ScriptableObject
{
    [Header("Wave Identification")]
    [Tooltip("Editor-only name for this wave.")]
    public string waveName = "New Wave";

    [Header("Wave Content")]
    [Tooltip("Define the groups of animals that spawn during this wave.")]
    public List<WaveSpawnEntry> spawnEntries = new List<WaveSpawnEntry>();

    // REMOVED all timing, duration, end condition, delay fields.
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\WaveManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Managers/WaveManager.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine.UI;

public enum WaveManagerState
{
    PausedBeforeRun,     // Initial state, game logic paused
    WaitingForSpawnTime, // Run started, waiting for correct time in cycle
    WaveInProgress,      // Spawning triggered for this cycle, counting down day cycles
    SequenceComplete     // All waves done
}

public class WaveManager : MonoBehaviour
{
    public static WaveManager Instance { get; private set; }

    [Header("Core Dependencies")]
    [SerializeField] private FaunaManager faunaManager;
    [SerializeField] private WeatherManager weatherManager;
    [SerializeField] private Camera mainCamera;

    [Header("Wave Sequence")]
    [SerializeField] private List<WaveDefinition> wavesSequence;

    [Header("Wave Timing & Spawning (Global)")]
    [Tooltip("How many full Day+Night cycles each wave lasts.")]
    [SerializeField][Range(1, 10)] private int waveDurationInDayCycles = 1;
    [Tooltip("The phase during which spawning should occur each cycle.")]
    [SerializeField] private WeatherManager.CyclePhase spawnStartPhase = WeatherManager.CyclePhase.Day;
    [Tooltip("The percentage progress within the Spawn Start Phase when spawning triggers (0-100).")]
    [SerializeField][Range(0f, 100f)] private float spawnStartPercentage = 50f;
    [SerializeField] private bool loopSequence = false;
    [Tooltip("If checked, animals from the previous wave are destroyed when a new wave starts.")]
    [SerializeField] private bool deletePreviousWaveAnimals = true;

    [Header("UI & Feedback")]
    [SerializeField] private TextMeshProUGUI waveStatusText;
    [SerializeField] private Button startRunButton;
    [SerializeField] private TextMeshProUGUI timeTrackerText;

    [Header("State (Read Only)")]
    [SerializeField] private WaveManagerState currentState = WaveManagerState.PausedBeforeRun;
    [SerializeField] private int currentWaveIndex = -1;

    // --- Runtime State ---
    private WaveDefinition activeWaveDefinition = null;
    private int dayCyclesRemainingForWave = 0;
    private bool hasSpawnedThisCycle = false;
    private bool isInitialPause = true; // <<< NEW: Flag for initial pause

    // --- Public Accessors ---
    public WaveManagerState CurrentState => currentState;
    public int CurrentWaveNumber => currentWaveIndex + 1;
    public int TotalWaves => wavesSequence != null ? wavesSequence.Count : 0;
    public bool IsRunActive => currentState != WaveManagerState.PausedBeforeRun && currentState != WaveManagerState.SequenceComplete;

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Validations (same as before)
        if (faunaManager == null) Debug.LogError("[WaveManager] FaunaManager missing!", this);
        if (weatherManager == null) Debug.LogError("[WaveManager] WeatherManager missing!", this);
        if (mainCamera == null) Debug.LogError("[WaveManager] Main Camera missing!", this);
        if (waveStatusText == null) Debug.LogWarning("[WaveManager] Wave Status Text missing.", this);
        if (timeTrackerText == null) Debug.LogWarning("[WaveManager] Time Tracker Text missing.", this);
        if (wavesSequence == null || wavesSequence.Count == 0) Debug.LogWarning("[WaveManager] Wave Sequence empty.", this);
        if (startRunButton == null) Debug.LogWarning("[WaveManager] Start Run Button missing.", this);
        else startRunButton.onClick.AddListener(TryStartRun);

        // <<< SET INITIAL PAUSE >>>
        Debug.Log("[WaveManager Awake] Setting initial Time.timeScale = 0");
        Time.timeScale = 0f;
        isInitialPause = true;
        // -------------------------
    }

    void Start()
    {
        if (weatherManager != null) weatherManager.OnPhaseChanged += HandleWeatherPhaseChange;
        InitializeManager(); // Sets state, updates button
    }

     void OnDestroy()
    {
        if (weatherManager != null) weatherManager.OnPhaseChanged -= HandleWeatherPhaseChange;
        if (startRunButton != null) startRunButton.onClick.RemoveListener(TryStartRun);
        // Ensure timescale is reset if manager is destroyed
        if(isInitialPause || Time.timeScale != 1f) Time.timeScale = 1f;
    }

    void InitializeManager()
    {
        currentWaveIndex = -1;
        activeWaveDefinition = null;
        dayCyclesRemainingForWave = 0;
        hasSpawnedThisCycle = false;
        // Don't set timescale here anymore, Awake handles initial pause
        SetState(WaveManagerState.PausedBeforeRun);
    }

    void Update()
    {
        // Always update UI if possible
        if (weatherManager != null) UpdateTimeTrackerUI();

        // Skip logic if paused initially OR dependencies missing
        if (isInitialPause || faunaManager == null || weatherManager == null || mainCamera == null)
        {
            // Still need to manage button state even if paused initially
             if (currentState == WaveManagerState.PausedBeforeRun && startRunButton != null)
             {
                  startRunButton.gameObject.SetActive(true);
                  startRunButton.interactable = true;
             }
             return;
        }

        // State Machine Update (only runs after initial pause is over)
        switch (currentState)
        {
            case WaveManagerState.WaitingForSpawnTime: Update_WaitingForSpawnTime(); break;
            case WaveManagerState.WaveInProgress: /* Handled by event */ break;
            case WaveManagerState.SequenceComplete: Update_IdleReady(); break;
             // PausedBeforeRun is handled above
        }
    }

    // --- Event Handler (HandleWeatherPhaseChange) --- (Unchanged)
    void HandleWeatherPhaseChange(WeatherManager.CyclePhase newPhase) { if (currentState == WaveManagerState.PausedBeforeRun || isInitialPause) return; if (newPhase == WeatherManager.CyclePhase.TransitionToDay) { if (currentState == WaveManagerState.WaveInProgress) { dayCyclesRemainingForWave--; hasSpawnedThisCycle = false; if(Debug.isDebugBuild) Debug.Log($"[WaveManager] Day cycle complete. Cycles remaining: {dayCyclesRemainingForWave}"); if (dayCyclesRemainingForWave <= 0) { EndWaveGameplay(); } else { SetState(WaveManagerState.WaitingForSpawnTime); UpdateWaveStatusText(); } } else if (currentState == WaveManagerState.WaitingForSpawnTime) { hasSpawnedThisCycle = false; } } else if (newPhase == spawnStartPhase && currentState == WaveManagerState.WaitingForSpawnTime && !hasSpawnedThisCycle) { Update_WaitingForSpawnTime(); } }


    // --- State Update Methods ---

    void Update_WaitingForSpawnTime() // (Unchanged)
    { if (hasSpawnedThisCycle || weatherManager == null) return; WeatherManager.CyclePhase currentPhase = weatherManager.CurrentPhase; float totalPhaseTime = weatherManager.CurrentTotalPhaseTime; float remainingPhaseTime = weatherManager.CurrentPhaseTimer; float progressPercent = (totalPhaseTime > 0) ? (1f - (remainingPhaseTime / totalPhaseTime)) * 100f : 0f; if (currentPhase == spawnStartPhase && progressPercent >= spawnStartPercentage) { StartWaveSpawning(); } }

    void Update_IdleReady() // (Now only manages button for looping)
    {
         if (startRunButton != null)
         {
            bool showButton = (currentState == WaveManagerState.SequenceComplete && loopSequence);
            startRunButton.gameObject.SetActive(showButton);
            startRunButton.interactable = showButton;
         }
    }

    void UpdateTimeTrackerUI() // (Unchanged)
    { if (timeTrackerText == null || weatherManager == null) return; WeatherManager.CyclePhase phase = weatherManager.CurrentPhase; float total = weatherManager.CurrentTotalPhaseTime; float remaining = weatherManager.CurrentPhaseTimer; float progressPercent = (total > 0) ? (1f - (remaining / total)) * 100f : 0f; string phaseName = phase.ToString().Replace("Transition", ""); timeTrackerText.text = $"{phaseName} [{progressPercent:F0}%]"; if (Time.timeScale == 0f && isInitialPause) timeTrackerText.text += " (Paused)"; } // Show paused during initial pause

    void UpdateWaveStatusText() // (Added PausedBeforeRun case)
    {
         if (waveStatusText == null) return;
         switch(currentState)
         {
             case WaveManagerState.PausedBeforeRun: waveStatusText.text = "Press Start Run"; break;
             case WaveManagerState.WaitingForSpawnTime: waveStatusText.text = $"Wave {CurrentWaveNumber} - Waiting..."; break;
             case WaveManagerState.WaveInProgress: waveStatusText.text = $"Wave {CurrentWaveNumber} [{dayCyclesRemainingForWave} cycles left]"; break;
            case WaveManagerState.SequenceComplete: waveStatusText.text = loopSequence ? "Sequence Done. Start Again?" : "All Waves Cleared!"; break;
             default: waveStatusText.text = ""; break;
         }
    }

    // --- State Transition and Action Methods ---

    void SetState(WaveManagerState newState) // (Removed weather pause logic)
    {
        if (currentState == newState) return;
        if(Debug.isDebugBuild) Debug.Log($"[WaveManager] State Change: {currentState} -> {newState}");
        currentState = newState;

        // Update Button State
        if (startRunButton != null)
        {
            bool showButton = (newState == WaveManagerState.PausedBeforeRun) || (newState == WaveManagerState.SequenceComplete && loopSequence);
            startRunButton.gameObject.SetActive(showButton);
            startRunButton.interactable = showButton;
        }

        // Update Status Text
        UpdateWaveStatusText();
    }

    public void TryStartRun() // <<< MODIFIED
    {
        // Only allow starting from PausedBeforeRun OR SequenceComplete if looping
        if (currentState != WaveManagerState.PausedBeforeRun && !(currentState == WaveManagerState.SequenceComplete && loopSequence))
        {
             if(Debug.isDebugBuild) Debug.Log($"[WaveManager] Cannot start run. State: {currentState}, Looping: {loopSequence}");
             return;
        }

        Debug.Log("[WaveManager] Starting Run...");

        // <<< RESUME TIME >>>
        if (isInitialPause || Time.timeScale != 1f)
        {
            Debug.Log("[WaveManager] Setting Time.timeScale = 1");
            Time.timeScale = 1f;
            isInitialPause = false; // Mark initial pause as over
        }
        // ----------------

        InitializeRun(); // Prepare first wave state
        SetState(WaveManagerState.WaitingForSpawnTime); // Transition state
    }

    void InitializeRun() // (Unchanged)
    { currentWaveIndex = 0; if (wavesSequence == null || wavesSequence.Count == 0 || wavesSequence[currentWaveIndex] == null) { Debug.LogError("[WaveManager] Cannot initialize run: Bad wave sequence!"); SetState(WaveManagerState.SequenceComplete); return; } if(deletePreviousWaveAnimals && currentState == WaveManagerState.SequenceComplete && loopSequence) { ClearAllActiveAnimals(); } activeWaveDefinition = wavesSequence[currentWaveIndex]; dayCyclesRemainingForWave = waveDurationInDayCycles; hasSpawnedThisCycle = false; Debug.Log($"[WaveManager] Run initialized. Starting Wave {CurrentWaveNumber}. Duration: {dayCyclesRemainingForWave} cycles."); }

    void StartWaveSpawning() // (Unchanged)
    { if (activeWaveDefinition == null || currentState != WaveManagerState.WaitingForSpawnTime) { return; } Debug.Log($"[WaveManager] Wave {CurrentWaveNumber} - Spawning Triggered (Phase: {spawnStartPhase} >= {spawnStartPercentage}%)"); hasSpawnedThisCycle = true; SetState(WaveManagerState.WaveInProgress); if (faunaManager != null) faunaManager.ExecuteSpawnWave(activeWaveDefinition); else Debug.LogError("[WaveManager] Cannot execute spawn wave, FaunaManager missing!"); }

    void EndWaveGameplay() // (Unchanged)
    { Debug.Log($"[WaveManager] Wave {CurrentWaveNumber} Gameplay Ended (Duration Met)."); if (faunaManager != null) faunaManager.StopAllSpawnCoroutines(); if (deletePreviousWaveAnimals) { ClearAllActiveAnimals(); } activeWaveDefinition = null; currentWaveIndex++; if (currentWaveIndex >= wavesSequence.Count) { if (loopSequence) { Debug.Log("[WaveManager] Looping back."); InitializeRun(); SetState(WaveManagerState.WaitingForSpawnTime); } else { Debug.Log("[WaveManager] Sequence complete."); SetState(WaveManagerState.SequenceComplete); } } else { if (wavesSequence[currentWaveIndex] == null) { Debug.LogError($"[WaveManager] Wave definition {currentWaveIndex} NULL!"); SetState(WaveManagerState.SequenceComplete); return; } activeWaveDefinition = wavesSequence[currentWaveIndex]; dayCyclesRemainingForWave = waveDurationInDayCycles; hasSpawnedThisCycle = false; Debug.Log($"[WaveManager] Preparing Wave {CurrentWaveNumber}. Duration: {dayCyclesRemainingForWave} cycles."); SetState(WaveManagerState.WaitingForSpawnTime); } }

    void ClearAllActiveAnimals() // (Unchanged)
    { if(Debug.isDebugBuild) Debug.Log("[WaveManager] Clearing all active animals."); AnimalController[] activeAnimals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None); int count = 0; foreach(AnimalController animal in activeAnimals) { if(animal != null) { Destroy(animal.gameObject); count++; } } if(Debug.isDebugBuild) Debug.Log($"[WaveManager] Destroyed {count} animals."); }

    public Camera GetMainCamera() { return mainCamera; } // (Unchanged)
}





--------------------------------------------------------------------------------
This is part 3 out of 7 of script collection. 4 more parts remain.
--------------------------------------------------------------------------------