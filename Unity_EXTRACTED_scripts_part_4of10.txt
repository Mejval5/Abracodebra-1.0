This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-05-29 10:42:16
PART 4 OF 10
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantOutline.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── Panels
│   │       │   ├── Panel_DropZone.prefab
│   │       │   ├── Panel_GeneListItem.prefab
│   │       │   ├── Panel_GeneSequenceItem.prefab
│   │       │   ├── Panel_SeedListItem.prefab
│   │       │   └── Panel_SeedSelectionButton.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   ├── PLANTOTRON_Machine.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           ├── DualGridRuleTile_Grass.asset
│           └── DualGridRuleTile_Water.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_PoopFertilizer.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Seeds
│   │   └── SeedDefinition_000_Base.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       ├── Wave_001.asset
│       └── Wave_002.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── LeafData.cs
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.Cell.cs
│   │   │   ├── PlantGrowth.Growth.cs
│   │   │   ├── PlantGrowth.NodeExecution.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── SlowdownZone.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   ├── Seeds
│   │   │   ├── PlantotronGeneItem.cs
│   │   │   ├── PlantotronGeneSequenceItem.cs
│   │   │   ├── PlantotronMachine.cs
│   │   │   ├── PlantotronSeedItem.cs
│   │   │   ├── PlantotronSequenceDropZone.cs
│   │   │   ├── PlantotronUI.cs
│   │   │   ├── PlayerGeneticsInventory.cs
│   │   │   ├── SeedDefinition.cs
│   │   │   ├── SeedInstance.cs
│   │   │   ├── SeedSelectionButton.cs
│   │   │   └── SeedSelectionUI.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManager.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── OutlinePartController.cs
│       ├── PixelPerfectSetup.cs
│       ├── PlantOutlineController.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       ├── ShadowPartController.cs
│       ├── WaterReflection.cs
│       └── WaterReflectionManager.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Custom_WaterReflectionGradient.mat
│   ├── Sprite-Lit-Advanced_Overlay_Base.mat
│   ├── Sprite-Lit-Default_OverlayAdvanced.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   ├── SpriteEmissiveUnlit.shader
│   ├── WaterReflection.shader
│   └── WaterReflectionSimple.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Effects\FireflyController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Rendering.Universal;
using System.Collections.Generic;

public class FireflyController : MonoBehaviour
{
    [Header("References (Optional)")]
    [Tooltip("Optional Light2D component for local glow.")]
    [SerializeField] private Light2D pointLight;
    [Tooltip("SpriteRenderer for flickering emission and alpha fade.")]
    [SerializeField] private SpriteRenderer spriteRenderer;

    [Header("Movement")]
    [Tooltip("Min/Max movement speed")]
    [SerializeField] private Vector2 speedRange = new Vector2(0.5f, 1.5f);
    [Tooltip("How often (in seconds) the firefly changes direction while wandering")]
    [SerializeField] private float directionChangeInterval = 2.0f;
    [Tooltip("Chance (0-1) that the firefly will pause when changing direction")]
    [SerializeField] [Range(0f, 1f)] private float pauseChance = 0.2f;
    [Tooltip("Min/Max duration (in seconds) for pauses")]
    [SerializeField] private Vector2 pauseDurationRange = new Vector2(0.5f, 1.5f);

    [Header("Lifetime & Fade")]
    [Tooltip("Min/Max lifetime (in seconds) before the firefly despawns")]
    [SerializeField] private Vector2 lifetimeRange = new Vector2(8f, 18f);
    [Tooltip("Duration (in seconds) of the fade-in effect when spawning")]
    [SerializeField] private float fadeInDuration = 0.75f;
    [Tooltip("Duration (in seconds) of the fade-out effect before despawning")]
    [SerializeField] private float fadeOutDuration = 1.5f;

    [Header("Normal Glow Flicker")]
    [Tooltip("If true, the firefly will have a subtle flickering effect during its lifetime")]
    [SerializeField] private bool enableFlicker = true;
    [Tooltip("Min/Max intensity values for normal flickering")]
    [SerializeField] private Vector2 intensityRange = new Vector2(1.5f, 3.0f);
    [Tooltip("Speed of normal flickering (cycles per second) - higher values create more rapid changes")]
    [SerializeField] private float flickerSpeed = 5.0f;

    [Header("Spawn Flicker Effect")]
    [Tooltip("If true, the firefly will have a special flickering effect when first spawned")]
    [SerializeField] private bool enableSpawnEffect = true;
    [Tooltip("Duration (in seconds) of the special spawn effect")]
    [SerializeField] private float spawnEffectDuration = 0.5f;
    [Tooltip("Base brightness to gradually increase to during spawn effect")]
    [SerializeField] private float spawnBaseIntensity = 2.0f;
    [Tooltip("Probability (0-1) of short blackout flickers during spawn effect")]
    [SerializeField] [Range(0f, 1f)] private float spawnBlackoutChance = 0.3f;
    [Tooltip("Min/Max duration (in seconds) of blackout flickers during spawn")]
    [SerializeField] private Vector2 blackoutDurationRange = new Vector2(0.01f, 0.08f);
    [Tooltip("Min/Max spacing (in seconds) between blackout flickers")]
    [SerializeField] private Vector2 blackoutSpacingRange = new Vector2(0.05f, 0.2f);

    [Header("Scent Attraction")]
    [Tooltip("How often (in seconds) the firefly checks for nearby scent sources.")]
    [SerializeField] private float scentCheckInterval = 1.0f;
    [Tooltip("Maximum distance squared the OverlapCircle will check.")]
    [SerializeField] private float scentOverlapCheckRadius = 10f;
    [Tooltip("How strongly the firefly steers towards the scent target.")]
    [SerializeField] private float attractionStrength = 2.0f;
    [Tooltip("Preferred distance to orbit the scent source.")]
    [SerializeField] private float orbitDistance = 0.8f;
    [Tooltip("How much randomness/wobble in the attracted movement.")]
    [SerializeField] private float attractionWobble = 0.5f;
    [Tooltip("Which Scent Definitions attract this firefly.")]
    [SerializeField] private List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();

    // --- Public Accessor ---
    public Transform AttractionTarget => attractionTarget;

    // --- Internal State ---
    private FireflyManager manager;
    private Vector2 currentVelocity;
    private float currentSpeed;
    private float stateTimer;
    private bool isPaused;
    private float lifetime;
    private float age = 0f;
    private float currentAlpha = 0f; // Overall transparency/fade progress
    private float flickerOffset;
    private Material spriteMaterialInstance; // Instanced material for modification

    // Scent State
    private Transform attractionTarget = null;
    private float scentCheckTimer;
    private ScentDefinition currentTargetScentDef = null;

    // Movement Bounds
    private Vector2 minBounds;
    private Vector2 maxBounds;

    // Store the original emission color *without* intensity scaling from the material asset
    private Color baseEmissionColor = Color.black; // Default to black if reading fails
    
    // New fields for tracking the improved spawn effect
    private float nextBlackoutTime = 0f;
    private float blackoutEndTime = 0f;
    private bool isInBlackout = false;

    void Awake()
    {
        if (spriteRenderer == null) spriteRenderer = GetComponent<SpriteRenderer>();
        if (spriteRenderer != null && spriteRenderer.material != null) {
            // Create instance BEFORE reading base emission
            spriteMaterialInstance = spriteRenderer.material;
            // Try to read the base emission color set in the material asset
            if (spriteMaterialInstance.HasProperty("_EmissionColor")) {
                 // Important: Get the color value directly. If it's HDR, this value
                 // might already have some intensity baked in, depending on how it was set.
                 // Ideally, set the material's emission color to the desired *hue/saturation*
                 // with an intensity of 1 in the editor, and control brightness purely via script.
                 baseEmissionColor = spriteMaterialInstance.GetColor("_EmissionColor");
                 // If the color read already has intensity > 1 baked in, we might need to normalize it.
                 // For simplicity, let's assume the user sets the base color correctly.
                 // Example normalization (if needed):
                 // float currentIntensity = Mathf.Max(baseEmissionColor.r, baseEmissionColor.g, baseEmissionColor.b);
                 // if (currentIntensity > 1.0f) baseEmissionColor /= currentIntensity;
            } else {
                 Debug.LogWarning($"[{gameObject.name}] Material '{spriteMaterialInstance.name}' does not have an '_EmissionColor' property.", gameObject);
            }
        } else if (spriteRenderer == null || spriteRenderer.material == null) {
            Debug.LogWarning($"[{gameObject.name}] FireflyController: Cannot modify material properties (flicker/fade), SpriteRenderer or its material is missing.", gameObject);
            enableFlicker = false;
            enableSpawnEffect = false;
        }

        flickerOffset = Random.Range(0f, 100f);
    }

    public void Initialize(FireflyManager owner, Vector2 minB, Vector2 maxB)
    {
        manager = owner; 
        minBounds = minB; 
        maxBounds = maxB;
        
        lifetime = Random.Range(lifetimeRange.x, lifetimeRange.y);
        age = 0f; 
        currentAlpha = 0f;
        
        attractionTarget = null; 
        currentTargetScentDef = null;
        scentCheckTimer = Random.Range(0, scentCheckInterval);
        
        // Initialize blackout effect timing based on spawnBlackoutChance
        isInBlackout = false;
        
        // Only schedule blackouts if the chance is above zero
        if (Random.value < spawnBlackoutChance) {
            float initialDelay = Random.Range(0.01f, 0.1f); // Small random delay before first blackout
            nextBlackoutTime = Time.time + initialDelay;
        } else {
            // Set to a time after spawn effect is over if we don't want blackouts for this instance
            nextBlackoutTime = Time.time + spawnEffectDuration + 1f;
        }
        blackoutEndTime = 0f;
        
        PickNewWanderState();
        // Apply initial state (fully transparent, potentially zero intensity)
        ApplyVisualState(0f);
    }

    void Update()
    {
        age += Time.deltaTime;

        HandleLifetimeAndFade(); // Calculates currentAlpha
        if (currentAlpha <= 0f && age > fadeInDuration) { Die(); return; }

        HandleScentDetection();
        HandleMovement();
        HandleGlowAndFlicker(); // Calculates target intensity & calls ApplyVisualState
    }

    void HandleLifetimeAndFade()
    {
        // Calculate target alpha based on age and lifetime
        if (age < fadeInDuration) {
            currentAlpha = Mathf.Clamp01(age / fadeInDuration); // Fade In
        } else if (lifetime - age < fadeOutDuration) {
            currentAlpha = Mathf.Clamp01((lifetime - age) / fadeOutDuration); // Fade Out
        } else {
            currentAlpha = 1.0f; // Fully Visible
        }

        // Check if lifetime naturally expired
        if (age >= lifetime && currentAlpha > 0) {
             currentAlpha = Mathf.Clamp01((lifetime - age + fadeOutDuration) / fadeOutDuration);
             if(currentAlpha <= 0) Die();
        }
    }

    void HandleScentDetection()
    {
        scentCheckTimer -= Time.deltaTime;
        if (scentCheckTimer <= 0f) { FindAttractionTarget(); scentCheckTimer = scentCheckInterval; }
        if (attractionTarget != null) { if (!attractionTarget.gameObject.activeInHierarchy || !attractionTarget.TryGetComponent<ScentSource>(out var currentScent) || currentScent.definition != currentTargetScentDef || (attractionTarget.position - transform.position).sqrMagnitude > (currentScent.EffectiveRadius * currentScent.EffectiveRadius) ) { attractionTarget = null; currentTargetScentDef = null; } }
    }

    void FindAttractionTarget()
    {
        Transform bestTarget = null; ScentDefinition bestScentDef = null; float bestScore = -1f;
        Collider2D[] hits = Physics2D.OverlapCircleAll(transform.position, scentOverlapCheckRadius);
        foreach (Collider2D hit in hits) {
            if (hit.TryGetComponent<ScentSource>(out ScentSource scent) && scent.definition != null) {
                if (attractiveScentDefinitions.Contains(scent.definition)) {
                    float distSq = (hit.transform.position - transform.position).sqrMagnitude; float scentRadiusSq = scent.EffectiveRadius * scent.EffectiveRadius;
                    if (distSq <= scentRadiusSq) { float score = 1.0f / (distSq + 0.01f); if (score > bestScore) { bestScore = score; bestTarget = hit.transform; bestScentDef = scent.definition; } }
                }
            }
        }
        if (bestTarget != attractionTarget) { attractionTarget = bestTarget; currentTargetScentDef = bestScentDef; if (attractionTarget != null) { isPaused = false; } }
    }

    void HandleMovement()
    {
        stateTimer -= Time.deltaTime;
        if (attractionTarget != null) {
            Vector2 directionToTarget = (attractionTarget.position - transform.position); float distanceToTarget = directionToTarget.magnitude; if (distanceToTarget > 0.01f) { directionToTarget /= distanceToTarget; }
            Vector2 orbitOffsetDir = new Vector2(-directionToTarget.y, directionToTarget.x) * Mathf.Sign(currentSpeed + 0.1f); Vector2 desiredDirection = directionToTarget * attractionStrength;
            if (distanceToTarget <= orbitDistance) { desiredDirection += orbitOffsetDir * (currentSpeed * 0.5f); } desiredDirection += Random.insideUnitCircle * attractionWobble;
            currentVelocity = Vector2.Lerp(currentVelocity.normalized, desiredDirection.normalized, Time.deltaTime * 5f) * currentSpeed;
        } else { if (stateTimer <= 0f) { PickNewWanderState(); } }
        if (!isPaused) {
             Vector2 currentPos = transform.position; Vector2 newPos = currentPos + currentVelocity * Time.deltaTime; bool clampedX = false; bool clampedY = false;
             if (newPos.x <= minBounds.x || newPos.x >= maxBounds.x) { clampedX = true; newPos.x = Mathf.Clamp(newPos.x, minBounds.x, maxBounds.x); } if (newPos.y <= minBounds.y || newPos.y >= maxBounds.y) { clampedY = true; newPos.y = Mathf.Clamp(newPos.y, minBounds.y, maxBounds.y); }
             if (clampedX || clampedY) { Vector2 reflectionNormal = Vector2.zero; if(clampedX) reflectionNormal.x = -Mathf.Sign(currentVelocity.x); if(clampedY) reflectionNormal.y = -Mathf.Sign(currentVelocity.y); currentVelocity = Vector2.Reflect(currentVelocity, reflectionNormal.normalized + Random.insideUnitCircle * 0.1f).normalized * currentSpeed; if (currentVelocity.sqrMagnitude < 0.01f) { currentVelocity = Random.insideUnitCircle.normalized * currentSpeed; } PickNewWanderState(true); }
            transform.position = newPos;
        }
    }

    void PickNewWanderState(bool forceMove = false)
    {
        if (attractionTarget != null && !forceMove) return;
        if (!forceMove && Random.value < pauseChance) { isPaused = true; currentVelocity = Vector2.zero; stateTimer = Random.Range(pauseDurationRange.x, pauseDurationRange.y); }
        else { isPaused = false; currentSpeed = Random.Range(speedRange.x, speedRange.y); if(currentVelocity.sqrMagnitude < 0.01f || forceMove) currentVelocity = Random.insideUnitCircle.normalized * currentSpeed; else currentVelocity = (currentVelocity.normalized + Random.insideUnitCircle * 0.5f).normalized * currentSpeed; stateTimer = directionChangeInterval * Random.Range(0.7f, 1.3f); }
    }

    void HandleGlowAndFlicker()
    {
        float targetFlickerIntensity;

        // New spawn flickering effect that simulates a fluorescent tube turning on
        if (enableSpawnEffect && age < spawnEffectDuration) 
        {
            // Base linear brightening from 0 to spawnBaseIntensity based on progress
            float progress = age / spawnEffectDuration;
            float baseIntensity = Mathf.Lerp(0f, spawnBaseIntensity, progress);
            
            // Blackout flickering logic - Check if we need to schedule a new blackout
            if (Time.time >= nextBlackoutTime && !isInBlackout) 
            {
                // Start a new blackout with probability based on spawnBlackoutChance
                if (Random.value < spawnBlackoutChance) {
                    isInBlackout = true;
                    float blackoutDuration = Random.Range(blackoutDurationRange.x, blackoutDurationRange.y);
                    blackoutEndTime = Time.time + blackoutDuration;
                    
                    // Schedule the next potential blackout check
                    float spacingTime = Random.Range(blackoutSpacingRange.x, blackoutSpacingRange.y);
                    nextBlackoutTime = blackoutEndTime + spacingTime;
                } else {
                    // No blackout this time, but schedule next check
                    float spacingTime = Random.Range(blackoutSpacingRange.x, blackoutSpacingRange.y);
                    nextBlackoutTime = Time.time + spacingTime;
                }
            }
            
            // Update blackout state
            if (isInBlackout && Time.time > blackoutEndTime) 
            {
                isInBlackout = false;
            }
            
            // Apply blackout if active
            targetFlickerIntensity = isInBlackout ? 0f : baseIntensity;
        }
        else if (enableFlicker) 
        {
            // Normal runtime flickering (unchanged)
            float noise = Mathf.PerlinNoise(Time.time * flickerSpeed, flickerOffset);
            targetFlickerIntensity = Mathf.Lerp(intensityRange.x, intensityRange.y, noise);
        }
        else 
        {
            // Steady state if flickering disabled
            targetFlickerIntensity = intensityRange.x;
        }

        // Apply the calculated intensity and the current fade alpha
        ApplyVisualState(targetFlickerIntensity);
    }

    /// <summary>
    /// Applies the visual state based on calculated flicker intensity and fade alpha.
    /// </summary>
    /// <param name="flickerIntensity">The target brightness intensity for emission/light.</param>
    void ApplyVisualState(float flickerIntensity)
    {
        // 1. Apply overall transparency (Alpha Fade) to the SpriteRenderer's base color alpha
        if (spriteMaterialInstance != null)
        {
            // Ensure _Color property exists before trying to set it
            if (spriteMaterialInstance.HasProperty("_Color"))
            {
                Color baseColor = spriteMaterialInstance.GetColor("_Color");
                baseColor.a = currentAlpha; // Apply fade alpha
                spriteMaterialInstance.SetColor("_Color", baseColor);
            }

            // 2. Apply Flicker Intensity to Emission Color's brightness
            if (spriteMaterialInstance.HasProperty("_EmissionColor"))
            {
                 // Apply intensity to the base emission color we stored in Awake
                 // Use LinearToGammaSpace if in Linear color space for more visually correct intensity scalinG
                 Color finalEmissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(flickerIntensity);
                 // Alternative if baseEmissionColor already has intensity: Multiply directly
                 // Color finalEmissionColor = baseEmissionColor * flickerIntensity;
                 spriteMaterialInstance.SetColor("_EmissionColor", finalEmissionColor);
            }
        }

        // 3. Apply Flicker Intensity (modulated by alpha fade) to Light2D
        if (pointLight != null)
        {
            // Light intensity should reflect both flicker and fade
            pointLight.intensity = flickerIntensity * currentAlpha;
        }
    }

    void Die()
    {
        if (manager != null) manager.ReportFireflyDespawned(this);
        currentAlpha = 0f; ApplyVisualState(0f); // Ensure visuals are off
        Destroy(gameObject);
    }

    void OnDestroy() 
    { 
        if (spriteMaterialInstance != null) Destroy(spriteMaterialInstance); 
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Effects\FireflyManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Effects/FireflyManager.cs

using UnityEngine;
using UnityEngine.Rendering.Universal;
using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif

public class FireflyManager : MonoBehaviour
{
    public static FireflyManager Instance { get; private set; }

    [Header("Core Dependencies")]
    [SerializeField] private WeatherManager weatherManager;
    [SerializeField] private GameObject fireflyPrefab;
    [SerializeField] private Transform fireflyParent;

    // (Keep Spawning Settings, Spawn Area, Movement Bounds, Photosynthesis Bonus)
    [Header("Spawning Settings")]
    [SerializeField] private int maxFireflies = 50;
    [SerializeField] private float spawnInterval = 0.5f;
    [SerializeField] [Range(0f, 1f)] private float nightThreshold = 0.25f;

    [Header("Spawn Area")]
    [SerializeField] private Vector2 spawnCenter = Vector2.zero;
    [SerializeField] private Vector2 spawnAreaSize = new Vector2(20f, 10f);

    [Header("Movement Bounds (for Fireflies)")]
    [SerializeField] private Vector2 movementMinBounds = new Vector2(-12f, -7f);
    [SerializeField] private Vector2 movementMaxBounds = new Vector2(12f, 7f);

    [Header("Photosynthesis Bonus Settings")]
    public float photosynthesisRadius = 3f;
    public float photosynthesisIntensityPerFly = 0.05f;
    public float maxPhotosynthesisBonus = 0.5f;


    [Header("Debugging")]
    [Tooltip("Show attraction lines in Game View during runtime.")]
    [SerializeField] private bool showAttractionLinesRuntime = false;
    [SerializeField] private Color attractionLineColorRuntime = Color.magenta; // Renamed for Gizmo
    [SerializeField] private bool logGizmoCalls = false;
    [Space] // Add space for visual separation
    [Tooltip("Prefab used to draw attraction lines at runtime.")]
    [SerializeField] private GameObject lineVisualizerPrefab; // <<< ADDED
    [Tooltip("Parent transform for instantiated line visualizers.")]
    [SerializeField] private Transform lineContainer; // <<< ADDED

    // --- Public Accessor ---
    public bool ShowAttractionLinesRuntime => showAttractionLinesRuntime;

    // --- Internal State ---
    private List<FireflyController> activeFireflies = new List<FireflyController>();
    private float spawnTimer;
    private bool isNight = false;
    
    

    // Dictionary to track line visualizers per firefly
    private Dictionary<FireflyController, LineRenderer> activeLineVisualizers = new Dictionary<FireflyController, LineRenderer>();

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;
        // Validate Core Dependencies
        if (weatherManager == null) { Debug.LogError($"[{nameof(FireflyManager)}] WeatherManager missing!", this); enabled = false; return; }
        if (fireflyPrefab == null) { Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing!", this); enabled = false; return; }
        if (fireflyPrefab.GetComponent<FireflyController>() == null) { Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing Controller script!", this); enabled = false; return; }
        if (fireflyParent == null) { fireflyParent = transform; }

        // Validate Debug Dependencies
        if (lineVisualizerPrefab == null) { Debug.LogError($"[{nameof(FireflyManager)}] Line Visualizer Prefab is not assigned!", this); }
        if (lineContainer == null) { Debug.LogError($"[{nameof(FireflyManager)}] Line Container transform is not assigned!", this); }
    }

    void Update()
    {
        isNight = weatherManager.sunIntensity <= nightThreshold;

        if (isNight) {
            spawnTimer -= Time.deltaTime;
            if (spawnTimer <= 0f) { TrySpawnFirefly(); spawnTimer = spawnInterval; }
        } else { spawnTimer = spawnInterval; }

        // Update runtime visualizers in Update
        UpdateRuntimeLineVisualizers();
    }

    void TrySpawnFirefly()
    {
        if (activeFireflies.Count >= maxFireflies) return;

        float spawnX = spawnCenter.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
        float spawnY = spawnCenter.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
        Vector2 spawnPos = new Vector2(spawnX, spawnY);

        GameObject fireflyGO = Instantiate(fireflyPrefab, spawnPos, Quaternion.identity, fireflyParent);
        FireflyController controller = fireflyGO.GetComponent<FireflyController>();

        if (controller != null) {
            controller.Initialize(this, movementMinBounds, movementMaxBounds);
            activeFireflies.Add(controller);
            // Don't create line visualizer here, do it in Update when needed
        } else { /* LogError, Destroy */ }
    }

    public void ReportFireflyDespawned(FireflyController firefly)
    {
        activeFireflies.Remove(firefly);

        // Clean up associated line visualizer
        if (activeLineVisualizers.TryGetValue(firefly, out LineRenderer line))
        {
            if (line != null) Destroy(line.gameObject); // Destroy the visualizer GO
            activeLineVisualizers.Remove(firefly);
        }
    }

    // --- Runtime Visualizer Update ---
    void UpdateRuntimeLineVisualizers()
    {
        if (!Application.isPlaying) return; // Only run in play mode

        // Check if lines should be shown globally
        bool showLines = showAttractionLinesRuntime && lineVisualizerPrefab != null && lineContainer != null;

        // --- Update existing lines and create new ones ---
        // Use a temporary list to avoid modifying dictionary while iterating
        List<FireflyController> firefliesToRemoveLine = new List<FireflyController>();

        foreach (var kvp in activeLineVisualizers)
        {
            FireflyController firefly = kvp.Key;
            LineRenderer line = kvp.Value;

            if (firefly == null || line == null) // Firefly or line destroyed unexpectedly
            {
                firefliesToRemoveLine.Add(firefly); // Mark for removal
                if(line != null) Destroy(line.gameObject); // Destroy orphan line
                continue;
            }

            Transform target = firefly.AttractionTarget;

            if (showLines && target != null) // Should be visible and has target
            {
                line.enabled = true;
                line.SetPosition(0, firefly.transform.position);
                line.SetPosition(1, target.position);
                
                // IMPORTANT: Ensure the color is set properly
                if (line.startColor != attractionLineColorRuntime || line.endColor != attractionLineColorRuntime)
                {
                    line.startColor = attractionLineColorRuntime;
                    line.endColor = attractionLineColorRuntime;
                    
                    if (Debug.isDebugBuild)
                        Debug.Log($"[FireflyManager] Set line color to {attractionLineColorRuntime}", line.gameObject);
                }
            }
            else // Should be hidden or lost target
            {
                line.enabled = false;
            }
        }

        // Remove entries whose fireflies are gone
        foreach (var firefly in firefliesToRemoveLine)
        {
            activeLineVisualizers.Remove(firefly);
        }


        // --- Add lines for fireflies that don't have one yet ---
        if (showLines)
        {
            foreach (FireflyController firefly in activeFireflies)
            {
                if (firefly == null || activeLineVisualizers.ContainsKey(firefly)) continue; // Skip nulls or those already processed

                Transform target = firefly.AttractionTarget;
                if (target != null) // Only create if it has a target AND should be shown
                {
                    GameObject lineGO = Instantiate(lineVisualizerPrefab, lineContainer); // Instantiate under container
                    LineRenderer newLine = lineGO.GetComponent<LineRenderer>();
                    if (newLine != null)
                    {
                        // Configure initial points (will be updated next frame anyway)
                        newLine.SetPosition(0, firefly.transform.position);
                        newLine.SetPosition(1, target.position);
                        
                        // IMPORTANT: Set the line color correctly
                        newLine.startColor = attractionLineColorRuntime;
                        newLine.endColor = attractionLineColorRuntime;
                        
                        newLine.enabled = true;
                        activeLineVisualizers.Add(firefly, newLine); // Add to tracking dictionary
                        
                        if (Debug.isDebugBuild)
                            Debug.Log($"[FireflyManager] Created new line with color {attractionLineColorRuntime}", newLine.gameObject);
                    }
                    else
                    {
                         Debug.LogError($"Line Visualizer Prefab '{lineVisualizerPrefab.name}' is missing LineRenderer component!", lineVisualizerPrefab);
                         Destroy(lineGO); // Destroy invalid instance
                    }
                }
            }
        }
        // --- Hide/Destroy lines if global flag turned off ---
        else if (!showLines && activeLineVisualizers.Count > 0)
        {
             // Destroy all active line visualizers if the flag is off
             foreach (var kvp in activeLineVisualizers)
             {
                 if (kvp.Value != null) Destroy(kvp.Value.gameObject);
             }
             activeLineVisualizers.Clear();
        }
    }


    // (Keep GetNearbyFireflyCount)
     public int GetNearbyFireflyCount(Vector3 position, float radius)
    {
        int count = 0; float radiusSq = radius * radius;
        for (int i = activeFireflies.Count - 1; i >= 0; i--)
        {
            if (activeFireflies[i] == null) { activeFireflies.RemoveAt(i); continue; }
            if ((activeFireflies[i].transform.position - position).sqrMagnitude <= radiusSq) { count++; }
        }
        return count;
    }

    // --- Gizmos (Editor Visualization - Unchanged) ---
    #if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.green; Gizmos.DrawWireCube(spawnCenter, spawnAreaSize);
        Gizmos.color = Color.blue;
        Vector3 boundsCenter = (movementMinBounds + movementMaxBounds) / 2f;
        Vector3 boundsSize = movementMaxBounds - movementMinBounds;
        Gizmos.DrawWireCube(boundsCenter, boundsSize);

        // Gizmo drawing for attraction lines
        if (showAttractionLinesRuntime && Application.isPlaying) {
             if (logGizmoCalls) { /*...*/ }
             bool didDrawLine = false;
             Gizmos.color = attractionLineColorRuntime; // Use Gizmo color
             foreach (FireflyController firefly in activeFireflies) {
                if (firefly == null) continue;
                Transform target = firefly.AttractionTarget;
                if (target != null) { Gizmos.DrawLine(firefly.transform.position, target.position); didDrawLine = true; }
             }
             if (logGizmoCalls && !didDrawLine && activeFireflies.Count > 0) { /*...*/ }
        }
    }
    #endif
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\AnimalDiet.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;

// Simplified Preference: Links FoodType to satiation amount and behavior priority
[System.Serializable]
public class DietPreferenceSimplified
{
    [Tooltip("The specific FoodType this preference applies to.")]
    public FoodType foodType;

    [Tooltip("How much satiation (hunger reduction) is gained when this food is eaten.")]
    public float satiationAmount = 5f;

    [Tooltip("Priority for seeking this food (higher value = higher priority). Used for choosing between nearby valid foods.")]
    [Range(0.1f, 5f)]
    public float preferencePriority = 1f;
}


// Simplified Diet: Defines hunger stats and list of preferences
[CreateAssetMenu(fileName = "Diet_", menuName = "Ecosystem/Animal Diet (Simplified)")]
public class AnimalDiet : ScriptableObject
{
    [Header("Diet Preferences")]
    [Tooltip("List of foods this animal can eat and how much they satisfy hunger.")]
    public List<DietPreferenceSimplified> acceptableFoods = new List<DietPreferenceSimplified>();

    [Header("Hunger Mechanics")]
    [Tooltip("Maximum hunger level.")]
    public float maxHunger = 20f;
    [Tooltip("Rate at which hunger increases per second.")]
    public float hungerIncreaseRate = 0.5f;
    [Tooltip("Hunger level above which the animal will actively seek food.")]
    public float hungerThreshold = 10f;

    // Removed starvation for simplicity, can be added back later if needed
    // [Header("Starvation")]
    // public float starvationDamageRate = 0.5f;

    /// <summary>
    /// Checks if a specific FoodType is included in this diet's acceptable foods.
    /// </summary>
    public bool CanEat(FoodType food)
    {
        if (food == null) return false;
        return acceptableFoods.Any(pref => pref.foodType == food);
    }

    /// <summary>
    /// Gets the DietPreferenceSimplified entry for a specific FoodType.
    /// </summary>
    public DietPreferenceSimplified GetPreference(FoodType food)
    {
         if (food == null) return null;
         return acceptableFoods.FirstOrDefault(p => p.foodType == food);
    }

    /// <summary>
    /// Gets the satiation amount provided by a specific FoodType for this diet.
    /// </summary>
    public float GetSatiationValue(FoodType food)
    {
        var pref = GetPreference(food);
        return pref != null ? pref.satiationAmount : 0f;
    }

    /// <summary>
    /// Finds the best food target from nearby colliders based on preference and distance.
    /// </summary>
    public GameObject FindBestFood(Collider2D[] nearbyColliders, Vector3 animalPosition)
    {
        GameObject bestTarget = null;
        float highestScore = -1f; // Start below any possible score

        foreach (var collider in nearbyColliders)
        {
            if (collider == null) continue;

            FoodItem foodItem = collider.GetComponent<FoodItem>();

            // Must have FoodItem and its FoodType must be edible by this diet
            if (foodItem != null && foodItem.foodType != null && CanEat(foodItem.foodType))
            {
                DietPreferenceSimplified pref = GetPreference(foodItem.foodType);
                if (pref == null) continue; // Should be caught by CanEat, but safe check

                float distance = Vector3.Distance(animalPosition, collider.transform.position);
                // Simple score: Higher preference is better, closer is better.
                // Avoid division by zero or very small distances inflating score excessively.
                float score = pref.preferencePriority / (1f + distance); // Inverse distance weighting

                if (score > highestScore)
                {
                    highestScore = score;
                    bestTarget = collider.gameObject;
                }
            }
        }
        return bestTarget;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[RequireComponent(typeof(Collider2D))] // Still need collider for detection
public class FoodItem : MonoBehaviour
{
    [Header("Food Identification")]
    [Tooltip("Reference to the ScriptableObject defining what type of food this is.")]
    public FoodType foodType;

    private void Start()
    {
        // Simple validation
        if (foodType == null)
        {
            Debug.LogWarning($"FoodItem on GameObject '{gameObject.name}' is missing its FoodType reference!", gameObject);
            // Optionally disable the collider so it can't be detected as food
            // Collider2D col = GetComponent<Collider2D>();
            // if (col != null) col.enabled = false;
            enabled = false; // Disable script if not configured
        }
        // No health, no consume logic needed here anymore.
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodType.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "FoodType_", menuName = "Ecosystem/Food Type (Simplified)")]
public class FoodType : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Identifying name for this food type (e.g., 'Leaf', 'Fruit').")]
    public string foodName = "Default Food";
    [Tooltip("Icon used in UI or debugging.")]
    public Sprite icon;

    // Keep category for potential filtering later, but not actively used by core logic yet
    public enum FoodCategory { Plant_Leaf, Plant_Fruit, Plant_Stem, Plant_Seed, Other }
    [Header("Categorization")]
    [Tooltip("General category this food falls into.")]
    public FoodCategory category = FoodCategory.Other;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Scents\ScentDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Scents/ScentDefinition.cs
using UnityEngine;

[CreateAssetMenu(fileName = "Scent_", menuName = "Ecosystem/Scent Definition")]
public class ScentDefinition : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Unique identifier used internally and potentially for node effects.")]
    public string scentID = "default_scent"; // Still useful for debugging/lookup
    [Tooltip("Display name for UI or debugging.")]
    public string displayName = "Default Scent";

    // [Header("Gameplay Properties")] - Removed scentType enum field

    [Tooltip("Base radius for this scent type if not modified by nodes.")]
    public float baseRadius = 1f;
    [Tooltip("Base strength for this scent type if not modified by nodes.")]
    public float baseStrength = 1f;

    [Header("Visuals (Optional)")]
    [Tooltip("Particle effect prefab to instantiate when this scent is active.")]
    public GameObject particleEffectPrefab;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Scents\ScentLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Scents/ScentLibrary.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "ScentLibrary", menuName = "Ecosystem/Scent Library")]
public class ScentLibrary : ScriptableObject
{
    public List<ScentDefinition> scents;

    // Helper method to find a scent by its ID (still potentially useful)
    public ScentDefinition GetScentByID(string id)
    {
        if (string.IsNullOrEmpty(id) || scents == null) return null;
        return scents.FirstOrDefault(s => s != null && s.scentID == id);
    }

    // Helper to get the actual list of definitions
    public List<ScentDefinition> GetAllDefinitions()
    {
        // Return a copy or filter out nulls
        return scents?.Where(s => s != null).ToList() ?? new List<ScentDefinition>();
    }

}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public List<NodeEffectData> effects = new List<NodeEffectData>();
    public int orderIndex;

    // Runtime flags
    [HideInInspector] // Don't show in NodeDefinition inspector, set at runtime
    public bool canBeDeleted = true; // <<< NEW FLAG (Defaults to true)

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
        // Ensure default deletability on creation
        canBeDeleted = true;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeDefinition.cs
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    [Header("Display")]
    public string displayName;
    [TextArea]
    public string description;
    public Sprite thumbnail;
    [Tooltip("Tint color applied to the thumbnail image.")]
    public Color thumbnailTintColor = Color.white;
    [Tooltip("Background color for the Node View representation.")]
    public Color backgroundColor = Color.gray;

    [Header("Prefab & Effects")]
    [Tooltip("Optional: Specific NodeView prefab for this node type. If null, the default from NodeEditorGridController is used.")]
    public GameObject nodeViewPrefab;
    [Tooltip("List of effects this node applies. Configure these effects carefully.")]
    public List<NodeEffectData> effects; // This is the list configured in the Inspector

    /// <summary>
    /// Creates a deep copy of the effects list configured in this NodeDefinition asset.
    /// This ensures that runtime NodeData instances get their own copies of effects.
    /// </summary>
    /// <returns>A new list containing copies of the NodeEffectData.</returns>
    public List<NodeEffectData> CloneEffects()
    {
        List<NodeEffectData> copy = new List<NodeEffectData>();
        if (effects == null) {
            // Debug.LogWarning($"NodeDefinition '{this.name}' has a null effects list."); // Optional warning
            return copy; // Handle null list
        }

        foreach (var originalEffect in effects)
        {
            if (originalEffect == null) {
                 Debug.LogWarning($"NodeDefinition '{this.name}' contains a null effect in its list."); // Optional warning
                 continue; // Skip null effects
            }

            // Create a new instance and copy ALL relevant fields
            NodeEffectData newEffect = new NodeEffectData()
            {
                effectType = originalEffect.effectType,
                primaryValue = originalEffect.primaryValue,
                secondaryValue = originalEffect.secondaryValue,
                isPassive = originalEffect.isPassive,
                // --- FIXED: Copy the ScentDefinition reference ---
                scentDefinitionReference = originalEffect.scentDefinitionReference
                // --------------------------------------------------
            };
            copy.Add(newEffect);
        }
        return copy;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System; // Needed for [Serializable]

// Define the configuration for a single initial node
[Serializable] // Make it visible and editable in the Inspector
public struct InitialNodeConfig
{
    [Tooltip("The Node Definition to spawn.")]
    public NodeDefinition nodeDefinition;

    [Tooltip("The zero-based index of the cell where this node should spawn (0 is the leftmost cell).")]
    [Min(0)]
    public int cellIndex;

    [Tooltip("Can the player drag this initial node to other cells?")]
    public bool canMove;

    [Tooltip("Can the player delete this initial node using the Delete key?")]
    public bool canDelete;
}


[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    [Header("Available Node Definitions")]
    [Tooltip("List of all Node Definitions available in the dropdown menu.")]
    public List<NodeDefinition> definitions; // Your existing list

    [Header("Initial Node Layout")]
    [Tooltip("Nodes to automatically spawn in specific slots when the grid initializes.")]
    public List<InitialNodeConfig> initialNodes; // <<< NEW LIST ADDED
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeEffectData.cs
using System;
using UnityEngine;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;

    [Tooltip("Primary numeric value for the effect (e.g., Amount, Duration, Radius Bonus).")] // Updated tooltip
    public float primaryValue;
    [Tooltip("Secondary numeric value for the effect (e.g., Speed, Intensity, Strength Bonus).")] // Updated tooltip
    public float secondaryValue;

    [Tooltip("If TRUE, effect runs once during growth. If FALSE, effect executes during mature cycles.")]
    public bool isPassive = false;

    // --- Scent Specific ---
    // [Tooltip("Identifier (scentID from ScentDefinition) of the scent to apply. Used only if effectType is ScentModifier.")]
    // public string scentIdentifier; // <<< REMOVED

    [Tooltip("The Scent Definition to apply/modify. Used only if effectType is ScentModifier.")]
    public ScentDefinition scentDefinitionReference; // <<< ADDED: Direct reference
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeEffectType.cs
using System;
using UnityEngine;

public enum NodeEffectType
{
    // --- Passive / Growth Phase Effects (isPassive = true) ---
    // These typically run once at the start to define the plant's structure and base stats.

    // [Tooltip("Base cost calculation (Not currently implemented in PlantGrowth execution).")]
    // ManaCost, // REMOVED
    [Tooltip("Determines the maximum energy the plant can store.")]
    EnergyStorage,
    [Tooltip("Determines the base rate of energy generation through photosynthesis per leaf.")]
    EnergyPhotosynthesis,
    [Tooltip("A required marker effect for a node chain to be spawnable as a plant.")]
    SeedSpawn,
    [Tooltip("Modifies the minimum and maximum potential length of the main stem.")]
    StemLength,
    [Tooltip("Modifies the time interval between each step of stem/leaf growth.")]
    GrowthSpeed,
    [Tooltip("Modifies the number of stem segments between leaf spawns.")]
    LeafGap,
    [Tooltip("Sets the pattern in which leaves are spawned (e.g., Parallel, Alternating).")]
    LeafPattern,
    [Tooltip("Modifies the chance for the stem to grow diagonally instead of straight up.")]
    StemRandomness,
    [Tooltip("Modifies the base time duration between Mature Phase execution cycles.")]
    Cooldown,
    [Tooltip("Modifies the base time delay between executing the effects of sequential nodes within a Mature Phase cycle.")]
    CastDelay,
    [Tooltip("Allows the plant to absorb poop within a radius and regrow eaten leaves or gain energy. PrimaryValue=Detection Radius, SecondaryValue=Energy Added.")]
    PoopFertilizer,


    // --- Active / Mature Phase Effects (isPassive = false) ---
    // These execute periodically after the plant has finished growing.

    [Tooltip("Energy cost deducted from the plant when this node's active effects are executed during the mature cycle.")]
    EnergyCost, // <<< RENAMED/ADDED
    [Tooltip("Triggers the spawning of a projectile or other output effect (requires OutputNodeEffect component).")]
    Output,
    [Tooltip("Modifies the damage potential of subsequent 'Output' effects in the same cycle.")]
    Damage,
    [Tooltip("Causes the plant to attempt to spawn a berry in an available adjacent slot during the mature cycle.")]
    GrowBerry,
    // Add potentially more active effects: Heal, ApplyStatus, AreaEffect, etc.
    
    
    [Tooltip("Modifies the scent emitted by the next spawned carrier (Berry, Projectile). PrimaryValue=Radius Add, SecondaryValue=Strength Add.")]
    ScentModifier,
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\OutputNodeEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/OutputNodeEffect.cs
using UnityEngine;
using System.Collections.Generic; // Required for Dictionary

public class OutputNodeEffect : MonoBehaviour
{
    [Header("References")]
    [Tooltip("Prefab for the projectile to spawn.")]
    public GameObject projectilePrefab;

    [Header("Settings")]
    public Vector2 spawnOffset = Vector2.up;

    // Store reference needed to call ApplyScentDataToObject
    private PlantGrowth parentPlantGrowth;

    void Awake()
    {
        // Get reference to parent PlantGrowth to access ApplyScentDataToObject helper
        parentPlantGrowth = GetComponentInParent<PlantGrowth>();
        if (parentPlantGrowth == null)
        {
            // This is a critical error if scent application is expected
            Debug.LogError($"[{nameof(OutputNodeEffect)}] Could not find parent PlantGrowth component! Scent application will fail.", gameObject);
        }
    }

    /// <summary>
    /// Activated by PlantGrowth during the Mature Execution Cycle.
    /// Spawns a projectile and applies accumulated effects (damage, scent).
    /// </summary>
    /// <param name="damageMultiplier">Contextual damage modifier calculated from the node chain.</param>
    /// <param name="scentRadiusBonuses">Accumulated radius bonuses per ScentDefinition.</param> // <<< UPDATED PARAM TYPE
    /// <param name="scentStrengthBonuses">Accumulated strength bonuses per ScentDefinition.</param> // <<< UPDATED PARAM TYPE
    public void Activate(float damageMultiplier,
                         Dictionary<ScentDefinition, float> scentRadiusBonuses, // <<< UPDATED TYPE
                         Dictionary<ScentDefinition, float> scentStrengthBonuses) // <<< UPDATED TYPE
    {
        // --- Validations ---
        if (projectilePrefab == null) {
            Debug.LogError($"[{nameof(OutputNodeEffect)}] Projectile Prefab not assigned!", gameObject);
            return;
        }
        
         if (parentPlantGrowth == null) { // Check again in case Awake failed silently
              Debug.LogError($"[{nameof(OutputNodeEffect)}] Cannot activate, parent PlantGrowth reference is missing. Scent application will fail.", gameObject);
             // Decide if we should still spawn projectile without scent or just return
             // return; // Option: Abort if scent cannot be applied
         }

        // Debug.Log($"[OutputNodeEffect] Activate called. Damage Multiplier: {damageMultiplier}. Spawning projectile.");

        // --- Spawn Projectile ---
        Vector2 spawnPos = (Vector2)transform.position + spawnOffset;
        GameObject projGO = Instantiate(projectilePrefab, spawnPos, transform.rotation); // Use plant's rotation or aim logic

        // --- Apply Accumulated Scents to Projectile ---
        // Call the public helper method on the parent PlantGrowth instance
        if (parentPlantGrowth != null) // Check if reference exists before calling
        {
            // Debug.Log($"[{gameObject.name} Activate] Calling ApplyScentDataToObject for {projGO.name}. Passing {scentStrengthsBonuses?.Count ?? 0} scent strength entries."); /////////// here
            
             // Call the public helper with the NEW dictionaries
             parentPlantGrowth.ApplyScentDataToObject(projGO, scentRadiusBonuses, scentStrengthBonuses);
        }
        // -----------------------------------------------

        // --- Initialize Projectile Stats ---
        SpellProjectile spellProj = projGO.GetComponent<SpellProjectile>();
        if(spellProj != null)
        {
            // TODO: Get base damage/speed from effects or projectile definition?
            float baseDamage = 10f; // Example base value
            float baseSpeed = 5f; // Example base value

            float finalDamage = baseDamage * damageMultiplier; // Apply accumulated multiplier
            float finalSpeed = baseSpeed; // TODO: Apply speed modifiers if implemented

            spellProj.Initialize(finalDamage, finalSpeed);
            // Set other properties like friendly fire based on plant context?
        }
        // else { Debug.LogWarning($"[{nameof(OutputNodeEffect)}] Spawned projectile '{projGO.name}' is missing SpellProjectile component.", projGO); }
    }
}





--------------------------------------------------------------------------------
This is part 4 out of 10 of script collection. 6 more parts remain.
--------------------------------------------------------------------------------