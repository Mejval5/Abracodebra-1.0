This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-04-01 04:16:33
PART 2 OF 3
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   └── NodeDefinitionPostprocessor.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   └── Animal_Fox.prefab
│   │   ├── Plants
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelFruit.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   └── PlantPrefab.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       └── ThoughtBubble.prefab
│   └── General
│       ├── GardenerPrefab.prefab
│       └── Projectile_Basic_Pixel.prefab
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   └── Animal_000_Bunny.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   └── Nodes Plant
│       ├── NodeDefinitionLibrary.asset
│       ├── Node_000_Seed.asset
│       └── Node_000_Seed_Solo.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   └── ThoughtTrigger.cs
│   │   └── Plants
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── UI
│   └── Visuals
│       └── NightColorPostProcess.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Test
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Linq;
using System.Collections.Generic;

[RequireComponent(typeof(Rigidbody2D))]
public class AnimalController : MonoBehaviour
{
    // Assigned via FaunaManager on instantiation
    private AnimalDefinition definition;

    [Header("Thought/Dialogue Setup")]
    public AnimalThoughtLibrary thoughtLibrary;      // Assign GlobalAnimalThoughtLibrary asset
    public GameObject thoughtBubblePrefab;           // Assign your ThoughtBubble prefab

    [Header("Transforms for Visual Alignment")]
    public Transform mouthTransform;                 // For aligning mouth (for future pooping VFX)
    public Transform bubbleSpawnTransform;           // Where thought bubbles spawn

    [Header("Thought Bubble Settings")]
    public float thoughtCooldownTime = 5f;             // Minimum time between thought bubbles
    private float thoughtCooldownTimer = 0f;

    private string speciesName;                      // Derived from definition.animalName

    // Basic runtime stats
    private float currentHealth;
    private float currentHunger;

    private Rigidbody2D rb;
    private SpriteRenderer spriteRenderer;           // For sprite flipping
    private Vector2 moveDirection;

    // Global movement bounds (set via FaunaManager; hidden in Inspector)
    [HideInInspector] private Vector2 minBounds;
    [HideInInspector] private Vector2 maxBounds;

    [Header("Eating Settings")]
    public float eatDuration = 2f;                    // Time spent eating
    [Tooltip("How close the animal must be to a leaf to eat it.")]
    public float eatDistance = 0.5f;
    private bool isEating = false;
    private float eatTimer = 0f;
    private GameObject currentTargetLeaf;

    [Header("Wander Behavior Settings")]
    [Tooltip("Intensity multiplier (0 to 1) controlling the chance to pause while wandering.")]
    [Range(0f, 1f)]
    public float wanderPauseIntensity = 0.5f;
    [Tooltip("Minimum duration for a moving phase while wandering.")]
    public float wanderMinMoveDuration = 1f;
    [Tooltip("Maximum duration for a moving phase while wandering.")]
    public float wanderMaxMoveDuration = 3f;
    [Tooltip("Minimum duration for a pause while wandering.")]
    public float wanderMinPauseDuration = 0.5f;
    [Tooltip("Maximum duration for a pause while wandering.")]
    public float wanderMaxPauseDuration = 2f;
    private bool isWanderPaused = false;
    private float wanderStateTimer = 0f;

    [Header("Pooping Settings")]
    [Tooltip("Minimum delay after eating before the animal poops.")]
    public float minPoopDelay = 5f;
    [Tooltip("Maximum delay after eating before the animal poops.")]
    public float maxPoopDelay = 10f;
    [Tooltip("Duration (in seconds) the animal spends pooping (not moving).")]
    public float poopDuration = 1f;
    [Tooltip("List of poop prefabs for random selection.")]
    public List<GameObject> poopPrefabs;
    [Tooltip("Maximum amount to vary each color channel (0-1) for the poop sprite.")]
    public float poopColorVariation = 0.1f;

    // Internal pooping state variables
    private bool isPooping = false;
    private float poopTimer = 0f;      // For the pooping phase duration
    private float poopDelayTimer = 0f; // Delay before pooping after eating
    private bool hasPooped = false;    // True if the animal has already pooped after the last eating cycle

    public void Initialize(AnimalDefinition def)
    {
        definition = def;
        currentHealth = definition.maxHealth;
        currentHunger = 0f;
        speciesName = definition.animalName; // e.g., "Bunny"
        // Start with no pending poop (already pooped)
        hasPooped = true;
        poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);
    }

    private void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        if (!spriteRenderer)
            spriteRenderer = GetComponentInChildren<SpriteRenderer>();
    }

    private void Update()
    {
        if (definition == null)
        {
            Debug.LogWarning("[AnimalController] 'definition' is null. Did you call Initialize()?");
            return;
        }

        // Decrement thought bubble cooldown timer
        thoughtCooldownTimer -= Time.deltaTime;

        // Increase hunger over time
        currentHunger += definition.hungerDecayRate * Time.deltaTime;

        // Process pooping only if not eating and hasn't already pooped in this cycle
        if (!isEating && !hasPooped)
        {
            poopDelayTimer -= Time.deltaTime;
            if (!isPooping && poopDelayTimer <= 0f)
            {
                // Start pooping phase
                isPooping = true;
                poopTimer = poopDuration;
                ShowThought(ThoughtTrigger.Pooping);
                moveDirection = Vector2.zero; // Stop moving during pooping
            }
            if (isPooping)
            {
                poopTimer -= Time.deltaTime;
                if (poopTimer <= 0f)
                {
                    SpawnPoop();
                    isPooping = false;
                    hasPooped = true; // Mark that we've pooped this cycle
                }
            }
        }

        // If in eating state, update timer and exit early
        if (isEating)
        {
            eatTimer -= Time.deltaTime;
            if (eatTimer <= 0f)
            {
                isEating = false;
                FinishEatingLeaf();
            }
            return;
        }

        // Behavior based on hunger:
        if (currentHunger >= definition.hungerThreshold)
        {
            //Debug.Log($"{speciesName} is hungry! (Hunger: {currentHunger:0.00}/{definition.hungerThreshold})");
            if (thoughtCooldownTimer <= 0f)
            {
                ShowThought(ThoughtTrigger.Hungry);
                thoughtCooldownTimer = thoughtCooldownTime;
            }
            if (currentTargetLeaf == null)
                currentTargetLeaf = FindNearestLeaf();
            if (currentTargetLeaf != null)
                MoveTowardLeaf(currentTargetLeaf);
            else
                Wander();
        }
        else
        {
            Wander();
            currentTargetLeaf = null;
        }

        FlipSpriteBasedOnDirection(moveDirection);
    }

    private void FixedUpdate()
    {
        if (isEating || rb == null)
            return;
        Vector2 newPos = rb.position + moveDirection * definition.movementSpeed * Time.fixedDeltaTime;
        newPos.x = Mathf.Clamp(newPos.x, minBounds.x, maxBounds.x);
        newPos.y = Mathf.Clamp(newPos.y, minBounds.y, maxBounds.y);
        rb.MovePosition(newPos);
    }

    // Wander behavior: alternate between moving and pausing with random durations.
    private void Wander()
    {
        if (wanderStateTimer <= 0f)
        {
            if (isWanderPaused)
            {
                isWanderPaused = false;
                float angle = Random.Range(0f, 360f);
                moveDirection = new Vector2(Mathf.Cos(angle), Mathf.Sin(angle));
                wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration);
            }
            else
            {
                if (Random.value < wanderPauseIntensity)
                {
                    isWanderPaused = true;
                    moveDirection = Vector2.zero;
                    wanderStateTimer = Random.Range(wanderMinPauseDuration, wanderMaxPauseDuration);
                }
                else
                {
                    float angle = Random.Range(0f, 360f);
                    moveDirection = new Vector2(Mathf.Cos(angle), Mathf.Sin(angle));
                    wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration);
                }
            }
        }
        else
        {
            wanderStateTimer -= Time.deltaTime;
        }
    }

    private void MoveTowardLeaf(GameObject leafObj)
    {
        if (isEating)
            return; // Avoid re-triggering if already eating
        if (!leafObj)
        {
            currentTargetLeaf = null;
            return;
        }
        Vector2 leafPos = leafObj.transform.position;
        Vector2 myPos = transform.position;
        float distance = Vector2.Distance(myPos, leafPos);
        if (distance <= eatDistance)
        {
            isEating = true;
            eatTimer = eatDuration;
            ShowThought(ThoughtTrigger.Eating);
        }
        else
        {
            moveDirection = (leafPos - myPos).normalized;
        }
    }

    private void FinishEatingLeaf()
    {
        if (currentTargetLeaf)
        {
            Destroy(currentTargetLeaf);
            currentTargetLeaf = null;
        }
        currentHunger -= definition.eatAmount;
        if (currentHunger < 0f)
            currentHunger = 0f;
        // Reset pooping state for this eating cycle.
        hasPooped = false;
        poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);
    }

    private GameObject FindNearestLeaf()
    {
        GameObject[] leaves = GameObject.FindGameObjectsWithTag("Leaf");
        if (leaves.Length == 0)
            return null;
        Vector2 myPos = transform.position;
        GameObject nearest = null;
        float nearestDist = float.MaxValue;
        foreach (var leaf in leaves)
        {
            float dist = Vector2.Distance(myPos, leaf.transform.position);
            if (dist < nearestDist)
            {
                nearestDist = dist;
                nearest = leaf;
            }
        }
        return nearest;
    }

    // Thought bubble logic: spawn a bubble as a child of bubbleSpawnTransform.
    private void ShowThought(ThoughtTrigger trigger)
    {
        if (!thoughtLibrary || !thoughtBubblePrefab)
        {
            Debug.LogWarning($"[{speciesName}] Missing thought library or bubble prefab!");
            return;
        }
        if (string.IsNullOrEmpty(speciesName))
            return;
        var matchingEntries = thoughtLibrary.allThoughts
            .Where(t => t.speciesName == speciesName && t.trigger == trigger)
            .ToList();
        if (matchingEntries.Count == 0)
        {
            Debug.Log($"[{speciesName}] No thought lines for trigger {trigger}.");
            return;
        }
        var chosenEntry = matchingEntries[Random.Range(0, matchingEntries.Count)];
        if (chosenEntry.lines == null || chosenEntry.lines.Count == 0)
        {
            Debug.Log($"[{speciesName}] Thought entry for trigger {trigger} has no lines.");
            return;
        }
        string randomLine = chosenEntry.lines[Random.Range(0, chosenEntry.lines.Count)];
        Debug.Log($"[{speciesName}] Spawning thought bubble: {randomLine}");
        Transform spawnParent = bubbleSpawnTransform ? bubbleSpawnTransform : transform;
        GameObject bubbleObj = Instantiate(thoughtBubblePrefab, spawnParent.position, Quaternion.identity, spawnParent);
        bubbleObj.transform.localPosition = Vector3.zero;
        ThoughtBubbleController bubble = bubbleObj.GetComponent<ThoughtBubbleController>();
        if (bubble != null)
            bubble.Initialize(randomLine, spawnParent, 2f);
        else
            Debug.LogWarning($"[{speciesName}] ThoughtBubblePrefab is missing ThoughtBubbleController!");
    }

    // Spawn a poop object at the mouthTransform (or fallback to self)
    private void SpawnPoop()
    {
        if (poopPrefabs != null && poopPrefabs.Count > 0)
        {
            int index = Random.Range(0, poopPrefabs.Count);
            GameObject selectedPrefab = poopPrefabs[index];
            Transform spawnPoint = mouthTransform ? mouthTransform : transform;
            GameObject poopObj = Instantiate(selectedPrefab, spawnPoint.position, Quaternion.identity);
            // Random flip and color variation as before.
            SpriteRenderer sr = poopObj.GetComponent<SpriteRenderer>();
            if (sr != null)
            {
                sr.flipX = (Random.value > 0.5f);
                Color originalColor = sr.color;
                float variation = poopColorVariation;
                float newR = Mathf.Clamp01(originalColor.r + Random.Range(-variation, variation));
                float newG = Mathf.Clamp01(originalColor.g + Random.Range(-variation, variation));
                float newB = Mathf.Clamp01(originalColor.b + Random.Range(-variation, variation));
                sr.color = new Color(newR, newG, newB, originalColor.a);
            }
            // Attach PoopController if not present.
            PoopController pc = poopObj.GetComponent<PoopController>();
            if (pc == null)
            {
                pc = poopObj.AddComponent<PoopController>();
            }
            // Initialize PoopController using its Inspector settings (no lifetime passed).
            pc.Initialize();
        }
        else
        {
            Debug.LogWarning($"[{speciesName}] No poopPrefabs assigned!");
        }
    }

    // Sprite flipping based on horizontal movement direction.
    private void FlipSpriteBasedOnDirection(Vector2 direction)
    {
        if (!spriteRenderer)
            return;
        if (direction.x < -0.01f)
            spriteRenderer.flipX = true;
        else if (direction.x > 0.01f)
            spriteRenderer.flipX = false;
    }

    // Public setter for movement bounds (called from FaunaManager)
    public void SetMovementBounds(Vector2 min, Vector2 max)
    {
        minBounds = min;
        maxBounds = max;
    }

    // Public method to compare species name (used by FaunaManager)
    public bool SpeciesNameEquals(string other)
    {
        return speciesName == other;
    }
}






////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalSpawnData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[System.Serializable]
public class AnimalSpawnData {
    public AnimalDefinition animalDefinition;
    [Range(0f, 1f)]
    [Tooltip("Spawn rate multiplier (0 = no spawn; lower values = less frequent spawns).")]
    public float spawnRateMultiplier = 1f;
    [Tooltip("Maximum number of this animal type allowed to be spawned (0 = no limit).")]
    public int maximumSpawned = 0;
    
    [HideInInspector]
    public float spawnTimer = 0f;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalThoughtLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "AnimalThoughtLibrary", menuName = "Ecosystem/Animal Thought Library")]
public class AnimalThoughtLibrary : ScriptableObject
{
    public List<AnimalThoughtLine> allThoughts;
}

[System.Serializable]
public class AnimalThoughtLine
{
    [Header("Which Animal?")]
    public string speciesName; // e.g. "Bunny", "Fox", "Bird"

    [Header("Trigger Condition")]
    public ThoughtTrigger trigger;

    [Header("Possible Lines to Randomly Choose From")]
    public List<string> lines;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\EcosystemManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class EcosystemManager : MonoBehaviour
{
    public static EcosystemManager Instance { get; private set; }

    [Header("Parent Transforms")]
    public Transform animalParent;   // e.g., an empty GameObject "SpawnedEcosystem/Animals"
    public Transform plantParent;    // e.g., an empty GameObject "SpawnedEcosystem/Plants"

    [Header("Sorting Options")]
    public bool sortAnimalsBySpecies = true;
    public bool sortPlantsBySpecies = true;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FaunaManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

public class FaunaManager : MonoBehaviour
{
    [Header("Animal Spawn Settings")]
    public List<AnimalSpawnData> animalsToSpawn;
    public float globalSpawnCooldown = 5f;
    public float spawnRadius = 3f;
    public bool continuousSpawn = true;
    public Vector2 spawnCenter = Vector2.zero;

    [Header("Ecosystem Parent Settings")]
    public Transform ecosystemParent; // e.g., "SpawnedEcosystem/Animals"

    [Header("Global Movement Bounds for Animals")]
    public Vector2 animalMinBounds = new Vector2(-10f, -5f);
    public Vector2 animalMaxBounds = new Vector2(10f, 5f);

    private void Start()
    {
        // Initialize each spawn entry's timer to its effective cooldown.
        foreach (var spawnData in animalsToSpawn)
        {
            if (spawnData.spawnRateMultiplier > 0f)
                spawnData.spawnTimer = globalSpawnCooldown / spawnData.spawnRateMultiplier;
            else
                spawnData.spawnTimer = Mathf.Infinity; // won't spawn if 0
        }
    }

        private void Update()
    {
        if (continuousSpawn)
        {
            foreach (var spawnData in animalsToSpawn)
            {
                if (spawnData.spawnRateMultiplier <= 0f)
                    continue;

                // Check current count for this species.
                int currentCount = 0;
                if (ecosystemParent != null && spawnData.animalDefinition != null && !string.IsNullOrEmpty(spawnData.animalDefinition.animalName))
                {
                    // Try finding the dedicated parent first (more efficient if structure is maintained)
                    Transform speciesParent = ecosystemParent.Find(spawnData.animalDefinition.animalName);
                    if (speciesParent != null)
                        currentCount = speciesParent.childCount;
                    else {
                        // Fallback if species parent doesn't exist yet, count all matching animals
                        // Use FindObjectsByType for modern Unity versions - faster as we don't need sorting
                        AnimalController[] allAnimals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
                        currentCount = 0; // Reset count before iterating through found animals
                        foreach (var a in allAnimals)
                        {
                            if (a != null && a.SpeciesNameEquals(spawnData.animalDefinition.animalName))
                                currentCount++;
                        }
                    }
                }
                else // Fallback if no ecosystem parent or definition name
                {
                     // Use FindObjectsByType for modern Unity versions - faster as we don't need sorting
                    AnimalController[] allAnimals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None); // <--- THIS LINE IS UPDATED
                    currentCount = 0;
                    foreach (var a in allAnimals)
                    {
                        if (a != null && spawnData.animalDefinition != null && a.SpeciesNameEquals(spawnData.animalDefinition.animalName)) // Added null check for spawnData.animalDefinition
                            currentCount++;
                    }
                }
                // If maximum is set (>0) and current count is reached, skip spawn.
                if (spawnData.maximumSpawned > 0 && currentCount >= spawnData.maximumSpawned)
                    continue;

                // Decrement spawn timer and spawn if ready.
                spawnData.spawnTimer -= Time.deltaTime;
                if (spawnData.spawnTimer <= 0f)
                {
                    float effectiveCooldown = globalSpawnCooldown / spawnData.spawnRateMultiplier;
                    Vector2 randomOffset = Random.insideUnitCircle * spawnRadius;
                    SpawnAnimal(spawnData.animalDefinition, spawnCenter + randomOffset);
                    // Reset timer only AFTER successful spawn attempt potentially
                    spawnData.spawnTimer = effectiveCooldown > 0 ? effectiveCooldown : float.PositiveInfinity; // Prevent division by zero/negative cooldowns
                }
            }
        }
    }

    public GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position)
    {
        if (definition == null || definition.prefab == null)
        {
            Debug.LogWarning("[FaunaManager] Invalid animal definition or missing prefab!");
            return null;
        }

        GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

        // Parent the animal under ecosystemParent with species grouping.
        if (ecosystemParent != null)
        {
            Transform speciesParent = ecosystemParent;
            if (!string.IsNullOrEmpty(definition.animalName))
            {
                speciesParent = ecosystemParent.Find(definition.animalName);
                if (speciesParent == null)
                {
                    GameObject subParent = new GameObject(definition.animalName);
                    subParent.transform.SetParent(ecosystemParent);
                    speciesParent = subParent.transform;
                }
            }
            animalObj.transform.SetParent(speciesParent);
        }

        // Get the existing AnimalController on the prefab.
        AnimalController controller = animalObj.GetComponent<AnimalController>();
        if (!controller)
        {
            Debug.LogWarning("[FaunaManager] Prefab missing AnimalController. Adding one dynamically.");
            controller = animalObj.AddComponent<AnimalController>();
        }
        controller.Initialize(definition);
        controller.SetMovementBounds(animalMinBounds, animalMaxBounds);
        return animalObj;
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\PoopController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class PoopController : MonoBehaviour
{
    [Tooltip("Total lifetime of this poop (in seconds) before disappearing.")]
    public float lifetime = 10f;
    [Tooltip("Duration at the end of the lifetime during which the poop fades out.")]
    public float fadeDuration = 2f;
    [Tooltip("Fadeout curve to control the alpha during fade-out. X axis goes from 0 (start of fade) to 1 (end of fade).")]
    public AnimationCurve fadeCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);

    private SpriteRenderer sr;
    private float timer = 0f;
    private Color initialColor;

    private void Awake()
    {
        sr = GetComponent<SpriteRenderer>();
        if (sr != null)
        {
            initialColor = sr.color;
        }
    }

    private void Update()
    {
        timer += Time.deltaTime;
        if (timer >= lifetime)
        {
            Destroy(gameObject);
            return;
        }

        // If within fadeDuration at the end, apply fade-out using the fadeCurve.
        float remaining = lifetime - timer;
        if (remaining < fadeDuration && sr != null)
        {
            // Normalize fade time (0 = start, 1 = end)
            float t = 1f - (remaining / fadeDuration);
            float alphaMultiplier = fadeCurve.Evaluate(t);
            Color newColor = initialColor;
            newColor.a = alphaMultiplier;
            sr.color = newColor;
        }
    }

    // Initialize with default parameters if none are provided.
    public void Initialize(float lifetimeValue = -1f, float fadeDurationValue = -1f)
    {
        if (lifetimeValue > 0f)
            lifetime = lifetimeValue;
        if (fadeDurationValue > 0f)
            fadeDuration = fadeDurationValue;
        timer = 0f;
        if (sr != null)
            initialColor = sr.color;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtBubbleController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class ThoughtBubbleController : MonoBehaviour
{
    public TMP_Text messageText;
    public float lifetime = 2f;

    private Transform followTarget;

    public void Initialize(string message, Transform target, float duration = 2f)
    {
        if (messageText != null)
            messageText.text = message;
        followTarget = target;
        lifetime = duration;
    }

    private void Update()
    {
        lifetime -= Time.deltaTime;
        if (lifetime <= 0f)
            Destroy(gameObject);

        // Follow the target if needed (optional if already a child)
        if (followTarget != null)
        {
            transform.position = followTarget.position;
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtTrigger.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public enum ThoughtTrigger
{
    Hungry,
    Eating,
    HealthLow,
    Fleeing,
    Pooping,
    // Add more triggers as needed
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public List<NodeEffectData> effects = new List<NodeEffectData>();

    // (Optional) To store the order if you need explicit ordering.
    public int orderIndex;

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    [Header("Display")]
    public string displayName;
    [TextArea]
    public string description;
    public Sprite thumbnail;
    [Tooltip("Tint color applied to the thumbnail image.")]
    public Color thumbnailTintColor = Color.white; // ADDED: Thumbnail tint
    [Tooltip("Background color for the Node View representation.")]
    public Color backgroundColor = Color.gray;

    [Header("Prefab & Effects")]
    [Tooltip("Optional: Specific NodeView prefab for this node type. If null, the default from NodeEditorGridController is used.")]
    public GameObject nodeViewPrefab;
    [Tooltip("List of effects this node applies.")]
    public List<NodeEffectData> effects;

    // Method to clone the effects list for NodeData.
    public List<NodeEffectData> CloneEffects()
    {
        List<NodeEffectData> copy = new List<NodeEffectData>();
        if (effects == null) return copy; // Handle null list

        foreach (var eff in effects)
        {
            // Perform a shallow copy, assuming NodeEffectData is simple enough
            NodeEffectData newEff = new NodeEffectData()
            {
                effectType = eff.effectType,
                primaryValue = eff.primaryValue,
                secondaryValue = eff.secondaryValue
            };
            copy.Add(newEff);
        }
        return copy;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    public List<NodeDefinition> definitions;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;
    public float primaryValue;
    public float secondaryValue;

    // Renamed from isGrowthPhaseOnly and default changed to false
    [Tooltip("If TRUE, this effect only contributes once to calculate initial plant stats (Passive Growth Effect). If FALSE, this effect executes during the periodic Mature Phase cycles (Active Effect).")]
    public bool isPassive = false; // Defaulting to false, meaning effects are Active unless specified otherwise
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿public enum NodeEffectType
{
    // Config / Growth Phase Effects (isGrowthPhaseOnly = true)
    ManaCost,           // Base cost calculation (might apply later too?)
    EnergyStorage,      // Determines max energy
    EnergyPhotosynthesis, // Determines base energy generation rate
    SeedSpawn,          // Marker effect to allow spawning
    StemLength,         // Modifies min/max stem length
    GrowthSpeed,        // Modifies time between growth steps
    LeafGap,            // Modifies spacing between leaves
    LeafPattern,        // Sets leaf pattern type
    StemRandomness,     // Modifies stem growth direction variance
    Cooldown,           // Base time between Mature Phase cycles
    CastDelay,          // Base time between Nodes in a Mature Phase cycle

    // Active / Mature Phase Effects (isGrowthPhaseOnly = false)
    Output,             // Triggers spell/projectile spawning
    Damage,             // Adds damage potential to outputs
    // Add potentially more active effects: Heal, ApplyStatus, AreaEffect, etc.
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\OutputNodeEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

// Example - This component might be on the Plant Prefab or dynamically added/found
public class OutputNodeEffect : MonoBehaviour
{
    [Header("References")]
    [Tooltip("Prefab for the projectile to spawn.")]
    public GameObject projectilePrefab; // Assign your projectile prefab

    [Header("Settings")]
    public Vector2 spawnOffset = Vector2.up; // Offset relative to plant transform

    /// <summary>
    /// Activated by PlantGrowth during the Mature Execution Cycle.
    /// </summary>
    /// <param name="damageMultiplier">Contextual damage modifier calculated from the node chain.</param>
    public void Activate(float damageMultiplier) // Example parameter
    {
        if (projectilePrefab == null) {
            Debug.LogError("[OutputNodeEffect] Projectile Prefab not assigned!", gameObject);
            return;
        }

        Debug.Log($"[OutputNodeEffect] Activate called. Damage Multiplier: {damageMultiplier}. Spawning projectile.");

        // --- Calculate Spawn Position ---
        Vector2 spawnPos = (Vector2)transform.position + spawnOffset;

        // --- Instantiate Projectile ---
        GameObject projGO = Instantiate(projectilePrefab, spawnPos, transform.rotation); // Use plant's rotation or aim logic

        // --- Initialize Projectile (if needed) ---
        SpellProjectile spellProj = projGO.GetComponent<SpellProjectile>();
        if(spellProj != null)
        {
            // TODO: Calculate final damage/speed etc. based on node effects and damageMultiplier
            float finalDamage = 10f * damageMultiplier; // Example calculation
            float speed = 5f; // Get speed from effects?
            spellProj.Initialize(finalDamage, speed);
            // Set other properties like friendly fire based on plant context?
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;
using TMPro;
using System.Linq;

public class NodeExecutor : MonoBehaviour
{
    [Header("UI Graph Source")]
    [SerializeField] private NodeEditorGridController nodeEditorGrid;

    [Header("Plant Spawning")]
    [SerializeField] private GameObject plantPrefab;
    [SerializeField] private GardenerController gardener;

    [Header("Debugging")]
    [SerializeField] private TMP_Text debugOutput;

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space)) SpawnPlantFromUIGraph();
    }

    public void SpawnPlantFromUIGraph()
    {
        if (nodeEditorGrid == null) { DebugLogError("Node Editor Grid Controller not assigned!"); return; }
        if (plantPrefab == null) { DebugLogError("Plant prefab not assigned!"); return; }
        if (gardener == null) { DebugLogError("Gardener Controller not assigned!"); return; }

        NodeGraph graphToSpawn = nodeEditorGrid.GetCurrentUIGraph();

        if (graphToSpawn == null || graphToSpawn.nodes == null || graphToSpawn.nodes.Count == 0) { DebugLog("No nodes in UI graph."); return; }

        // Use the renamed flag 'isPassive'
        bool seedFound = graphToSpawn.nodes.Any(node => node.effects != null && node.effects.Any(eff => eff.effectType == NodeEffectType.SeedSpawn && eff.isPassive)); // SeedSpawn should be passive
        if (!seedFound) { DebugLog("Node chain lacks a passive SeedSpawn effect."); return; }

        DebugLog($"Spawning plant from UI graph with {graphToSpawn.nodes.Count} nodes...");
        Vector2 spawnPos = gardener.GetPlantingPosition();
        GameObject plantObj = Instantiate(plantPrefab, spawnPos, Quaternion.identity);

        PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
        if (growthComponent != null)
        {
            NodeGraph graphCopy = new NodeGraph();
            graphCopy.nodes = new List<NodeData>();
            foreach(NodeData originalNodeData in graphToSpawn.nodes)
            {
                 NodeData newNodeData = new NodeData {
                    nodeId = originalNodeData.nodeId,
                    nodeDisplayName = originalNodeData.nodeDisplayName,
                    orderIndex = originalNodeData.orderIndex,
                    effects = CloneEffectsList(originalNodeData.effects) // Deep copy effects
                };
                graphCopy.nodes.Add(newNodeData);
            }
            growthComponent.InitializeAndGrow(graphCopy);
            DebugLog("Plant spawned and initialized.");
        }
        else { DebugLogError($"Prefab '{plantPrefab.name}' missing PlantGrowth!"); Destroy(plantObj); }
    }

    private List<NodeEffectData> CloneEffectsList(List<NodeEffectData> originalList)
    {
        if (originalList == null) return new List<NodeEffectData>();
        List<NodeEffectData> newList = new List<NodeEffectData>(originalList.Count);
        foreach(var eff in originalList)
        {
             NodeEffectData newEff = new NodeEffectData {
                 effectType = eff.effectType,
                 primaryValue = eff.primaryValue,
                 secondaryValue = eff.secondaryValue,
                 isPassive = eff.isPassive // Use the renamed flag
             };
             newList.Add(newEff);
        }
        return newList;
    }

    private void DebugLog(string msg) { Debug.Log($"[NodeExecutor] {msg}"); if (debugOutput != null) debugOutput.text += msg + "\n"; }
    private void DebugLogError(string msg) { Debug.LogError($"[NodeExecutor] {msg}"); if (debugOutput != null) debugOutput.text += $"ERROR: {msg}\n"; }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes = new List<NodeData>();
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\ColorExtensions.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public static class ColorExtensions
{
    public static Color WithAlpha(this Color c, float alpha)
    {
        return new Color(c.r, c.g, c.b, alpha);
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\DeselectOnClickOutside.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems; // Required for IPointerClickHandler

// Add this script to an invisible, fullscreen background UI Image
// Make sure it's the first child of the Canvas to render behind everything else
public class DeselectOnClickOutside : MonoBehaviour, IPointerClickHandler
{
    public void OnPointerClick(PointerEventData eventData)
    {
        // Check if the click was with the left mouse button
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            // If the background is clicked, clear the current node selection
            // Debug.Log("Background Clicked. Clearing Node Selection.");
            NodeCell.ClearSelection();
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeCell.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
// Remove IPointerClickHandler interface from here
// Keep IDropHandler for dropping onto the cell background
public class NodeCell : MonoBehaviour, IPointerClickHandler, IDropHandler // Keep IPointerClickHandler for RIGHT click on empty
{
    public static NodeCell CurrentlySelectedCell { get; private set; }
    public int CellIndex { get; private set; }

    private NodeEditorGridController _controller;
    private NodeData _nodeData;
    private NodeView _nodeView;
    private Image _backgroundImage;

    // --- Init remains the same ---
    public void Init(int index, NodeEditorGridController gridController, Image bgImage)
    {
        CellIndex = index;
        _controller = gridController;
        _backgroundImage = bgImage;

        if (_backgroundImage != null && _controller != null)
        {
            _backgroundImage.color = _controller.EmptyCellColor;
            _backgroundImage.enabled = true;
        }
    }

    // --- HasNode, Getters remain the same ---
    public bool HasNode() => _nodeData != null && _nodeView != null;
    public NodeData GetNodeData() => _nodeData;
    public NodeView GetNodeView() => _nodeView;

    // --- AssignNode, AssignNodeView remain the same ---
     public void AssignNode(NodeDefinition def)
    {
        if (def == null || _controller == null) return;
        RemoveNode();

        _nodeData = new NodeData() { /* ... data setup ... */
            nodeId = System.Guid.NewGuid().ToString(),
            nodeDisplayName = def.displayName,
            effects = def.CloneEffects(),
            orderIndex = this.CellIndex
        };

        GameObject prefabToInstantiate = def.nodeViewPrefab != null ? def.nodeViewPrefab : _controller.NodeViewPrefab;
        if (prefabToInstantiate == null) { /* ... error handling ... */ Debug.LogError($"..."); _nodeData = null; return; }

        GameObject nodeViewGO = Instantiate(prefabToInstantiate, transform);
        _nodeView = nodeViewGO.GetComponent<NodeView>();
        if (_nodeView == null) { /* ... error handling ... */ Debug.LogError($"..."); Destroy(nodeViewGO); _nodeData = null; return; }

        _nodeView.Initialize(_nodeData, def, _controller); // Init NodeView

        NodeDraggable draggable = _nodeView.GetComponent<NodeDraggable>();
        if (draggable == null) draggable = _nodeView.gameObject.AddComponent<NodeDraggable>();
        draggable.Initialize(_controller, this); // Init Draggable

        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }
     public void AssignNodeView(NodeView view, NodeData data)
    {
         RemoveNode();
         _nodeView = view;
         _nodeData = data;
         if (_nodeView != null) {
             _nodeView.transform.SetParent(transform, false);
             if (_nodeData != null) _nodeData.orderIndex = this.CellIndex;
             // Parent ref will be updated by NodeDraggable.SnapToCell which calls NodeView.UpdateParent...
         }
         if(_backgroundImage != null) _backgroundImage.enabled = true;
    }


    // --- RemoveNode, ClearNodeReference remain the same ---
    public void RemoveNode()
    {
        bool wasSelected = (CurrentlySelectedCell == this);
        if (_nodeView != null) {
            if (wasSelected) {
                 _nodeView.Unhighlight();
                 CurrentlySelectedCell = null;
            }
            Destroy(_nodeView.gameObject);
        }
        _nodeView = null; _nodeData = null;
        if (wasSelected && CurrentlySelectedCell == this) CurrentlySelectedCell = null;
        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }
     public void ClearNodeReference()
    {
        _nodeView = null; _nodeData = null;
        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }

    // --- Selection Handling (SelectCell, ClearSelection) remains the same ---
     public static void SelectCell(NodeCell cellToSelect)
    {
        if (cellToSelect == null || !cellToSelect.HasNode()) { ClearSelection(); return; }
        if (CurrentlySelectedCell == cellToSelect) return;
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Unhighlight();
        }
        CurrentlySelectedCell = cellToSelect;
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Highlight();
        }
    }
     public static void ClearSelection()
    {
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Unhighlight();
        }
        CurrentlySelectedCell = null;
    }

    // --- Event Handlers UPDATED ---

    /// <summary>
    /// Handles clicks on the CELL BACKGROUND image.
    /// Left Click: Does nothing (NodeView handles selection).
    /// Right Click: Opens add node menu ONLY if the cell is currently empty.
    /// </summary>
    public void OnPointerClick(PointerEventData eventData)
    {
        // This click is on the NodeCell's background image

        if (eventData.button == PointerEventData.InputButton.Right)
        {
            // Right Click: Only allow opening the dropdown if the cell is currently EMPTY.
            if (!HasNode())
            {
                // Debug.Log($"NodeCell Background Clicked (Right) on Empty Cell {CellIndex}. Opening dropdown.");
                ClearSelection(); // Clear selection before showing add menu
                _controller?.OnEmptyCellRightClicked(this, eventData);
            }
            // If right-clicking the background of an occupied cell, do nothing.
        }
        // Left click on the background does nothing regarding selection now.
    }


    // --- OnDrop remains the same ---
    public void OnDrop(PointerEventData eventData)
    {
        GameObject draggedObject = eventData.pointerDrag;
        if (draggedObject != null) {
            NodeDraggable draggedNode = draggedObject.GetComponent<NodeDraggable>();
            if (draggedNode != null && _controller != null) {
                 _controller.HandleNodeDrop(draggedNode, draggedNode.OriginalCell, eventData.position);
            }
        }
    }
}





--------------------------------------------------------------------------------
This is part 2 out of 3 of script collection. 1 more parts remain.
--------------------------------------------------------------------------------