This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-04-13 14:51:27
PART 4 OF 5
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   ├── Custom_TilemapOverlay_preview.mat
│   ├── DefaultTilemap.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   └── PlantPrefab.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           └── DualGridRuleTile_Grass.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   └── Animal_000_Bunny.asset
│   ├── Animals Diet
│   │   └── Diet_000_Bunny.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   └── Node_002_FireflyPheromone.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   └── TileInteractionLibrary.asset
│   └── Tools
│       ├── ToolDefinition_000_GardeningHoe.asset
│       └── ToolDefinition_001_WateringCan.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   └── ThoughtTrigger.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       └── RuntimeCircleDrawer.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Custom_TilemapOverlay_preview2.mat
│   ├── SpriteEmissiveUnlit.shader
│   └── TilemapOverlay.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeEditorGridController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using TMPro;
using System.Linq;

[RequireComponent(typeof(RectTransform))]
public class NodeEditorGridController : MonoBehaviour // Keep this script on the persistent "UIManager" or similar object
{
    public static NodeEditorGridController Instance { get; private set; }

    [Header("Grid Layout & Appearance")]
    [SerializeField][Min(1)] private int emptyCellsCount = 8;
    [SerializeField] private Vector2 cellSize = new Vector2(64f, 64f);
    [SerializeField] private float cellMargin = 10f;

    [Header("Empty Cell Visuals")]
    [SerializeField] private Sprite emptyCellSprite;
    [SerializeField] private Color emptyCellColor = Color.white;
    [SerializeField] private Vector3 emptyCellScale = Vector3.one; // Still potentially useful for cell GO scale

    [Header("Node Visuals")]
    [SerializeField] private GameObject nodeViewPrefab;
    [SerializeField] private Vector3 nodeImageScale = Vector3.one; // For the image *inside* the node view
    [SerializeField] private Color selectedNodeBackgroundColor = new Color(0.9f, 0.9f, 0.7f, 1f);

    [Header("Node Definitions & Interaction")]
    [SerializeField] private NodeDefinitionLibrary definitionLibrary;
    [SerializeField] private TMP_Dropdown nodeDropdown;

    [Header("UI References")]
    [Tooltip("The UI GameObject (Panel) that gets toggled visible/hidden.")]
    [SerializeField] private GameObject gridUIParent; // The Panel to show/hide
    [Tooltip("The Transform within the UI Panel where cell GameObjects should be created.")]
    [SerializeField] private Transform cellContainer; // The container for cell GOs (e.g., 'GridContainer')


    private List<NodeCell> nodeCells = new List<NodeCell>();
    // Removed _rectTransform as it's less relevant now the script isn't on the grid panel itself
    private Canvas _rootCanvas;
    private NodeGraph _uiGraphRepresentation = new NodeGraph();


    public GameObject NodeViewPrefab => nodeViewPrefab;
    public Vector3 NodeImageScale => nodeImageScale;
    public NodeDefinitionLibrary DefinitionLibrary => definitionLibrary;
    public Color SelectedNodeBackgroundColor => selectedNodeBackgroundColor;
    public Color EmptyCellColor => emptyCellColor;
    public NodeGraph GetCurrentUIGraph() => _uiGraphRepresentation;


    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Get components relative to this script's GameObject
        _rootCanvas = GetComponentInParent<Canvas>(); // Find the root canvas
        if (_rootCanvas == null) Debug.LogError("[NodeEditorGridController] Root Canvas not found!", gameObject);

        // Validate essential references
        if (gridUIParent == null) Debug.LogError("[NodeEditorGridController] Grid UI Parent (the panel to toggle) not assigned.", gameObject);
        if (cellContainer == null) Debug.LogError("[NodeEditorGridController] Cell Container (parent for cells) not assigned.", gameObject);
        if (nodeDropdown == null) Debug.LogWarning("[NodeEditorGridController] Node Dropdown not assigned.", gameObject);
        if (definitionLibrary == null) Debug.LogError("[NodeEditorGridController] Node Definition Library not assigned!", gameObject);
    }

    void OnDestroy()
    {
        if (Instance == this) Instance = null;
    }

    void Start()
    {
        if (nodeDropdown != null) nodeDropdown.gameObject.SetActive(false);

        // Check if references are set before proceeding
        if (cellContainer != null && definitionLibrary != null)
        {
            CreateCells();
            SpawnInitialNodes(); // Call after cells are created
            RefreshGraph(); // Refresh after potentially spawning initial nodes
        }
        else
        {
            Debug.LogError("[NodeEditorGridController] Cannot initialize grid - Cell Container or Definition Library is missing.", gameObject);
        }
    }

    private void CreateCells()
    {
        // Ensure cellContainer is assigned
        if (cellContainer == null)
        {
            Debug.LogError("[NodeEditorGridController] Cannot create cells - Cell Container is not assigned.", gameObject);
            return;
        }

        // Clear existing cells from the container
        foreach (Transform child in cellContainer) // Iterate through the actual container
        {
            if (child.GetComponent<NodeCell>() != null)
            {
                Destroy(child.gameObject);
            }
        }
        nodeCells.Clear();
        NodeCell.ClearSelection();

        // Layout calculations (assuming cellContainer uses appropriate layout components or manual positioning)
        // If using GridLayoutGroup on cellContainer, positioning is automatic.
        // If positioning manually based on cellContainer's RectTransform:
        RectTransform containerRect = cellContainer.GetComponent<RectTransform>();
        if (containerRect == null)
        {
             Debug.LogError("[NodeEditorGridController] Cell Container needs a RectTransform for manual layout calculations.", cellContainer.gameObject);
             return; // Cannot proceed with manual layout
        }

        // Example Manual Layout (adjust based on containerRect's pivot/anchors):
        // Assuming center pivot (0.5, 0.5) for the container
        float totalWidth = (emptyCellsCount * cellSize.x) + ((emptyCellsCount - 1) * cellMargin);
        float startX = -(totalWidth / 2f) + (cellSize.x / 2f);
        float startY = 0; // Assuming horizontal layout centered vertically

        for (int i = 0; i < emptyCellsCount; i++)
        {
            GameObject cellGO = new GameObject($"Cell_{i}");
            RectTransform rt = cellGO.AddComponent<RectTransform>();

            // *** Parent to the designated cellContainer ***
            cellGO.transform.SetParent(cellContainer, false);

            // --- Manual Positioning --- (Comment out if using GridLayoutGroup)
            // Set anchors and pivot (e.g., center) for the cell itself
            rt.anchorMin = new Vector2(0.5f, 0.5f);
            rt.anchorMax = new Vector2(0.5f, 0.5f);
            rt.pivot = new Vector2(0.5f, 0.5f);
            rt.sizeDelta = cellSize;

            // Calculate position relative to container
            float xPos = startX + i * (cellSize.x + cellMargin);
            float yPos = startY;
            rt.anchoredPosition = new Vector2(xPos, yPos);
            // --- End Manual Positioning ---

            // Apply scale if needed
            rt.localScale = emptyCellScale;

            Image cellImage = cellGO.AddComponent<Image>();
            cellImage.sprite = emptyCellSprite;
            cellImage.color = emptyCellColor;
            cellImage.raycastTarget = true;

            NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
            cellLogic.Init(i, this, cellImage);
            nodeCells.Add(cellLogic);

            // If using GridLayoutGroup on cellContainer, you might not need manual positioning.
            // The GridLayoutGroup component handles size and spacing. Just ensure cellGO has a LayoutElement if needed.
            // Example (if using GridLayout):
            // LayoutElement le = cellGO.GetComponent<LayoutElement>() ?? cellGO.AddComponent<LayoutElement>();
            // le.preferredWidth = cellSize.x;
            // le.preferredHeight = cellSize.y;
        }
    }

    private void SpawnInitialNodes()
    {
        if (definitionLibrary == null || definitionLibrary.initialNodes == null)
        {
            return;
        }
        if (nodeCells.Count == 0)
        {
             Debug.LogWarning("[NodeEditorGridController] Cannot spawn initial nodes - cells haven't been created yet (check for earlier errors).");
             return;
        }

        foreach (var config in definitionLibrary.initialNodes)
        {
            if (config.nodeDefinition == null)
            {
                Debug.LogWarning($"Initial node config has null NodeDefinition. Skipping.");
                continue;
            }

            if (config.cellIndex < 0 || config.cellIndex >= nodeCells.Count)
            {
                Debug.LogWarning($"Initial node config for '{config.nodeDefinition.name}' has invalid cell index ({config.cellIndex}). Max index is {nodeCells.Count - 1}. Skipping.");
                continue;
            }

            NodeCell targetCell = nodeCells[config.cellIndex];
            if (targetCell.HasNode())
            {
                Debug.LogWarning($"Initial node config for '{config.nodeDefinition.name}' targets cell {config.cellIndex}, but it's already occupied. Skipping.");
                continue;
            }

            targetCell.AssignNode(config.nodeDefinition);

            NodeView spawnedView = targetCell.GetNodeView();
            if (spawnedView != null)
            {
                NodeDraggable draggable = spawnedView.GetComponent<NodeDraggable>();
                if (draggable != null)
                {
                    draggable.enabled = config.canMove;
                } else if (config.canMove) {
                     Debug.LogWarning($"Initial node '{config.nodeDefinition.name}' in cell {config.cellIndex} is set to 'canMove=true' but its prefab is missing the NodeDraggable component.", spawnedView.gameObject);
                }

                NodeData spawnedData = targetCell.GetNodeData();
                if (spawnedData != null)
                {
                    spawnedData.canBeDeleted = config.canDelete;
                }
            }
        }
    }


    void Update()
    {
        // UI Toggle
        if (Input.GetKeyDown(KeyCode.Tab))
        {
             ToggleGridUI(); // This should now work correctly
        }

        // Delete Node Handling
        if (Input.GetKeyDown(KeyCode.Delete))
        {
            if (NodeCell.CurrentlySelectedCell != null)
            {
                NodeCell selected = NodeCell.CurrentlySelectedCell;
                NodeData data = selected.GetNodeData();

                if (data != null && data.canBeDeleted)
                {
                    selected.RemoveNode();
                    RefreshGraph();
                }
                else if (data != null && !data.canBeDeleted)
                {
                     Debug.Log($"Node '{data.nodeDisplayName}' cannot be deleted.");
                }
            }
        }

        // Dropdown Escape Handling
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf)
            {
                HideDropdown();
            }
             else if (NodeCell.CurrentlySelectedCell != null) {
                 NodeCell.ClearSelection();
             }
        }
    }

    public void ToggleGridUI()
    {
        if (gridUIParent != null)
        {
            bool currentState = gridUIParent.activeSelf;
            gridUIParent.SetActive(!currentState); // This toggles the assigned panel

            if (!gridUIParent.activeSelf) // If hiding UI
            {
                 if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) HideDropdown();
                 NodeCell.ClearSelection(); // Deselect nodes when UI hides
            }
        }
        else Debug.LogWarning("[NodeEditorGridController] Grid UI Parent not assigned.");
    }

    public void OnEmptyCellRightClicked(NodeCell cell, PointerEventData eventData)
    {
        if (nodeDropdown == null) { Debug.LogError("[NodeEditorGridController] Node Dropdown not assigned."); return; }
        if (definitionLibrary == null || definitionLibrary.definitions == null) { Debug.LogError("[NodeEditorGridController] Node Definition Library not assigned or has no definitions."); return; }

        StopCoroutine("ShowDropdownCoroutine");
        StartCoroutine(ShowDropdownCoroutine(cell, eventData));
    }

     private IEnumerator ShowDropdownCoroutine(NodeCell cell, PointerEventData eventData)
     {
         List<TMP_Dropdown.OptionData> options = new List<TMP_Dropdown.OptionData>();
         options.Add(new TMP_Dropdown.OptionData("Select Node..."));
         var sortedDefinitions = definitionLibrary.definitions
                                     .Where(def => def != null)
                                     .OrderBy(def => def.displayName)
                                     .ToList();
         foreach (var def in sortedDefinitions) {
             TMP_Dropdown.OptionData option = new TMP_Dropdown.OptionData();
             option.text = def.displayName;
             option.image = def.thumbnail;
             options.Add(option);
         }
         nodeDropdown.ClearOptions();
         nodeDropdown.AddOptions(options);

         nodeDropdown.onValueChanged.RemoveAllListeners();
         nodeDropdown.onValueChanged.AddListener((selectedIndex) => {
             OnDropdownValueChanged(selectedIndex, cell, sortedDefinitions);
         });

         RectTransform dropdownRect = nodeDropdown.GetComponent<RectTransform>();
         RectTransformUtility.ScreenPointToLocalPointInRectangle(
             dropdownRect.parent as RectTransform,
             eventData.position,
             _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera,
             out Vector2 localPos);
         dropdownRect.localPosition = localPos;

         if (!nodeDropdown.gameObject.activeSelf) nodeDropdown.gameObject.SetActive(true);

         yield return null;

         try {
             if (nodeDropdown.template == null) {
                 Debug.LogError("Dropdown template is not assigned in the Inspector!", nodeDropdown.gameObject);
                 HideDropdown();
                 yield break;
             }
             nodeDropdown.Show();
         } catch (System.NullReferenceException nre) {
              Debug.LogError($"Error showing dropdown: {nre.Message}", nodeDropdown.gameObject);
             HideDropdown();
             yield break;
         }

         nodeDropdown.value = 0;
         nodeDropdown.RefreshShownValue();
     }

     private void OnDropdownValueChanged(int selectedIndex, NodeCell targetCell, List<NodeDefinition> sortedDefs)
     {
         HideDropdown();

         if (selectedIndex > 0) {
             int definitionIndex = selectedIndex - 1;
             if (definitionIndex >= 0 && definitionIndex < sortedDefs.Count) {
                 NodeDefinition selectedDef = sortedDefs[definitionIndex];
                 if (selectedDef != null) {
                     targetCell.AssignNode(selectedDef);
                     NodeCell.SelectCell(targetCell);
                     RefreshGraph();
                 }
             } else {
                  Debug.LogError($"Dropdown selection index ({selectedIndex}) resulted in an out-of-bounds index ({definitionIndex}) for the definition list.");
             }
         }
     }

    public void HideDropdown()
    {
        if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf)
        {
            nodeDropdown.Hide();
            nodeDropdown.gameObject.SetActive(false);
        }
    }

    public void RefreshGraph()
    {
        if (_uiGraphRepresentation == null) _uiGraphRepresentation = new NodeGraph();
        _uiGraphRepresentation.nodes.Clear();
        // Ensure cells are ordered correctly by index when building the graph
        foreach (var cell in nodeCells.OrderBy(c => c.CellIndex))
        {
            NodeData data = cell.GetNodeData();
            if (data != null)
            {
                data.orderIndex = cell.CellIndex;
                _uiGraphRepresentation.nodes.Add(data);
            }
        }
    }

     public bool HandleNodeDrop(NodeDraggable draggedDraggable, NodeCell originalCell, Vector2 screenPosition)
     {
         NodeCell targetCell = FindCellAtScreenPosition(screenPosition);
         bool changed = false;

         if (targetCell != null && originalCell != null)
         {
             NodeView draggedView = draggedDraggable.GetComponent<NodeView>();
             NodeData draggedData = draggedView?.GetNodeData();

             if (draggedView == null || draggedData == null) {
                 Debug.LogError("Dragged object missing NodeView or NodeData!", draggedDraggable.gameObject);
                 draggedDraggable.ResetPosition();
                 return false;
             }

             if (targetCell == originalCell) {
                 draggedDraggable.ResetPosition();
                 NodeCell.SelectCell(targetCell);
                 return false;
             }

             NodeView existingViewInTarget = targetCell.GetNodeView();
             NodeData existingDataInTarget = targetCell.GetNodeData();

             NodeCell.ClearSelection();

             originalCell.ClearNodeReference();

             if (existingViewInTarget != null && existingDataInTarget != null) {
                 NodeDraggable existingDraggable = existingViewInTarget.GetComponent<NodeDraggable>();
                 originalCell.AssignNodeView(existingViewInTarget, existingDataInTarget);
                 if (existingDraggable != null) existingDraggable.SnapToCell(originalCell);
             }

             targetCell.AssignNodeView(draggedView, draggedData);
             draggedDraggable.SnapToCell(targetCell);

             NodeCell.SelectCell(targetCell);
             changed = true;
         }
         else
         {
             draggedDraggable.ResetPosition();
             if (originalCell != null && originalCell.HasNode()) {
                 NodeCell.SelectCell(originalCell);
             } else {
                 NodeCell.ClearSelection();
             }
         }

         if (changed) RefreshGraph();

         return changed;
     }

     private NodeCell FindCellAtScreenPosition(Vector2 screenPosition)
     {
         NodeCell foundCell = null;
         if (cellContainer == null) return null; // Cannot find cells if container is missing

         // Check all NodeCell components *within the specified container*
         foreach (Transform cellTransform in cellContainer)
         {
             NodeCell cell = cellTransform.GetComponent<NodeCell>();
             if (cell == null) continue; // Skip if child isn't a NodeCell

             RectTransform cellRect = cell.GetComponent<RectTransform>();
             if (cellRect == null) continue; // Skip if cell doesn't have a RectTransform

             bool contains = RectTransformUtility.RectangleContainsScreenPoint(
                 cellRect,
                 screenPosition,
                 _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera
             );
             if (contains) {
                 foundCell = cell;
                 break;
             }
         }
         return foundCell;
     }

     #if UNITY_EDITOR
     void OnDrawGizmos()
     {
         // Draw gizmos only in the editor and when not playing
         // Check if cellContainer is assigned before drawing
         if (!Application.isPlaying && cellContainer != null && cellContainer.TryGetComponent<RectTransform>(out var containerRect))
         {
             Gizmos.color = new Color(0f, 1f, 0f, 0.5f); // Semi-transparent green

             // Use the same layout logic as CreateCells (example for manual layout)
             float totalWidth = (emptyCellsCount * cellSize.x) + ((emptyCellsCount - 1) * cellMargin);
             float startX_for_gizmo = -(totalWidth / 2f) + (cellSize.x / 2f); // Relative to container center pivot
             float startY_for_gizmo = 0;

             // Store original matrix
             Matrix4x4 originalMatrix = Gizmos.matrix;

             for (int i = 0; i < emptyCellsCount; i++)
             {
                 // Calculate center position of the cell in container's local space
                 float xOffset = startX_for_gizmo + i * (cellSize.x + cellMargin);
                 Vector3 localCellCenter = new Vector3(xOffset, startY_for_gizmo, 0);

                 // Transform local center to world space using the CELL CONTAINER's transform
                 Vector3 worldCellCenter = cellContainer.TransformPoint(localCellCenter);

                 // Calculate gizmo size based on CELL CONTAINER's lossy scale
                 Vector3 gizmoSize = new Vector3(cellSize.x * cellContainer.lossyScale.x, cellSize.y * cellContainer.lossyScale.y, 0.1f);

                 // Set Gizmos matrix to handle CELL CONTAINER's rotation
                 Gizmos.matrix = Matrix4x4.TRS(worldCellCenter, cellContainer.rotation, Vector3.one);

                 // Draw wire cube centered at the transformed position
                 Gizmos.DrawWireCube(Vector3.zero, gizmoSize);
             }
             // Restore original Gizmos matrix
             Gizmos.matrix = originalMatrix;
         }
         // Optional: Draw a box around the container itself
         // else if (!Application.isPlaying && cellContainer != null && cellContainer.TryGetComponent<RectTransform>(out containerRect)) {
         //     Gizmos.color = Color.yellow;
         //     // Simplified world space box based on container rect
         //     Vector3[] corners = new Vector3[4];
         //     containerRect.GetWorldCorners(corners);
         //     Vector3 center = (corners[0] + corners[2]) * 0.5f;
         //     Vector3 size = new Vector3(Mathf.Abs(corners[0].x - corners[2].x), Mathf.Abs(corners[0].y - corners[2].y), 0.1f);
         //     Gizmos.matrix = Matrix4x4.TRS(center, containerRect.rotation, Vector3.one);
         //     Gizmos.DrawWireCube(Vector3.zero, size);
         //     Gizmos.matrix = Matrix4x4.identity;
         // }
     }
     #endif
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeSelectable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

public class NodeSelectable : MonoBehaviour, IPointerClickHandler
{
    public static GameObject CurrentSelected { get; set; }

    public void OnPointerClick(PointerEventData eventData)
    {
        Select(gameObject);
    }

    public static void Select(GameObject node)
    {
        if (CurrentSelected != null && CurrentSelected != node)
        {
            // (Optional) Remove highlight from previously selected node.
        }
        CurrentSelected = node;
        // (Optional) Add highlight effect here.
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeView.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.EventSystems;
using System.Collections.Generic;
using System.Text;

[RequireComponent(typeof(RectTransform))]
public class NodeView : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler
{
    // --- Fields remain the same ---
    [Header("UI Elements (Assign in Prefab)")]
    [SerializeField] private Image thumbnailImage;
    [SerializeField] private Image backgroundImage;
    [SerializeField] private GameObject tooltipPanel;
    [SerializeField] private TMP_Text tooltipText;
    [SerializeField] private TMP_Text nodeNameText;
    [Header("Configuration")]
    [SerializeField] private bool displayNodeName = false;

    private NodeData _nodeData;
    private NodeDefinition _nodeDefinition;
    private NodeEditorGridController _controller;
    private NodeCell _parentCell;
    private Color _originalBackgroundColor;

    // --- Initialize, UpdateParentCellReference, Getters, Highlight, Unhighlight remain the same ---
     public void Initialize(NodeData data, NodeDefinition definition, NodeEditorGridController controller)
    { /* ... as before ... */
         _nodeData = data; _nodeDefinition = definition; _controller = controller;
         UpdateParentCellReference();
         if (_nodeData == null || _nodeDefinition == null || _controller == null || _parentCell == null) { gameObject.SetActive(false); return; }
         if (thumbnailImage != null) { thumbnailImage.sprite = _nodeDefinition.thumbnail; thumbnailImage.color = _nodeDefinition.thumbnailTintColor; thumbnailImage.rectTransform.localScale = _controller.NodeImageScale; thumbnailImage.enabled = (thumbnailImage.sprite != null); if (!thumbnailImage.raycastTarget) thumbnailImage.raycastTarget = true; }
         if (backgroundImage != null) { _originalBackgroundColor = _nodeDefinition.backgroundColor; backgroundImage.color = _originalBackgroundColor; backgroundImage.enabled = true; if (!backgroundImage.raycastTarget) backgroundImage.raycastTarget = true; }
         if (tooltipPanel != null) tooltipPanel.SetActive(false);
         if (nodeNameText != null) { nodeNameText.text = _nodeData.nodeDisplayName; nodeNameText.gameObject.SetActive(displayNodeName); }
    }
     public void UpdateParentCellReference() { _parentCell = GetComponentInParent<NodeCell>(); /* ... null check ... */ }
     public NodeData GetNodeData() => _nodeData;
     public NodeDefinition GetNodeDefinition() => _nodeDefinition;
     public NodeCell GetParentCell() => _parentCell;
     public void Highlight() { if (backgroundImage != null && _controller != null) backgroundImage.color = _controller.SelectedNodeBackgroundColor; }
     public void Unhighlight() { if (backgroundImage != null) backgroundImage.color = _originalBackgroundColor; }


    // --- Tooltip Handling with Logging ---
    public void OnPointerEnter(PointerEventData eventData)
    {
        // --- Add Log ---
        Debug.Log($"[NodeView OnPointerEnter] Fired on {gameObject.name}. Tooltip Panel assigned: {tooltipPanel != null}", gameObject);

        // Ensure the CanvasGroup allows raycasts IF it exists
        CanvasGroup cg = GetComponent<CanvasGroup>();
        if (cg != null && cg.blocksRaycasts == false)
        {
             Debug.LogWarning($"--> PointerEnter detected but CanvasGroup is blocking raycasts! Drag state might be stuck?", gameObject);
             // Optionally force it: cg.blocksRaycasts = true;
        }


        if (tooltipPanel != null && tooltipText != null && _nodeDefinition != null && _nodeData != null)
        {
            // --- Add Log ---
            // Debug.Log("--> Activating Tooltip Panel");
            tooltipPanel.SetActive(true);
            tooltipText.text = BuildTooltipString();
        }
         else if (tooltipPanel == null) {
             // Debug.LogWarning("--> Tooltip Panel is not assigned in Inspector.", gameObject);
         }
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        // --- Add Log ---
        // Debug.Log($"[NodeView OnPointerExit] Fired on {gameObject.name}", gameObject);

        if (tooltipPanel != null)
        {
             // Debug.Log("--> Deactivating Tooltip Panel");
            tooltipPanel.SetActive(false);
        }
    }

    // --- Pointer Down remains the same ---
    public void OnPointerDown(PointerEventData eventData) { /* ... as before ... */
         // Debug.Log($"[NodeView OnPointerDown] Fired on: {gameObject.name} in Cell: {_parentCell?.CellIndex} | Button: {eventData.button}", gameObject);
        if (eventData.button == PointerEventData.InputButton.Left) {
            if (_parentCell != null) {
                 // Debug.Log($"--> Left Click Confirmed. Requesting SelectCell for {_parentCell.CellIndex}");
                NodeCell.SelectCell(_parentCell);
            } else { UpdateParentCellReference(); if (_parentCell != null) NodeCell.SelectCell(_parentCell); else Debug.LogError("[NodeView] ParentCell null on PointerDown!", gameObject); }
        }
    }

    // --- BuildTooltipString remains the same ---
    private string BuildTooltipString() { /* ... as before ... */
         StringBuilder sb = new StringBuilder(); sb.Append("<b>").Append(_nodeData.nodeDisplayName).Append("</b>\n"); if (!string.IsNullOrEmpty(_nodeDefinition.description)) sb.Append(_nodeDefinition.description).Append("\n"); if (_nodeData.effects != null && _nodeData.effects.Count > 0) { sb.Append("<i>Effects:</i>\n"); foreach (var eff in _nodeData.effects) { sb.Append("- ").Append(eff.effectType.ToString()).Append(": "); sb.Append(eff.primaryValue.ToString("G3")); if (eff.secondaryValue != 0) sb.Append(" / ").Append(eff.secondaryValue.ToString("G3")); sb.Append("\n"); } } return sb.ToString().TrimEnd();
     }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Player\GardenerController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class GardenerController : MonoBehaviour
{
    [Header("Movement Settings")]
    public float moveSpeed = 5f;
    
    [Header("Planting Settings")]
    public Vector2 seedPlantingOffset = new Vector2(0f, -0.5f); // Configurable offset for seed planting

    [Header("Visual Settings")]
    [Tooltip("If true, the sprite will be flipped when moving left")]
    public bool flipSpriteWhenMovingLeft = true;
    [Tooltip("If true, the character will face the opposite direction when flipped")]
    public bool flipHorizontalDirection = true;

    [Header("Animation Settings")]
    [Tooltip("Set to false to disable animations")]
    public bool useAnimations = true;
    public string runningParameterName = "isRunning";
    public string plantingParameterName = "isPlanting";
    [Tooltip("Should match your planting animation length exactly")]
    public float plantingDuration = 0.25f; // UPDATED to match your 0.25s animation


    
    // Private references
    private Rigidbody2D rb;
    private Vector2 movement;
    private SortableEntity sortableEntity;
    private SpriteRenderer spriteRenderer;
    private Animator animator;
    // Private variables
    private bool isPlanting = false;
    private float plantingTimer = 0f;
    private bool wasMovingBeforePlanting = false;

    private void Awake()
    {
        // Get required components
        rb = GetComponent<Rigidbody2D>();
        sortableEntity = GetComponent<SortableEntity>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        animator = GetComponent<Animator>();
        
        // Add SortableEntity if not already present
        if (sortableEntity == null)
            sortableEntity = gameObject.AddComponent<SortableEntity>();
            
        // Warn if sprite renderer is missing
        if (spriteRenderer == null)
            Debug.LogWarning("GardenerController: SpriteRenderer component not found. Sprite flipping won't work.");
            
        // Warn if animator is missing but animations are enabled
        if (animator == null && useAnimations)
            Debug.LogWarning("GardenerController: Animator component not found but useAnimations is true.");
    }

    private void Update()
    {
        // Handle movement input and planting action
        if (!isPlanting)
        {
            movement.x = Input.GetAxisRaw("Horizontal");
            movement.y = Input.GetAxisRaw("Vertical");
        
            // Check if we're moving (store for later)
            bool isMoving = movement.sqrMagnitude > 0.01f;
        
            // Handle planting action
            if (Input.GetKeyDown(KeyCode.Space))
            {
                // Store movement state before planting
                wasMovingBeforePlanting = isMoving;
                StartPlantingAnimation();
            }
        }
        else
        {
            // When planting, we don't accept movement input
            movement = Vector2.zero;
        
            // Handle planting timer
            plantingTimer -= Time.deltaTime;
            if (plantingTimer <= 0)
            {
                EndPlantingAnimation();
            }
        }
    
        // Update animations after all state changes are processed
        UpdateAnimations();
    
        // Handle sprite flipping based on movement direction
        UpdateSpriteDirection();
    }

    private void FixedUpdate()
    {
        // Only move if not planting
        if (!isPlanting)
        {
            rb.MovePosition(rb.position + movement.normalized * moveSpeed * Time.fixedDeltaTime);
        }
    }
    
    // Update character animations based on state
    private void UpdateAnimations()
    {
        if (!useAnimations || animator == null) return;
    
        // Set running animation parameter
        bool isMoving = movement.sqrMagnitude > 0.01f;
        animator.SetBool(runningParameterName, isMoving);
    }
    
    // Update sprite direction based on movement
    private void UpdateSpriteDirection()
    {
        if (spriteRenderer == null || !flipSpriteWhenMovingLeft) return;
        
        if (movement.x != 0)
        {
            // Only flip if moving horizontally
            bool shouldFlip = (movement.x < 0);
            
            // Apply flipping logic based on settings
            if (flipHorizontalDirection)
            {
                spriteRenderer.flipX = shouldFlip;
            }
            else
            {
                // Alternative approach: flip the entire transform
                // This is useful if the sprite is already facing left initially
                Vector3 scale = transform.localScale;
                scale.x = shouldFlip ? -Mathf.Abs(scale.x) : Mathf.Abs(scale.x);
                transform.localScale = scale;
            }
        }
    }
    
    // Start planting animation and process
    public void StartPlantingAnimation()
    {
        if (!useAnimations || isPlanting) return;
    
        isPlanting = true;
        plantingTimer = plantingDuration;
    
        // Set animation parameters
        if (animator != null)
        {
            // Set planting to true and ensure running is false
            animator.SetBool(plantingParameterName, true);
            animator.SetBool(runningParameterName, false);
        }
    }
    
    // End planting animation and resume normal control
    
    private void EndPlantingAnimation()
    {
        // Reset planting state
        isPlanting = false;
    
        // Reset animation parameters
        if (animator != null)
        {
            animator.SetBool(plantingParameterName, false);
        
            // Important: don't immediately set isRunning based on current movement
            // because movement is zero during planting. Instead:
            if (wasMovingBeforePlanting && (Input.GetAxisRaw("Horizontal") != 0 || Input.GetAxisRaw("Vertical") != 0))
            {
                // Only resume running if we were running before AND still have directional input
                animator.SetBool(runningParameterName, true);
            }
        }
    
        // Now update movement based on current input
        movement.x = Input.GetAxisRaw("Horizontal");
        movement.y = Input.GetAxisRaw("Vertical");
    }
    
    // Returns the position used for planting seeds, now with configurable offset
    public Vector2 GetPlantingPosition()
    {
        return (Vector2)transform.position + seedPlantingOffset;
    }
    
    // Public method to set planting animation duration
    public void SetPlantingDuration(float duration)
    {
        plantingDuration = Mathf.Max(0.1f, duration); // Ensure minimum duration
    }
    
    // Public method to trigger planting animation from other scripts
    public void Plant()
    {
        StartPlantingAnimation();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlayerTileInteractor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[RequireComponent(typeof(ToolSwitcher))]
public class PlayerTileInteractor : MonoBehaviour
{
    private ToolSwitcher toolSwitcher;

    private void Awake()
    {
        toolSwitcher = GetComponent<ToolSwitcher>();
        if (toolSwitcher == null)
            Debug.LogError("PlayerTileInteractor: No ToolSwitcher found on this GameObject!");
    }

    private void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            if (TileInteractionManager.Instance == null)
            {
                Debug.LogError("No TileInteractionManager in scene!");
                return;
            }

            ToolDefinition currentTool = toolSwitcher.CurrentTool;
            if (currentTool == null)
            {
                Debug.Log("No tool is currently selected.");
                return;
            }

            // Attempt to apply the tool
            TileInteractionManager.Instance.ApplyToolAction(currentTool);
        }
    }
}





////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Tilemaps;
using System;

[Serializable]
public class TextureOverlaySettings
{
    [Tooltip("The texture to overlay on this tilemap")]
    public Texture2D overlayTexture;
    
    [Tooltip("Tint color for the overlay texture")]
    public Color tintColor = Color.white;
    
    [Tooltip("Scale of the overlay texture (higher value = bigger texture)")]
    [Range(0.1f, 20f)]
    public float scale = 1.0f;
    
    [Tooltip("Offset for the overlay texture")]
    public Vector2 offset = Vector2.zero;
    
    [Tooltip("Should the texture repeat as tiles?")]
    public bool tileTexture = false;
    
    [Tooltip("Should this texture be animated?")]
    public bool useAnimation = false;
    
    [Tooltip("Animation speed (tiles per second)")]
    [Range(0.1f, 10f)]
    public float animationSpeed = 1.0f;
    
    [Tooltip("Number of animation frames along X axis")]
    [Range(1, 32)]
    public int animationTiles = 1;
}

[CreateAssetMenu(fileName = "TileDefinition", menuName = "Tiles/Tile Definition")]
public class TileDefinition : ScriptableObject
{
    [Header("Basic Identification")]
    [Tooltip("Display name for this tile type (used in UI and debugging)")]
    public string displayName;    // e.g. "Grass", "Dirt", "Wet Dirt"
    
    [Header("Visual Properties")]
    [Tooltip("Optional tint color to apply to the RenderTilemap")]
    public Color tintColor = Color.white;
    
    [Header("Texture Overlays")]
    [Tooltip("Texture overlays for this tile type")]
    public TextureOverlaySettings[] overlays;
    
    [Header("Auto-Reversion (optional)")]
    [Tooltip("If > 0, after this many seconds, the tile reverts to 'revertToTile'.")]
    public float revertAfterSeconds = 0f;

    [Tooltip("If revertAfterSeconds > 0, tile reverts to this tile definition.")]
    public TileDefinition revertToTile;

    [Header("Overlay Option")]
    [Tooltip("If true, this tile will be placed on top without removing the tile underneath ")]
    public bool keepBottomTile = false;

#if UNITY_EDITOR
    // This method will be called from the custom editor
    public void UpdateColor()
    {
        // Find the TileInteractionManager in the scene using the non-deprecated method
        var manager = UnityEngine.Object.FindAnyObjectByType<TileInteractionManager>();
        if (manager == null) return;

        foreach (var mapping in manager.tileDefinitionMappings)
        {
            if (mapping.tileDef == this && mapping.tilemapModule != null)
            {
                Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                if (renderTilemapTransform != null)
                {
                    Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
                    if (renderTilemap != null)
                    {
                        renderTilemap.color = tintColor;
                        UnityEditor.EditorUtility.SetDirty(renderTilemap);
                    }
                }
            }
        }
    }

    public void UpdateOverlays()
    {
        // Find the TileInteractionManager in the scene
        var manager = UnityEngine.Object.FindAnyObjectByType<TileInteractionManager>();
        if (manager == null) return;

        foreach (var mapping in manager.tileDefinitionMappings)
        {
            if (mapping.tileDef == this && mapping.tilemapModule != null)
            {
                Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                if (renderTilemapTransform != null)
                {
                    TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
                    if (renderer != null)
                    {
                        // Apply the overlay material and settings
                        manager.ApplyOverlayToTilemap(mapping.tileDef, renderer);
                        UnityEditor.EditorUtility.SetDirty(renderer);
                    }
                }
            }
        }
    }
#endif
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "TileInteractionLibrary", menuName = "Tiles/Tile Interaction Library")]
public class TileInteractionLibrary : ScriptableObject
{
    [Tooltip("List of rules: (Tool, fromTile) => toTile.")]
    public List<TileInteractionRule> rules;
}





--------------------------------------------------------------------------------
This is part 4 out of 5 of script collection. 1 more parts remain.
--------------------------------------------------------------------------------