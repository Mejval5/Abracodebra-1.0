This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-05-28 18:59:47
PART 9 OF 9
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantOutline.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── Panels
│   │       │   ├── Panel_GeneListItem.prefab
│   │       │   ├── Panel_GeneSequenceItem.prefab
│   │       │   ├── Panel_SeedListItem.prefab
│   │       │   └── Panel_SeedSelectionButton.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   ├── PLANTOTRON_Machine.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           ├── DualGridRuleTile_Grass.asset
│           └── DualGridRuleTile_Water.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_PoopFertilizer.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Seeds
│   │   └── SeedDefinition_000_Base.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       ├── Wave_001.asset
│       └── Wave_002.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── LeafData.cs
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.Cell.cs
│   │   │   ├── PlantGrowth.Growth.cs
│   │   │   ├── PlantGrowth.NodeExecution.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── SlowdownZone.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   ├── Seeds
│   │   │   ├── PlantotronGeneItem.cs
│   │   │   ├── PlantotronGeneSequenceItem.cs
│   │   │   ├── PlantotronMachine.cs
│   │   │   ├── PlantotronSeedItem.cs
│   │   │   ├── PlantotronUI.cs
│   │   │   ├── PlayerGeneticsInventory.cs
│   │   │   ├── SeedDefinition.cs
│   │   │   ├── SeedInstance.cs
│   │   │   ├── SeedSelectionButton.cs
│   │   │   └── SeedSelectionUI.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManager.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── OutlinePartController.cs
│       ├── PixelPerfectSetup.cs
│       ├── PlantOutlineController.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       ├── ShadowPartController.cs
│       ├── WaterReflection.cs
│       └── WaterReflectionManager.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Custom_WaterReflectionGradient.mat
│   ├── Sprite-Lit-Advanced_Overlay_Base.mat
│   ├── Sprite-Lit-Default_OverlayAdvanced.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   ├── SpriteEmissiveUnlit.shader
│   ├── WaterReflection.shader
│   └── WaterReflectionSimple.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\PlantOutlineController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/PlantOutlineController.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[RequireComponent(typeof(RectTransform))]
public class PlantOutlineController : MonoBehaviour
{
    // --- Fields ---
    [Header("Outline Settings")]
    [SerializeField] private Color outlineColor = Color.black;
    [SerializeField] private bool excludeOuterCorners = false;
    [SerializeField] private bool excludeBaseCell = true;
    [SerializeField] private GameObject outlinePartPrefab;
    
    [Header("Sorting")]
    [SerializeField] private string outlineSortingLayerName = "Default";
    [SerializeField] private int outlineSortingOrder = -1;

    [Header("Debugging")]
    [SerializeField] private bool debugLogging = false;

    // Public accessors
    public Color OutlineColor => outlineColor;
    public int OutlineSortingLayer => outlineSortingLayerID;
    public int OutlineSortingOrder => outlineSortingOrder;

    // Internal State
    private int outlineSortingLayerID;
    private PlantGrowth parentPlantGrowth;
    private Dictionary<Vector2Int, OutlinePartController> outlinePartMap = new Dictionary<Vector2Int, OutlinePartController>();
    private HashSet<Vector2Int> plantCellCoords = new HashSet<Vector2Int>();
    
    // Neighbor offsets - 8 directions around a cell
    private static readonly Vector2Int[] neighborOffsets = new Vector2Int[]
    {
        new Vector2Int(-1, -1), // Down-Left
        new Vector2Int(0, -1),  // Down
        new Vector2Int(1, -1),  // Down-Right
        new Vector2Int(-1, 0),  // Left
        new Vector2Int(1, 0),   // Right
        new Vector2Int(-1, 1),  // Up-Left
        new Vector2Int(0, 1),   // Up
        new Vector2Int(1, 1),   // Up-Right
    };

    // Just the cardinal directions (for certain operations)
    private static readonly Vector2Int[] cardinalOffsets = new Vector2Int[]
    {
        new Vector2Int(0, -1),  // Down
        new Vector2Int(-1, 0),  // Left
        new Vector2Int(1, 0),   // Right
        new Vector2Int(0, 1),   // Up
    };

    void Awake()
    {
        parentPlantGrowth = GetComponentInParent<PlantGrowth>();
        if (parentPlantGrowth == null)
        {
            Debug.LogError($"[{gameObject.name} Awake] Missing PlantGrowth parent!", gameObject);
            enabled = false;
            return;
        }
        
        if (outlinePartPrefab == null)
        {
            Debug.LogError($"[{gameObject.name} Awake] Outline Part Prefab not assigned!", gameObject);
            enabled = false;
            return;
        }
        
        // Get the proper sorting layer ID from the name
        outlineSortingLayerID = SortingLayer.NameToID(outlineSortingLayerName);
        if (outlineSortingLayerID == 0 && outlineSortingLayerName != "Default")
        {
            Debug.LogWarning($"[{gameObject.name} Awake] Sorting Layer '{outlineSortingLayerName}' not found, using 'Default'.");
            outlineSortingLayerID = SortingLayer.NameToID("Default");
        }
        
        // Zero out local transform values to avoid unexpected visual glitches
        transform.localPosition = Vector3.zero;
        transform.localRotation = Quaternion.identity;
        transform.localScale = Vector3.one;
        
        if (debugLogging)
            Debug.Log($"[{gameObject.name} Awake] Initialized outline controller for {parentPlantGrowth.gameObject.name}");
    }

    // --- Methods Called by PlantGrowth ---

    // OnPlantCellAdded - Called when a new plant cell is added
    public void OnPlantCellAdded(Vector2Int plantCoord, GameObject plantCellGO)
    {
        if (plantCellGO == null)
        {
            if (debugLogging)
                Debug.LogWarning($"[{gameObject.name}] OnPlantCellAdded: Null GameObject at {plantCoord}");
            return;
        }
        
        // Add to our plant cells set
        plantCellCoords.Add(plantCoord);
        
        // Remove any existing outline at the plant location (should be clear already, but safety)
        RemoveOutlinePartIfExists(plantCoord);
        
        // Get the SpriteRenderer from the plant cell
        SpriteRenderer plantRenderer = plantCellGO.GetComponentInChildren<SpriteRenderer>();
        if (plantRenderer == null)
        {
            Debug.LogWarning($"Plant cell added at {plantCoord} missing SpriteRenderer.", plantCellGO);
            return;
        }
        
        // Check all neighboring coordinates around this plant cell
        foreach (Vector2Int offset in neighborOffsets)
        {
            Vector2Int neighborCoord = plantCoord + offset;
            
            // Only create outline parts where:
            // 1. There's no plant cell
            // 2. There's no outline part already
            // 3. It passes any exclusion rules
            if (!plantCellCoords.Contains(neighborCoord) && 
                !outlinePartMap.ContainsKey(neighborCoord))
            {
                if (ShouldExcludeOutlineAt(neighborCoord))
                    continue;
                    
                CreateOutlinePart(neighborCoord, plantRenderer);
            }
        }
        
        if (debugLogging)
            Debug.Log($"[{gameObject.name}] Added cell at {plantCoord}, now tracking {plantCellCoords.Count} cells and {outlinePartMap.Count} outline parts");
    }

    // OnPlantCellRemoved - Called when a plant cell is removed
    public void OnPlantCellRemoved(Vector2Int plantCoord)
    {
        if (!plantCellCoords.Contains(plantCoord))
        {
            if (debugLogging)
                Debug.LogWarning($"[{gameObject.name}] OnPlantCellRemoved: Coordinate {plantCoord} not found in plant cells!");
            return;
        }
        
        // Remove the coordinate from our internal tracking
        plantCellCoords.Remove(plantCoord);
        
        if (debugLogging)
            Debug.Log($"[{gameObject.name}] Removed cell at {plantCoord}, now have {plantCellCoords.Count} cells");
        
        // 1. Check if outline should appear *at the removed location*
        if (!outlinePartMap.ContainsKey(plantCoord))
        {
            if (HasPlantNeighbor(plantCoord))
            {
                SpriteRenderer sourceRenderer = FindValidNeighborRenderer(plantCoord);
                if (sourceRenderer != null && !ShouldExcludeOutlineAt(plantCoord))
                {
                    CreateOutlinePart(plantCoord, sourceRenderer);
                    if (debugLogging)
                        Debug.Log($"[{gameObject.name}] Created new outline at removed cell position {plantCoord}");
                }
            }
        }
        
        // 2. Re-evaluate all neighboring coordinates
        foreach (Vector2Int offset in neighborOffsets)
        {
            Vector2Int neighborCoord = plantCoord + offset;
            
            // Check if an outline exists at this neighbor
            if (outlinePartMap.TryGetValue(neighborCoord, out OutlinePartController outlinePart))
            {
                // Safety check for destroyed outline part
                if (outlinePart == null)
                {
                    outlinePartMap.Remove(neighborCoord);
                    if (debugLogging)
                        Debug.Log($"[{gameObject.name}] Removed null outline at {neighborCoord} from dictionary");
                    continue;
                }
                
                // Check if this neighbor still needs an outline
                bool neighborStillHasPlantNeighbor = HasPlantNeighbor(neighborCoord);
                
                if (!neighborStillHasPlantNeighbor)
                {
                    // No longer has any plant neighbors, remove it
                    RemoveOutlinePartIfExists(neighborCoord);
                    if (debugLogging)
                        Debug.Log($"[{gameObject.name}] Removed orphaned outline at {neighborCoord}");
                }
                else if (!outlinePart.IsSourceRendererValid())
                {
                    // Outline's source was likely the removed cell, update it
                    SpriteRenderer newSource = FindValidNeighborRenderer(neighborCoord);
                    if (newSource != null)
                    {
                        outlinePart.UpdateSourceRenderer(newSource);
                        outlinePart.SyncSpriteAndTransform();
                        if (debugLogging)
                            Debug.Log($"[{gameObject.name}] Updated source for outline at {neighborCoord}");
                    }
                    else
                    {
                        // This case is unlikely but could happen in complex removals
                        if (debugLogging)
                            Debug.LogWarning($"[{gameObject.name}] Outline at {neighborCoord} lost source but HasPlantNeighbor=true. Removing.");
                        RemoveOutlinePartIfExists(neighborCoord);
                    }
                }
            }
            // If no outline at this neighbor, but there should be one (e.g., it was excluded before)
            else if (!plantCellCoords.Contains(neighborCoord) && HasPlantNeighbor(neighborCoord))
            {
                if (!ShouldExcludeOutlineAt(neighborCoord))
                {
                    SpriteRenderer sourceRenderer = FindValidNeighborRenderer(neighborCoord);
                    if (sourceRenderer != null)
                    {
                        CreateOutlinePart(neighborCoord, sourceRenderer);
                        if (debugLogging)
                            Debug.Log($"[{gameObject.name}] Created new outline at neighbor {neighborCoord} after cell removal");
                    }
                }
            }
        }
    }

    // --- Internal Helper Methods ---

    // CreateOutlinePart - Creates an outline part at the specified coordinates
    private void CreateOutlinePart(Vector2Int coord, SpriteRenderer sourceRenderer)
    {
        if (outlinePartPrefab == null)
        {
            Debug.LogError($"[{gameObject.name}] CreateOutlinePart: outlinePartPrefab is null!");
            return;
        }
        
        if (sourceRenderer == null)
        {
            Debug.LogWarning($"[{gameObject.name}] CreateOutlinePart: sourceRenderer is null for coord {coord}");
            return;
        }
        
        // Check if already exists (safety)
        if (outlinePartMap.ContainsKey(coord))
        {
            if (debugLogging)
                Debug.LogWarning($"[{gameObject.name}] CreateOutlinePart: Outline already exists at {coord}");
            return;
        }
        
        // Instantiate the outline part
        GameObject outlineInstance = Instantiate(outlinePartPrefab, transform);
        if (outlineInstance == null)
        {
            Debug.LogError($"[{gameObject.name}] CreateOutlinePart: Failed to instantiate outline prefab!");
            return;
        }
        
        // Set position using PlantGrowth's cell spacing
        float spacing = parentPlantGrowth.GetCellSpacing();
        outlineInstance.transform.localPosition = (Vector2)coord * spacing;
        
        // Get the controller and initialize it
        OutlinePartController outlineController = outlineInstance.GetComponent<OutlinePartController>();
        if (outlineController != null)
        {
            outlineController.Initialize(sourceRenderer, coord, this);
            outlineController.SetVisibility(true);
            outlinePartMap.Add(coord, outlineController);
            
            if (debugLogging)
                Debug.Log($"[{gameObject.name}] Created outline part at {coord} using source {sourceRenderer.gameObject.name}");
        }
        else
        {
            Debug.LogError($"[{gameObject.name}] Outline Part Prefab missing OutlinePartController script!", outlinePartPrefab);
            Destroy(outlineInstance);
        }
    }

    // RemoveOutlinePartIfExists - Removes an outline part if it exists at the specified coordinates
    private void RemoveOutlinePartIfExists(Vector2Int coord)
    {
        if (outlinePartMap.TryGetValue(coord, out OutlinePartController outlinePart))
        {
            if (outlinePart != null)
            {
                outlinePart.DestroyOutlinePart();
                if (debugLogging)
                    Debug.Log($"[{gameObject.name}] Destroyed outline part at {coord}");
            }
            outlinePartMap.Remove(coord);
        }
    }

    // HasPlantNeighbor - Checks if the specified coordinates have any plant neighbors
    private bool HasPlantNeighbor(Vector2Int coord)
    {
        foreach (Vector2Int offset in neighborOffsets)
        {
            if (plantCellCoords.Contains(coord + offset))
            {
                return true;
            }
        }
        return false;
    }

    // FindValidNeighborRenderer - Finds a valid SpriteRenderer from a neighboring plant cell
    private SpriteRenderer FindValidNeighborRenderer(Vector2Int coord)
    {
        foreach (Vector2Int offset in neighborOffsets)
        {
            Vector2Int neighborCoord = coord + offset;
            
            // Check if there's a plant cell at this coordinate
            if (plantCellCoords.Contains(neighborCoord))
            {
                // Get the GameObject from PlantGrowth
                GameObject plantGO = parentPlantGrowth.GetCellGameObjectAt(neighborCoord);
                if (plantGO != null)
                {
                    SpriteRenderer renderer = plantGO.GetComponentInChildren<SpriteRenderer>();
                    if (renderer != null)
                    {
                        if (debugLogging)
                            Debug.Log($"[{gameObject.name}] Found valid renderer at {neighborCoord} for outline at {coord}");
                        return renderer;
                    }
                }
            }
        }
        
        if (debugLogging)
            Debug.LogWarning($"[{gameObject.name}] Could not find any valid neighbor renderer for {coord}");
        return null;
    }

    // ShouldExcludeOutlineAt - Checks if an outline should be excluded at the specified coordinates
    private bool ShouldExcludeOutlineAt(Vector2Int coord)
    {
        // Exclude base cell (e.g., under the seed) if enabled
        if (excludeBaseCell && coord == Vector2Int.down && plantCellCoords.Contains(Vector2Int.zero))
        {
            return true;
        }
        
        // Exclude outer corners if enabled
        if (excludeOuterCorners && IsOuterCornerCandidate(coord))
        {
            return true;
        }
        
        return false;
    }

    // IsOuterCornerCandidate - Checks if the coordinate is a potential outer corner
    private bool IsOuterCornerCandidate(Vector2Int coord)
    {
        // If it's a plant cell, it's not an outer corner
        if (plantCellCoords.Contains(coord))
            return false;
            
        // Count the number of plant neighbors
        int plantNeighborCount = 0;
        foreach (Vector2Int offset in neighborOffsets)
        {
            if (plantCellCoords.Contains(coord + offset)) {
                plantNeighborCount++;
            }
        }
        
        // In typical 2D grid outline detection, an outer corner has 3 neighbors
        return plantNeighborCount == 3;
    }

    void OnDestroy()
    {
        // Clean up resources when destroyed
        foreach (var kvp in outlinePartMap)
        {
            if (kvp.Value != null)
            {
                kvp.Value.DestroyOutlinePart();
            }
        }
        outlinePartMap.Clear();
        plantCellCoords.Clear();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\PlantShadowController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/PlantShadowController.cs
using UnityEngine;
using System.Collections.Generic;

public class PlantShadowController : MonoBehaviour
{
    [Header("Global Shadow Settings")]
    [SerializeField] private Color shadowColor = new Color(0f, 0f, 0f, 0.5f);
    [SerializeField] [Range(0.1f, 2f)] [Tooltip("Vertical squash factor (1 = none, <1 = flatter, >1 = taller)")]
    private float squashFactor = 0.6f;
    [SerializeField] [Range(0f, 360f)] [Tooltip("Rotation angle of the shadow around the plant's base (0 = right, 90 = up, 180 = left, 270 = down)")]
    private float shadowAngleDegrees = 270f; // Default to directly downwards
    [SerializeField] [Tooltip("Flip the shadow horizontally?")]
    private bool flipShadow = false;
    // Removed: lightSourceDirection
    // Removed: shadowDistance
    // Removed: skewAngleDegrees (replaced by shadowAngleDegrees for direction)
    
    [Header("Distance Fade")]
    [Tooltip("Enable fading parts based on distance from the root.")]
    [SerializeField] private bool enableDistanceFade = true;
    [Tooltip("Distance from the root where the shadow part starts fading.")]
    [SerializeField] private float fadeStartDistance = 1.5f;
    [Tooltip("Distance from the root where the shadow part is fully faded (alpha 0).")]
    [SerializeField] private float fadeEndDistance = 3.0f;
    [Tooltip("Minimum alpha value even when fully faded (e.g., 0.1 for slight visibility).")]
    [SerializeField] [Range(0f, 1f)] private float minFadeAlpha = 0.0f;

    [Header("Sorting")]
    [SerializeField] [Tooltip("Name of the Sorting Layer for shadows (e.g., 'Shadows')")]
    private string shadowSortingLayerName = "Default";
    [SerializeField] [Tooltip("Sorting Order within the layer (lower values are rendered first)")]
    private int shadowSortingOrder = -1;

    // --- Internal ID ---
    private int shadowSortingLayerID;

    // Public accessors for ShadowPartController
    public Color ShadowColor => shadowColor;
    public int ShadowSortingLayer => shadowSortingLayerID;
    public int ShadowSortingOrder => shadowSortingOrder;

    // <<< NEW ACCESSORS for Fade >>>
    public bool EnableDistanceFade => enableDistanceFade;
    public float FadeStartDistance => fadeStartDistance;
    public float FadeEndDistance => fadeEndDistance;
    public float MinFadeAlpha => minFadeAlpha;
    
    // Cached base transform values
    private Vector3 baseLocalScale;
    private Quaternion baseLocalRotation;
    private Vector3 baseLocalPosition;

    // Dictionary to manage shadow parts (unchanged)
    private Dictionary<SpriteRenderer, ShadowPartController> shadowPartMap = new Dictionary<SpriteRenderer, ShadowPartController>();

    void Awake()
    {
        // Convert layer name to ID (unchanged)
        shadowSortingLayerID = SortingLayer.NameToID(shadowSortingLayerName);
        if (shadowSortingLayerID == 0 && shadowSortingLayerName != "Default")
        {
            Debug.LogWarning($"Sorting Layer '{shadowSortingLayerName}' not found. Shadow will use 'Default'.", this);
            shadowSortingLayerID = SortingLayer.NameToID("Default");
        }

        // Cache initial transform state (unchanged)
        baseLocalScale = transform.localScale;
        baseLocalRotation = transform.localRotation;
        // --- IMPORTANT: Ensure _ShadowRoot starts at local position (0,0,0) relative to the Plant root ---
        baseLocalPosition = transform.localPosition;
        if (baseLocalPosition != Vector3.zero) {
             Debug.LogWarning($"'{gameObject.name}' initial localPosition is not zero ({baseLocalPosition}). Shadow origin might be slightly offset from plant root.", gameObject);
        }
    }

    void LateUpdate()
    {
        // 1. Set Position: Keep the shadow root at the plant's origin (relative to parent)
        // We don't apply any offset anymore.
        transform.localPosition = baseLocalPosition; // Should typically be Vector3.zero

        // 2. Set Rotation based on the angle slider
        // Apply the rotation relative to the initial orientation
        Quaternion angleRotation = Quaternion.Euler(0, 0, shadowAngleDegrees);
        transform.localRotation = baseLocalRotation * angleRotation;

        // 3. Calculate and Apply Scale (Squash + Flip)
        Vector3 finalScale = baseLocalScale; // Start with original scale
        // Apply squash factor (typically affects the Y-axis before rotation)
        // To apply squash along the *rotated* Y-axis is more complex.
        // Let's keep the simpler approach: squash the local Y scale.
        finalScale.y *= squashFactor;

        // Apply horizontal flip if checked (affects the X-axis)
        if (flipShadow)
        {
            finalScale.x *= -1f;
        }
        // Apply the calculated scale
        transform.localScale = finalScale;

    }

    // --- Methods for PlantGrowth Integration (Unchanged) ---

    public void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject shadowPartPrefab)
    {
        if (plantPartRenderer == null || shadowPartPrefab == null) return;
        if (shadowPartMap.ContainsKey(plantPartRenderer)) return;
        GameObject shadowInstance = Instantiate(shadowPartPrefab, transform);
        ShadowPartController shadowController = shadowInstance.GetComponent<ShadowPartController>();
        if (shadowController != null) { shadowController.Initialize(plantPartRenderer, this); shadowPartMap.Add(plantPartRenderer, shadowController); }
        else { Debug.LogError($"Shadow Part Prefab '{shadowPartPrefab.name}' missing ShadowPartController.", shadowPartPrefab); Destroy(shadowInstance); }
    }

    public void UnregisterPlantPart(SpriteRenderer plantPartRenderer)
    {
        if (plantPartRenderer != null && shadowPartMap.TryGetValue(plantPartRenderer, out ShadowPartController shadowController)) {
            if (shadowController != null) { shadowController.OnPlantPartDestroyed(); }
            shadowPartMap.Remove(plantPartRenderer);
        }
    }

    void OnDestroy()
    {
        shadowPartMap.Clear(); // Prevent memory leaks
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\RuntimeCircleDrawer.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/RuntimeCircleDrawer.cs

using UnityEngine;

/// <summary>
/// Draws a circle outline using a LineRenderer attached to the same GameObject.
/// Requires a LineRenderer component.
/// </summary>
[RequireComponent(typeof(LineRenderer))]
public class RuntimeCircleDrawer : MonoBehaviour
{
    [Range(3, 60)]
    public int segments = 30; // Number of line segments to approximate the circle
    public float radius = 1.0f;
    public float lineWidth = 0.02f;
    public Color color = Color.yellow;
    public Material lineMaterial; // Assign the same material used for firefly lines, or a specific one

    private LineRenderer lineRenderer;
    private bool needsRedraw = true; // Flag to force redraw on first UpdateCircle call or when params change
    private float currentRadius = -1f; // Store current values to detect changes
    private Color currentColor = Color.clear;

    void Awake()
    {
        lineRenderer = GetComponent<LineRenderer>();
        if (lineRenderer == null) { // Should not happen with RequireComponent
            Debug.LogError($"[{gameObject.name}] RuntimeCircleDrawer: Missing required LineRenderer component!");
            enabled = false; // Disable script if component missing
            return;
        }
        ConfigureLineRendererDefaults();
        lineRenderer.enabled = false; // Start hidden
    }

    // Sets initial parameters that don't change often
    void ConfigureLineRendererDefaults()
    {
        lineRenderer.useWorldSpace = false; // Draw relative to this object's transform
        lineRenderer.loop = true; // Connect the last point to the first
        lineRenderer.startWidth = lineWidth;
        lineRenderer.endWidth = lineWidth;
        
        // Only set material if one was provided and lineRenderer doesn't have one
        if (lineMaterial != null && lineRenderer.material == null)
        {
            lineRenderer.material = lineMaterial;
        }
        
        // Don't set color here - UpdateCircle will handle that

        // Attempt to match sorting with parent sprite
        SpriteRenderer parentSprite = GetComponentInParent<SpriteRenderer>();
        if (parentSprite != null) {
            lineRenderer.sortingLayerName = parentSprite.sortingLayerName;
            lineRenderer.sortingOrder = parentSprite.sortingOrder + 1; // Draw slightly in front
        } else {
            // Default sorting if no parent sprite found
            lineRenderer.sortingLayerName = "Default";
            lineRenderer.sortingOrder = 1;
        }
    }

    // Call this method to update the circle's appearance and make it visible
    public void UpdateCircle(float newRadius, Color newColor)
    {
        // Check if parameters have actually changed
        bool radiusChanged = !Mathf.Approximately(currentRadius, newRadius);
        bool colorChanged = currentColor != newColor;
        
        if (!needsRedraw && !radiusChanged && !colorChanged)
        {
            // Ensure it's enabled if it wasn't already
            if (!lineRenderer.enabled) lineRenderer.enabled = true;
            return; // No change needed
        }

        // Update stored values
        currentRadius = newRadius;
        radius = newRadius; // Update public field for potential inspector viewing
        currentColor = newColor;
        color = newColor; // Update public field

        // IMPORTANT: Update LineRenderer colors
        lineRenderer.startColor = currentColor;
        lineRenderer.endColor = currentColor;
        
        // Log color change for debugging
        if (colorChanged && Debug.isDebugBuild)
        {
            Debug.Log($"[RuntimeCircleDrawer] Updated color to: {newColor}", gameObject);
        }
        
        // Update width if you add properties for it too
        // lineRenderer.startWidth = newWidth;
        // lineRenderer.endWidth = newWidth;

        DrawCircle(); // Recalculate points
        lineRenderer.enabled = true; // Ensure it's visible
        needsRedraw = false; // Mark as drawn
    }

    // Call this to hide the circle
    public void HideCircle()
    {
        if (lineRenderer != null && lineRenderer.enabled)
        {
            lineRenderer.enabled = false;
            needsRedraw = true; // Needs redraw next time it's shown
        }
    }

    void DrawCircle()
    {
        if (lineRenderer == null || segments <= 2 || radius <= 0f) {
            lineRenderer.positionCount = 0; // Clear points if invalid params
            return;
        };

        // Only resize array if segment count changes (optimization)
        if (lineRenderer.positionCount != segments + 1) {
            lineRenderer.positionCount = segments + 1;
        }

        float angleStep = 360f / segments;
        Vector3[] points = new Vector3[segments + 1];

        for (int i = 0; i <= segments; i++)
        {
            float currentAngle = Mathf.Deg2Rad * (i * angleStep);
            float x = Mathf.Cos(currentAngle) * radius;
            float y = Mathf.Sin(currentAngle) * radius;
            points[i] = new Vector3(x, y, 0); // Z is 0 for local space relative to transform
        }

        lineRenderer.SetPositions(points);
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\ShadowPartController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/ShadowPartController.cs
using UnityEngine;
// using UnityEngine.Rendering; // Not needed for this simple fade

[RequireComponent(typeof(SpriteRenderer))]
public class ShadowPartController : MonoBehaviour
{
    private SpriteRenderer shadowRenderer;
    private SpriteRenderer plantPartRenderer;
    private Transform plantPartTransform;
    private Transform shadowRootTransform;
    private PlantShadowController mainShadowController;
    // Removed: initialLocalPosition - not needed for distance calc

    void Awake()
    {
        shadowRenderer = GetComponent<SpriteRenderer>();
        shadowRenderer.drawMode = SpriteDrawMode.Simple;
        shadowRenderer.enabled = false;
    }

    public void Initialize(SpriteRenderer targetPlantPartRenderer, PlantShadowController controller)
    {
        if (targetPlantPartRenderer == null || controller == null) { Destroy(gameObject); return; }
        plantPartRenderer = targetPlantPartRenderer;
        plantPartTransform = targetPlantPartRenderer.transform;
        mainShadowController = controller;
        shadowRootTransform = controller.transform;

        shadowRenderer.sortingLayerID = mainShadowController.ShadowSortingLayer;
        shadowRenderer.sortingOrder = mainShadowController.ShadowSortingOrder;
        // Color is now set in LateUpdate to include fade alpha

        transform.SetParent(shadowRootTransform, true); // Parent first

        shadowRenderer.enabled = plantPartRenderer.enabled && plantPartRenderer.sprite != null;
        // Initialize color with potentially full alpha
        UpdateColorAndFade();
    }

    void LateUpdate()
    {
        if (plantPartRenderer == null || !plantPartRenderer.enabled || plantPartRenderer.sprite == null || shadowRenderer == null || mainShadowController == null)
        {
            if (shadowRenderer != null) shadowRenderer.enabled = false;
            return;
        }

        shadowRenderer.enabled = true;

        // 1. Sync Sprite
        shadowRenderer.sprite = plantPartRenderer.sprite;

        // 2. Sync Position & Rotation (Relative to Shadow Root) - Unchanged
        Vector3 plantPartPosRelativeToPlantRoot = plantPartTransform.parent.InverseTransformPoint(plantPartTransform.position);
        transform.localPosition = plantPartPosRelativeToPlantRoot;
        transform.localRotation = plantPartTransform.localRotation;

        // 3. Sync Flip - Unchanged
        shadowRenderer.flipX = plantPartRenderer.flipX;
        shadowRenderer.flipY = plantPartRenderer.flipY;

        // 4. Sync Scale (relative to parent) - Unchanged
        transform.localScale = plantPartTransform.localScale;

        // 5. Update Color & Apply Distance Fade
        UpdateColorAndFade();
    }

    // <<< NEW METHOD >>>
    private void UpdateColorAndFade()
    {
        if(mainShadowController == null || shadowRenderer == null) return;

        Color baseShadowColor = mainShadowController.ShadowColor;
        float finalAlpha = baseShadowColor.a; // Start with the controller's base alpha

        // Apply distance fade if enabled
        if (mainShadowController.EnableDistanceFade)
        {
            float distance = Vector3.Distance(transform.position, shadowRootTransform.position); // Distance from shadow part to shadow root

            float fadeStart = mainShadowController.FadeStartDistance;
            float fadeEnd = mainShadowController.FadeEndDistance;
            float minAlpha = mainShadowController.MinFadeAlpha;

            if (distance >= fadeEnd)
            {
                finalAlpha *= minAlpha; // Apply min alpha
            }
            else if (distance > fadeStart)
            {
                // Calculate interpolation factor (0 at start, 1 at end)
                float t = Mathf.InverseLerp(fadeStart, fadeEnd, distance);
                // Lerp between 1 (full alpha multiplier) and minAlpha
                float distanceAlphaMultiplier = Mathf.Lerp(1f, minAlpha, t);
                finalAlpha *= distanceAlphaMultiplier; // Modulate base alpha
            }
            // Else (distance <= fadeStart), finalAlpha remains baseShadowColor.a
        }

        // Set the final color with calculated alpha
        shadowRenderer.color = new Color(baseShadowColor.r, baseShadowColor.g, baseShadowColor.b, finalAlpha);
    }
    // <<< END NEW METHOD >>>


    public void OnPlantPartDestroyed() // Unchanged
    {
         if (this != null && gameObject != null) { if (Application.isPlaying) { Destroy(gameObject); } else { DestroyImmediate(gameObject); } }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\WaterReflection.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/WaterReflection.cs
using UnityEngine;
using UnityEngine.Tilemaps;
using System.Collections.Generic; // Keep for potential future extensions, not strictly needed now

public class WaterReflection : MonoBehaviour
{
    // --- SECTION: Override Toggles ---
    [System.Serializable]
    public class OverrideSettings
    {
        [Tooltip("If checked, the local 'Reflection Opacity' value will be used instead of the global manager's default.")]
        public bool reflectionOpacity = false;
        [Tooltip("If checked, the local 'Reflection Tint' value will be used instead of the global manager's default.")]
        public bool reflectionTint = false;
        [Tooltip("If checked, the local 'Gradient Fade Base Material' will be used. Otherwise, manager's default is used.")]
        public bool gradientFadeBaseMaterial = false;
        [Tooltip("If checked, the local 'Sorting Order Offset' value will be used instead of the global manager's default.")]
        public bool sortingOrderOffset = false;
        [Tooltip("If checked, the local 'Use Water Masking' value will be used instead of the global manager's default.")]
        public bool useWaterMasking = false;
        [Tooltip("If checked, the local 'Water Tilemap Tag' value will be used instead of the global manager's default.")]
        public bool waterTilemapTag = false;
        [Tooltip("If checked, the local 'Show Debug Info' value will be used instead of the global manager's default.")]
        public bool showDebugInfo = false;
    }
    [Header("Overrides (Global Defaults from WaterReflectionManager)")]
    [SerializeField] private OverrideSettings overrides;


    // --- SECTION: Local Settings (Used if Overridden) ---
    [Header("Reflection Source")]
    [Tooltip("If true, Y Offset and Distance Fade calculations will be relative to this GameObject's parent. If false (default), relative to this GameObject.")]
    [SerializeField] private bool useParentAsReference = false; // This remains a local setting

    [Header("Local Reflection Settings (If Overridden)")]
    [Tooltip("Vertical offset of the reflection. Interpretation depends on 'Use Parent As Reference'.")]
    [SerializeField] private float yOffset = -1f; // This remains a local setting

    [Tooltip("Local opacity of the reflection (0 = invisible, 1 = fully opaque)")]
    [SerializeField] [Range(0f, 1f)] private float localReflectionOpacity = 0.5f;

    [Tooltip("Local additional tint color for the reflection")]
    [SerializeField] private Color localReflectionTint = Color.white;

    [Header("Local Distance Fade (If Overridden)")]
    [Tooltip("Enable fading reflection. Requires 'Gradient Fade Base Material' (local or global) to be assigned.")]
    [SerializeField] private bool enableDistanceFade = true; // This remains local as it depends on material
    [Tooltip("Vertical distance from the reference Y where fade starts.")]
    [SerializeField] private float fadeStartDistance = 0.0f; // Local
    [Tooltip("Vertical distance from the reference Y where reflection becomes min alpha.")]
    [SerializeField] private float fadeEndDistance = 1.0f; // Local
    [Tooltip("Minimum alpha when fully faded.")]
    [SerializeField] [Range(0f, 1f)] private float minFadeAlpha = 0.0f; // Local
    [Tooltip("Local override for the gradient fade material. If unassigned and override is false, uses manager's default.")]
    [SerializeField] private Material localGradientFadeBaseMaterial;

    [Header("Local Sorting (If Overridden)")]
    [Tooltip("Local sorting order offset for the reflection")]
    [SerializeField] private int localSortingOrderOffset = -1;

    [Header("Local Water Masking (If Overridden)")]
    [Tooltip("Local override for using water masking")]
    [SerializeField] private bool localUseWaterMasking = true;
    [Tooltip("Local override for the water tilemap tag")]
    [SerializeField] private string localWaterTilemapTag = "Water";

    [Header("Local Debug (If Overridden)")]
    [SerializeField] private bool localShowDebugInfo = false;


    // --- Internal References ---
    private SpriteRenderer originalRenderer;
    private Animator originalAnimator;
    private GameObject reflectionObject;
    private SpriteRenderer reflectionRenderer;
    private Animator reflectionAnimator;
    private Material reflectionMaterialInstance; // Instanced material for this reflection

    // --- Resolved Settings (from Manager or Local) ---
    private float _actualReflectionOpacity;
    private Color _actualReflectionTint;
    private Material _actualGradientFadeBaseMaterial;
    private int _actualSortingOrderOffset;
    private bool _actualUseWaterMasking;
    private string _actualWaterTilemapTag;
    private bool _actualShowDebugInfo;


    // --- Cached Values for Optimization ---
    private Sprite lastSprite;
    private Color lastOriginalColor;
    private bool lastFlipX, lastFlipY;
    private bool lastEnabled;
    private Vector3 lastScale;
    private Vector3 lastPosition;
    private float lastParentY;

    void Awake()
    {
        ResolveSettings(); // Determine actual settings to use

        originalRenderer = GetComponent<SpriteRenderer>();
        originalAnimator = GetComponent<Animator>();

        if (originalRenderer == null)
        {
            if (_actualShowDebugInfo) Debug.LogError($"[WaterReflection] No SpriteRenderer found on {gameObject.name}! Component disabled.", this);
            enabled = false;
            return;
        }

        if (useParentAsReference && transform.parent == null)
        {
            if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] 'Use Parent As Reference' is true on {gameObject.name}, but it has no parent. Will use self as reference.", this);
            useParentAsReference = false;
        }

        if (Application.isPlaying)
        {
            if (enableDistanceFade && _actualGradientFadeBaseMaterial == null)
            {
                 if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection Awake] '{gameObject.name}': 'Enable Distance Fade' is true, but no 'Gradient Fade Base Material' (local or global) is assigned/found. Distance fade will not use the custom shader.", this);
            }
        }

        CreateReflectionObject();

        if (_actualUseWaterMasking)
        {
            SetupWaterMaskingInteraction();
        }
    }
    
    void ResolveSettings()
    {
        if (WaterReflectionManager.Instance != null)
        {
            _actualReflectionOpacity = overrides.reflectionOpacity ? localReflectionOpacity : WaterReflectionManager.Instance.defaultReflectionOpacity;
            _actualReflectionTint = overrides.reflectionTint ? localReflectionTint : WaterReflectionManager.Instance.defaultReflectionTint;
            _actualGradientFadeBaseMaterial = overrides.gradientFadeBaseMaterial ? localGradientFadeBaseMaterial : WaterReflectionManager.Instance.defaultGradientFadeMaterial;
            _actualSortingOrderOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : WaterReflectionManager.Instance.defaultSortingOrderOffset;
            _actualUseWaterMasking = overrides.useWaterMasking ? localUseWaterMasking : WaterReflectionManager.Instance.defaultUseWaterMasking;
            _actualWaterTilemapTag = overrides.waterTilemapTag && !string.IsNullOrEmpty(localWaterTilemapTag) ? localWaterTilemapTag : WaterReflectionManager.Instance.defaultWaterTilemapTag;
            _actualShowDebugInfo = overrides.showDebugInfo ? localShowDebugInfo : WaterReflectionManager.Instance.globalShowDebugInfo;
        }
        else // Fallback if no manager in scene
        {
            _actualReflectionOpacity = localReflectionOpacity;
            _actualReflectionTint = localReflectionTint;
            _actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
            _actualSortingOrderOffset = localSortingOrderOffset;
            _actualUseWaterMasking = localUseWaterMasking;
            _actualWaterTilemapTag = localWaterTilemapTag;
            _actualShowDebugInfo = localShowDebugInfo;
            if (Application.isPlaying) Debug.LogWarning("[WaterReflection] WaterReflectionManager not found in scene. Using local settings for all reflections.", this);
        }
    }


    void Start()
    {
        UpdateReflectionVisuals();
        UpdateReflectionTransform();
        CacheCurrentState();
    }

    void LateUpdate()
    {
        if (originalRenderer == null || reflectionObject == null)
        {
            if (reflectionObject != null) reflectionObject.SetActive(false);
            return;
        }
        UpdateReflectionTransform();
        if (HasVisualStateChanged())
        {
            UpdateReflectionVisuals();
            CacheCurrentState();
        }
    }

    private void CreateReflectionObject()
    {
        reflectionObject = new GameObject($"{gameObject.name}_Reflection");
        reflectionObject.transform.SetParent(transform.parent, false);
        reflectionObject.transform.SetSiblingIndex(transform.GetSiblingIndex() + 1);

        reflectionRenderer = reflectionObject.AddComponent<SpriteRenderer>();
        reflectionRenderer.sortingLayerName = originalRenderer.sortingLayerName;
        reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + _actualSortingOrderOffset; // Use resolved
        reflectionRenderer.drawMode = originalRenderer.drawMode;

        if (enableDistanceFade && _actualGradientFadeBaseMaterial != null) // Use resolved
        {
            reflectionMaterialInstance = new Material(_actualGradientFadeBaseMaterial);
            reflectionRenderer.material = reflectionMaterialInstance;
            if (_actualShowDebugInfo && Application.isPlaying) Debug.Log($"[{gameObject.name}] Instantiated gradient material for reflection using '{_actualGradientFadeBaseMaterial.name}'.", this);
        }
        else
        {
            reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
            if (enableDistanceFade && _actualGradientFadeBaseMaterial == null && _actualShowDebugInfo && Application.isPlaying)
            {
                 Debug.Log($"[{gameObject.name}] Using sharedMaterial for reflection as no gradientFadeBaseMaterial (local or global) was resolved during CreateReflectionObject.", this);
            }
        }

        if (originalAnimator != null)
        {
            reflectionAnimator = reflectionObject.AddComponent<Animator>();
            reflectionAnimator.runtimeAnimatorController = originalAnimator.runtimeAnimatorController;
        }
        SortableEntity originalSortable = GetComponent<SortableEntity>();
        if (originalSortable != null)
        {
            reflectionObject.AddComponent<SortableEntity>();
        }
        if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Created reflection for {gameObject.name}", this);
    }

    private void UpdateReflectionTransform()
    {
        if (reflectionObject == null || originalRenderer == null) return;
        Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
        Vector3 originalWorldPos = transform.position;
        Vector3 reflectionWorldPos = originalWorldPos;
        float referenceYForOffset = referenceTransform.position.y;
        reflectionWorldPos.y = referenceYForOffset + yOffset - (originalWorldPos.y - referenceYForOffset);
        reflectionObject.transform.position = reflectionWorldPos;
        reflectionObject.transform.rotation = transform.rotation;
        reflectionObject.transform.localScale = transform.localScale;
        Vector3 currentLocalScale = reflectionObject.transform.localScale;
        currentLocalScale.y *= -1;
        reflectionObject.transform.localScale = currentLocalScale;
    }

    private void UpdateReflectionVisuals()
    {
        if (reflectionRenderer == null || originalRenderer == null) return;

        reflectionRenderer.sprite = originalRenderer.sprite;
        reflectionRenderer.flipX = originalRenderer.flipX;
        reflectionRenderer.flipY = originalRenderer.flipY;

        Color baseOriginalSpriteColor = originalRenderer.color;
        Color finalReflectionTintedColor = baseOriginalSpriteColor * _actualReflectionTint; // Use resolved
        float finalCombinedAlpha = baseOriginalSpriteColor.a * _actualReflectionOpacity; // Use resolved
        reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);

        if (enableDistanceFade && reflectionMaterialInstance != null)
        {
            Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
            float waterSurfaceY = referenceTransform.position.y;
            reflectionMaterialInstance.SetFloat("_FadeStart", fadeStartDistance);
            reflectionMaterialInstance.SetFloat("_FadeEnd", fadeEndDistance);
            reflectionMaterialInstance.SetFloat("_MinAlpha", minFadeAlpha);
            reflectionMaterialInstance.SetFloat("_OriginalY", waterSurfaceY);
            Color materialBaseColor = _actualReflectionTint; // Use resolved
            materialBaseColor.a = _actualReflectionOpacity * baseOriginalSpriteColor.a; // Use resolved
            reflectionMaterialInstance.SetColor("_Color", materialBaseColor);
        }
        else if (!enableDistanceFade && reflectionMaterialInstance != null)
        {
            reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
            Destroy(reflectionMaterialInstance);
            reflectionMaterialInstance = null;
        }

        reflectionRenderer.enabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;

        if (reflectionAnimator != null && originalAnimator != null)
        {
            reflectionAnimator.enabled = originalAnimator.enabled;
            if (originalAnimator.runtimeAnimatorController != null && originalAnimator.parameterCount > 0)
            {
                foreach (AnimatorControllerParameter param in originalAnimator.parameters)
                {
                    try {
                        switch (param.type)
                        {
                            case AnimatorControllerParameterType.Bool:
                                reflectionAnimator.SetBool(param.name, originalAnimator.GetBool(param.name));
                                break;
                            case AnimatorControllerParameterType.Float:
                                reflectionAnimator.SetFloat(param.name, originalAnimator.GetFloat(param.name));
                                break;
                            case AnimatorControllerParameterType.Int:
                                reflectionAnimator.SetInteger(param.name, originalAnimator.GetInteger(param.name));
                                break;
                        }
                    } catch (System.Exception e) {
                        if(_actualShowDebugInfo) Debug.LogWarning($"Failed to sync animator param '{param.name}': {e.Message}", reflectionAnimator);
                    }
                }
            }
        }
    }

    private bool HasVisualStateChanged()
    {
        if (originalRenderer == null) return false;
        bool parentYChanged = false;
        if (useParentAsReference && transform.parent != null)
        {
            parentYChanged = !Mathf.Approximately(lastParentY, transform.parent.position.y);
        }
        return lastSprite != originalRenderer.sprite ||
               !ColorsApproximatelyEqual(lastOriginalColor, originalRenderer.color) ||
               lastFlipX != originalRenderer.flipX ||
               lastFlipY != originalRenderer.flipY ||
               lastEnabled != (originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy) ||
               lastScale != transform.localScale ||
               lastPosition != transform.position ||
               parentYChanged;
    }

    private void CacheCurrentState()
    {
        if (originalRenderer == null) return;
        lastSprite = originalRenderer.sprite;
        lastOriginalColor = originalRenderer.color;
        lastFlipX = originalRenderer.flipX;
        lastFlipY = originalRenderer.flipY;
        lastEnabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;
        lastScale = transform.localScale;
        lastPosition = transform.position;
        if (useParentAsReference && transform.parent != null)
        {
            lastParentY = transform.parent.position.y;
        }
    }

    private bool ColorsApproximatelyEqual(Color c1, Color c2, float tolerance = 0.001f)
    {
        return Mathf.Abs(c1.r - c2.r) < tolerance &&
               Mathf.Abs(c1.g - c2.g) < tolerance &&
               Mathf.Abs(c1.b - c2.b) < tolerance &&
               Mathf.Abs(c1.a - c2.a) < tolerance;
    }

    private void SetupWaterMaskingInteraction()
    {
        if (!_actualUseWaterMasking || reflectionRenderer == null) return; // Use resolved
        GameObject waterTilemapGO = FindWaterTilemapByTag(); // FindWaterTilemapByTag will use resolved tag
        if (waterTilemapGO == null)
        {
            if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Water tilemap for masking not found on {gameObject.name} using tag '{_actualWaterTilemapTag}'. Masking disabled.", this);
            // _actualUseWaterMasking = false; // Don't change resolved setting here, just don't apply mask
            return;
        }
        SpriteMask maskComponent = waterTilemapGO.GetComponent<SpriteMask>();
        if (maskComponent == null)
        {
            maskComponent = waterTilemapGO.AddComponent<SpriteMask>();
            maskComponent.sprite = null;
            if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Added SpriteMask to water tilemap '{waterTilemapGO.name}' for object '{gameObject.name}'.", waterTilemapGO);
        }
        reflectionRenderer.maskInteraction = SpriteMaskInteraction.VisibleInsideMask;
        if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Reflection of '{gameObject.name}' will be masked by '{waterTilemapGO.name}'.", this);
    }

    private GameObject FindWaterTilemapByTag()
    {
        // Uses _actualWaterTilemapTag which is resolved in Awake
        if (string.IsNullOrEmpty(_actualWaterTilemapTag)) return FindWaterTilemapFallback();
        GameObject taggedWater = GameObject.FindGameObjectWithTag(_actualWaterTilemapTag);
        if (taggedWater != null && taggedWater.GetComponent<Tilemap>() != null)
        {
            if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Found water tilemap by tag '{_actualWaterTilemapTag}': {taggedWater.name} for {gameObject.name}", this);
            return taggedWater;
        }
        if (taggedWater != null && taggedWater.GetComponent<Tilemap>() == null && _actualShowDebugInfo)
        {
            Debug.LogWarning($"[WaterReflection] GameObject '{taggedWater.name}' (tag '{_actualWaterTilemapTag}') has no Tilemap component!", this);
        }
        return FindWaterTilemapFallback();
    }

    private GameObject FindWaterTilemapFallback()
    {
        if (TileInteractionManager.Instance != null)
        {
            var mappings = TileInteractionManager.Instance.tileDefinitionMappings;
            if (mappings != null)
            {
                foreach (var mapping in mappings)
                {
                    if (mapping?.tileDef != null && mapping.tilemapModule != null && mapping.tileDef.isWaterTile)
                    {
                        Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                        if (renderTilemapTransform != null && renderTilemapTransform.GetComponent<Tilemap>() != null)
                        {
                            if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Auto-detected water tilemap via TIM: {renderTilemapTransform.name} for {gameObject.name}", this);
                            return renderTilemapTransform.gameObject;
                        }
                    }
                }
            }
        }
        if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Could not auto-detect water tilemap via TileInteractionManager for {gameObject.name}.", this);
        return null;
    }

    void OnDestroy()
    {
        if (reflectionObject != null)
        {
            if (Application.isPlaying) Destroy(reflectionObject);
            else DestroyImmediate(reflectionObject);
        }
        if (reflectionMaterialInstance != null)
        {
            if (Application.isPlaying) Destroy(reflectionMaterialInstance);
            else DestroyImmediate(reflectionMaterialInstance);
        }
    }

    void OnValidate()
    {
        // In OnValidate, we don't have access to the Manager's instance easily,
        // so we'll primarily validate local settings.
        // The ResolveSettings() call in Awake will handle combining with manager settings at runtime.
        if (Application.isEditor && !Application.isPlaying)
        {
            // Check if local material is needed but missing
            bool localMaterialNeeded = enableDistanceFade && (!overrides.gradientFadeBaseMaterial || localGradientFadeBaseMaterial == null);
            bool globalMaterialMightBeUsed = enableDistanceFade && !overrides.gradientFadeBaseMaterial && localGradientFadeBaseMaterial == null;

            if (localMaterialNeeded && !globalMaterialMightBeUsed) // Warn if local override is on but local material missing
            {
                 Debug.LogWarning($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true and 'Override Gradient Material' is true, but 'Local Gradient Fade Base Material' is not assigned. Assign local material or uncheck override.", this);
            }
            else if (globalMaterialMightBeUsed) // Inform that global will be used if local isn't set
            {
                 Debug.Log($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true. If 'Local Gradient Fade Base Material' remains unassigned and override is false, the global default from WaterReflectionManager will be used in Play mode.", this);
            }


            // Basic visual update for editor preview if possible
            if (reflectionRenderer != null && originalRenderer != null)
            {
                // Determine settings as best as possible for editor preview (without manager)
                Color previewTint = overrides.reflectionTint ? localReflectionTint : Color.white; // Default to white if no manager
                float previewOpacity = overrides.reflectionOpacity ? localReflectionOpacity : 0.5f;
                int previewSortOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : -1;

                reflectionRenderer.sprite = originalRenderer.sprite;
                reflectionRenderer.flipX = originalRenderer.flipX;
                reflectionRenderer.flipY = originalRenderer.flipY;
                reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + previewSortOffset;
                Color baseOriginalSpriteColor = originalRenderer.color;
                Color finalReflectionTintedColor = baseOriginalSpriteColor * previewTint;
                float finalCombinedAlpha = baseOriginalSpriteColor.a * previewOpacity;
                reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);
                UpdateReflectionTransform(); // Keep transform updated
            }
        }
    }


    // --- Public Methods for Runtime Control (Could be removed if not needed, or kept for dynamic changes) ---
    public void SetLocalReflectionOpacity(float opacity) // Example of changing a local-only value
    {
        localReflectionOpacity = Mathf.Clamp01(opacity);
        if (overrides.reflectionOpacity) // Only re-resolve and update if this local value is being used
        {
            ResolveSettings();
            if (Application.isPlaying && originalRenderer != null) UpdateReflectionVisuals();
        }
    }
    // Add more setters if you need to programmatically change local override values and have them take effect.
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\WaterReflectionManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/Managers/WaterReflectionManager.cs
using UnityEngine;

public class WaterReflectionManager : MonoBehaviour
{
    public static WaterReflectionManager Instance { get; private set; }

    [Header("Global Default Reflection Settings")]
    [Tooltip("Default material to use for reflections if 'Enable Distance Fade' is true and no specific material is assigned on the WaterReflection component. Assign your 'Custom/WaterReflectionGradient' material asset here.")]
    public Material defaultGradientFadeMaterial;

    [Tooltip("Default opacity for all reflections (0 = invisible, 1 = fully opaque). Can be overridden per instance.")]
    [Range(0f, 1f)] public float defaultReflectionOpacity = 0.5f;

    [Tooltip("Default additional tint color for all reflections. Can be overridden per instance.")]
    public Color defaultReflectionTint = Color.white;

    [Tooltip("Default sorting order offset for reflections (usually negative). Can be overridden per instance.")]
    public int defaultSortingOrderOffset = -1;

    [Header("Global Default Water Masking Settings")]
    [Tooltip("Default setting for whether to use water masking. Can be overridden per instance.")]
    public bool defaultUseWaterMasking = true;

    [Tooltip("Default tag used to identify the water tilemap. Can be overridden per instance.")]
    public string defaultWaterTilemapTag = "Water";

    [Header("Global Debug Settings")]
    [Tooltip("Enable debug logs for all WaterReflection instances that don't override this.")]
    public bool globalShowDebugInfo = false;


    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Debug.LogWarning($"[WaterReflectionManager] Duplicate instance found on {gameObject.name}. Destroying self.", gameObject);
            Destroy(gameObject);
            return;
        }
        Instance = this;

        if (defaultGradientFadeMaterial == null)
        {
            Debug.LogWarning("[WaterReflectionManager] Default Gradient Fade Material is not assigned. Distance fade may not work correctly for reflections that don't have their own material specified.", this);
        }
    }
}





--------------------------------------------------------------------------------
This is the final part (9 of 9).
--------------------------------------------------------------------------------