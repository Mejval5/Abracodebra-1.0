This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-05-29 10:42:16
PART 5 OF 10
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantOutline.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── Panels
│   │       │   ├── Panel_DropZone.prefab
│   │       │   ├── Panel_GeneListItem.prefab
│   │       │   ├── Panel_GeneSequenceItem.prefab
│   │       │   ├── Panel_SeedListItem.prefab
│   │       │   └── Panel_SeedSelectionButton.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   ├── PLANTOTRON_Machine.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           ├── DualGridRuleTile_Grass.asset
│           └── DualGridRuleTile_Water.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_PoopFertilizer.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Seeds
│   │   └── SeedDefinition_000_Base.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       ├── Wave_001.asset
│       └── Wave_002.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── LeafData.cs
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.Cell.cs
│   │   │   ├── PlantGrowth.Growth.cs
│   │   │   ├── PlantGrowth.NodeExecution.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── SlowdownZone.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   ├── Seeds
│   │   │   ├── PlantotronGeneItem.cs
│   │   │   ├── PlantotronGeneSequenceItem.cs
│   │   │   ├── PlantotronMachine.cs
│   │   │   ├── PlantotronSeedItem.cs
│   │   │   ├── PlantotronSequenceDropZone.cs
│   │   │   ├── PlantotronUI.cs
│   │   │   ├── PlayerGeneticsInventory.cs
│   │   │   ├── SeedDefinition.cs
│   │   │   ├── SeedInstance.cs
│   │   │   ├── SeedSelectionButton.cs
│   │   │   └── SeedSelectionUI.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManager.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── OutlinePartController.cs
│       ├── PixelPerfectSetup.cs
│       ├── PlantOutlineController.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       ├── ShadowPartController.cs
│       ├── WaterReflection.cs
│       └── WaterReflectionManager.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Custom_WaterReflectionGradient.mat
│   ├── Sprite-Lit-Advanced_Overlay_Base.mat
│   ├── Sprite-Lit-Default_OverlayAdvanced.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   ├── SpriteEmissiveUnlit.shader
│   ├── WaterReflection.shader
│   └── WaterReflectionSimple.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Runtime/NodeExecutor.cs (UPDATED for Seed System)
using System.Collections.Generic;
using UnityEngine;
using TMPro;
using System.Linq;

public class NodeExecutor : MonoBehaviour
{
    [Header("Plant Spawning")]
    [SerializeField] private GameObject plantPrefab;
    [SerializeField] private GardenerController gardener;

    [Header("UI References (Legacy Support)")]
    [SerializeField] private NodeEditorGridController nodeEditorGrid; // Keep for fallback

    [Header("Debugging")]
    [SerializeField] private TMP_Text debugOutput;
    [SerializeField] private bool showDebugLogs = false;

    private void Update()
    {
        // Legacy spacebar planting (now shows seed selection)
        if (Input.GetKeyDown(KeyCode.Space))
        {
            AttemptPlantingWithSeedSelection();
        }
    }

    /// <summary>
    /// NEW: Attempts to plant using seed selection system
    /// </summary>
    public void AttemptPlantingWithSeedSelection()
    {
        // Validate basic requirements
        if (!ValidateBasicPlantingRequirements())
            return;

        // Use seed selection UI
        if (SeedSelectionUI.Instance != null)
        {
            SeedSelectionUI.Instance.AttemptAutoSelection(OnSeedSelectedForPlanting);
        }
        else
        {
            DebugLogError("Seed Selection UI not found! Cannot plant with seed selection.");
            // Fallback to legacy system
            SpawnPlantFromUIGraph();
        }
    }

    /// <summary>
    /// NEW: Called when a seed is selected for planting
    /// </summary>
    private void OnSeedSelectedForPlanting(SeedInstance selectedSeed)
    {
        if (selectedSeed == null)
        {
            DebugLogError("Selected seed is null!");
            return;
        }

        bool success = SpawnPlantFromSeedInstance(selectedSeed);
        
        if (success)
        {
            // Remove the seed from inventory (it was planted)
            if (PlayerGeneticsInventory.Instance != null)
            {
                PlayerGeneticsInventory.Instance.RemoveSeed(selectedSeed);
                DebugLog($"Planted and consumed seed: {selectedSeed.seedName}");
            }
        }
    }

    /// <summary>
    /// NEW: Spawns a plant from a SeedInstance
    /// </summary>
    public bool SpawnPlantFromSeedInstance(SeedInstance seedInstance)
    {
        // Validate seed instance
        if (seedInstance == null)
        {
            DebugLogError("Cannot spawn plant: SeedInstance is null!");
            return false;
        }

        if (!seedInstance.IsValidForPlanting())
        {
            DebugLogError($"Cannot spawn plant: Seed '{seedInstance.seedName}' is not valid for planting!");
            return false;
        }

        // Validate basic requirements
        if (!ValidateBasicPlantingRequirements())
            return false;

        DebugLog($"Spawning plant from seed: {seedInstance.seedName}");

        // Convert seed to NodeGraph
        NodeGraph graphToSpawn = seedInstance.ToNodeGraph();
        
        if (graphToSpawn == null || graphToSpawn.nodes == null || graphToSpawn.nodes.Count == 0)
        {
            DebugLogError($"Failed to convert seed '{seedInstance.seedName}' to NodeGraph!");
            return false;
        }

        // Spawn the plant
        return SpawnPlantFromNodeGraph(graphToSpawn, seedInstance.seedName);
    }

    /// <summary>
    /// LEGACY: Spawns plant from UI graph (kept for backward compatibility)
    /// </summary>
    public void SpawnPlantFromUIGraph()
    {
        // --- Validations ---
        if (nodeEditorGrid == null) { DebugLogError("Node Editor Grid Controller not assigned!"); return; }
        if (!ValidateBasicPlantingRequirements()) return;

        // Get the current graph state from the UI grid
        NodeGraph graphToSpawn = nodeEditorGrid.GetCurrentUIGraph();

        if (graphToSpawn == null || graphToSpawn.nodes == null || graphToSpawn.nodes.Count == 0) {
             DebugLog("No nodes in UI graph to spawn.");
             return;
        }

        // Validate if the graph is spawnable
        bool seedFound = graphToSpawn.nodes.Any(node => node != null && node.effects != null && 
            node.effects.Any(eff => eff != null && eff.effectType == NodeEffectType.SeedSpawn && eff.isPassive));
        
        if (!seedFound) {
            DebugLog("Cannot spawn plant: Node chain lacks a passive SeedSpawn effect.");
            return;
        }

        DebugLog($"Spawning plant from UI graph with {graphToSpawn.nodes.Count} nodes...");
        SpawnPlantFromNodeGraph(graphToSpawn, "UI Graph Plant");
    }

    /// <summary>
    /// Core plant spawning logic (used by both new and legacy systems)
    /// </summary>
    private bool SpawnPlantFromNodeGraph(NodeGraph graphToSpawn, string plantName)
    {
        // Determine spawn position and parent
        Vector2 spawnPos = gardener.GetPlantingPosition();
        Transform plantParent = EcosystemManager.Instance?.plantParent;

        // Instantiate the plant prefab
        GameObject plantObj = Instantiate(plantPrefab, spawnPos, Quaternion.identity, plantParent);
        plantObj.name = $"Plant_{plantName}_{System.DateTime.Now:HHmmss}"; // Add timestamp for uniqueness

        // Get the PlantGrowth component
        PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
        if (growthComponent != null)
        {
            // Create a DEEP COPY of the NodeGraph
            NodeGraph graphCopy = CloneNodeGraph(graphToSpawn);

            // Initialize the plant with the deep copy
            growthComponent.InitializeAndGrow(graphCopy);
            DebugLog($"Plant '{plantName}' spawned and initialized successfully.");
            return true;
        }
        else
        {
            // Log error and destroy invalid object if PlantGrowth is missing
            DebugLogError($"Prefab '{plantPrefab.name}' missing PlantGrowth component! Destroying spawned object.");
            Destroy(plantObj);
            return false;
        }
    }

    /// <summary>
    /// Validates basic requirements for planting
    /// </summary>
    private bool ValidateBasicPlantingRequirements()
    {
        if (plantPrefab == null) { DebugLogError("Plant prefab not assigned!"); return false; }
        if (gardener == null) { DebugLogError("Gardener Controller not assigned!"); return false; }
        return true;
    }

    /// <summary>
    /// Creates a deep copy of a NodeGraph
    /// </summary>
    private NodeGraph CloneNodeGraph(NodeGraph original)
    {
        NodeGraph graphCopy = new NodeGraph();
        graphCopy.nodes = new List<NodeData>(original.nodes.Count);

        foreach(NodeData originalNodeData in original.nodes)
        {
            if (originalNodeData == null) {
                DebugLogWarning("Encountered null NodeData in graph during copy. Skipping.");
                continue;
            }

             // Create a new NodeData instance
             NodeData newNodeData = new NodeData {
                nodeId = originalNodeData.nodeId,
                nodeDisplayName = originalNodeData.nodeDisplayName,
                orderIndex = originalNodeData.orderIndex,
                canBeDeleted = originalNodeData.canBeDeleted,
                effects = CloneEffectsList(originalNodeData.effects)
            };
            graphCopy.nodes.Add(newNodeData);
        }

        return graphCopy;
    }

    /// <summary>
    /// Creates a deep copy of a list of NodeEffectData
    /// </summary>
    private List<NodeEffectData> CloneEffectsList(List<NodeEffectData> originalList)
    {
        if (originalList == null) return new List<NodeEffectData>();

        List<NodeEffectData> newList = new List<NodeEffectData>(originalList.Count);
        foreach(var originalEffect in originalList)
        {
            if(originalEffect == null) {
                DebugLogWarning("Encountered null NodeEffectData in list during copy. Skipping.");
                continue;
            }

             NodeEffectData newEffect = new NodeEffectData {
                 effectType = originalEffect.effectType,
                 primaryValue = originalEffect.primaryValue,
                 secondaryValue = originalEffect.secondaryValue,
                 isPassive = originalEffect.isPassive,
                 scentDefinitionReference = originalEffect.scentDefinitionReference
             };
             newList.Add(newEffect);
        }
        return newList;
    }

    // --- Helper methods for logging ---
    private void DebugLog(string msg) {
        if (showDebugLogs) Debug.Log($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += msg + "\n";
    }
    
    private void DebugLogError(string msg) {
        Debug.LogError($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += $"ERROR: {msg}\n";
    }
    
    private void DebugLogWarning(string msg) {
        if (showDebugLogs) Debug.LogWarning($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += $"WARNING: {msg}\n";
    }

    // --- Public API Methods ---

    /// <summary>
    /// Public method for external scripts to plant a specific seed
    /// </summary>
    public bool PlantSeed(SeedInstance seed)
    {
        return SpawnPlantFromSeedInstance(seed);
    }

    /// <summary>
    /// Public method to get available plantable seeds count
    /// </summary>
    public int GetPlantableSeedsCount()
    {
        if (PlayerGeneticsInventory.Instance == null)
            return 0;
            
        return PlayerGeneticsInventory.Instance.GetPlantableSeeds().Count;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes = new List<NodeData>();
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\PlantotronGeneItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Seeds/PlantotronGeneItem.cs (FIXED)
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using TMPro;

public class PlantotronGeneItem : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler, IBeginDragHandler, IDragHandler, IEndDragHandler
{
    [Header("UI References")]
    public TMP_Text geneNameText;
    public TMP_Text geneCountText;
    public Image geneIcon;
    public Button addButton;
    public Image backgroundImage;
    
    [Header("Visual Settings")]
    public Color normalColor = Color.white;
    public Color hoverColor = Color.yellow;
    public Color dragColor = new Color(1f, 0.8f, 0.8f, 1f);
    
    [Header("Drag Settings")]
    public float dragAlpha = 0.6f;
    
    private PlayerGeneticsInventory.GeneCount geneCount;
    private PlantotronUI parentUI;
    private bool isDragging = false;
    private Vector3 originalPosition;
    private Transform originalParent;
    private CanvasGroup canvasGroup;
    private Canvas rootCanvas;
    private RectTransform rectTransform;
    
    // Drag visual clone
    private GameObject dragClone;
    private PlantotronSequenceDropZone currentDropZone;
    
    // FIXED: Add public accessor for the gene
    public NodeDefinition GetGene()
    {
        return geneCount?.gene;
    }
    
    public void Initialize(PlayerGeneticsInventory.GeneCount geneCountData, PlantotronUI ui)
    {
        geneCount = geneCountData;
        parentUI = ui;
        
        if (geneCount?.gene == null || parentUI == null)
        {
            Debug.LogError("[PlantotronGeneItem] Invalid initialization parameters!");
            return;
        }
        
        // Setup components
        rectTransform = GetComponent<RectTransform>();
        canvasGroup = GetComponent<CanvasGroup>();
        if (canvasGroup == null)
            canvasGroup = gameObject.AddComponent<CanvasGroup>();
        
        rootCanvas = GetComponentInParent<Canvas>();
        if (rootCanvas != null)
            rootCanvas = rootCanvas.rootCanvas;
        
        // Setup UI elements
        if (geneNameText != null)
            geneNameText.text = geneCount.gene.displayName;
            
        if (geneCountText != null)
        {
            geneCountText.text = $"x{geneCount.count}";
        }
        
        if (geneIcon != null)
        {
            geneIcon.sprite = geneCount.gene.thumbnail;
            geneIcon.color = geneCount.gene.thumbnailTintColor;
        }
        
        // Setup add button
        if (addButton != null)
        {
            addButton.onClick.RemoveAllListeners();
            addButton.onClick.AddListener(OnAddButtonClicked);
            addButton.interactable = geneCount.count > 0;
        }
        
        // Set initial background color
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
            
        // Store original transform info
        originalPosition = transform.position;
        originalParent = transform.parent;
    }
    
    public void OnPointerEnter(PointerEventData eventData)
    {
        if (!isDragging && backgroundImage != null)
            backgroundImage.color = hoverColor;
            
        if (parentUI != null && geneCount?.gene != null)
            parentUI.ShowGeneDetails(geneCount.gene);
    }
    
    public void OnPointerExit(PointerEventData eventData)
    {
        if (!isDragging && backgroundImage != null)
            backgroundImage.color = normalColor;
    }
    
    public void OnPointerClick(PointerEventData eventData)
    {
        if (parentUI != null && geneCount?.gene != null)
            parentUI.OnGeneClicked(geneCount.gene);
    }
    
    private void OnAddButtonClicked()
    {
        if (parentUI != null && geneCount?.gene != null && geneCount.count > 0)
        {
            parentUI.TryAddGeneToSequence(geneCount.gene);
        }
    }
    
    public void OnBeginDrag(PointerEventData eventData)
    {
        if (geneCount?.count <= 0) return; // Can't drag if no genes available
    
        isDragging = true;
    
        // Visual feedback
        if (backgroundImage != null)
            backgroundImage.color = dragColor;
        if (canvasGroup != null)
            canvasGroup.alpha = dragAlpha;
    
        // Create drag clone for better visual feedback
        CreateDragClone();
    
        // Enable drop zones through parent UI
        if (parentUI != null)
        {
            parentUI.EnableDropZones(true);
            Debug.Log("[PlantotronGeneItem] Enabled drop zones for drag");
        }
    }
    
    public void OnDrag(PointerEventData eventData)
    {
        if (!isDragging || dragClone == null) return;
        
        // Move drag clone to follow cursor
        Vector2 localPoint;
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(
            rootCanvas.transform as RectTransform, 
            eventData.position, 
            rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : rootCanvas.worldCamera, 
            out localPoint))
        {
            dragClone.transform.localPosition = localPoint;
        }
        
        // Check for drop zones
        CheckDropZones(eventData);
    }
    
    public void OnEndDrag(PointerEventData eventData)
    {
        isDragging = false;
    
        // Reset visual state
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
        if (canvasGroup != null)
            canvasGroup.alpha = 1f;
    
        // Clean up drag clone
        if (dragClone != null)
        {
            Destroy(dragClone);
            dragClone = null;
        }
    
        // Disable drop zones through parent UI
        if (parentUI != null)
        {
            parentUI.EnableDropZones(false);
            Debug.Log("[PlantotronGeneItem] Disabled drop zones after drag");
        }
    
        // FIXED: Handle drop using Unity's drop system instead of manual detection
        // The drop will be handled by PlantotronSequenceDropZone.OnDrop
        if (currentDropZone != null)
        {
            currentDropZone.SetHighlight(false);
            currentDropZone = null;
        }
    }
    
    private void CreateDragClone()
    {
        if (rootCanvas == null) return;
        
        // Create a visual clone
        dragClone = Instantiate(gameObject, rootCanvas.transform);
        dragClone.name = gameObject.name + "_DragClone";
        
        // Remove interactive components from clone
        Button[] buttons = dragClone.GetComponentsInChildren<Button>();
        foreach (var btn in buttons)
            btn.interactable = false;
        
        // Make it slightly transparent
        CanvasGroup cloneGroup = dragClone.GetComponent<CanvasGroup>();
        if (cloneGroup == null)
            cloneGroup = dragClone.AddComponent<CanvasGroup>();
        cloneGroup.alpha = 0.8f;
        cloneGroup.blocksRaycasts = false;
        
        // Position at cursor
        dragClone.transform.SetAsLastSibling();
    }
    
    private void CheckDropZones(PointerEventData eventData)
    {
        // Clear current drop zone highlighting
        if (currentDropZone != null)
        {
            currentDropZone.SetHighlight(false);
            currentDropZone = null;
        }
        
        // Check for new drop zone
        var results = new System.Collections.Generic.List<RaycastResult>();
        EventSystem.current.RaycastAll(eventData, results);
        
        foreach (var result in results)
        {
            PlantotronSequenceDropZone dropZone = result.gameObject.GetComponent<PlantotronSequenceDropZone>();
            if (dropZone != null && dropZone.CanAcceptDrop())
            {
                currentDropZone = dropZone;
                dropZone.SetHighlight(true);
                break;
            }
        }
    }
    
    // Update the display when gene count changes
    public void UpdateDisplay()
    {
        if (geneCountText != null && geneCount != null)
        {
            geneCountText.text = $"x{geneCount.count}";
        }
        
        if (addButton != null && geneCount != null)
        {
            addButton.interactable = geneCount.count > 0;
        }
    }
    
    void OnDestroy()
    {
        if (addButton != null)
            addButton.onClick.RemoveAllListeners();
        
        if (dragClone != null)
            Destroy(dragClone);
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\PlantotronGeneSequenceItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Seeds/PlantotronGeneSequenceItem.cs (FIXED)
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using TMPro;

public class PlantotronSequenceItem : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, 
    IBeginDragHandler, IDragHandler, IEndDragHandler, IPointerClickHandler
{
    [Header("UI References")]
    public TMP_Text geneNameText;
    public TMP_Text sequenceIndexText;
    public Image geneIcon;
    public Button removeButton;
    public Image backgroundImage;
    
    [Header("Visual Settings")]
    public Color normalColor = new Color(0.9f, 0.9f, 0.9f, 1f);
    public Color hoverColor = Color.yellow;
    public Color dragColor = new Color(1f, 0.8f, 0.8f, 1f);
    public Color dropTargetColor = new Color(0.8f, 1f, 0.8f, 1f);
    
    [Header("Drag Settings")]
    public float dragAlpha = 0.6f;
    
    private NodeDefinition gene;
    private int sequenceIndex;
    private PlantotronUI parentUI;
    private bool isDragging = false;
    private bool isDropTarget = false;
    private Vector3 originalPosition;
    private Transform originalParent;
    private CanvasGroup canvasGroup;
    private Canvas rootCanvas;
    private GameObject dragClone;
    private PlantotronSequenceItem currentDropTarget;
    
    public void Initialize(NodeDefinition geneDefinition, int index, PlantotronUI ui)
    {
        gene = geneDefinition;
        sequenceIndex = index;
        parentUI = ui;
        
        if (gene == null || parentUI == null)
        {
            Debug.LogError("[PlantotronSequenceItem] Invalid initialization parameters!");
            return;
        }
        
        // Setup components
        canvasGroup = GetComponent<CanvasGroup>();
        if (canvasGroup == null)
            canvasGroup = gameObject.AddComponent<CanvasGroup>();
        
        rootCanvas = GetComponentInParent<Canvas>();
        if (rootCanvas != null)
            rootCanvas = rootCanvas.rootCanvas;
        
        // Setup UI elements
        if (geneNameText != null)
            geneNameText.text = gene.displayName;
            
        if (sequenceIndexText != null)
            sequenceIndexText.text = $"{index + 1}.";
            
        if (geneIcon != null)
        {
            geneIcon.sprite = gene.thumbnail;
            geneIcon.color = gene.thumbnailTintColor;
        }
        
        // Setup remove button
        if (removeButton != null)
        {
            removeButton.onClick.RemoveAllListeners();
            removeButton.onClick.AddListener(OnRemoveButtonClicked);
        }
        
        // Set initial background color
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
            
        // Store original transform info
        originalPosition = transform.position;
        originalParent = transform.parent;
    }
    
    public void OnPointerEnter(PointerEventData eventData)
    {
        if (!isDragging && !isDropTarget && backgroundImage != null)
            backgroundImage.color = hoverColor;
            
        if (parentUI != null && gene != null)
            parentUI.ShowGeneDetails(gene);
    }
    
    public void OnPointerExit(PointerEventData eventData)
    {
        if (!isDragging && !isDropTarget && backgroundImage != null)
            backgroundImage.color = normalColor;
    }
    
    public void OnPointerClick(PointerEventData eventData)
    {
        if (parentUI != null && gene != null)
            parentUI.ShowGeneDetails(gene);
    }
    
    private void OnRemoveButtonClicked()
    {
        if (parentUI != null)
            parentUI.TryRemoveGeneFromSequence(sequenceIndex);
    }
    
    public void OnBeginDrag(PointerEventData eventData)
    {
        isDragging = true;
        
        // Visual feedback
        if (backgroundImage != null)
            backgroundImage.color = dragColor;
        if (canvasGroup != null)
            canvasGroup.alpha = dragAlpha;
        
        // Create drag clone
        CreateDragClone();
        
        // Make this item appear on top during drag
        transform.SetAsLastSibling();
        
        // FIXED: Enable drop zones for internal sequence dragging
        if (parentUI != null)
        {
            parentUI.EnableDropZones(true);
            Debug.Log("[PlantotronSequenceItem] Enabled drop zones for internal sequence drag");
        }
    }
    
    public void OnDrag(PointerEventData eventData)
    {
        if (!isDragging || dragClone == null) return;
        
        // Move drag clone to follow cursor
        Vector2 localPoint;
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(
            rootCanvas.transform as RectTransform, 
            eventData.position, 
            rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : rootCanvas.worldCamera, 
            out localPoint))
        {
            dragClone.transform.localPosition = localPoint;
        }
        
        // Check for drop targets
        CheckDropTargets(eventData);
    }
    
    public void OnEndDrag(PointerEventData eventData)
    {
        isDragging = false;
        
        // Reset visual state
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
        if (canvasGroup != null)
            canvasGroup.alpha = 1f;
        
        // Clean up drag clone
        if (dragClone != null)
        {
            Destroy(dragClone);
            dragClone = null;
        }
        
        // Reset position and parent
        transform.position = originalPosition;
        transform.SetParent(originalParent);
        
        // FIXED: Disable drop zones after dragging
        if (parentUI != null)
        {
            parentUI.EnableDropZones(false);
            Debug.Log("[PlantotronSequenceItem] Disabled drop zones after internal sequence drag");
        }
        
        // Handle drop
        if (currentDropTarget != null && currentDropTarget != this)
        {
            // Swap positions in the gene sequence
            if (parentUI != null)
                parentUI.TryMoveGeneInSequence(this.sequenceIndex, currentDropTarget.sequenceIndex);
            
            currentDropTarget.SetDropTarget(false);
            currentDropTarget = null;
        }
    }
    
    private void CreateDragClone()
    {
        if (rootCanvas == null) return;
        
        // Create a visual clone
        dragClone = Instantiate(gameObject, rootCanvas.transform);
        dragClone.name = gameObject.name + "_DragClone";
        
        // Remove interactive components from clone
        Button[] buttons = dragClone.GetComponentsInChildren<Button>();
        foreach (var btn in buttons)
            btn.interactable = false;
        
        // Make it slightly transparent
        CanvasGroup cloneGroup = dragClone.GetComponent<CanvasGroup>();
        if (cloneGroup == null)
            cloneGroup = dragClone.AddComponent<CanvasGroup>();
        cloneGroup.alpha = 0.8f;
        cloneGroup.blocksRaycasts = false;
        
        // Position at cursor
        dragClone.transform.SetAsLastSibling();
    }
    
    private void CheckDropTargets(PointerEventData eventData)
    {
        // Clear current drop target highlighting
        if (currentDropTarget != null)
        {
            currentDropTarget.SetDropTarget(false);
            currentDropTarget = null;
        }
        
        // Check for new drop target
        var results = new System.Collections.Generic.List<RaycastResult>();
        EventSystem.current.RaycastAll(eventData, results);
        
        foreach (var result in results)
        {
            PlantotronSequenceItem sequenceItem = result.gameObject.GetComponent<PlantotronSequenceItem>();
            if (sequenceItem != null && sequenceItem != this)
            {
                currentDropTarget = sequenceItem;
                sequenceItem.SetDropTarget(true);
                break;
            }
        }
    }
    
    public void SetDropTarget(bool isTarget)
    {
        isDropTarget = isTarget;
        if (backgroundImage != null)
        {
            if (isTarget)
                backgroundImage.color = dropTargetColor;
            else if (!isDragging)
                backgroundImage.color = normalColor;
        }
    }
    
    // Public method to update the sequence index and display
    public void UpdateIndex(int newIndex)
    {
        sequenceIndex = newIndex;
        if (sequenceIndexText != null)
            sequenceIndexText.text = $"{newIndex + 1}.";
            
        // Update original position for drag reset
        originalPosition = transform.position;
    }
    
    public int GetIndex()
    {
        return sequenceIndex;
    }
    
    public NodeDefinition GetGene()
    {
        return gene;
    }
    
    void OnDestroy()
    {
        if (removeButton != null)
            removeButton.onClick.RemoveAllListeners();
        
        if (dragClone != null)
            Destroy(dragClone);
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\PlantotronMachine.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Seeds/PlantotronMachine.cs (FIXED)
using UnityEngine;
using System.Collections;

[RequireComponent(typeof(Collider2D))]
public class PlantotronMachine : MonoBehaviour
{
    [Header("Interaction Settings")]
    [Tooltip("Maximum distance for player interaction")]
    public float interactionRange = 2f;
    
    [Tooltip("Key to press for interaction (default: E)")]
    public KeyCode interactionKey = KeyCode.E;
    
    [Header("UI References")]
    [Tooltip("The Plantotron UI panel to show/hide")]
    public PlantotronUI uiPanel;
    
    [Header("Visual Feedback")]
    [Tooltip("GameObject to show when player is in range (optional)")]
    public GameObject interactionPrompt;
    
    [Tooltip("Highlight material/effect when player is nearby (optional)")]
    public Material highlightMaterial;
    
    [Header("Audio (Optional)")]
    [Tooltip("Sound to play when machine is activated")]
    public AudioClip activationSound;
    
    [Header("Debug")]
    [SerializeField] private bool showDebugLogs = true; // Changed to true for debugging
    
    // Internal state
    private bool playerInRange = false;
    private Transform playerTransform;
    private SpriteRenderer machineRenderer;
    private Material originalMaterial;
    private AudioSource audioSource;
    private bool isUIOpen = false;
    private Coroutine openUICoroutine;
    
    // Cache for player detection
    private const string PLAYER_TAG = "Player";
    
    void Awake()
    {
        // Get components
        machineRenderer = GetComponent<SpriteRenderer>();
        audioSource = GetComponent<AudioSource>();
        
        // Ensure collider is set as trigger
        Collider2D col = GetComponent<Collider2D>();
        if (col != null && !col.isTrigger)
        {
            col.isTrigger = true;
            if (showDebugLogs)
                Debug.Log($"[PlantotronMachine] Set collider on {gameObject.name} to trigger mode");
        }
        
        // Store original material
        if (machineRenderer != null)
        {
            originalMaterial = machineRenderer.material;
        }
        
        // Validate UI panel
        if (uiPanel == null)
        {
            Debug.LogError($"[PlantotronMachine] UI Panel not assigned on {gameObject.name}!", this);
        }
        else
        {
            // CRITICAL FIX: Ensure UI starts properly closed
            if (uiPanel.gameObject.activeSelf)
            {
                uiPanel.gameObject.SetActive(false);
                if (showDebugLogs)
                    Debug.Log("[PlantotronMachine] UI Panel was active in Awake, forcing inactive");
            }
        }
        
        // Hide interaction prompt initially
        if (interactionPrompt != null)
        {
            interactionPrompt.SetActive(false);
        }
    }
    
    void Update()
    {
        // Only check for interaction if player is in range
        if (playerInRange && playerTransform != null)
        {
            // Double-check distance (in case player moved quickly)
            float distance = Vector2.Distance(transform.position, playerTransform.position);
            if (distance <= interactionRange)
            {
                // Check for interaction input
                if (Input.GetKeyDown(interactionKey))
                {
                    ToggleMachine();
                }
            }
            else
            {
                // Player moved out of range
                SetPlayerInRange(false);
            }
        }
    }
    
    void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag(PLAYER_TAG))
        {
            playerTransform = other.transform;
            SetPlayerInRange(true);
            
            if (showDebugLogs)
                Debug.Log($"[PlantotronMachine] Player entered interaction range");
        }
    }
    
    void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag(PLAYER_TAG))
        {
            SetPlayerInRange(false);
            
            if (showDebugLogs)
                Debug.Log($"[PlantotronMachine] Player left interaction range");
        }
    }
    
    private void SetPlayerInRange(bool inRange)
    {
        if (playerInRange == inRange) return;
        
        playerInRange = inRange;
        
        // Update visual feedback
        if (interactionPrompt != null)
        {
            interactionPrompt.SetActive(inRange);
        }
        
        // Update highlight effect
        if (machineRenderer != null && highlightMaterial != null)
        {
            machineRenderer.material = inRange ? highlightMaterial : originalMaterial;
        }
        
        // If player left range while UI is open, close it
        if (!inRange && isUIOpen)
        {
            CloseMachine();
        }
        
        if (!inRange)
        {
            playerTransform = null;
        }
    }
    
    private void ToggleMachine()
    {
        if (uiPanel == null)
        {
            Debug.LogError("[PlantotronMachine] Cannot toggle - UI Panel is null!");
            return;
        }
        
        if (isUIOpen)
        {
            CloseMachine();
        }
        else
        {
            OpenMachine();
        }
    }
    
    private void OpenMachine()
    {
        if (uiPanel == null) return;
        
        if (showDebugLogs)
            Debug.Log("[PlantotronMachine] Opening machine");
        
        // Check if player has genetics inventory
        if (PlayerGeneticsInventory.Instance == null)
        {
            Debug.LogError("[PlantotronMachine] Cannot open - PlayerGeneticsInventory not found!");
            return;
        }
        
        // Stop any existing open coroutine
        if (openUICoroutine != null)
        {
            StopCoroutine(openUICoroutine);
        }
        
        // Start the opening process
        openUICoroutine = StartCoroutine(OpenMachineCoroutine());
    }
    
    private IEnumerator OpenMachineCoroutine()
    {
        isUIOpen = true;
        
        // Activate the UI GameObject first
        if (!uiPanel.gameObject.activeSelf)
        {
            uiPanel.gameObject.SetActive(true);
            if (showDebugLogs)
                Debug.Log("[PlantotronMachine] Activated UI GameObject");
        }
        
        // Wait a frame for the GameObject to be properly activated
        yield return null;
        
        // Now call the UI's OpenUI method
        uiPanel.OpenUI();
        
        // Play activation sound
        if (audioSource != null && activationSound != null)
        {
            audioSource.PlayOneShot(activationSound);
        }
        
        // Optional: Pause the game or disable player movement
        // Time.timeScale = 0f; // Uncomment if you want to pause the game
        
        if (showDebugLogs)
            Debug.Log("[PlantotronMachine] Machine opened successfully");
            
        openUICoroutine = null;
    }
    
    private void CloseMachine()
    {
        if (uiPanel == null) return;
        
        if (showDebugLogs)
            Debug.Log("[PlantotronMachine] Closing machine");
        
        // Stop any opening coroutine
        if (openUICoroutine != null)
        {
            StopCoroutine(openUICoroutine);
            openUICoroutine = null;
        }
        
        isUIOpen = false;
        
        // Close the UI first
        uiPanel.CloseUI();
        
        // Then deactivate the GameObject
        if (uiPanel.gameObject.activeSelf)
        {
            uiPanel.gameObject.SetActive(false);
        }
        
        // Resume the game if it was paused
        // Time.timeScale = 1f; // Uncomment if you paused the game
        
        if (showDebugLogs)
            Debug.Log("[PlantotronMachine] Machine closed");
    }
    
    // Public method for external scripts to open/close the machine
    public void SetMachineOpen(bool open)
    {
        if (open && !isUIOpen)
            OpenMachine();
        else if (!open && isUIOpen)
            CloseMachine();
    }
    
    // Public method to check if machine is currently open
    public bool IsMachineOpen()
    {
        return isUIOpen;
    }
    
    void OnDrawGizmosSelected()
    {
        // Draw interaction range in editor
        Gizmos.color = Color.green;
        Gizmos.DrawWireSphere(transform.position, interactionRange);
        
        // Draw a line to player if in range during play mode
        if (Application.isPlaying && playerTransform != null && playerInRange)
        {
            Gizmos.color = Color.yellow;
            Gizmos.DrawLine(transform.position, playerTransform.position);
        }
    }
    
    void OnDestroy()
    {
        // Clean up
        if (machineRenderer != null && originalMaterial != null)
        {
            machineRenderer.material = originalMaterial;
        }
        
        if (openUICoroutine != null)
        {
            StopCoroutine(openUICoroutine);
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\PlantotronSeedItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Seeds/PlantotronSeedItem.cs (FIXED)
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using TMPro;

public class PlantotronSeedItem : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler
{
    [Header("UI References")]
    public TMP_Text seedNameText;
    public TMP_Text seedStatusText;
    public Image seedIcon;
    public Button selectButton;
    public Button deleteButton;
    public Image backgroundImage;
    
    [Header("Visual Settings")]
    public Color normalColor = Color.white;
    public Color hoverColor = Color.yellow;
    public Color selectedColor = Color.cyan;
    public Color modifiedColor = Color.cyan;
    public Color vanillaColor = Color.green;
    
    private SeedInstance seed;
    private PlantotronUI parentUI;
    
    public void Initialize(SeedInstance seedInstance, PlantotronUI ui)
    {
        seed = seedInstance;
        parentUI = ui;
        
        if (seed == null || parentUI == null)
        {
            Debug.LogError("[PlantotronSeedItem] Invalid initialization parameters!");
            return;
        }
        
        Debug.Log($"[PlantotronSeedItem] Initializing seed item for: {seed.seedName}");
        
        // Setup UI elements
        if (seedNameText != null)
            seedNameText.text = seed.seedName;
            
        if (seedStatusText != null)
        {
            string status = seed.isModified ? "Modified" : "Vanilla";
            int geneCount = seed.currentGenes?.Count ?? 0;
            seedStatusText.text = $"{status} • {geneCount} genes";
            seedStatusText.color = seed.isModified ? modifiedColor : vanillaColor;
        }
        
        if (seedIcon != null && seed.baseSeedDefinition != null)
        {
            seedIcon.sprite = seed.baseSeedDefinition.icon;
        }
        
        // Setup buttons
        if (selectButton != null)
        {
            selectButton.onClick.RemoveAllListeners();
            selectButton.onClick.AddListener(OnSelectButtonClicked);
            Debug.Log($"[PlantotronSeedItem] Select button configured for {seed.seedName}");
        }
        else
        {
            Debug.LogWarning($"[PlantotronSeedItem] Select button is null for {seed.seedName}!");
        }
        
        if (deleteButton != null)
        {
            deleteButton.onClick.RemoveAllListeners();
            deleteButton.onClick.AddListener(OnDeleteButtonClicked);
        }
        
        // Set initial background color
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
        
        Debug.Log($"[PlantotronSeedItem] Successfully initialized: {seed.seedName}");
    }
    
    public void OnPointerEnter(PointerEventData eventData)
    {
        if (backgroundImage != null)
            backgroundImage.color = hoverColor;
            
        if (parentUI != null && seed != null)
            parentUI.ShowSeedDetails(seed);
    }
    
    public void OnPointerExit(PointerEventData eventData)
    {
        if (backgroundImage != null)
            backgroundImage.color = normalColor;
    }
    
    public void OnPointerClick(PointerEventData eventData)
    {
        Debug.Log($"[PlantotronSeedItem] OnPointerClick fired for {seed?.seedName ?? "null seed"}");
        
        if (parentUI != null && seed != null)
        {
            Debug.Log($"[PlantotronSeedItem] Calling OnSeedSelected for {seed.seedName}");
            parentUI.OnSeedSelected(seed);
        }
        else
        {
            Debug.LogError($"[PlantotronSeedItem] OnPointerClick failed - parentUI: {parentUI != null}, seed: {seed != null}");
        }
    }
    
    private void OnSelectButtonClicked()
    {
        Debug.Log($"[PlantotronSeedItem] Select button clicked for {seed?.seedName ?? "null seed"}");
        
        if (parentUI != null && seed != null)
        {
            Debug.Log($"[PlantotronSeedItem] Calling OnSeedSelected from button for {seed.seedName}");
            parentUI.OnSeedSelected(seed);
        }
        else
        {
            Debug.LogError($"[PlantotronSeedItem] Button click failed - parentUI: {parentUI != null}, seed: {seed != null}");
        }
    }
    
    private void OnDeleteButtonClicked()
    {
        Debug.Log($"[PlantotronSeedItem] Delete button clicked for {seed?.seedName ?? "null seed"}");
        
        if (seed != null && PlayerGeneticsInventory.Instance != null)
        {
            PlayerGeneticsInventory.Instance.RemoveSeed(seed);
        }
    }
    
    public void SetSelected(bool isSelected)
    {
        if (backgroundImage != null)
        {
            backgroundImage.color = isSelected ? selectedColor : normalColor;
        }
    }
    
    void OnDestroy()
    {
        if (selectButton != null)
            selectButton.onClick.RemoveAllListeners();
        if (deleteButton != null)
            deleteButton.onClick.RemoveAllListeners();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Seeds\PlantotronSequenceDropZone.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Seeds/PlantotronSequenceDropZone.cs (FIXED)
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class PlantotronSequenceDropZone : MonoBehaviour, IDropHandler
{
    [Header("Visual Settings")]
    public Color normalColor = new Color(0.2f, 0.8f, 0.2f, 0.2f); // Slightly visible green
    public Color highlightColor = new Color(0.2f, 1f, 0.2f, 0.5f); // Bright green when highlighted
    
    private Image backgroundImage;
    private PlantotronUI parentUI;
    private int insertIndex = -1;
    private bool isEnabled = false;
    
    void Awake()
    {
        backgroundImage = GetComponent<Image>();
        if (backgroundImage == null)
        {
            backgroundImage = gameObject.AddComponent<Image>();
        }
        
        // Set initial state - slightly visible so you can see where they are
        backgroundImage.color = normalColor;
        backgroundImage.raycastTarget = true;
        gameObject.SetActive(false); // Start disabled
    }
    
    public void Initialize(PlantotronUI ui, int index)
    {
        parentUI = ui;
        insertIndex = index;
        
        if (parentUI != null)
        {
            Debug.Log($"[PlantotronSequenceDropZone] Initialized drop zone {index}");
        }
    }
    
    public void SetEnabled(bool enabled)
    {
        isEnabled = enabled;
        gameObject.SetActive(enabled);
        
        if (!enabled)
            SetHighlight(false);
            
        Debug.Log($"[PlantotronSequenceDropZone] Zone {insertIndex} enabled: {enabled}");
    }
    
    public void SetHighlight(bool highlight)
    {
        if (backgroundImage != null)
        {
            backgroundImage.color = highlight ? highlightColor : normalColor;
            Debug.Log($"[PlantotronSequenceDropZone] Zone {insertIndex} highlighted: {highlight}");
        }
    }
    
    public bool CanAcceptDrop()
    {
        bool canAccept = isEnabled && parentUI != null && parentUI.GetCurrentSelectedSeed() != null;
        Debug.Log($"[PlantotronSequenceDropZone] Zone {insertIndex} can accept drop: {canAccept}");
        return canAccept;
    }
    
    // OLD METHOD - Keep for compatibility but make it handle both cases
    public void OnGeneDropped(NodeDefinition gene)
    {
        if (parentUI != null && CanAcceptDrop() && gene != null)
        {
            Debug.Log($"[PlantotronSequenceDropZone] Gene {gene.displayName} dropped on zone {insertIndex}");
            parentUI.TryAddGeneToSequence(gene, insertIndex);
        }
    }
    
    // FIXED: New IDropHandler implementation to handle actual drop events
    public void OnDrop(PointerEventData eventData)
    {
        Debug.Log($"[PlantotronSequenceDropZone] OnDrop triggered on zone {insertIndex}");
        
        if (!CanAcceptDrop())
        {
            Debug.Log($"[PlantotronSequenceDropZone] Zone {insertIndex} cannot accept drop");
            return;
        }
        
        GameObject draggedObject = eventData.pointerDrag;
        if (draggedObject == null)
        {
            Debug.LogWarning("[PlantotronSequenceDropZone] No dragged object found in drop event");
            return;
        }
        
        Debug.Log($"[PlantotronSequenceDropZone] Processing drop of {draggedObject.name}");
        
        // Handle drops from PlantotronGeneItem (gene inventory -> sequence)
        PlantotronGeneItem geneItem = draggedObject.GetComponent<PlantotronGeneItem>();
        if (geneItem != null)
        {
            // Get the gene from the gene item - we need to access its internal gene reference
            // Since PlantotronGeneItem doesn't expose the gene directly, we need to get it through the parent UI
            var allGeneItems = FindObjectsOfType<PlantotronGeneItem>();
            foreach (var item in allGeneItems)
            {
                if (item.gameObject == draggedObject)
                {
                    // We need to find which gene this represents by checking the inventory
                    if (PlayerGeneticsInventory.Instance != null)
                    {
                        // Try all available genes to find which one this item represents
                        foreach (var geneCount in PlayerGeneticsInventory.Instance.AvailableGenes)
                        {
                            if (geneCount.gene != null && geneCount.count > 0)
                            {
                                // Try adding this gene - TryAddGeneToSequence will handle validation
                                bool success = parentUI.TryAddGeneToSequence(geneCount.gene, insertIndex);
                                if (success)
                                {
                                    Debug.Log($"[PlantotronSequenceDropZone] Successfully added gene {geneCount.gene.displayName} at index {insertIndex}");
                                    return;
                                }
                            }
                        }
                    }
                    break;
                }
            }
            Debug.LogWarning("[PlantotronSequenceDropZone] Could not determine which gene was being dragged from inventory");
            return;
        }
        
        // Handle drops from PlantotronSequenceItem (internal sequence reordering)
        PlantotronSequenceItem sequenceItem = draggedObject.GetComponent<PlantotronSequenceItem>();
        if (sequenceItem != null)
        {
            NodeDefinition gene = sequenceItem.GetGene();
            if (gene != null)
            {
                Debug.Log($"[PlantotronSequenceDropZone] Moving sequence gene {gene.displayName} to index {insertIndex}");
                
                // For internal reordering, we need to move the gene rather than add a new one
                int fromIndex = sequenceItem.GetIndex();
                if (fromIndex != insertIndex)
                {
                    bool success = parentUI.TryMoveGeneInSequence(fromIndex, insertIndex);
                    if (success)
                    {
                        Debug.Log($"[PlantotronSequenceDropZone] Successfully moved gene from {fromIndex} to {insertIndex}");
                    }
                    else
                    {
                        Debug.LogWarning($"[PlantotronSequenceDropZone] Failed to move gene from {fromIndex} to {insertIndex}");
                    }
                }
                return;
            }
        }
        
        Debug.LogWarning($"[PlantotronSequenceDropZone] Unknown drag source: {draggedObject.name}");
    }
}





--------------------------------------------------------------------------------
This is part 5 out of 10 of script collection. 5 more parts remain.
--------------------------------------------------------------------------------