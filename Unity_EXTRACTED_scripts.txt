This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-05-26 16:14:09
================================================================================

DIRECTORY STRUCTURE
--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantOutline.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           ├── DualGridRuleTile_Grass.asset
│           └── DualGridRuleTile_Water.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_PoopFertilizer.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       ├── Wave_001.asset
│       └── Wave_002.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── LeafData.cs
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.Cell.cs
│   │   │   ├── PlantGrowth.Growth.cs
│   │   │   ├── PlantGrowth.NodeExecution.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── SlowdownZone.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManagement.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── OutlinePartController.cs
│       ├── PlantOutlineController.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       └── ShadowPartController.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Sprite-Lit-Advanced_Overlay_Base.mat
│   ├── Sprite-Lit-Default_OverlayAdvanced.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   ├── SpriteEmissiveUnlit.shader
│   └── WaterReflection.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionAutoAdder.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionAutoAdder : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets,
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string folderPath = Path.GetDirectoryName(assetPath);
                string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
                if (libraryFiles.Length > 0)
                {
                    NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
                    if (library != null && !library.definitions.Contains(nodeDef))
                    {
                        library.definitions.Add(nodeDef);
                        EditorUtility.SetDirty(library);
                        AssetDatabase.SaveAssets();
                    }
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionCreator.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;

public static class NodeDefinitionCreator
{
    private const string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

    [MenuItem(MenuPath, false, 50)]
    public static void CreateNodeDefinition()
    {
        // Figure out which folder the user is in, or use Assets/
        string folder = GetSelectedPathOrFallback();

        // Determine the next numeric index for "Node_XXX_"
        int nextNumber = GetNextNodeNumber(folder);

        // e.g., "Node_007_"
        string newName = $"Node_{nextNumber:D3}_";
        string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

        // Create the NodeDefinition
        NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
        AssetDatabase.CreateAsset(nodeDef, newPath);
        
        // Save and refresh, but DO NOT select or focus the ProjectWindow.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        Debug.Log($"Created NodeDefinition at: {newPath}");
        // Notice we don't call Selection.activeObject = nodeDef
        // or EditorUtility.FocusProjectWindow()
        // or ProjectWindowUtil.ShowCreatedAsset(nodeDef)
        // thus we avoid changing the user's folder.
    }

    // (Optional) Validate the menu item so it’s disabled if the game is running
    [MenuItem(MenuPath, true)]
    private static bool ValidateCreateNodeDefinition()
    {
        return !Application.isPlaying;
    }

    private static string GetSelectedPathOrFallback()
    {
        // Attempt to get the folder the user has selected in the Project window
        string path = "Assets";
        foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets))
        {
            path = AssetDatabase.GetAssetPath(obj);
            if (!string.IsNullOrEmpty(path))
            {
                // If it's a file, get its parent folder
                if (File.Exists(path))
                {
                    path = Path.GetDirectoryName(path);
                }
                break;
            }
        }
        return path;
    }

    private static int GetNextNodeNumber(string folderPath)
    {
        int nextNumber = 1;
        // Look for existing Node_XXX_ files
        string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
        foreach (var file in files)
        {
            string fName = Path.GetFileNameWithoutExtension(file);
            if (fName.StartsWith("Node_") && fName.Length >= 8)
            {
                // extract the 3-digit number from Node_000_
                string numberPart = fName.Substring(5, 3);
                if (int.TryParse(numberPart, out int num) && num >= nextNumber)
                {
                    nextNumber = num + 1;
                }
            }
        }
        return nextNumber;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(NodeDefinition))]
public class NodeDefinitionEditor : Editor
{
    // Serialized properties for all the fields in NodeDefinition
    SerializedProperty displayName;
    SerializedProperty description;
    SerializedProperty thumbnail;
    SerializedProperty thumbnailTintColor;
    SerializedProperty backgroundColor;
    SerializedProperty nodeViewPrefab;
    SerializedProperty effects;

    private void OnEnable()
    {
        displayName = serializedObject.FindProperty("displayName");
        description = serializedObject.FindProperty("description");
        thumbnail = serializedObject.FindProperty("thumbnail");
        thumbnailTintColor = serializedObject.FindProperty("thumbnailTintColor");
        backgroundColor = serializedObject.FindProperty("backgroundColor");
        nodeViewPrefab = serializedObject.FindProperty("nodeViewPrefab");
        effects = serializedObject.FindProperty("effects");
    }

    public override void OnInspectorGUI()
    {
        serializedObject.Update();

        // "Display" section
        EditorGUILayout.LabelField("Display", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(displayName);
        EditorGUILayout.PropertyField(description);
        EditorGUILayout.PropertyField(thumbnail);
        EditorGUILayout.PropertyField(thumbnailTintColor);
        EditorGUILayout.PropertyField(backgroundColor);

        EditorGUILayout.Space();

        // "Prefab & Effects" section
        EditorGUILayout.LabelField("Prefab & Effects", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(nodeViewPrefab);

        // Draw the effects field with a minimum height
        EditorGUILayout.PropertyField(effects, new GUIContent("Effects"), true, GUILayout.MinHeight(1300f));

        serializedObject.ApplyModifiedProperties();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionLibraryEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;

[CustomEditor(typeof(NodeDefinitionLibrary))]
public class NodeDefinitionLibraryEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            UpdateLibrary();
        }
    }

    private void UpdateLibrary()
    {
        NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

        // Get the folder of the current library asset.
        string libraryPath = AssetDatabase.GetAssetPath(library);
        string folderPath = Path.GetDirectoryName(libraryPath);

        // Find all .asset files in the folder.
        string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

        // Load NodeDefinition assets from that folder.
        List<NodeDefinition> defs = new List<NodeDefinition>();
        foreach (string file in assetFiles)
        {
            // Ignore the library asset itself.
            if (file == libraryPath)
                continue;

            NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
            if (def != null)
                defs.Add(def);
        }

        // Sort definitions by the numeric portion in the file name (assumes "Node_XXX_...").
        defs = defs.OrderBy(d => {
            string name = d.name;
            if (name.StartsWith("Node_") && name.Length >= 8)
            {
                string numStr = name.Substring(5, 3);
                if (int.TryParse(numStr, out int num))
                    return num;
            }
            return int.MaxValue; // if no number is found, sort last.
        }).ToList();

        library.definitions = defs;
        EditorUtility.SetDirty(library);
        AssetDatabase.SaveAssets();
        Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionPostprocessor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionPostprocessor : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, 
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string fileName = Path.GetFileNameWithoutExtension(assetPath);
                // Check if file name already starts with "Node_"
                if (!fileName.StartsWith("Node_"))
                {
                    string folderPath = Path.GetDirectoryName(assetPath);
                    // Get all files in folder that start with "Node_"
                    var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
                    int nextNumber = 1;
                    foreach (var file in files)
                    {
                        string fName = Path.GetFileNameWithoutExtension(file);
                        string[] parts = fName.Split('_');
                        if (parts.Length >= 2 && int.TryParse(parts[1], out int num))
                        {
                            if (num >= nextNumber)
                                nextNumber = num + 1;
                        }
                    }
                    string newName = $"Node_{nextNumber:D3}_";
                    AssetDatabase.RenameAsset(assetPath, newName);
                    AssetDatabase.SaveAssets();
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeEffectDrawer.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Editor/NodeEffectDrawer.cs
using UnityEngine;
using UnityEditor;

[CustomPropertyDrawer(typeof(NodeEffectData))]
public class NodeEffectDrawer : PropertyDrawer
{
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        EditorGUI.BeginProperty(position, label, property);

        // Get properties
        var effectTypeProp = property.FindPropertyRelative("effectType");
        var primaryValueProp = property.FindPropertyRelative("primaryValue");
        var secondaryValueProp = property.FindPropertyRelative("secondaryValue");
        var isPassiveProp = property.FindPropertyRelative("isPassive");
        // var scentIdentifierProp = property.FindPropertyRelative("scentIdentifier"); // REMOVED
        var scentDefRefProp = property.FindPropertyRelative("scentDefinitionReference"); // ADDED

        // Calculate rects - basic vertical layout
        Rect typeRect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);
        Rect passiveRect = new Rect(position.x, typeRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight);
        Rect primaryRect = new Rect(position.x, passiveRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight);
        Rect secondaryRect = new Rect(position.x, primaryRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight);
        Rect scentRect = new Rect(position.x, secondaryRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight); // Reuse rect position

        // Draw fields
        EditorGUI.PropertyField(typeRect, effectTypeProp);
        EditorGUI.PropertyField(passiveRect, isPassiveProp);

        // Determine labels based on type
        GUIContent primaryLabel = new GUIContent(primaryValueProp.displayName);
        GUIContent secondaryLabel = new GUIContent(secondaryValueProp.displayName);

        NodeEffectType currentType = (NodeEffectType)effectTypeProp.enumValueIndex;

        bool showScentField = false;
        switch (currentType)
        {
            case NodeEffectType.ScentModifier:
                primaryLabel.text = "Radius Bonus"; // Contextual label
                secondaryLabel.text = "Strength Bonus"; // Contextual label
                showScentField = true;
                break;
            case NodeEffectType.Damage:
                primaryLabel.text = "Damage Multiplier Add";
                break;
             // Add other cases...
            default:
                break;
        }

        EditorGUI.PropertyField(primaryRect, primaryValueProp, primaryLabel);
        EditorGUI.PropertyField(secondaryRect, secondaryValueProp, secondaryLabel);

        // Conditionally draw scent definition Object Field
        if (showScentField)
        {
            // Draw Object Field restricted to ScentDefinition type
            EditorGUI.ObjectField(scentRect, scentDefRefProp, typeof(ScentDefinition), new GUIContent("Scent Definition")); // Use correct label
        }

        EditorGUI.EndProperty();
    }

    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
    {
        float height = EditorGUIUtility.singleLineHeight; // Type
        height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Passive
        height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Primary
        height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Secondary

        // Add height for scent field only if needed
        var effectTypeProp = property.FindPropertyRelative("effectType");
        NodeEffectType currentType = (NodeEffectType)effectTypeProp.enumValueIndex;
        if (currentType == NodeEffectType.ScentModifier)
        {
            height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Scent Definition Reference
        }

        return height;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\LeafData.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/LeafData.cs
using UnityEngine;

/// <summary>
/// Class to store information about leaves for regrowth tracking
/// </summary>
[System.Serializable]
public class LeafData
{
    public Vector2Int GridCoord;
    public bool IsActive; // True if the leaf exists, false if it was eaten
    
    public LeafData(Vector2Int coord, bool isActive = true)
    {
        GridCoord = coord;
        IsActive = isActive;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantCell.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantCell.cs (Fix Leaf Tracking)

using UnityEngine;

// Define the enum here if it's closely tied to PlantCell,
// or move it to a separate file (e.g., PlantEnums.cs) for better organization.
public enum PlantCellType { Seed, Stem, Leaf, Flower, Fruit } // <<< ADDED ENUM DEFINITION

public class PlantCell : MonoBehaviour
{
    // Set these references when the cell is spawned by PlantGrowth
    [HideInInspector] public PlantGrowth ParentPlantGrowth;
    [HideInInspector] public Vector2Int GridCoord;
    [HideInInspector] public PlantCellType CellType; // Uses the enum defined above

    // Called automatically by Unity when this GameObject is destroyed
    private void OnDestroy()
    {
        // Notify the parent plant that this cell is gone, if the parent still exists
        if (ParentPlantGrowth != null)
        {
            // If it's a leaf being destroyed, ensure it's marked as inactive for potential regrowth
            if (CellType == PlantCellType.Leaf)
            {
                // Call the plant growth to let it know this is a leaf being destroyed
                // This helps ensure we mark it as inactive for regrowth
                if (Debug.isDebugBuild)
                    Debug.Log($"[PlantCell OnDestroy] Leaf at {GridCoord} is being destroyed - notifying parent plant", gameObject);
            }
            
            // Notify parent to update tracking and handle removal
            ParentPlantGrowth.ReportCellDestroyed(GridCoord);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.Cell.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.Cell.cs
using System.Collections.Generic;
using System.Linq; // Added this namespace for OrderBy()
using UnityEngine;

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- CELL MANAGEMENT METHODS ---
    // ------------------------------------------------

    public void ReportCellDestroyed(Vector2Int coord)
    {
        if (cells.ContainsKey(coord))
        {
            // Check what type of cell is being destroyed
            PlantCellType cellType = cells[coord];
        
            // If it's a leaf, mark it as inactive for potential regrowth
            if (cellType == PlantCellType.Leaf)
            {
                // Find and update the leaf data
                for (int i = 0; i < leafDataList.Count; i++)
                {
                    if (leafDataList[i].GridCoord == coord)
                    {
                        LeafData updatedData = leafDataList[i];
                        updatedData.IsActive = false; // Mark as eaten/missing
                        leafDataList[i] = updatedData;
                    
                        if (Debug.isDebugBuild)
                            Debug.Log($"[{gameObject.name}] Leaf at {coord} marked as missing for potential regrowth via ReportCellDestroyed.");
                    
                        break;
                    }
                }
            }
        
            cells.Remove(coord);
            // Assume RemovePlantCell(GameObject) will be called externally for proper cleanup
            // We still need to clean the GO list if destruction happened unexpectedly
            activeCellGameObjects.RemoveAll(go => go == null || (go.GetComponent<PlantCell>()?.GridCoord == coord));

            // Trigger outline update after internal state change
            if (enableOutline && outlineController != null)
            {
                outlineController.OnPlantCellRemoved(coord);
            }
        }
    }

    // RemovePlantCell (Handles shadow AND outline unregistration)
    public void RemovePlantCell(GameObject cellToRemove)
    {
        if (cellToRemove == null) return;

        PlantCell cellComp = cellToRemove.GetComponent<PlantCell>();
        if (cellComp == null) { Destroy(cellToRemove); return; } // Destroy if no component

        Vector2Int coord = cellComp.GridCoord;
        
        // NEW: Check if this is a leaf and mark it as inactive in our leaf data list
        if (cellComp.CellType == PlantCellType.Leaf)
        {
            // Find matching leaf data and mark as inactive (missing)
            for (int i = 0; i < leafDataList.Count; i++)
            {
                if (leafDataList[i].GridCoord == coord)
                {
                    LeafData updatedData = leafDataList[i];
                    updatedData.IsActive = false; // Mark as eaten/missing
                    leafDataList[i] = updatedData;
                    
                    if (Debug.isDebugBuild)
                        Debug.Log($"[{gameObject.name}] Leaf at {coord} marked as missing for potential regrowth.");
                    
                    break;
                }
            }
        }

        // --- Unregister Visuals FIRST ---
        // Shadow
        SpriteRenderer partRenderer = cellToRemove.GetComponentInChildren<SpriteRenderer>(); // More robust check
        if (shadowController != null && partRenderer != null) {
            shadowController.UnregisterPlantPart(partRenderer);
        }

        // Outline (this now triggers the update based on internal state)
        // No direct call to outlineController needed here, ReportCellDestroyed handles it.

        // --- Remove from internal tracking ---
        if (cells.ContainsKey(coord)) {
            cells.Remove(coord);
        }
        activeCellGameObjects.Remove(cellToRemove);

        // --- Destroy the GameObject ---
        Destroy(cellToRemove);

        // --- Trigger Outline Update AFTER internal state reflects the removal ---
        // Moved notification to ReportCellDestroyed which should be called by PlantCell OnDestroy
        // If called directly, ensure ReportCellDestroyed is also called or call the outline update here:
        // if (enableOutline && outlineController != null) {
        //     outlineController.OnPlantCellRemoved(coord);
        // }
    }


    // ClearAllVisuals (Combined cleanup helper for Shadows and Outlines)
    private void ClearAllVisuals()
    {
        // Create a copy because RemovePlantCell modifies the list
        List<GameObject> cellsToClear = new List<GameObject>(activeCellGameObjects);
        foreach (GameObject cellGO in cellsToClear) {
            if (cellGO != null) {
                // Directly destroy, OnDestroy in PlantCell calls ReportCellDestroyed -> Outline Update
                Destroy(cellGO);
            }
        }
        // Ensure lists/dicts are clear after iteration
        activeCellGameObjects.Clear();
        cells.Clear();

        // Also clear any outlines that might be orphaned
        if (outlineController != null) {
             // This assumes OutlineController has a method to clear all its parts
             // outlineController.ClearAllOutlineParts();
             // Or simply destroy/recreate the outline controller if simpler
        }

        rootCellInstance = null;
    }


    // SpawnCellVisual - Creates a cell visual GameObject
    private GameObject SpawnCellVisual(PlantCellType cellType, Vector2Int coords,
                                 Dictionary<ScentDefinition, float> accumulatedScentRadiusBonus = null,
                                 Dictionary<ScentDefinition, float> accumulatedScentStrengthBonus = null)
    {
        if (cells.ContainsKey(coords)) {
             Debug.LogWarning($"[{gameObject.name}] Trying to spawn {cellType} at occupied coord {coords}.");
            return null;
        }

        GameObject prefab = null;
        switch (cellType) {
            case PlantCellType.Seed: prefab = seedCellPrefab; break;
            case PlantCellType.Stem: prefab = stemCellPrefab; break;
            case PlantCellType.Leaf: prefab = leafCellPrefab; break;
            case PlantCellType.Fruit: prefab = berryCellPrefab; break;
        }

        if (prefab == null) {
            Debug.LogError($"[{gameObject.name}] Prefab for PlantCellType.{cellType} is null!");
            return null;
        }

        // Create visual cell
        Vector2 worldPos = (Vector2)transform.position + ((Vector2)coords * cellSpacing);
        GameObject instance = Instantiate(prefab, worldPos, Quaternion.identity, transform);
        instance.name = $"{gameObject.name}_{cellType}_{coords.x}_{coords.y}";

        // Set up PlantCell component
        PlantCell cellComp = instance.GetComponent<PlantCell>() ?? instance.AddComponent<PlantCell>();
        cellComp.ParentPlantGrowth = this;
        cellComp.GridCoord = coords;
        cellComp.CellType = cellType;

        // Add to tracking
        cells[coords] = cellType;
        activeCellGameObjects.Add(instance);

        // Set up SortableEntity
        SortableEntity sorter = instance.GetComponent<SortableEntity>() ?? instance.AddComponent<SortableEntity>();
        if (cellType == PlantCellType.Seed) {
            sorter.SetUseParentYCoordinate(false);
        } else {
            sorter.SetUseParentYCoordinate(true);
        }

        // Apply scent data if it's a fruit
        if (cellType == PlantCellType.Fruit) {
            ApplyScentDataToObject(instance, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
        }

        // Register visual effects
        RegisterShadowForCell(instance, cellType.ToString());
        // Outline registration now happens via OnPlantCellAdded call
        if (enableOutline && outlineController != null)
        {
             outlineController.OnPlantCellAdded(coords, instance);
        }

        return instance;
    }

    // --- Helper Methods for Shadow & Outline Integration ---
    private void RegisterShadowForCell(GameObject cellInstance, string cellTypeName)
    {
        if (shadowController == null || shadowPartPrefab == null || cellInstance == null) return;

        SpriteRenderer partRenderer = cellInstance.GetComponentInChildren<SpriteRenderer>(); // More robust
        if (partRenderer != null) {
            shadowController.RegisterPlantPart(partRenderer, shadowPartPrefab);
        } else {
            Debug.LogWarning($"Plant '{gameObject.name}': {cellTypeName} missing SpriteRenderer. No shadow.", cellInstance);
        }
    }

    // REMOVED: RegisterOutlineForCell (Logic moved to SpawnCellVisual calling outlineController.OnPlantCellAdded)

    // --- Stat Calculation ---
    private void CalculateAndApplyStats()
    {
        // (Function body remains the same as before)
        if (nodeGraph == null) {
            Debug.LogError($"[{gameObject.name}] CalculateAndApplyStats called with null NodeGraph!");
            return;
        }

        float baseEnergyStorage = 10f;
        float basePhotosynthesisRate = 0.5f;
        int baseStemMin = 3;
        int baseStemMax = 5;
        float baseGrowthSpeedInterval = 0.5f; // Base time per step
        int baseLeafGap = 1;
        int baseLeafPattern = 0;
        float baseGrowthRandomness = 0.1f;
        float baseCooldown = 5f;
        float baseCastDelay = 0.1f;

        float accumulatedEnergyStorage = 0f;
        float accumulatedPhotosynthesis = 0f;
        int stemLengthModifier = 0;
        float growthSpeedTimeModifier = 0f;
        int leafGapModifier = 0;
        int currentLeafPattern = baseLeafPattern;
        float growthRandomnessModifier = 0f;
        float cooldownModifier = 0f;
        float castDelayModifier = 0f;
        bool seedFound = false;
        
        // Initialize poop fertilizer values to zero
        poopDetectionRadius = 0f;
        poopEnergyBonus = 0f; // Renamed from poopAbsorptionRate

        foreach (NodeData node in nodeGraph.nodes.OrderBy(n => n.orderIndex)) {
            if (node?.effects == null) continue;
            foreach (var effect in node.effects) {
                if (effect == null || !effect.isPassive) continue;
                switch (effect.effectType) {
                    case NodeEffectType.SeedSpawn:
                        seedFound = true;
                        break;
                    case NodeEffectType.EnergyStorage:
                        accumulatedEnergyStorage += effect.primaryValue;
                        break;
                    case NodeEffectType.EnergyPhotosynthesis:
                        accumulatedPhotosynthesis += effect.primaryValue;
                        break;
                    case NodeEffectType.StemLength:
                        stemLengthModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.GrowthSpeed:
                        // Modify the *time interval* per step
                        growthSpeedTimeModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.LeafGap:
                        leafGapModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.LeafPattern:
                        currentLeafPattern = Mathf.Clamp(Mathf.RoundToInt(effect.primaryValue), 0, 4); // Assuming max 4 patterns defined
                        break;
                    case NodeEffectType.StemRandomness:
                        growthRandomnessModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.Cooldown:
                        cooldownModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.CastDelay:
                        castDelayModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.PoopFertilizer:
                        poopDetectionRadius = Mathf.Max(0f, effect.primaryValue);
                        poopEnergyBonus = Mathf.Max(0f, effect.secondaryValue); // Renamed from poopAbsorptionRate
                        break;
                        // Add other passive effects here if needed
                }
            }
        }

        finalMaxEnergy = Mathf.Max(1f, baseEnergyStorage + accumulatedEnergyStorage);
        finalPhotosynthesisRate = Mathf.Max(0f, basePhotosynthesisRate + accumulatedPhotosynthesis);
        int finalStemMin = Mathf.Max(1, baseStemMin + stemLengthModifier);
        int finalStemMax = Mathf.Max(finalStemMin, baseStemMax + stemLengthModifier);
        finalGrowthSpeed = Mathf.Max(0.01f, baseGrowthSpeedInterval + growthSpeedTimeModifier); // This is now TIME PER STEP
        finalLeafGap = Mathf.Max(0, baseLeafGap + leafGapModifier);
        finalLeafPattern = currentLeafPattern;
        finalGrowthRandomness = Mathf.Clamp01(baseGrowthRandomness + growthRandomnessModifier);
        cycleCooldown = Mathf.Max(0.1f, baseCooldown + cooldownModifier);
        nodeCastDelay = Mathf.Max(0.01f, baseCastDelay + castDelayModifier);

        targetStemLength = seedFound ? Random.Range(finalStemMin, finalStemMax + 1) : 0;
        // REMOVED: totalGrowthDuration calculation (less relevant)

        if (!seedFound) {
            Debug.LogWarning($"[{gameObject.name}] NodeGraph lacks SeedSpawn effect. Growth aborted.", gameObject);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.Growth.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.Growth.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq; // Keep for OrderBy

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- TIME-BASED GROWTH SYSTEM ---                // <<< NEW SYSTEM
    // ------------------------------------------------

    // Helper class to store pre-calculated growth steps (same as before)
    private class GrowthStep
    {
        public PlantCellType CellType;
        public Vector2Int Position;
        public int StemIndex; // Track which stem this belongs to (for percentage)
    }

    // --- GrowthCoroutine_TimeBased ---              // <<< FIXED COROUTINE
    private IEnumerator GrowthCoroutine_TimeBased()
    {
        if (targetStemLength <= 0)
        {
            currentState = PlantState.GrowthComplete;
            growthCoroutine = null;
            yield break;
        }

        List<GrowthStep> growthPlan = PreCalculateGrowthPlan();
        
        // Reset all growth tracking variables
        totalPlannedSteps = growthPlan.Count;
        stepsCompleted = 0;
        actualGrowthProgress = 0f;
        
        if (totalPlannedSteps == 0)
        {
            currentState = PlantState.GrowthComplete;
            growthCoroutine = null;
            yield break;
        }

        // --- Count stem steps for better time estimation ---
        int stemStepsCount = growthPlan.Count(step => step.CellType == PlantCellType.Stem);
        if (stemStepsCount == 0) stemStepsCount = 1; // Safety check

        // --- Initialize Time Variables ---
        currentGrowthElapsedTime = 0f; // Reset elapsed time for this growth cycle
        float baseTimePerStep = finalGrowthSpeed;
        if (baseTimePerStep <= 0.001f) baseTimePerStep = 0.01f;

        // --- Calculate Initial Estimated Total Time (for continuous mode) ---
        float initialTileMultiplier = 1.0f;
        if (PlantGrowthModifierManager.Instance != null)
        {
            initialTileMultiplier = PlantGrowthModifierManager.Instance.GetGrowthSpeedMultiplier(this);
            initialTileMultiplier = Mathf.Clamp(initialTileMultiplier, 0.1f, 10.0f);
        }
        float initialEffectiveTimePerStep = baseTimePerStep / initialTileMultiplier;
        if (initialEffectiveTimePerStep < 0.001f) initialEffectiveTimePerStep = 0.001f;
        
        // --- Use stem count for time estimate, not total steps ---
        estimatedTotalGrowthTime = stemStepsCount * initialEffectiveTimePerStep;
        // Ensure estimated time is at least a small positive value
        if (estimatedTotalGrowthTime < 0.01f) estimatedTotalGrowthTime = 0.01f;

        float lastUpdateTime = Time.time;
        float updateProgressInterval = 0.1f; // Update progress at least every 0.1 seconds

        // --- Track actual progress toward next step ---
        float progressTowardNextStep = 0f;

        // --- Growth Loop ---
        while (stepsCompleted < totalPlannedSteps && currentState == PlantState.Growing)
        {
            // 1. Get Current Frame's Delta Time
            float frameDeltaTime = Time.deltaTime;
            currentGrowthElapsedTime += frameDeltaTime;

            // 2. Get Current Tile Modifier
            float currentTileMultiplier = 1.0f;
            if (PlantGrowthModifierManager.Instance != null)
            {
                currentTileMultiplier = PlantGrowthModifierManager.Instance.GetGrowthSpeedMultiplier(this);
                currentTileMultiplier = Mathf.Clamp(currentTileMultiplier, 0.1f, 10.0f);
            }

            // 3. Calculate current effective time per step
            float currentEffectiveTimePerStep = baseTimePerStep / currentTileMultiplier;
            if (currentEffectiveTimePerStep < 0.001f) currentEffectiveTimePerStep = 0.001f;

            // 4. FIXED: Calculate progress rate - how quickly we accumulate progress relative to base rate
            //    When growth speed increases, we accumulate progress faster proportionally
            float progressRate = initialEffectiveTimePerStep / currentEffectiveTimePerStep;
            
            // 5. Add progress toward next step based on adjusted progress rate
            progressTowardNextStep += frameDeltaTime * progressRate;
            
            // 6. Calculate partial progress (0-1) toward next step for UI smoothness
            actualGrowthProgress = Mathf.Clamp01(progressTowardNextStep / initialEffectiveTimePerStep);
            
            // 7. Check if we've accumulated enough progress for one or more steps
            int stepsToProcessThisFrame = 0;
            
            while (progressTowardNextStep >= initialEffectiveTimePerStep && stepsCompleted < totalPlannedSteps) 
            {
                stepsToProcessThisFrame++;
                progressTowardNextStep -= initialEffectiveTimePerStep;
                
                // Limit steps per frame to prevent lag
                if (stepsToProcessThisFrame >= 3) break;
            }

            // 8. Process the steps
            if (stepsToProcessThisFrame > 0)
            {
                for (int i = 0; i < stepsToProcessThisFrame; i++)
                {
                    int currentPlanIndex = stepsCompleted;
                    if (currentPlanIndex >= totalPlannedSteps) break;

                    GrowthStep step = growthPlan[currentPlanIndex];
                    GameObject spawnedCell = SpawnCellVisual(step.CellType, step.Position, null, null);

                    // Update stem count for discrete percentage display
                    if (step.CellType == PlantCellType.Stem)
                    {
                        currentStemCount = step.StemIndex;
                        if (!continuousIncrement) // Only update UI from here if discrete
                        {
                             UpdateGrowthPercentageUI();
                        }
                    }
                    
                    stepsCompleted++;
                }
                
                lastUpdateTime = Time.time;
                
                // Update partial progress after steps
                actualGrowthProgress = Mathf.Clamp01(progressTowardNextStep / initialEffectiveTimePerStep);
            }
            
            // 9. Update UI based on time interval regardless of steps processed
            if (Time.time - lastUpdateTime > updateProgressInterval)
            {
                if (continuousIncrement)
                {
                    UpdateGrowthPercentageUI();
                }
                lastUpdateTime = Time.time;
            }

            // 10. Yield
            yield return null;
        }

        // Final update to ensure we reach 100%
        currentState = PlantState.GrowthComplete;
        stepsCompleted = totalPlannedSteps;
        actualGrowthProgress = 1.0f;
        growthCoroutine = null;
    }


    // --- PreCalculateGrowthPlan ---                     // <<< NEW HELPER
    /// <summary>
    /// Generates the full sequence of stem and leaf placements based on calculated stats.
    /// </summary>
    /// <returns>A list of GrowthStep objects defining the growth sequence.</returns>
    private List<GrowthStep> PreCalculateGrowthPlan()
    {
        List<GrowthStep> plan = new List<GrowthStep>();
        Vector2Int currentPos = Vector2Int.zero; // Start relative to the seed
        int spiralDir = 1; // Used for spiral pattern
        int patternCount = 0; // Used for alternating patterns

        // Simulate the growth stem by stem
        for (int stemIndex = 1; stemIndex <= targetStemLength; stemIndex++)
        {
            // Determine growth direction for this stem
            Vector2Int growthDir = GetStemDirection(); // Use the randomness calculated in stats
            Vector2Int nextStemPos = currentPos + growthDir;

            // Add stem step to the plan
            plan.Add(new GrowthStep {
                CellType = PlantCellType.Stem,
                Position = nextStemPos,
                StemIndex = stemIndex
            });

            currentPos = nextStemPos; // Update position for leaf calculation

            // Check if leaves should be added for this stem segment
            if ((finalLeafGap >= 0) && (stemIndex % (finalLeafGap + 1)) == 0)
            {
                patternCount++;

                // Base positions for leaves relative to the *new* stem position
                Vector2Int leftBase = currentPos + Vector2Int.left;
                Vector2Int rightBase = currentPos + Vector2Int.right;

                // Calculate leaf positions based on the chosen pattern
                List<Vector2Int> leafPositions = CalculateLeafPositions(
                    currentPos, // Current stem position
                    leftBase,   // Potential left leaf position
                    rightBase,  // Potential right leaf position
                    patternCount, // Counter for alternating patterns
                    ref spiralDir // Ref for spiral direction state
                );

                // Add leaf steps to the plan
                foreach (Vector2Int leafPos in leafPositions)
                {
                    plan.Add(new GrowthStep {
                        CellType = PlantCellType.Leaf,
                        Position = leafPos,
                        StemIndex = stemIndex // Associate leaf with the stem it grew from
                    });
                }
            }
        }
        
        // Track all leaf positions for potential regrowth
        foreach (GrowthStep step in plan)
        {
            if (step.CellType == PlantCellType.Leaf)
            {
                leafDataList.Add(new LeafData(step.Position, true));
            }
        }
        
        return plan;
    }


    // --- GetStemDirection - Determines the next stem growth direction ---
    // (Logic remains the same, uses finalGrowthRandomness)
    private Vector2Int GetStemDirection()
    {
        // Use pre-calculated randomness factor
        if (Random.value < finalGrowthRandomness) // Check against the final calculated value
        {
            // Randomly choose left-up or right-up diagonal
            return (Random.value < 0.5f) ? (Vector2Int.up + Vector2Int.left) : (Vector2Int.up + Vector2Int.right);
        }
        // Default to straight up
        return Vector2Int.up;
    }

    // --- CalculateLeafPositions - Calculates leaf positions based on pattern ---
    // (Logic remains the same, uses finalLeafPattern)
    private List<Vector2Int> CalculateLeafPositions(
        Vector2Int stemPos, Vector2Int leftBase, Vector2Int rightBase, int counter, ref int spiralDir)
    {
        List<Vector2Int> leafPositions = new List<Vector2Int>();

        switch (finalLeafPattern) // Use the final calculated pattern
        {
            case 0: // Parallel leaves
                leafPositions.Add(leftBase);
                leafPositions.Add(rightBase);
                break;

            case 1: // Alternating Offset leaves
                 // Initialize random offset ONCE per plant growth instance
                if (offsetRightForPattern1 == null)
                    offsetRightForPattern1 = Random.value < 0.5f;

                if (offsetRightForPattern1.Value) { // Offset right leaf up
                    leafPositions.Add(leftBase);
                    leafPositions.Add(rightBase + Vector2Int.up);
                } else { // Offset left leaf up
                    leafPositions.Add(leftBase + Vector2Int.up);
                    leafPositions.Add(rightBase);
                }
                break;

            case 2: // Alternating Parallel/Offset combination
                switch (counter % 4) {
                    case 0: // Treat 0 like 2 for parallel
                    case 2: // Parallel
                        leafPositions.Add(leftBase);
                        leafPositions.Add(rightBase);
                        break;
                    case 1: // Offset left up
                        leafPositions.Add(leftBase + Vector2Int.up);
                        leafPositions.Add(rightBase);
                        break;
                    case 3: // Offset right up
                        leafPositions.Add(leftBase);
                        leafPositions.Add(rightBase + Vector2Int.up);
                        break;
                }
                break;

            case 3: // Spiral leaves
                // Place one leaf normally, offset the other based on spiral direction
                if (spiralDir > 0) { // e.g., Right leaf is higher
                    leafPositions.Add(leftBase);
                    leafPositions.Add(rightBase + Vector2Int.up);
                } else { // e.g., Left leaf is higher
                    leafPositions.Add(leftBase + Vector2Int.up);
                    leafPositions.Add(rightBase);
                }
                spiralDir *= -1; // Flip direction for next time
                break;

            case 4: // Example: Symmetric double leaves on both sides
                leafPositions.Add(leftBase);
                leafPositions.Add(leftBase + Vector2Int.up);
                leafPositions.Add(rightBase);
                leafPositions.Add(rightBase + Vector2Int.up);
                break;

             default: // Fallback to parallel
                 leafPositions.Add(leftBase);
                 leafPositions.Add(rightBase);
                 break;
        }

        return leafPositions;
    }

} // End PARTIAL Class


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.NodeExecution.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.NodeExecution.cs
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- NODE EXECUTION METHODS ---
    // ------------------------------------------------

    private IEnumerator ExecuteMatureCycle()
    {
        if (nodeGraph?.nodes == null || nodeGraph.nodes.Count == 0) {
             Debug.LogError($"[{gameObject.name}] NodeGraph missing or empty!", gameObject);
             currentState = PlantState.Mature_Idle;
             cycleTimer = cycleCooldown; // Reset timer even on error
             yield break;
        }

        // --- Accumulation Phase ---
        float damageMultiplier = 1.0f;
        Dictionary<ScentDefinition, float> accumulatedScentRadiusBonus = new Dictionary<ScentDefinition, float>();
        Dictionary<ScentDefinition, float> accumulatedScentStrengthBonus = new Dictionary<ScentDefinition, float>();
        float totalEnergyCostForCycle = 0f;

        // Process all nodes to accumulate effects
        foreach (var node in nodeGraph.nodes.OrderBy(n => n.orderIndex))
        {
            if (node?.effects == null || node.effects.Count == 0) continue;

            foreach (var effect in node.effects)
            {
                 if (effect == null || effect.isPassive) continue; // Skip passive effects

                 // Accumulate specific non-passive effects
                 switch (effect.effectType)
                 {
                    case NodeEffectType.EnergyCost:
                         totalEnergyCostForCycle += Mathf.Max(0f, effect.primaryValue);
                         break;
                    case NodeEffectType.Damage:
                         damageMultiplier = Mathf.Max(0.1f, damageMultiplier + effect.primaryValue);
                         break;
                    case NodeEffectType.ScentModifier:
                        if (effect.scentDefinitionReference != null)
                        {
                             ScentDefinition key = effect.scentDefinitionReference;
                             // Use TryGetValue for cleaner addition
                             accumulatedScentRadiusBonus.TryGetValue(key, out float currentRad);
                             accumulatedScentRadiusBonus[key] = currentRad + effect.primaryValue;

                             accumulatedScentStrengthBonus.TryGetValue(key, out float currentStr);
                             accumulatedScentStrengthBonus[key] = currentStr + effect.secondaryValue;
                        }
                        else {
                             Debug.LogWarning($"Node '{node.nodeDisplayName ?? "Unnamed"}' has ScentModifier effect but ScentDefinition reference is NULL.");
                        }
                        break;
                    // Other accumulation effects could go here
                 }
            }
        }
        
        // --- NEW: Check for poop to absorb in this cycle ---
        if (poopDetectionRadius > 0f)
        {
            CheckForPoopAndAbsorb();
        }

        // --- Execution Phase ---
        // Check Energy Cost *before* executing actions
        if (currentEnergy < totalEnergyCostForCycle) {
             if(Debug.isDebugBuild) Debug.Log($"[{gameObject.name}] Not enough energy ({currentEnergy}/{totalEnergyCostForCycle}) for mature cycle.");
             currentState = PlantState.Mature_Idle;
             cycleTimer = cycleCooldown; // Reset timer
             yield break; // Exit if not enough energy
        }

        // Spend energy
        currentEnergy = Mathf.Max(0f, currentEnergy - totalEnergyCostForCycle);
        UpdateUI(); // Update UI after spending energy

        // Execute node effects in order
        foreach (var node in nodeGraph.nodes.OrderBy(n => n.orderIndex))
        {
            if (node?.effects == null || node.effects.Count == 0) continue;

            // Check if this node contains any *active* effects that require a delay
            bool hasActionEffectInNode = node.effects.Any(eff => eff != null && !eff.isPassive &&
                                            eff.effectType != NodeEffectType.EnergyCost && // Don't delay for cost
                                            eff.effectType != NodeEffectType.Damage &&   // Don't delay for damage mod
                                            eff.effectType != NodeEffectType.ScentModifier); // Don't delay for scent mod

            // Apply delay BEFORE processing effects of this node if applicable
            if (hasActionEffectInNode && nodeCastDelay > 0.01f) {
                 yield return new WaitForSeconds(nodeCastDelay);
            }

            // Execute individual active effects
            foreach (var effect in node.effects)
            {
                 // Skip passive and accumulation-only effects during execution
                 if (effect == null || effect.isPassive ||
                     effect.effectType == NodeEffectType.EnergyCost ||
                     effect.effectType == NodeEffectType.Damage ||
                     effect.effectType == NodeEffectType.ScentModifier) continue;

                 // Execute the actual active effect
                 switch (effect.effectType) {
                     case NodeEffectType.Output:
                        // Find component on THIS plant root or its children
                        OutputNodeEffect outputComp = GetComponentInChildren<OutputNodeEffect>();
                        if (outputComp != null) {
                             outputComp.Activate(damageMultiplier, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
                        } else {
                             Debug.LogWarning($"[{gameObject.name}] Node requested Output effect, but no OutputNodeEffect component found.", this);
                        }
                         break;
                     case NodeEffectType.GrowBerry:
                         TrySpawnBerry(accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
                         break;
                     // Add other ACTIVE effect cases here (e.g., Heal, StatusEffect)
                 }
            }
        }

        // --- Cycle Complete ---
        // Reset timer and state after executing all nodes
        cycleTimer = cycleCooldown;
        currentState = PlantState.Mature_Idle;
    }

    // --- TrySpawnBerry - Tries to create a berry on the plant ---
    private void TrySpawnBerry(Dictionary<ScentDefinition, float> scentRadiiBonus, Dictionary<ScentDefinition, float> scentStrengthsBonus)
    {
        if (berryCellPrefab == null) {
            Debug.LogWarning($"[{gameObject.name}] Berry Prefab not assigned. Cannot spawn berry.", gameObject);
            return;
        }

        // Find potential coordinates adjacent to existing stems/leaves where berries can grow
        // Consider only coords adjacent to stems for typical berry growth
        var potentialCoords = cells
            .Where(cellKvp => cellKvp.Value == PlantCellType.Stem || cellKvp.Value == PlantCellType.Seed) // Only grow off Stem/Seed
            .SelectMany(cellKvp => {
                Vector2Int coord = cellKvp.Key;
                // Define potential relative offsets for berries (e.g., above, left, right)
                Vector2Int[] berryOffsets = { Vector2Int.up, Vector2Int.left, Vector2Int.right };
                List<Vector2Int> candidates = new List<Vector2Int>();
                foreach(var offset in berryOffsets) {
                    candidates.Add(coord + offset);
                }
                return candidates;
            })
            .Where(coord => !cells.ContainsKey(coord)) // Ensure the target coordinate is empty
            .Distinct() // Avoid duplicates if multiple stems border the same empty cell
            .ToList();

        if (potentialCoords.Count > 0) {
            // Choose a random empty valid spot
            Vector2Int chosenCoord = potentialCoords[Random.Range(0, potentialCoords.Count)];
            // Spawn the berry visual, passing accumulated scent data
            GameObject berryGO = SpawnCellVisual(PlantCellType.Fruit, chosenCoord, scentRadiiBonus, scentStrengthsBonus);
             if (berryGO == null) {
                  Debug.LogError($"[{gameObject.name}] Failed to spawn berry visual at {chosenCoord}, SpawnCellVisual returned null.");
             }
        } else {
             if(Debug.isDebugBuild) Debug.Log($"[{gameObject.name}] No valid empty adjacent locations found to spawn a berry.");
        }
    }


    // --- ApplyScentDataToObject - Applies scent to an object like a berry or projectile ---
    public void ApplyScentDataToObject(GameObject targetObject, Dictionary<ScentDefinition, float> scentRadiusBonuses, Dictionary<ScentDefinition, float> scentStrengthBonuses)
    {
        // (Function body remains the same as before)
        if (targetObject == null) {
            Debug.LogError("ApplyScentDataToObject: targetObject is null.");
            return;
        }

        if (EcosystemManager.Instance == null) {
            Debug.LogError("ApplyScentDataToObject: EcosystemManager instance not found.");
            return;
        }

        if (EcosystemManager.Instance.scentLibrary == null) {
            Debug.LogWarning("ApplyScentDataToObject: Scent Library not assigned in EcosystemManager.");
            return;
        }

        // Find the ScentDefinition with the highest accumulated strength bonus
        ScentDefinition strongestScentDef = null;
        float maxStrengthBonus = -1f; // Use -1 to correctly handle 0 bonus values

        if (scentStrengthBonuses != null && scentStrengthBonuses.Count > 0) {
            foreach (var kvp in scentStrengthBonuses) {
                if (kvp.Key != null && kvp.Value > maxStrengthBonus) {
                    maxStrengthBonus = kvp.Value;
                    strongestScentDef = kvp.Key;
                }
            }
        } else {
             // if (Debug.isDebugBuild) Debug.Log($"[{gameObject.name} ApplyScentToObject] No scent strength bonuses provided.");
        }

        // Apply the strongest scent found (if any)
        if (strongestScentDef != null) {
             // if (Debug.isDebugBuild) Debug.Log($"[{gameObject.name} ApplyScentToObject] Applying strongest scent '{strongestScentDef.displayName}' to {targetObject.name} (Str Bonus: {maxStrengthBonus})");

            ScentSource scentSource = targetObject.GetComponent<ScentSource>();
            if (scentSource == null) {
                scentSource = targetObject.AddComponent<ScentSource>();
            }

            // Configure the ScentSource component
            scentSource.definition = strongestScentDef;

            // Retrieve the corresponding bonuses (defaulting to 0 if not found)
            scentRadiusBonuses.TryGetValue(strongestScentDef, out float radiusBonus);
            scentSource.radiusModifier = radiusBonus;
            scentSource.strengthModifier = maxStrengthBonus; // Apply the max strength found

            // Instantiate particle effect if defined and not already present
            if (strongestScentDef.particleEffectPrefab != null) {
                bool particleExists = false;
                // Check immediate children for an existing particle system to avoid duplicates
                foreach(Transform child in targetObject.transform){
                    if(child.TryGetComponent<ParticleSystem>(out _)){
                        particleExists = true;
                        break;
                    }
                }
                if (!particleExists) {
                     // Instantiate under the target object
                    Instantiate(strongestScentDef.particleEffectPrefab, targetObject.transform.position, Quaternion.identity, targetObject.transform);
                }
            }
        } else {
            // if (Debug.isDebugBuild) Debug.Log($"[{gameObject.name} ApplyScentToObject] No strongest scent found to apply to {targetObject.name}.");
        }
    }

} // End PARTIAL Class


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using TMPro;

// --- Enums ---
public enum PlantState { Initializing, Growing, GrowthComplete, Mature_Idle, Mature_Executing }

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- SERIALIZED FIELDS ---
    // ------------------------------------------------

    [Header("UI & Visuals")]
    [SerializeField] private TMP_Text energyText;
    [SerializeField] private GameObject seedCellPrefab;
    [SerializeField] private GameObject stemCellPrefab;
    [SerializeField] private GameObject leafCellPrefab;
    [SerializeField] private GameObject berryCellPrefab; // Used for PlantCellType.Fruit
    [SerializeField] private float cellSpacing = 0.08f;

    [Header("Shadow Setup")]
    [SerializeField] [Tooltip("Assign the PlantShadowController component from the child _ShadowRoot GameObject")]
    private PlantShadowController shadowController;
    [SerializeField] [Tooltip("Assign your 'PlantShadow' prefab (GO + SpriteRenderer + ShadowPartController script)")]
    private GameObject shadowPartPrefab;

    [Header("Outline Setup")]
    [SerializeField] [Tooltip("Enable or disable plant outline visualization")]
    private bool enableOutline = true;
    [SerializeField] [Tooltip("Assign the PlantOutlineController component from the child _OutlineRoot GameObject")]
    private PlantOutlineController outlineController;
    [SerializeField] [Tooltip("Assign your outline part prefab (GO + SpriteRenderer + OutlinePartController script)")]
    private GameObject outlinePartPrefab;

    [Header("Growth & UI Timing")]
    [SerializeField] private bool showGrowthPercentage = true;
    [SerializeField] private bool allowPhotosynthesisDuringGrowth = false;
    [SerializeField] [Tooltip("Percentage UI updates only on these increments (e.g., 5 shows 0, 5, 10...).")]
    [Range(1, 25)] private int percentageIncrement = 5;
    // --- NEW FIELD ---
    [SerializeField] [Tooltip("If true, percentage display approximates smooth progress based on time. If false, it reflects discrete stem cell additions.")]
    private bool continuousIncrement = false;
    // -----------------

    // ------------------------------------------------
    // --- INTERNAL STATE & DATA ---
    // ------------------------------------------------

    private NodeGraph nodeGraph;
    public PlantState currentState = PlantState.Initializing;
    public float currentEnergy = 0f;
    private Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
    private List<GameObject> activeCellGameObjects = new List<GameObject>();
    private FireflyManager fireflyManagerInstance;
    private GameObject rootCellInstance;
    private Coroutine growthCoroutine;
    private bool isGrowthCompletionHandled = false;

    // ------------------------------------------------
    // --- POOP FERTILIZER DATA ---
    // ------------------------------------------------
    private float poopDetectionRadius = 0f;
    private float poopEnergyBonus = 0f; // Renamed from poopAbsorptionRate
    private List<LeafData> leafDataList = new List<LeafData>();

    // ------------------------------------------------
    // --- CALCULATED STATS ---
    // ------------------------------------------------

    private int targetStemLength;
    private float finalGrowthSpeed; // Represents time interval per step
    private int finalLeafGap;
    private int finalLeafPattern;
    private float finalGrowthRandomness;
    private float finalMaxEnergy;
    private float finalPhotosynthesisRate;
    private float cycleCooldown;
    private float nodeCastDelay;

    // ------------------------------------------------
    // --- RUNTIME VARIABLES ---
    // ------------------------------------------------

    private int currentStemCount = 0;
    private float cycleTimer = 0f;
    private int displayedGrowthPercentage = -1;
    private bool? offsetRightForPattern1 = null;
    // --- NEW FIELDS for Continuous Mode ---
    private float currentGrowthElapsedTime = 0f;
    private float estimatedTotalGrowthTime = 1f; // Default to 1 to avoid division by zero
    // --- NEW FIELDS for better growth tracking ---
    private float actualGrowthProgress = 0f; // The normalized progress value (0-1) representing true growth completion
    private int stepsCompleted = 0; // Track how many steps have been completed
    private int totalPlannedSteps = 0; // Total number of steps in the growth plan

    // ------------------------------------------------
    // --- UNITY LIFECYCLE METHODS ---
    // ------------------------------------------------

    void Awake()
    {
        // --- Critical Setup Check ---
        bool setupValid = true;
        if (shadowController == null) { shadowController = GetComponentInChildren<PlantShadowController>(true); if (shadowController == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': PlantShadowController ref missing!", this); setupValid = false; } else { Debug.LogWarning($"PlantGrowth on '{gameObject.name}': Found PlantShadowController dynamically.", this); } }
        if (shadowPartPrefab == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Shadow Part Prefab missing!", this); setupValid = false; }
        if (enableOutline) { if (outlineController == null) { outlineController = GetComponentInChildren<PlantOutlineController>(true); if (outlineController == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': PlantOutlineController ref missing but outline is enabled!", this); setupValid = false; } else { Debug.LogWarning($"PlantGrowth on '{gameObject.name}': Found PlantOutlineController dynamically.", this); } } if (outlinePartPrefab == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Outline Part Prefab missing but outline is enabled!", this); setupValid = false; } }
        if (seedCellPrefab == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Seed Cell Prefab missing!", this); setupValid = false; } if (energyText == null) Debug.LogWarning($"PlantGrowth on '{gameObject.name}': Energy Text (TMP_Text) missing.", this);
        if (!setupValid) { enabled = false; return; }
        if (!enableOutline && outlineController != null) { outlineController.gameObject.SetActive(false); }
        fireflyManagerInstance = FireflyManager.Instance;
        EnsureUIReferences();
    }

    void Start()
    {
        UpdateUI();
    }

    private void Update()
    {
        // Handle frame-dependent UI updates and state transitions
        switch (currentState)
        {
            case PlantState.Growing:
                if (allowPhotosynthesisDuringGrowth)
                    AccumulateEnergy();

                // --- Update percentage UI every frame ONLY if in continuous mode ---
                if (showGrowthPercentage && continuousIncrement)
                {
                    UpdateGrowthPercentageUI();
                }
                // (Discrete mode updates are handled within the coroutine)
                break;

            case PlantState.GrowthComplete:
                if (!isGrowthCompletionHandled)
                {
                    isGrowthCompletionHandled = true;
                    if (showGrowthPercentage && targetStemLength > 0)
                    {
                        UpdateGrowthPercentageUI(true); // Force 100% display
                    }
                    currentState = PlantState.Mature_Idle;
                    cycleTimer = cycleCooldown;
                    UpdateUI(); // Update energy text if needed
                }
                break;

            case PlantState.Mature_Idle:
                AccumulateEnergy();
                UpdateUI();
                cycleTimer -= Time.deltaTime;
                if (cycleTimer <= 0f && currentEnergy >= 1f)
                {
                    currentState = PlantState.Mature_Executing;
                    StartCoroutine(ExecuteMatureCycle()); // Assumes ExecuteMatureCycle is in another partial file
                }
                break;

            case PlantState.Mature_Executing:
                AccumulateEnergy();
                UpdateUI();
                break;

            case PlantState.Initializing:
                break;
        }
    }

    private void OnDestroy()
    {
        StopAllCoroutines(); growthCoroutine = null;
        if (PlantGrowthModifierManager.Instance != null) { PlantGrowthModifierManager.Instance.UnregisterPlant(this); }
        ClearAllVisuals(); // Assumes ClearAllVisuals is in another partial file
    }

    // ------------------------------------------------
    // --- PUBLIC INITIALIZATION ---
    // ------------------------------------------------

    public void InitializeAndGrow(NodeGraph graph)
    {
        if (graph == null || graph.nodes == null) { Debug.LogError($"[{gameObject.name}] Null/empty NodeGraph provided.", gameObject); Destroy(gameObject); return; }
        if (growthCoroutine != null) { StopCoroutine(growthCoroutine); growthCoroutine = null; }
        ClearAllVisuals();
        rootCellInstance = null; currentStemCount = 0; offsetRightForPattern1 = null; isGrowthCompletionHandled = false; displayedGrowthPercentage = -1;
        currentGrowthElapsedTime = 0f; // <-- RESET
        estimatedTotalGrowthTime = 1f; // <-- RESET to default
        stepsCompleted = 0; // <-- RESET new variable
        totalPlannedSteps = 0; // <-- RESET new variable
        actualGrowthProgress = 0f; // <-- RESET new variable
        nodeGraph = graph; currentState = PlantState.Initializing; currentEnergy = 0f;
        // Clear any old leaf data
        leafDataList.Clear();
        CalculateAndApplyStats();
        GameObject spawnedSeed = SpawnCellVisual(PlantCellType.Seed, Vector2Int.zero, null, null);
        if (spawnedSeed != null) {
            rootCellInstance = spawnedSeed;
            if (PlantGrowthModifierManager.Instance != null && TileInteractionManager.Instance != null) { Vector3Int gridPos = TileInteractionManager.Instance.WorldToCell(transform.position); TileDefinition currentTile = TileInteractionManager.Instance.FindWhichTileDefinitionAt(gridPos); PlantGrowthModifierManager.Instance.RegisterPlantTile(this, currentTile); }
            if (targetStemLength > 0) {
                currentState = PlantState.Growing;
                UpdateGrowthPercentageUI(); // Initial UI update (0%)
                growthCoroutine = StartCoroutine(GrowthCoroutine_TimeBased());
            } else {
                Debug.LogWarning($"[{gameObject.name}] Target stem length is {targetStemLength}. Skipping visual growth phase.", gameObject);
                currentState = PlantState.GrowthComplete; isGrowthCompletionHandled = false; UpdateUI();
            }
        } else { Debug.LogError($"[{gameObject.name}] Failed to spawn initial seed! Aborting growth.", gameObject); currentState = PlantState.Mature_Idle; Destroy(gameObject, 0.1f); }
        UpdateUI();
    }

    // ------------------------------------------------
    // --- ENERGY & UI ---
    // ------------------------------------------------

    private void AccumulateEnergy()
    {
        if (finalPhotosynthesisRate <= 0 || finalMaxEnergy <= 0) return; float sunlight = WeatherManager.Instance ? WeatherManager.Instance.sunIntensity : 1f; int leafCount = cells.Values.Count(c => c == PlantCellType.Leaf); float tileMultiplier = (PlantGrowthModifierManager.Instance != null) ? PlantGrowthModifierManager.Instance.GetEnergyRechargeMultiplier(this) : 1.0f; float fireflyBonusRate = 0f; if (fireflyManagerInstance != null) { int nearbyFlyCount = fireflyManagerInstance.GetNearbyFireflyCount(transform.position, fireflyManagerInstance.photosynthesisRadius); fireflyBonusRate = Mathf.Min(nearbyFlyCount * fireflyManagerInstance.photosynthesisIntensityPerFly, fireflyManagerInstance.maxPhotosynthesisBonus); } float standardPhotosynthesis = finalPhotosynthesisRate * leafCount * sunlight; float totalRate = (standardPhotosynthesis + fireflyBonusRate) * tileMultiplier; float delta = totalRate * Time.deltaTime; currentEnergy = Mathf.Clamp(currentEnergy + delta, 0f, finalMaxEnergy);
    }

    // --- FIXED: UpdateGrowthPercentageUI with Continuous Mode Logic ---
    /// <summary>
    /// Calculates the target display percentage based on chosen mode (discrete/continuous)
    /// and updates the UI text ONLY if the snapped value has changed.
    /// </summary>
    /// <param name="forceComplete">If true, forces the display to 100%.</param>
    private void UpdateGrowthPercentageUI(bool forceComplete = false)
    {
        if (!showGrowthPercentage || energyText == null) return;

        float rawPercentageFloat = 0f; // The calculated percentage before snapping

        if (forceComplete || currentState == PlantState.GrowthComplete)
        {
            rawPercentageFloat = 100f;
        }
        // --- Check Continuous Flag Here ---
        else if (continuousIncrement) // --- CONTINUOUS MODE ---
        {
            // NEW: Use actual growth progress instead of elapsed time
            if (totalPlannedSteps > 0) 
            {
                // Calculate percentage based on steps completed
                rawPercentageFloat = ((float)stepsCompleted / totalPlannedSteps) * 100f;
                
                // Add partial progress toward next step based on actual growth progress
                if (actualGrowthProgress > 0f && stepsCompleted < totalPlannedSteps)
                {
                    float stepSize = 100f / totalPlannedSteps;
                    float partialStepProgress = actualGrowthProgress * stepSize;
                    rawPercentageFloat = (stepsCompleted * stepSize) + partialStepProgress;
                }
            }
            else
            {
                // Fallback if no planned steps (shouldn't happen)
                rawPercentageFloat = (currentState == PlantState.Growing) ? 0f : 100f;
            }
        }
        else // --- DISCRETE MODE ---
        {
            // Calculate based on current stem count vs target
            if (targetStemLength <= 0)
            {
                rawPercentageFloat = 0f; // No stems to grow
            }
            else
            {
                rawPercentageFloat = Mathf.Clamp(((float)currentStemCount / targetStemLength) * 100f, 0f, 100f);
            }
        }

        // --- Snap the calculated percentage (Applies to BOTH modes) ---
        int targetDisplayValue; // The final value to show (snapped)
        if (percentageIncrement <= 1)
        {
            targetDisplayValue = Mathf.FloorToInt(rawPercentageFloat);
        }
        else
        {
            // Use proper rounding to closest increment rather than floor
            targetDisplayValue = Mathf.RoundToInt(rawPercentageFloat / percentageIncrement) * percentageIncrement;
        }
        targetDisplayValue = Mathf.Min(targetDisplayValue, 100); // Clamp final value
        
        // Ensure we don't show 100% until growth is complete, unless forced
        if (targetDisplayValue == 100 && currentState == PlantState.Growing && !forceComplete)
        {
            targetDisplayValue = 95; // Cap at 95% until actually complete
        }

        // --- Update TextMeshPro only if the snapped value changed ---
        if (targetDisplayValue != displayedGrowthPercentage)
        {
            displayedGrowthPercentage = targetDisplayValue;
            energyText.text = $"{displayedGrowthPercentage}%";
        }
    }


    // --- UpdateUI (Consolidated) ---
    private void UpdateUI()
    {
        if (energyText == null) return;

        // If showing percentage AND in a state where it's relevant (Growing or just completed)
        // Let UpdateGrowthPercentageUI handle it (called from Update or completion logic)
        if (showGrowthPercentage && (currentState == PlantState.Growing || currentState == PlantState.GrowthComplete))
        {
           // If not using continuous increment, the discrete update happens in the coroutine.
           // If using continuous, it happens in Update(). If complete, it happens in Update().
           // No need to directly modify text here for percentage display.
        }
        else // Otherwise (Idle, Executing, or not showing percentage), show Energy
        {
            energyText.text = $"{Mathf.FloorToInt(currentEnergy)}/{Mathf.FloorToInt(finalMaxEnergy)}";
        }
    }

    // ------------------------------------------------
    // --- UI REFERENCE HELPER ---
    // ------------------------------------------------

    private void EnsureUIReferences()
    {
        if (energyText) return; energyText = GetComponentInChildren<TMP_Text>(true); if (!energyText) { Debug.LogWarning($"[{gameObject.name}] Energy Text (TMP_Text) UI reference not assigned in Inspector and not found in children.", gameObject); }
    }

    // ------------------------------------------------
    // --- POOP FERTILIZER METHODS ---
    // ------------------------------------------------
    
    private void CheckForPoopAndAbsorb()
    {
        // Skip if no missing leaves to regrow and no energy bonus
        bool hasMissingLeaves = leafDataList.Any(leaf => !leaf.IsActive);
        bool canAddEnergy = poopEnergyBonus > 0f;
        
        if (Debug.isDebugBuild && poopDetectionRadius > 0f)
        {
            string leafStatus = hasMissingLeaves ? 
                $"Has {leafDataList.Count(l => !l.IsActive)} missing leaves" : 
                "No missing leaves";
            Debug.Log($"[{gameObject.name}] PoopFertilizer: {leafStatus}, Radius: {poopDetectionRadius}, Energy bonus: {poopEnergyBonus}");
        }
        
        if (!hasMissingLeaves && !canAddEnergy) return;
        
        // Look for poop in range
        Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, poopDetectionRadius);
        
        if (Debug.isDebugBuild && poopDetectionRadius > 0f)
        {
            Debug.Log($"[{gameObject.name}] PoopFertilizer: Found {colliders.Length} colliders in radius {poopDetectionRadius}");
            int poopCount = 0;
            foreach (Collider2D col in colliders)
            {
                if (col.GetComponent<PoopController>() != null)
                    poopCount++;
            }
            Debug.Log($"[{gameObject.name}] PoopFertilizer: {poopCount} of those colliders have PoopController");
        }
        
        // Process poop that we find
        foreach (Collider2D collider in colliders)
        {
            PoopController poop = collider.GetComponent<PoopController>();
            if (poop != null)
            {
                bool absorbed = false;
                
                // First try to regrow a leaf if there are missing leaves
                if (hasMissingLeaves)
                {
                    absorbed = TryRegrowLeaf();
                }
                
                // If we couldn't regrow a leaf (or didn't need to) but have energy bonus, add energy
                if ((!absorbed || !hasMissingLeaves) && canAddEnergy)
                {
                    currentEnergy = Mathf.Min(finalMaxEnergy, currentEnergy + poopEnergyBonus);
                    absorbed = true;
                    
                    if (Debug.isDebugBuild)
                        Debug.Log($"[{gameObject.name}] Added {poopEnergyBonus} energy from poop fertilizer. Current energy: {currentEnergy}");
                }
                
                // Destroy the poop if it was successfully used
                if (absorbed)
                {
                    Destroy(poop.gameObject);
                    break; // Process only one poop per cycle
                }
            }
        }
    }

    private bool TryRegrowLeaf()
    {
        // Look for a missing leaf to regrow
        int missingLeafIndex = -1;
        
        // Debug counts
        if (Debug.isDebugBuild)
        {
            int totalLeaves = leafDataList.Count;
            int missingLeaves = leafDataList.Count(leaf => !leaf.IsActive);
            Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Total leaves: {totalLeaves}, Missing leaves: {missingLeaves}");
        }
        
        for (int i = 0; i < leafDataList.Count; i++)
        {
            if (!leafDataList[i].IsActive)
            {
                missingLeafIndex = i;
                break;
            }
        }
        
        if (missingLeafIndex == -1)
        {
            if (Debug.isDebugBuild)
                Debug.Log($"[{gameObject.name}] TryRegrowLeaf: No missing leaves found to regrow.");
            return false; // No missing leaves found
        }
        
        // Get the leaf coordinate and mark it as active
        Vector2Int leafCoord = leafDataList[missingLeafIndex].GridCoord;
        
        // IMPORTANT: Check if the coordinate is already occupied by another cell
        if (cells.ContainsKey(leafCoord))
        {
            if (Debug.isDebugBuild)
                Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Cannot regrow leaf at {leafCoord} because cell is already occupied.");
            return false;
        }
        
        // Create the new leaf visual
        GameObject newLeaf = SpawnCellVisual(PlantCellType.Leaf, leafCoord);
        
        if (newLeaf != null)
        {
            // Update the leaf data to mark it as active ONLY if spawn succeeded
            leafDataList[missingLeafIndex] = new LeafData(leafCoord, true);
            
            if (Debug.isDebugBuild)
                Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Successfully regrew leaf at {leafCoord} using poop fertilizer!");
            return true;
        }
        
        // If we get here, the leaf couldn't be created
        if (Debug.isDebugBuild)
            Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Failed to spawn new leaf at {leafCoord}");
        
        // Leave the leaf marked as inactive in the tracking list
        return false;
    }

    // -----------------------------------------------
    // --- PUBLIC ACCESSORS FOR OUTLINES ---
    // -----------------------------------------------

    public bool DoesCellExistAt(Vector2Int coord) { return cells.ContainsKey(coord); }
    public float GetCellSpacing() { return this.cellSpacing; }
    public GameObject GetCellGameObjectAt(Vector2Int coord) { return activeCellGameObjects.FirstOrDefault(go => go != null && go.GetComponent<PlantCell>()?.GridCoord == coord); }
    public bool IsOutlineEnabled() { return enableOutline; }
    
    // Accessor for poop fertilizer visualization
    public float GetPoopDetectionRadius() { return poopDetectionRadius; }

    // --- PARTIAL CLASS METHODS (Assumed in other files) ---
    // Define these methods in the corresponding partial class files:
    // In PlantGrowth.Cell.cs: ReportCellDestroyed, RemovePlantCell, ClearAllVisuals, SpawnCellVisual, CalculateAndApplyStats, RegisterShadowForCell
    // In PlantGrowth.Growth.cs: GrowthStep class, GrowthCoroutine_TimeBased, PreCalculateGrowthPlan, GetStemDirection, CalculateLeafPositions
    // In PlantGrowth.NodeExecution.cs: ExecuteMatureCycle, TrySpawnBerry, ApplyScentDataToObject

} // End PARTIAL Class definition


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\WeatherManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/WeatherManager.cs
using UnityEngine;
using System;

public class WeatherManager : MonoBehaviour
{
    public static WeatherManager Instance { get; private set; }

    public enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }

    [Header("Day/Night Cycle Settings")]
    public bool dayNightCycleEnabled = true;
    public float dayDuration = 20f;
    public float nightDuration = 20f;
    public float transitionDuration = 5f;
    public AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

    [Header("Sunlight Settings")]
    [Range(0f, 1f)]
    public float sunIntensity = 1f;

    [Header("Fixed Sunlight When Cycle Off")]
    [Range(0f, 1f)]
    public float fixedSunIntensity = 1f;

    [Header("Sunlight Visualization")]
    public SpriteRenderer fadeSprite;
    public float minAlpha = 0f;
    public float maxAlpha = 1f;

    [Header("Time Scaling & Pausing")] // <<< UPDATED HEADER
    [Range(1f, 100f)]
    public float timeScaleMultiplier = 1f;
    public bool IsPaused { get; set; } = false; // <<< NEW: Pause flag

    // --- Public Properties & Events ---
    public CyclePhase CurrentPhase => currentPhase;
    public event Action<CyclePhase> OnPhaseChanged;
    public float CurrentPhaseTimer => phaseTimer; // <<< NEW: Expose timer
    public float CurrentTotalPhaseTime => totalPhaseTime; // <<< NEW: Expose total time

    // --- Internals ---
    private CyclePhase currentPhase = CyclePhase.Day;
    private float phaseTimer = 0f;
    private float totalPhaseTime = 0f;

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;
    }

    void Start()
    {
        EnterPhase(CyclePhase.Day, true);
    }

    void Update()
    {
        // --- PAUSE CHECK ---
        if (IsPaused) // <<< NEW: Check if paused
        {
            // If paused, potentially ensure timeScale is 1? Or leave it? Let's reset it.
            if (timeScaleMultiplier != 1f) timeScaleMultiplier = 1f;
            return; // Do nothing else if paused
        }
        // ---------------------

        if (!dayNightCycleEnabled)
        {
            sunIntensity = fixedSunIntensity;
            UpdateFadeSprite();
            if (timeScaleMultiplier != 1f) timeScaleMultiplier = 1f;
            return;
        }

        phaseTimer -= Time.deltaTime * timeScaleMultiplier;

        if (phaseTimer <= 0f)
        {
            CyclePhase nextPhase = currentPhase;
            switch (currentPhase)
            {
                case CyclePhase.Day: nextPhase = CyclePhase.TransitionToNight; break;
                case CyclePhase.TransitionToNight: nextPhase = CyclePhase.Night; break;
                case CyclePhase.Night: nextPhase = CyclePhase.TransitionToDay; break;
                case CyclePhase.TransitionToDay: nextPhase = CyclePhase.Day; break;
            }
            EnterPhase(nextPhase);
        }
        else
        {
            UpdateSunIntensity();
        }

        UpdateFadeSprite();
    }

    private void EnterPhase(CyclePhase nextPhase, bool forceEvent = false)
    {
        CyclePhase previousPhase = currentPhase;
        currentPhase = nextPhase;

        switch (nextPhase)
        {
            case CyclePhase.Day: totalPhaseTime = dayDuration; break;
            case CyclePhase.Night: totalPhaseTime = nightDuration; break;
            case CyclePhase.TransitionToNight:
            case CyclePhase.TransitionToDay: totalPhaseTime = transitionDuration; break;
        }
        totalPhaseTime = Mathf.Max(0.01f, totalPhaseTime);
        phaseTimer = totalPhaseTime;

        UpdateSunIntensity();

        if (previousPhase != currentPhase || forceEvent)
        {
            if (Debug.isDebugBuild) Debug.Log($"[WeatherManager] Phase Changed To: {currentPhase}");
            OnPhaseChanged?.Invoke(currentPhase);
        }
    }

    private void UpdateSunIntensity()
    {
        if (totalPhaseTime <= 0) return;
        float progress = 1f - Mathf.Clamp01(phaseTimer / totalPhaseTime);
        switch (currentPhase)
        {
            case CyclePhase.Day: sunIntensity = 1f; break;
            case CyclePhase.TransitionToNight: sunIntensity = Mathf.Lerp(1f, 0f, transitionCurve.Evaluate(progress)); break;
            case CyclePhase.Night: sunIntensity = 0f; break;
            case CyclePhase.TransitionToDay: sunIntensity = Mathf.Lerp(0f, 1f, transitionCurve.Evaluate(progress)); break;
        }
        sunIntensity = Mathf.Clamp01(sunIntensity);
    }

    private void UpdateFadeSprite()
    {
        if (fadeSprite != null)
        {
            float alpha = Mathf.Lerp(maxAlpha, minAlpha, sunIntensity);
            Color c = fadeSprite.color; c.a = alpha; fadeSprite.color = c;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\SpellProjectile.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SpellProjectile : MonoBehaviour
{
    [Header("Projectile Stats")]
    public float damage;
    public float speed;
    [Tooltip("If true, the projectile will be destroyed upon hitting a wizard.")]
    public bool destroyOnHit = true;

    [Header("Burning Effect (optional)")]
    public float burningDamage;   // DPS
    public float burningDuration; // Duration in seconds

    [Header("Friendly Fire")]
    public bool friendlyFire = false;
    public bool casterIsEnemy = false;

    public void Initialize(float dmg, float spd)
    {
        damage = dmg;
        speed = spd;
    }

    private void Update()
    {
        transform.Translate(Vector2.up * speed * Time.deltaTime);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\BurningStatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public class BurningStatusEffect : StatusEffect
{
    public BurningStatusEffect(float d, float dps) : base(d, dps) { }

    
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\StatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public abstract class StatusEffect
{
    public float duration; // Total duration.
    public float damagePerSecond;
    protected float elapsed = 0f;

    // Public property to expose elapsed time.
    public float Elapsed { get { return elapsed; } }

    public StatusEffect(float d, float dps)
    {
        duration = d;
        damagePerSecond = dps;
    }

    public bool IsExpired() => elapsed >= duration;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\SortableEntity.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SortableEntity : MonoBehaviour
{
    [Header("Sorting Configuration")]
    [Tooltip("Offset added to Y position for sorting calculation")]
    [SerializeField] private float sortingLayerYOffset = 0f;

    [Tooltip("Use parent's Y coordinate for sorting")]
    [SerializeField] private bool useParentYCoordinate = false;

    [Tooltip("Debug logging for sorting")]
    public bool debugSorting = false;

    private SpriteRenderer spriteRenderer;

    private void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        // If no SpriteRenderer, try to find one in children
        if (spriteRenderer == null)
            spriteRenderer = GetComponentInChildren<SpriteRenderer>();

        // Ensure sprite renderer exists
        if (spriteRenderer == null)
        {
            Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
        }
    }

    private void Start()
    {
        UpdateSortingOrder();
    }

    private void LateUpdate()
    {
        UpdateSortingOrder();
    }

    public void UpdateSortingOrder()
    {
        if (spriteRenderer == null) return;

        // Determine Y position for sorting
        float yPositionForSorting = useParentYCoordinate && transform.parent != null 
            ? transform.parent.position.y 
            : transform.position.y;

        int sortOrder = CalculateSortOrder(yPositionForSorting);
        spriteRenderer.sortingOrder = sortOrder;

        if (debugSorting)
        {
            Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
        }
    }

    private int CalculateSortOrder(float yPosition)
    {
        // Subtract offset to effectively move the sorting position
        return Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
    }

    // Public method to get current sorting order
    public int GetCurrentSortOrder()
    {
        if (spriteRenderer == null) return 0;
        return spriteRenderer.sortingOrder;
    }

    // Public method to set sorting order directly if needed
    public void SetSortingOrder(int order)
    {
        if (spriteRenderer != null)
            spriteRenderer.sortingOrder = order;
    }

    // Public method to set the parent Y coordinate usage flag
    // This eliminates the need for reflection in other scripts
    public void SetUseParentYCoordinate(bool value)
    {
        useParentYCoordinate = value;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "Animal_", menuName = "Ecosystem/Animal Definition (Simplified)")]
public class AnimalDefinition : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("The species name (e.g., 'Bunny', 'Fox').")]
    public string animalName = "DefaultAnimal";

    [Header("Core Stats")]
    public float maxHealth = 10f; // Keep health for potential future damage/predators
    public float movementSpeed = 2f;

    [Header("Diet")]
    [Tooltip("Reference to the AnimalDiet ScriptableObject defining eating habits.")]
    public AnimalDiet diet; // Needs to reference the simplified AnimalDiet SO

    [Header("Visuals")]
    [Tooltip("The prefab to instantiate for this animal.")]
    public GameObject prefab;

    // Removed meatFoodType
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "AnimalLibrary", menuName = "Ecosystem/Animal Library")]
public class AnimalLibrary : ScriptableObject
{
    public List<AnimalDefinition> animals;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using TMPro;

[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(SortableEntity))]
[RequireComponent(typeof(Collider2D))]
public class AnimalController : MonoBehaviour
{
    // --- Fields ---
    private AnimalDefinition definition;
    private AnimalDiet animalDiet;
    
    [Header("Optional Features")]
    public AnimalThoughtLibrary thoughtLibrary;
    public GameObject thoughtBubblePrefab;
    public Transform bubbleSpawnTransform;
    public Transform poopSpawnPoint;
    public List<GameObject> poopPrefabs;
    public Animator animator;
    
    [Header("UI References")]
    [SerializeField] private TextMeshProUGUI hpText;
    [SerializeField] private TextMeshProUGUI hungerText; // NEW: Hunger text reference

    [Header("UI Settings")] // NEW HEADER
    [Tooltip("Which key to hold to display HP and Hunger texts")]
    [SerializeField] private KeyCode showStatsKey = KeyCode.LeftAlt; // NEW: Configurable key for showing stats
    
    [Header("Behavior Tuning")]
    public float searchRadius = 5f;
    public float eatDistance = 0.5f;
    public float eatDuration = 1.5f;
    [Range(0f, 1f)]
    public float wanderPauseChance = 0.3f;
    public float wanderMinMoveDuration = 1f;
    public float wanderMaxMoveDuration = 3f;
    public float wanderMinPauseDuration = 0.5f;
    public float wanderMaxPauseDuration = 2f;
    public float minPoopDelay = 5f;
    public float maxPoopDelay = 10f;
    public float poopDuration = 1f;
    public float poopColorVariation = 0.1f;
    public float thoughtCooldownTime = 5f;
    [SerializeField] private List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();
    [SerializeField] private List<ScentDefinition> repellentScentDefinitions = new List<ScentDefinition>();

    // --- NEW: Food reassessment timer fields ---
    [Header("Food Seeking Improvements")]
    [Tooltip("How often (in seconds) to reassess nearby food even when current target is valid")]
    public float foodReassessmentInterval = 0.5f;
    private float foodReassessmentTimer = 0f;

    // --- Internal State ---
    private float currentHealth;
    private float currentHunger;
    private GameObject currentTargetFood = null;
    private Vector2 moveDirection = Vector2.zero;
    private bool isEating = false;
    private float eatTimer = 0f;
    private bool isWanderPaused = false;
    private float wanderStateTimer = 0f;
    private bool isPooping = false;
    private float poopTimer = 0f;
    private float poopDelayTimer = 0f;
    private bool hasPooped = true;
    private float thoughtCooldownTimer = 0f;
    private bool isSeekingScreenCenter = false;
    private Vector2 screenCenterTarget;

    // --- Component References ---
    private Rigidbody2D rb;
    private SpriteRenderer spriteRenderer;
    private Collider2D animalCollider;

    // --- Movement Bounds (Shifted Padded Screen Bounds) ---
    private Vector2 minBounds;
    private Vector2 maxBounds;

    // --- Public Accessors ---
    public float CurrentHealth => currentHealth;
    public string SpeciesName => definition ? definition.animalName : "Uninitialized";

    // --- NEW: Fields for slowdown system ---
    private float baseMovementSpeed;
    private List<float> activeSpeedMultipliers = new List<float>();

    // --- Initialize ---
    public void Initialize(AnimalDefinition def, Vector2 shiftedMinBounds, Vector2 shiftedMaxBounds, bool spawnedOffscreen = false)
    {
        definition = def; 
        if (definition == null) { Destroy(gameObject); return; }
        
        animalDiet = def.diet; 
        if (animalDiet == null) { enabled = false; return; }
        
        rb = GetComponent<Rigidbody2D>(); 
        spriteRenderer = GetComponentInChildren<SpriteRenderer>(); 
        animalCollider = GetComponent<Collider2D>();
        
        if (animalCollider == null) 
        { 
            Debug.LogError($"[{gameObject.name}] Missing Collider2D!", gameObject); 
            enabled = false; 
            return; 
        }

        // Store base movement speed - NEW
        baseMovementSpeed = definition.movementSpeed;
        activeSpeedMultipliers.Clear(); // NEW

        currentHealth = definition.maxHealth;
        currentHunger = 0f;
        hasPooped = true;
        poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);
        foodReassessmentTimer = Random.Range(0f, foodReassessmentInterval); // Randomize initial timer

        // Store the SHIFTED bounds received from FaunaManager
        minBounds = shiftedMinBounds;
        maxBounds = shiftedMaxBounds;
        
        // Calculate the target center based on the SHIFTED bounds
        screenCenterTarget = (minBounds + maxBounds) / 2f;

        isSeekingScreenCenter = spawnedOffscreen;
        if (isSeekingScreenCenter)
        {
            if(Debug.isDebugBuild) 
                Debug.Log($"[{gameObject.name} Initialize] Offscreen spawn. Seeking SHIFTED center ({screenCenterTarget}). SHIFTED Bounds: min{minBounds}, max{maxBounds}", gameObject);
            
            moveDirection = (screenCenterTarget - (Vector2)transform.position).normalized;
            if (moveDirection == Vector2.zero) 
                moveDirection = Random.insideUnitCircle.normalized;
        }
    
        EnsureUITextReferences();
    
        // Hide text elements initially
        SetStatsTextVisibility(false);
    
        UpdateHpText(); 
        UpdateHungerText();
    
        if (spriteRenderer == null) { /* Warning */ }
    }
    
    private void EnsureUITextReferences() 
    { 
        if (hpText == null) 
        {
            hpText = GetComponentInChildren<TextMeshProUGUI>(true);
            // If we found a TMP_Text but it should be for HP, don't assign it to both
            if (hpText != null && hpText.gameObject.name.Contains("Hunger"))
            {
                hungerText = hpText;
                hpText = null;
            }
        }
    
        if (hungerText == null)
        {
            // Try to find any TextMeshProUGUI component that's not the HP text
            TextMeshProUGUI[] allTexts = GetComponentsInChildren<TextMeshProUGUI>(true);
            foreach (var text in allTexts)
            {
                if (text != hpText)
                {
                    hungerText = text;
                    break;
                }
            }
        }
    }

    // --- Update ---
    void Update()
    {
        if (!enabled || rb == null) return;

        // Check for ALT key (or configured key) press to show/hide stats
        bool showStats = Input.GetKey(showStatsKey);
        SetStatsTextVisibility(showStats);

        if (isSeekingScreenCenter)
        {
            Vector2 currentPos = rb.position;
            // Check if center is within the SHIFTED padded bounds
            bool centerWithinBounds =
                currentPos.x >= minBounds.x && currentPos.x <= maxBounds.x &&
                currentPos.y >= minBounds.y && currentPos.y <= maxBounds.y;

            if (centerWithinBounds)
            {
                if(Debug.isDebugBuild) 
                    Debug.Log($"[{gameObject.name} Update] Center reached SHIFTED bounds! Pos: {currentPos}. MinB: {minBounds}, MaxB: {maxBounds}. Switching to normal AI.", gameObject);
                
                isSeekingScreenCenter = false;
                moveDirection = Vector2.zero;
            }
            else
            {
                // Seek the SHIFTED center target
                moveDirection = (screenCenterTarget - currentPos).normalized;
                if (moveDirection == Vector2.zero) 
                    moveDirection = Random.insideUnitCircle.normalized;
                
                FlipSpriteBasedOnDirection();
                UpdateAnimationState();
                return; // Skip normal AI
            }
        }

        // Normal AI Logic
        UpdateHunger();
        HandlePooping();
        UpdateThoughts();
        
        if (isEating) 
        { 
            HandleEating(); 
            moveDirection = Vector2.zero; 
        }
        else if (isPooping) 
        { 
            moveDirection = Vector2.zero; 
        }
        else 
        { 
            DecideNextAction(); 
        }

        FlipSpriteBasedOnDirection();
        UpdateAnimationState();
    }
    
    private void SetStatsTextVisibility(bool visible)
    {
        if (hpText != null)
        {
            hpText.gameObject.SetActive(visible);
        }
    
        if (hungerText != null)
        {
            hungerText.gameObject.SetActive(visible);
        }
    }

    // --- FixedUpdate ---
    void FixedUpdate()
    {
        if (rb == null) return;
        
        if (!isEating && !isPooping && moveDirection != Vector2.zero)
        {
            Vector2 currentPos = rb.position;
            Vector2 desiredMove = moveDirection.normalized * definition.movementSpeed * Time.fixedDeltaTime;
            Vector2 nextPos = currentPos + desiredMove;

            if (!isSeekingScreenCenter) // Clamp only when NOT seeking
            {
                // Clamp the CENTER position using the SHIFTED bounds
                nextPos.x = Mathf.Clamp(nextPos.x, minBounds.x, maxBounds.x);
                nextPos.y = Mathf.Clamp(nextPos.y, minBounds.y, maxBounds.y);
            }
            rb.MovePosition(nextPos);
        }
    }

    void UpdateHunger() 
    { 
        currentHunger += animalDiet.hungerIncreaseRate * Time.deltaTime; 
        currentHunger = Mathf.Min(currentHunger, animalDiet.maxHunger);
        // Update hunger text when hunger changes
        UpdateHungerText();
    }
    
    void ApplyStarvationDamage() 
    { 
        /* ... */ 
        UpdateHpText(); 
    }
    
    void HandlePooping() 
    { 
        if (!isEating && !hasPooped) 
        { 
            poopDelayTimer -= Time.deltaTime; 
            if (!isPooping && poopDelayTimer <= 0f) 
            { 
                StartPooping(); 
            } 
            if (isPooping) 
            { 
                poopTimer -= Time.deltaTime; 
                if (poopTimer <= 0f) 
                { 
                    FinishPooping(); 
                } 
            } 
        } 
    }
    
    void UpdateThoughts() 
    { 
        if (thoughtCooldownTimer > 0) 
        { 
            thoughtCooldownTimer -= Time.deltaTime; 
        } 
    }
    
    void DecideNextAction() 
    { 
        if (currentHunger >= animalDiet.hungerThreshold) 
        { 
            SeekFood(); 
        } 
        else 
        { 
            Wander(); 
            currentTargetFood = null; 
        } 
    }
    
    // --- Food seeking with periodic reassessment ---
    void SeekFood() 
    { 
        if (CanShowThought()) ShowThought(ThoughtTrigger.Hungry);
        
        // Reassess food periodically even if current target is valid
        foodReassessmentTimer -= Time.deltaTime;
        bool shouldReassess = foodReassessmentTimer <= 0f;
        bool targetValid = currentTargetFood != null && currentTargetFood.activeInHierarchy && 
                          currentTargetFood.GetComponent<FoodItem>() != null;
        
        // Reassess when timer expires or if target is invalid
        if (shouldReassess || !targetValid) 
        {
            // Store position of old target for comparison
            Vector3 oldTargetPosition = targetValid ? currentTargetFood.transform.position : Vector3.zero;
            
            // Find potentially better food
            GameObject potentialBetterFood = FindNearestFood();
            
            if (potentialBetterFood != null) 
            {
                // Always switch to new target if no current target
                if (!targetValid) 
                {
                    currentTargetFood = potentialBetterFood;
                    if(Debug.isDebugBuild) 
                        Debug.Log($"[{gameObject.name} SeekFood] Found new food target (no previous): {potentialBetterFood.name}");
                }
                // Switch to new target if it's better than current
                else if (potentialBetterFood != currentTargetFood) 
                {
                    // Get preferences for comparison
                    FoodItem currentFoodItem = currentTargetFood.GetComponent<FoodItem>();
                    FoodItem newFoodItem = potentialBetterFood.GetComponent<FoodItem>();
                    
                    if (currentFoodItem != null && newFoodItem != null) 
                    {
                        float currentPriority = animalDiet.GetPreference(currentFoodItem.foodType)?.preferencePriority ?? 0f;
                        float newPriority = animalDiet.GetPreference(newFoodItem.foodType)?.preferencePriority ?? 0f;
                        
                        // Switch if new food has higher priority
                        if (newPriority > currentPriority) 
                        {
                            if(Debug.isDebugBuild) 
                                Debug.Log($"[{gameObject.name} SeekFood] Switching to higher priority food: {newFoodItem.foodType.foodName} (priority: {newPriority}) from {currentFoodItem.foodType.foodName} (priority: {currentPriority})");
                            
                            currentTargetFood = potentialBetterFood;
                        }
                    }
                }
            }
            
            // Reset timer
            foodReassessmentTimer = foodReassessmentInterval;
        }
        
        // Proceed with target as before
        if (currentTargetFood != null) 
        {
            MoveTowardFood(currentTargetFood);
        } 
        else 
        {
            Wander();
        }
    }

    GameObject FindNearestFood() 
    { 
        Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, searchRadius); 
        return animalDiet.FindBestFood(colliders, transform.position); 
    }
    
    void MoveTowardFood(GameObject foodObj) 
    { 
        if (foodObj == null) return; 
        
        float distance = Vector2.Distance(transform.position, foodObj.transform.position); 
        if (distance <= eatDistance) 
        { 
            StartEating(); 
        } 
        else 
        { 
            moveDirection = (foodObj.transform.position - transform.position).normalized; 
            isWanderPaused = false; 
            wanderStateTimer = 0f; 
        } 
    }
    
    void StartEating() 
    { 
        isEating = true; 
        eatTimer = eatDuration; 
        moveDirection = Vector2.zero; 
        if (CanShowThought()) ShowThought(ThoughtTrigger.Eating); 
    }
    
    void HandleEating() 
    { 
        eatTimer -= Time.deltaTime; 
        if (eatTimer <= 0f) 
        { 
            isEating = false; 
            FinishEatingAction(); 
        } 
    }
    
    void FinishEatingAction() 
    { 
        if (currentTargetFood == null) return; 
        
        FoodItem foodItem = currentTargetFood.GetComponent<FoodItem>(); 
        if (foodItem != null && foodItem.foodType != null) 
        { 
            float satiationGain = animalDiet.GetSatiationValue(foodItem.foodType); 
            currentHunger -= satiationGain; 
            currentHunger = Mathf.Max(0f, currentHunger); 
            Destroy(currentTargetFood); 
            hasPooped = false; 
            poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay); 
            currentTargetFood = null;
            // Update hunger text
            UpdateHungerText();
        } 
        else 
        { 
            currentTargetFood = null; 
        } 
    }
    
    void StartPooping() 
    { 
        isPooping = true; 
        poopTimer = poopDuration; 
        moveDirection = Vector2.zero; 
        if (CanShowThought()) ShowThought(ThoughtTrigger.Pooping); 
    }
    
    void FinishPooping() 
    { 
        SpawnPoop(); 
        isPooping = false; 
        hasPooped = true; 
    }
    
    void SpawnPoop() 
    { 
        if (poopPrefabs == null || poopPrefabs.Count == 0) return; 
        
        int index = Random.Range(0, poopPrefabs.Count); 
        GameObject prefab = poopPrefabs[index]; 
        if (prefab == null) return; 
        
        Transform spawnT = poopSpawnPoint ? poopSpawnPoint : transform; 
        GameObject poopObj = Instantiate(prefab, spawnT.position, Quaternion.identity); 
        
        SpriteRenderer sr = poopObj.GetComponent<SpriteRenderer>(); 
        if (sr != null) 
        { 
            sr.flipX = Random.value > 0.5f; 
            Color c = sr.color; 
            float v = poopColorVariation; 
            sr.color = new Color(
                Mathf.Clamp01(c.r + Random.Range(-v, v)),
                Mathf.Clamp01(c.g + Random.Range(-v, v)),
                Mathf.Clamp01(c.b + Random.Range(-v, v)),
                c.a
            ); 
        } 
        
        PoopController pc = poopObj.GetComponent<PoopController>() ?? poopObj.AddComponent<PoopController>(); 
        pc.Initialize(); 
    }
    
    void Wander() 
    { 
        if (wanderStateTimer <= 0f) 
        { 
            if (isWanderPaused) 
            { 
                isWanderPaused = false; 
                moveDirection = Random.insideUnitCircle.normalized; 
                wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration); 
            } 
            else 
            { 
                if (Random.value < wanderPauseChance) 
                { 
                    isWanderPaused = true; 
                    moveDirection = Vector2.zero; 
                    wanderStateTimer = Random.Range(wanderMinPauseDuration, wanderMaxPauseDuration); 
                } 
                else 
                { 
                    moveDirection = Random.insideUnitCircle.normalized; 
                    wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration); 
                } 
            } 
        } 
        else 
        { 
            wanderStateTimer -= Time.deltaTime; 
        } 
    }
    
    void FlipSpriteBasedOnDirection() 
    { 
        if (spriteRenderer != null && Mathf.Abs(moveDirection.x) > 0.01f) 
        { 
            spriteRenderer.flipX = moveDirection.x < 0; 
        } 
    }
    
    void UpdateAnimationState() 
    { 
        if (animator == null) return; 
        bool isMoving = !isEating && !isPooping && moveDirection.sqrMagnitude > 0.01f; 
        animator.SetBool("IsMoving", isMoving); 
        animator.SetBool("IsEating", isEating); 
    }
    
    bool CanShowThought() 
    { 
        return thoughtLibrary != null && thoughtBubblePrefab != null && thoughtCooldownTimer <= 0f; 
    }
    
    void ShowThought(ThoughtTrigger trigger) 
    { 
        if (thoughtLibrary == null || thoughtLibrary.allThoughts == null) return; 
        
        var entry = thoughtLibrary.allThoughts.FirstOrDefault(t => 
            t != null && t.speciesName == SpeciesName && t.trigger == trigger
        ); 
        
        if (entry != null && entry.lines != null && entry.lines.Count > 0) 
        { 
            string line = entry.lines[Random.Range(0, entry.lines.Count)]; 
            Transform spawnT = bubbleSpawnTransform ? bubbleSpawnTransform : transform; 
            GameObject bubbleGO = Instantiate(thoughtBubblePrefab, spawnT.position, Quaternion.identity, spawnT); 
            bubbleGO.transform.localPosition = Vector3.zero; 
            
            ThoughtBubbleController bubble = bubbleGO.GetComponent<ThoughtBubbleController>(); 
            if (bubble) 
            { 
                bubble.Initialize(line, spawnT, 2f); 
                thoughtCooldownTimer = thoughtCooldownTime; 
            } 
            else 
            { 
                Destroy(bubbleGO); 
            } 
        } 
    }
    
    public enum CauseOfDeath { Unknown, Starvation, EatenByPredator }
    
    private void Die(CauseOfDeath cause) 
    { 
        Debug.Log($"[{SpeciesName} died: {cause}]", gameObject); 
        Destroy(gameObject); 
    }
    
    public bool SpeciesNameEquals(string other) 
    { 
        return definition != null && definition.animalName == other; 
    }
    
    private void UpdateHpText() 
    { 
        if (hpText == null || definition == null) return; 
        hpText.text = $"HP: {Mathf.FloorToInt(currentHealth)}/{Mathf.FloorToInt(definition.maxHealth)}"; 
    }
    
    private void UpdateHungerText()
    {
        if (hungerText == null || animalDiet == null) return;
        hungerText.text = $"Hunger: {Mathf.FloorToInt(currentHunger)}/{Mathf.FloorToInt(animalDiet.maxHunger)}";
    }

    // --- NEW METHODS FOR SLOWDOWN SYSTEM ---
    
    // Method to apply speed multiplier from SlowdownZone
    public void ApplySpeedMultiplier(float multiplier)
    {
        if (!activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Add(multiplier);
            UpdateMovementSpeed();
            
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Applied speed multiplier: {multiplier}. New speed: {definition.movementSpeed}");
            }
        }
    }

    // Method to remove speed multiplier when leaving SlowdownZone
    public void RemoveSpeedMultiplier(float multiplier)
    {
        if (activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Remove(multiplier);
            UpdateMovementSpeed();
            
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Removed speed multiplier: {multiplier}. New speed: {definition.movementSpeed}");
            }
        }
    }

    // Method to recalculate movement speed based on active multipliers
    private void UpdateMovementSpeed()
    {
        // Start with base speed (original speed from definition)
        float newSpeed = baseMovementSpeed;
        
        // Apply all active multipliers
        if (activeSpeedMultipliers.Count > 0)
        {
            // Use the most restrictive (lowest) multiplier
            float lowestMultiplier = 1.0f;
            foreach (float multiplier in activeSpeedMultipliers)
            {
                if (multiplier < lowestMultiplier)
                {
                    lowestMultiplier = multiplier;
                }
            }
            
            newSpeed *= lowestMultiplier;
        }
        
        // Update the definition's movement speed (which is used in FixedUpdate)
        definition.movementSpeed = newSpeed;
        
        // Optionally update animation speed to match movement
        if (animator != null)
        {
            float speedRatio = newSpeed / baseMovementSpeed;
            animator.speed = Mathf.Max(0.5f, speedRatio); // Don't go below half speed
        }
    }

}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalSpawnData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[System.Serializable]
public class AnimalSpawnData {
    public AnimalDefinition animalDefinition;
    [Range(0f, 1f)]
    [Tooltip("Spawn rate multiplier (0 = no spawn; lower values = less frequent spawns).")]
    public float spawnRateMultiplier = 1f;
    [Tooltip("Maximum number of this animal type allowed to be spawned (0 = no limit).")]
    public int maximumSpawned = 0;
    
    [HideInInspector]
    public float spawnTimer = 0f;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalThoughtLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "AnimalThoughtLibrary", menuName = "Ecosystem/Animal Thought Library")]
public class AnimalThoughtLibrary : ScriptableObject
{
    public List<AnimalThoughtLine> allThoughts;
}

[System.Serializable]
public class AnimalThoughtLine
{
    [Header("Which Animal?")]
    public string speciesName; // e.g. "Bunny", "Fox", "Bird"

    [Header("Trigger Condition")]
    public ThoughtTrigger trigger;

    [Header("Possible Lines to Randomly Choose From")]
    public List<string> lines;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\EcosystemManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/EcosystemManager.cs
using UnityEngine;

public class EcosystemManager : MonoBehaviour
{
    public static EcosystemManager Instance { get; private set; }

    [Header("Parent Transforms")]
    public Transform animalParent;
    public Transform plantParent;

    [Header("Libraries")]
    [Tooltip("Reference to the Scent Library asset.")]
    public ScentLibrary scentLibrary; // <<< ADDED

    [Header("Sorting Options")]
    public bool sortAnimalsBySpecies = true;
    public bool sortPlantsBySpecies = true;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // Validate Library Reference
        if (scentLibrary == null)
        {
            Debug.LogWarning($"[{nameof(EcosystemManager)}] Scent Library not assigned! Scent effects will not work.", this);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FaunaManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/FaunaManager.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class FaunaManager : MonoBehaviour
{
    [Header("Spawning Area (Global)")]
    [SerializeField] private Vector2 spawnCenter = Vector2.zero;
    [SerializeField] private Vector2 spawnAreaSize = new Vector2(20f, 10f);

    [Header("General Settings")]
    [SerializeField] private Transform ecosystemParent;
    [Tooltip("How far INSIDE the screen edge the effective animal movement bounds are.")]
    [SerializeField][Min(0f)] private float screenBoundsPadding = 0.5f;
    [Tooltip("How far OUTSIDE the screen edge the 'Offscreen' spawn area starts.")]
    [SerializeField][Min(0f)] private float offscreenSpawnMargin = 2.0f;

    [Header("Debugging")]
    [Tooltip("Show gizmos visualizing the Margin (Red) and Padding (Green) bounds.")]
    [SerializeField] private bool showBoundsGizmos = false;

    [Header("Functional Bounds Offset")] // <<< UPDATED HEADER NAME
    [Tooltip("Functional horizontal shift for gameplay bounds and spawning relative to camera view.")] // <<< UPDATED TOOLTIP
    [SerializeField][Range(-10f, 10f)] private float boundsOffsetX = 0f; // <<< RENAMED FIELD
    [Tooltip("Functional vertical shift for gameplay bounds and spawning relative to camera view.")] // <<< UPDATED TOOLTIP
    [SerializeField][Range(-10f, 10f)] private float boundsOffsetY = 0f; // <<< RENAMED FIELD

    // --- Runtime State ---
    private List<Coroutine> activeSpawnCoroutines = new List<Coroutine>();
    private Camera mainCamera;

    // --- Start, InitializeManager, Update, ExecuteSpawnWave, StopAllSpawnCoroutines, SpawnWaveEntryCoroutine (Unchanged) ---
    void Start() { InitializeManager(); }
    void InitializeManager() { activeSpawnCoroutines.Clear(); if (WaveManager.Instance != null) { mainCamera = WaveManager.Instance.GetMainCamera(); } if (mainCamera == null) { mainCamera = Camera.main; if (mainCamera == null) Debug.LogError("[FaunaManager] Cannot find Main Camera!", this); } if (ecosystemParent == null) { ecosystemParent = transform; Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned to self.", this); } }
    void Update() { /* ... */ }
    public void ExecuteSpawnWave(WaveDefinition waveDef) { if (waveDef == null) { Debug.LogError("[FaunaManager] ExecuteSpawnWave null WaveDefinition!", this); return; } if (waveDef.spawnEntries == null || waveDef.spawnEntries.Count == 0) { Debug.LogWarning($"[FaunaManager] Wave '{waveDef.waveName}' has no spawn entries.", this); return; } Debug.Log($"[FaunaManager] Executing spawn for Wave: '{waveDef.waveName}'"); foreach (WaveSpawnEntry entry in waveDef.spawnEntries) { if (entry.animalDefinition == null) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', null AnimalDefinition."); continue; } if (entry.spawnCount <= 0) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', Spawn Count <= 0."); continue; } WaveSpawnEntry currentEntry = entry; Coroutine spawnCoroutine = StartCoroutine(SpawnWaveEntryCoroutine(currentEntry)); activeSpawnCoroutines.Add(spawnCoroutine); } Debug.Log($"[FaunaManager] Started {activeSpawnCoroutines.Count} coroutine(s) for '{waveDef.waveName}'."); }
    public void StopAllSpawnCoroutines() { if (activeSpawnCoroutines.Count > 0) { Debug.Log("[FaunaManager] Stopping all spawn coroutines."); foreach (Coroutine co in activeSpawnCoroutines) { if (co != null) StopCoroutine(co); } activeSpawnCoroutines.Clear(); } }
     private IEnumerator SpawnWaveEntryCoroutine(WaveSpawnEntry entry) { if (entry.delayAfterSpawnTime > 0) { yield return new WaitForSeconds(entry.delayAfterSpawnTime); } for (int i = 0; i < entry.spawnCount; i++) { if (WaveManager.Instance != null && !WaveManager.Instance.IsRunActive) { Debug.Log($"[FaunaManager] Halting spawn '{entry.description}', run no longer active."); break; } Vector2 spawnPos = CalculateSpawnPosition(entry.spawnLocationType, entry.spawnRadius); bool isOffscreen = entry.spawnLocationType == WaveSpawnLocationType.Offscreen; GameObject spawnedAnimal = SpawnAnimal(entry.animalDefinition, spawnPos, isOffscreen); if (entry.spawnInterval > 0 && i < entry.spawnCount - 1) { yield return new WaitForSeconds(entry.spawnInterval); } } if (activeSpawnCoroutines.Count > 0) activeSpawnCoroutines.RemoveAt(0); } // Simplistic removal

    /// <summary>
    /// Calculates a spawn position based on the specified type, applying functional offset.
    /// </summary>
    private Vector2 CalculateSpawnPosition(WaveSpawnLocationType locationType, float radius) // <<< MODIFIED
    {
        if (mainCamera == null) { Debug.LogError("[FaunaManager] Missing Main Camera!"); return spawnCenter; }

        // --- Calculate the FUNCTIONAL offset ---
        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        // --- Apply offset to camera position for ALL calculations below ---
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

        Vector2 spawnPos = Vector2.zero;
        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;

        switch (locationType)
        {
            case WaveSpawnLocationType.Offscreen:
                // Use effectiveCamPos for calculations
                float marginMinX = effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin;
                float marginMaxX = effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin;
                float marginMinY = effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin;
                float marginMaxY = effectiveCamPos.y + camHeight / 2f + offscreenSpawnMargin;
                float extraOffset = 0.1f; // To spawn strictly outside the line
                int edge = Random.Range(0, 4);
                if (edge == 0) { spawnPos.x = marginMinX - extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
                else if (edge == 1) { spawnPos.x = marginMaxX + extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
                else if (edge == 2) { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMinY - extraOffset; }
                else { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMaxY + extraOffset; }
                break;

            case WaveSpawnLocationType.RandomNearPlayer:
                 Transform playerT = FindPlayerTransform();
                 if (playerT != null) {
                    // Spawn relative to player, still respecting the overall bounds offset implicitly
                    spawnPos = (Vector2)playerT.position + Random.insideUnitCircle * radius;
                 } else {
                     Debug.LogWarning("[FaunaManager] Player not found for RandomNearPlayer. Falling back to Global.");
                     goto case WaveSpawnLocationType.GlobalSpawnArea; // Fallthrough
                 }
                 break;

            case WaveSpawnLocationType.GlobalSpawnArea:
            default:
                // Use effectiveCamPos OR a fixed world space center? Let's stick to camera relative for now.
                // If you want truly fixed global spawn, use spawnCenter directly.
                // This uses the *shifted* camera center as the basis for the global area.
                spawnPos.x = effectiveCamPos.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
                spawnPos.y = effectiveCamPos.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
                break;
        }
        return spawnPos;
    }

    private Transform FindPlayerTransform()
    {
        Transform pT = null;
        if (WaveManager.Instance != null)
        {
            var pI = FindAnyObjectByType<PlayerTileInteractor>();
            if (pI != null) pT = pI.transform;
        }
        if (pT == null)
        {
            GameObject pO = GameObject.FindGameObjectWithTag("Player");
            if (pO != null) pT = pO.transform;
        }
        return pT;
    }
    
    /// <summary>
    /// Instantiates and initializes an animal, passing SHIFTED screen bounds.
    /// </summary>
    private GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position, bool isOffscreenSpawn) // <<< MODIFIED
    {
        if (definition == null || definition.prefab == null) { /* Error Log */ return null; }
        if (mainCamera == null) { /* Error Log */ return null; }

        // --- Calculate SHIFTED Padded Screen Bounds ---
        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

        Vector2 minPaddedBounds, maxPaddedBounds;
        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;

        minPaddedBounds.x = effectiveCamPos.x - camWidth / 2f + screenBoundsPadding;
        maxPaddedBounds.x = effectiveCamPos.x + camWidth / 2f - screenBoundsPadding;
        minPaddedBounds.y = effectiveCamPos.y - camHeight / 2f + screenBoundsPadding;
        maxPaddedBounds.y = effectiveCamPos.y + camHeight / 2f - screenBoundsPadding;
        // ---------------------------------------------

        GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

        // Parenting (unchanged)
        if (ecosystemParent != null) { Transform sP = ecosystemParent; if (!string.IsNullOrEmpty(definition.animalName)) { sP = ecosystemParent.Find(definition.animalName); if (sP == null) { GameObject subP = new GameObject(definition.animalName); subP.transform.SetParent(ecosystemParent); sP = subP.transform; } } animalObj.transform.SetParent(sP); }

        // Initialize Controller, passing the SHIFTED bounds
        AnimalController controller = animalObj.GetComponent<AnimalController>();
        if (controller != null) {
            controller.Initialize(definition, minPaddedBounds, maxPaddedBounds, isOffscreenSpawn); // Pass shifted bounds
        } else { /* Error Log & Destroy */ Destroy(animalObj); return null; }
        return animalObj;
    }

    /// <summary>
    /// Draws debug rectangles applying the functional offset.
    /// </summary>
    void OnDrawGizmos() // <<< MODIFIED to use offset
    {
        if (!showBoundsGizmos || mainCamera == null) return;

        // --- Apply functional offset for Gizmo drawing ---
        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;
        // --------------------------------------------------

        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;

        // Calculate corners using effectiveCamPos
        Vector2 paddedMin = new Vector2(effectiveCamPos.x - camWidth / 2f + screenBoundsPadding, effectiveCamPos.y - camHeight / 2f + screenBoundsPadding);
        Vector2 paddedMax = new Vector2(effectiveCamPos.x + camWidth / 2f - screenBoundsPadding, effectiveCamPos.y + camHeight / 2f - screenBoundsPadding);
        DrawWireRectangleGizmo(paddedMin, paddedMax, Color.green);

        Vector2 marginMin = new Vector2(effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin, effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin);
        Vector2 marginMax = new Vector2(effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin, effectiveCamPos.y + camHeight / 2f + offscreenSpawnMargin);
        DrawWireRectangleGizmo(marginMin, marginMax, Color.red);
    }

    void DrawWireRectangleGizmo(Vector2 min, Vector2 max, Color color) { /* Unchanged */ Gizmos.color = color; Gizmos.DrawLine(new Vector3(min.x, min.y, 0), new Vector3(max.x, min.y, 0)); Gizmos.DrawLine(new Vector3(max.x, min.y, 0), new Vector3(max.x, max.y, 0)); Gizmos.DrawLine(new Vector3(max.x, max.y, 0), new Vector3(min.x, max.y, 0)); Gizmos.DrawLine(new Vector3(min.x, max.y, 0), new Vector3(min.x, min.y, 0)); }

} // End of class


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FloraManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/FloraManager.cs
using UnityEngine;
using System.Collections.Generic; // Added for Dictionary
#if UNITY_EDITOR
using UnityEditor;
#endif

public class FloraManager : MonoBehaviour
{
    public static FloraManager Instance { get; private set; }

    [Header("Debugging - Scents")]
    [Tooltip("Show scent radii circle renderers in Game View during runtime.")]
    [SerializeField] private bool showScentRadiiRuntime = false;
    [SerializeField] private Color scentRadiusColorRuntime = Color.yellow;
    [SerializeField] private bool logGizmoCalls = false;
    [Space]
    [Tooltip("Prefab used to draw scent circles at runtime.")]
    [SerializeField] private GameObject circleVisualizerPrefab; // <<< ADDED
    [Tooltip("Parent transform for instantiated circle visualizers.")]
    [SerializeField] private Transform circleContainer; // <<< ADDED

    [Header("Debugging - Poop Absorption")] // <<< NEW HEADER
    [Tooltip("Show poop absorption radii circle renderers in Game View during runtime.")]
    [SerializeField] private bool showPoopAbsorptionRadiiRuntime = false;
    [Tooltip("Color of the poop absorption radius visualization.")]
    [SerializeField] private Color poopAbsorptionRadiusColorRuntime = new Color(0.6f, 0.4f, 0.2f, 0.5f); // Brown-ish color

    // --- Public Accessors ---
    public bool ShowScentRadiiRuntime => showScentRadiiRuntime;
    public Color ScentRadiusColorRuntime => scentRadiusColorRuntime;
    // <<< NEW ACCESSORS for poop absorption radius visualization >>>
    public bool ShowPoopAbsorptionRadiiRuntime => showPoopAbsorptionRadiiRuntime;
    public Color PoopAbsorptionRadiusColorRuntime => poopAbsorptionRadiusColorRuntime;

    // Dictionary to track circle visualizers per ScentSource
    private Dictionary<ScentSource, RuntimeCircleDrawer> activeCircleVisualizers = new Dictionary<ScentSource, RuntimeCircleDrawer>();
    // NEW: Dictionary to track poop absorption circle visualizers per PlantGrowth
    private Dictionary<PlantGrowth, RuntimeCircleDrawer> activePoopAbsorptionCircleVisualizers = new Dictionary<PlantGrowth, RuntimeCircleDrawer>();


    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Validate Debug Dependencies
        if (circleVisualizerPrefab == null) { Debug.LogError($"[{nameof(FloraManager)}] Circle Visualizer Prefab is not assigned!", this); }
        if (circleContainer == null) { Debug.LogError($"[{nameof(FloraManager)}] Circle Container transform is not assigned!", this); }
    }

     void Update() // Added Update loop
     {
         if (!Application.isPlaying) return;
         UpdateRuntimeCircleVisualizers();
         // NEW: Update poop absorption radius visualizers
         UpdatePoopAbsorptionCircleVisualizers();
     }

    void OnDestroy()
    {
        if (Instance == this) Instance = null;
        // Clean up any remaining visualizers when manager is destroyed
        foreach (var kvp in activeCircleVisualizers)
        {
            if (kvp.Value != null) Destroy(kvp.Value.gameObject);
        }
        activeCircleVisualizers.Clear();
        
        // NEW: Clean up poop absorption visualizers
        foreach (var kvp in activePoopAbsorptionCircleVisualizers)
        {
            if (kvp.Value != null) Destroy(kvp.Value.gameObject);
        }
        activePoopAbsorptionCircleVisualizers.Clear();
    }
    
    // NEW: Method to update poop absorption radius visualizers
    void UpdatePoopAbsorptionCircleVisualizers()
    {
        if (!Application.isPlaying) return;
        
        // Check if visualization is enabled
        bool showCircles = showPoopAbsorptionRadiiRuntime && circleVisualizerPrefab != null && circleContainer != null;
        
        if (!showCircles)
        {
            // If visualization is disabled, clean up any existing visualizers
            foreach (var kvp in activePoopAbsorptionCircleVisualizers)
            {
                if (kvp.Value != null) Destroy(kvp.Value.gameObject);
            }
            activePoopAbsorptionCircleVisualizers.Clear();
            return;
        }
        
        // Find all plants with the poop fertilizer effect
        PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
        HashSet<PlantGrowth> currentPlantsSet = new HashSet<PlantGrowth>(plants);
        
        // Track plants to remove (no longer exist or don't have the effect)
        List<PlantGrowth> plantsToRemove = new List<PlantGrowth>();
        
        // First, update existing visualizers
        foreach (var kvp in activePoopAbsorptionCircleVisualizers)
        {
            PlantGrowth plant = kvp.Key;
            RuntimeCircleDrawer drawer = kvp.Value;
            
            if (plant == null || drawer == null || !plant.gameObject.activeInHierarchy ||
                !currentPlantsSet.Contains(plant))
            {
                plantsToRemove.Add(plant);
                if (drawer != null) Destroy(drawer.gameObject);
                continue;
            }
            
            // Check if the plant still has a valid poop detection radius
            float poopRadius = GetPlantPoopDetectionRadius(plant);
            bool shouldShowThis = showCircles && poopRadius > 0.01f;
            
            if (shouldShowThis)
            {
                // Update drawer position and radius
                drawer.transform.position = plant.transform.position;
                drawer.UpdateCircle(poopRadius, poopAbsorptionRadiusColorRuntime);
            }
            else
            {
                drawer.HideCircle();
                plantsToRemove.Add(plant); // If radius is too small or zero, remove the visualizer
            }
        }
        
        // Remove plants that no longer need visualization
        foreach (var plant in plantsToRemove)
        {
            if (activePoopAbsorptionCircleVisualizers.TryGetValue(plant, out RuntimeCircleDrawer drawer))
            {
                if (drawer != null) Destroy(drawer.gameObject);
                activePoopAbsorptionCircleVisualizers.Remove(plant);
            }
        }
        
        // Create new visualizers for plants with poop fertilizer effect
        foreach (PlantGrowth plant in plants)
        {
            if (plant == null || activePoopAbsorptionCircleVisualizers.ContainsKey(plant)) continue;
            
            float poopRadius = GetPlantPoopDetectionRadius(plant);
            if (poopRadius <= 0.01f) continue; // Skip if radius is too small
            
            // Create new visualizer
            GameObject circleGO = Instantiate(circleVisualizerPrefab, plant.transform.position, 
                                             Quaternion.identity, circleContainer);
            RuntimeCircleDrawer newDrawer = circleGO.GetComponent<RuntimeCircleDrawer>();
            
            if (newDrawer != null)
            {
                newDrawer.UpdateCircle(poopRadius, poopAbsorptionRadiusColorRuntime);
                activePoopAbsorptionCircleVisualizers.Add(plant, newDrawer);
            }
            else
            {
                Debug.LogError($"Circle Visualizer Prefab '{circleVisualizerPrefab.name}' missing RuntimeCircleDrawer script!", circleVisualizerPrefab);
                Destroy(circleGO);
            }
        }
    }
    
    // NEW: Helper method to get poop detection radius from a plant
    private float GetPlantPoopDetectionRadius(PlantGrowth plant)
    {
        if (plant == null) return 0f;
        return plant.GetPoopDetectionRadius();
    }

    // --- Runtime Visualizer Update ---
    void UpdateRuntimeCircleVisualizers()
    {
        if (!Application.isPlaying) return; // Only run in play mode

        // Check if lines should be shown globally
        bool showCircles = showScentRadiiRuntime && circleVisualizerPrefab != null && circleContainer != null;

        // --- Update existing circles and create new ones ---
        // Use a temporary list to avoid modifying dictionary while iterating
        List<ScentSource> sourcesToRemove = new List<ScentSource>();

        foreach (var kvp in activeCircleVisualizers)
        {
            ScentSource source = kvp.Key;
            RuntimeCircleDrawer line = kvp.Value;

            if (source == null || line == null || !source.gameObject.activeInHierarchy) // Source or drawer destroyed unexpectedly
            {
                sourcesToRemove.Add(source); // Mark for removal
                if(line != null) Destroy(line.gameObject); // Destroy orphan drawer
                continue;
            }

            // Check if circles should be shown globally and if this source is valid
            bool shouldShowThis = showCircles && source.enabled && source.definition != null && source.EffectiveRadius > 0.01f;

            if (shouldShowThis)
            {
                 // Update drawer position to match source and update circle params
                 line.transform.position = source.transform.position;
                 line.transform.rotation = source.transform.rotation; // Match rotation? Optional.
                 line.UpdateCircle(source.EffectiveRadius, scentRadiusColorRuntime);
            }
            else
            {
                 line.HideCircle(); // Hide if shouldn't be shown
            }
        }

        // Remove entries for sources that are gone
        foreach (var source in sourcesToRemove)
        {
            if (activeCircleVisualizers.TryGetValue(source, out RuntimeCircleDrawer drawer) && drawer != null)
                Destroy(drawer.gameObject);
            activeCircleVisualizers.Remove(source);
        }

        // --- Add circles for new sources ---
        if (showCircles)
        {
            // Find all active ScentSources
            ScentSource[] currentSources = FindObjectsByType<ScentSource>(FindObjectsSortMode.None);
            
            foreach (ScentSource source in currentSources)
            {
                // Skip if already has a visualizer or is invalid
                if (source == null || activeCircleVisualizers.ContainsKey(source) || !source.enabled || 
                    source.definition == null || source.EffectiveRadius <= 0.01f) continue;

                 // Create new visualizer
                 GameObject circleGO = Instantiate(circleVisualizerPrefab, source.transform.position, 
                                                 source.transform.rotation, circleContainer);
                 RuntimeCircleDrawer newDrawer = circleGO.GetComponent<RuntimeCircleDrawer>();

                 if (newDrawer != null)
                 {
                      newDrawer.UpdateCircle(source.EffectiveRadius, scentRadiusColorRuntime);
                      activeCircleVisualizers.Add(source, newDrawer); // Add to tracking
                 }
                 else
                 {
                    Debug.LogError($"Circle Visualizer Prefab '{circleVisualizerPrefab.name}' is missing RuntimeCircleDrawer script!", circleVisualizerPrefab);
                    Destroy(circleGO);
                 }
            }
        }
        // --- Hide/Destroy all if global flag turned off ---
        else if (!showCircles && activeCircleVisualizers.Count > 0)
        {
             foreach (var kvp in activeCircleVisualizers)
             {
                 if (kvp.Value != null) Destroy(kvp.Value.gameObject);
             }
             activeCircleVisualizers.Clear();
        }
    }


    // --- Gizmo Drawing (Editor Visualization - Unchanged) ---
    #if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        // Use the runtime flag to ALSO control the editor gizmo
        if (showScentRadiiRuntime) {
             if (logGizmoCalls) { /*...*/ }
             Gizmos.color = scentRadiusColorRuntime; // Use runtime color for gizmo too
             ScentSource[] scentSources = FindObjectsByType<ScentSource>(FindObjectsSortMode.None);
             if (logGizmoCalls) { /*...*/ }
             int drawnCount = 0;
             foreach (ScentSource source in scentSources) {
                if (source == null || !source.enabled || source.definition == null) continue;
                float radius = source.EffectiveRadius;
                if (radius > 0.01f) { Gizmos.DrawWireSphere(source.transform.position, radius); drawnCount++; }
             }
             if (logGizmoCalls && drawnCount > 0) { /*...*/ }
             else if (logGizmoCalls && scentSources.Length > 0) { /*...*/ }
        }
        
        // NEW: Draw poop absorption radius in editor
        if (showPoopAbsorptionRadiiRuntime) {
             Gizmos.color = poopAbsorptionRadiusColorRuntime;
             PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
             int drawnCount = 0;
             
             foreach (PlantGrowth plant in plants) {
                if (plant == null) continue;
                float radius = GetPlantPoopDetectionRadius(plant);
                if (radius > 0.01f) {
                    Gizmos.DrawWireSphere(plant.transform.position, radius);
                    drawnCount++;
                }
             }
             
             if (logGizmoCalls && drawnCount > 0) {
                 Debug.Log($"[FloraManager] Drew {drawnCount} poop absorption radius gizmos");
             }
        }
    }
    #endif
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\PoopController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/PoopController.cs (Ensure Collider is Added)

using UnityEngine;
using TMPro;

[RequireComponent(typeof(Collider2D))] // Add RequireComponent for Collider2D
public class PoopController : MonoBehaviour
{
    [Tooltip("Total lifetime of this poop (in seconds) before disappearing.")]
    public float lifetime = 10f;
    [Tooltip("Duration at the end of the lifetime during which the poop fades out.")]
    public float fadeDuration = 2f;
    [Tooltip("Fadeout curve to control the alpha during fade-out. X axis goes from 0 (start of fade) to 1 (end of fade).")]
    public AnimationCurve fadeCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);

    private SpriteRenderer sr;
    private float timer = 0f;
    private Color initialColor;
    private Collider2D poopCollider; // Reference to the collider

    private void Awake()
    {
        sr = GetComponent<SpriteRenderer>();
        if (sr != null)
        {
            initialColor = sr.color;
        }
        
        // Ensure there's a collider and it's properly configured
        poopCollider = GetComponent<Collider2D>();
        if (poopCollider == null)
        {
            // If no collider exists, add a CircleCollider2D
            poopCollider = gameObject.AddComponent<CircleCollider2D>();
            Debug.Log($"Added CircleCollider2D to {gameObject.name} for poop detection", gameObject);
        }
        
        // Make sure it's a trigger so it doesn't block movement
        poopCollider.isTrigger = true;
    }

    private void Update()
    {
        timer += Time.deltaTime;
        if (timer >= lifetime)
        {
            Destroy(gameObject);
            return;
        }

        // If within fadeDuration at the end, apply fade-out using the fadeCurve.
        float remaining = lifetime - timer;
        if (remaining < fadeDuration && sr != null)
        {
            // Normalize fade time (0 = start, 1 = end)
            float t = 1f - (remaining / fadeDuration);
            float alphaMultiplier = fadeCurve.Evaluate(t);
            Color newColor = initialColor;
            newColor.a = alphaMultiplier;
            sr.color = newColor;
        }
    }

    // Initialize with default parameters if none are provided.
    public void Initialize(float lifetimeValue = -1f, float fadeDurationValue = -1f)
    {
        if (lifetimeValue > 0f)
            lifetime = lifetimeValue;
        if (fadeDurationValue > 0f)
            fadeDuration = fadeDurationValue;
        timer = 0f;
        if (sr != null)
            initialColor = sr.color;
            
        // Ensure collider is configured properly
        if (poopCollider == null)
        {
            poopCollider = GetComponent<Collider2D>();
            if (poopCollider == null)
            {
                poopCollider = gameObject.AddComponent<CircleCollider2D>();
            }
            poopCollider.isTrigger = true;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ScentSource.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/ScentSource.cs
using UnityEngine;

// No longer requires RuntimeCircleDrawer directly
// REMOVED: [RequireComponent(typeof(RuntimeCircleDrawer))]
public class ScentSource : MonoBehaviour
{
    [Header("Scent Definition")]
    [Tooltip("The base Scent Definition applied to this object.")]
    public ScentDefinition definition; // Assigned by PlantGrowth/Node effects

    [Header("Applied Modifiers")]
    [Tooltip("Bonus radius added by node effects.")]
    public float radiusModifier = 0f;
    [Tooltip("Bonus strength added by node effects.")]
    public float strengthModifier = 0f;

    // REMOVED: Debugging Reference private RuntimeCircleDrawer circleDrawer;

    // --- Calculated Effective Properties ---
    /// <summary> Gets the effective scent radius (Base Radius + Modifier), clamped >= 0. </summary>
    public float EffectiveRadius => Mathf.Max(0f, (definition != null ? definition.baseRadius : 0f) + radiusModifier);
    /// <summary> Gets the effective scent strength (Base Strength + Modifier), clamped >= 0. </summary>
    public float EffectiveStrength => Mathf.Max(0f, (definition != null ? definition.baseStrength : 0f) + strengthModifier);


    void Awake()
    {
        // No longer needs to get or manage the circle drawer component here
        // REMOVED: circleDrawer = GetComponent<RuntimeCircleDrawer>();
        // REMOVED: circleDrawer?.HideCircle();
    }

    // REMOVED: Update() method (FloraManager handles creating/updating/hiding the external visualizer)


    // Keep Gizmo for Editor visualization (runs independently of Update and runtime drawers)
    void OnDrawGizmosSelected()
    {
        float effectiveRadius = EffectiveRadius; // Calculate radius for gizmo

        if (definition != null) // Check if a definition is assigned
        {
            if (effectiveRadius > 0.01f) // Only draw if radius is meaningful
            {
                // Use definition name hash for consistent random color
                // Note: Random.InitState affects the *next* Random call globally,
                // which might be undesirable if other Gizmos rely on it.
                // A more robust way might be a custom color mapping or a simple hash function.
                // For simplicity, we'll keep Random.InitState for now.
                int prevState = Random.state.GetHashCode(); // Store previous state
                Random.InitState(definition.name.GetHashCode());
                Color gizmoColor = Random.ColorHSV(0f, 1f, 0.7f, 0.9f, 0.8f, 1f);
                gizmoColor.a = 0.3f; // Set alpha for gizmo
                Random.InitState(prevState); // Restore previous state

                Gizmos.color = gizmoColor;
                Gizmos.DrawWireSphere(transform.position, effectiveRadius);
            }
        }
        else // Draw default gray if no definition assigned yet
        {
            Gizmos.color = new Color(0.8f, 0.8f, 0.8f, 0.2f);
            Gizmos.DrawWireSphere(transform.position, 1f); // Default size for editor only
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\SlowdownZone.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

public class SlowdownZone : MonoBehaviour
{
    [Header("Slowdown Settings")]
    [Tooltip("How much to multiply movement speed by (0.5 = half speed)")]
    [Range(0.1f, 1.0f)]
    public float speedMultiplier = 0.5f;
    
    [Header("Collider Adjustment")]
    [Tooltip("How much to shrink the collider from its edges (in units)")]
    [Range(0f, 1f)]
    public float colliderShrinkAmount = 0.2f;
    
    [Header("Debug")]
    [SerializeField] private bool showDebugMessages = false;
    
    // Keep track of entities currently affected
    private Dictionary<int, AnimalController> affectedAnimals = new Dictionary<int, AnimalController>();
    private Dictionary<int, GardenerController> affectedPlayers = new Dictionary<int, GardenerController>();
    
    // Original collider properties (for shrinking)
    private Vector2 originalSize;
    private Vector2 originalOffset;
    private BoxCollider2D boxCollider;
    
    private void Awake()
    {
        // Get the collider and ensure it's a trigger
        Collider2D col = GetComponent<Collider2D>();
        if (col == null)
        {
            Debug.LogError($"SlowdownZone on '{gameObject.name}' requires a Collider2D component!", gameObject);
            enabled = false;
            return;
        }
        
        if (!col.isTrigger)
        {
            col.isTrigger = true;
            Debug.Log($"SlowdownZone on '{gameObject.name}' automatically enabled isTrigger on its collider.");
        }
        
        // Store original size for BoxCollider2D
        boxCollider = col as BoxCollider2D;
        if (boxCollider != null)
        {
            originalSize = boxCollider.size;
            originalOffset = boxCollider.offset;
            
            // Apply shrinking
            if (colliderShrinkAmount > 0)
            {
                ShrinkCollider();
            }
        }
        else
        {
            // If it's not a BoxCollider2D, log a warning
            Debug.LogWarning($"SlowdownZone on '{gameObject.name}' is using a collider type other than BoxCollider2D. " +
                             "Collider shrinking will not work.", gameObject);
        }
    }
    
    private void ShrinkCollider()
    {
        if (boxCollider == null) return;
        
        // Calculate new size by subtracting shrink amount from both dimensions
        Vector2 newSize = new Vector2(
            Mathf.Max(0.1f, originalSize.x - (colliderShrinkAmount * 2f)),
            Mathf.Max(0.1f, originalSize.y - (colliderShrinkAmount * 2f))
        );
        
        // Apply the new size
        boxCollider.size = newSize;
        
        if (showDebugMessages)
        {
            Debug.Log($"SlowdownZone: Shrunk collider from {originalSize} to {newSize}");
        }
    }
    
    private void OnValidate()
    {
        // Update collider size when values change in inspector
        if (Application.isPlaying && boxCollider != null)
        {
            ShrinkCollider();
        }
    }
    
    private void OnTriggerEnter2D(Collider2D other)
    {
        // Check if it's an animal
        AnimalController animal = other.GetComponent<AnimalController>();
        if (animal != null)
        {
            // Add to affected list
            int id = animal.GetInstanceID();
            affectedAnimals[id] = animal;
            
            // Apply slowdown effect
            animal.ApplySpeedMultiplier(speedMultiplier);
            
            if (showDebugMessages)
                Debug.Log($"SlowdownZone: '{animal.name}' entered zone, applied multiplier {speedMultiplier}");
            
            return; // Skip further checks if it's an animal
        }
        
        // Check if it's the player (gardener)
        GardenerController player = other.GetComponent<GardenerController>();
        if (player != null)
        {
            // Add to affected list
            int id = player.GetInstanceID();
            affectedPlayers[id] = player;
            
            // Apply slowdown effect
            player.ApplySpeedMultiplier(speedMultiplier);
            
            if (showDebugMessages)
                Debug.Log($"SlowdownZone: Player '{player.name}' entered zone, applied multiplier {speedMultiplier}");
        }
    }
    
    private void OnTriggerExit2D(Collider2D other)
    {
        // Check if it's an animal
        AnimalController animal = other.GetComponent<AnimalController>();
        if (animal != null)
        {
            // Remove from affected list
            int id = animal.GetInstanceID();
            if (affectedAnimals.ContainsKey(id))
            {
                affectedAnimals.Remove(id);
                
                // Remove slowdown effect
                animal.RemoveSpeedMultiplier(speedMultiplier);
                
                if (showDebugMessages)
                    Debug.Log($"SlowdownZone: '{animal.name}' exited zone, removed multiplier");
            }
            
            return; // Skip further checks if it's an animal
        }
        
        // Check if it's the player (gardener)
        GardenerController player = other.GetComponent<GardenerController>();
        if (player != null)
        {
            // Remove from affected list
            int id = player.GetInstanceID();
            if (affectedPlayers.ContainsKey(id))
            {
                affectedPlayers.Remove(id);
                
                // Remove slowdown effect
                player.RemoveSpeedMultiplier(speedMultiplier);
                
                if (showDebugMessages)
                    Debug.Log($"SlowdownZone: Player '{player.name}' exited zone, removed multiplier");
            }
        }
    }
    
    // Clean up when destroyed
    private void OnDestroy()
    {
        // Remove effects from all affected animals
        foreach (var animal in affectedAnimals.Values)
        {
            if (animal != null)
            {
                animal.RemoveSpeedMultiplier(speedMultiplier);
            }
        }
        affectedAnimals.Clear();
        
        // Remove effects from all affected players
        foreach (var player in affectedPlayers.Values)
        {
            if (player != null)
            {
                player.RemoveSpeedMultiplier(speedMultiplier);
            }
        }
        affectedPlayers.Clear();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtBubbleController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class ThoughtBubbleController : MonoBehaviour
{
    public TMP_Text messageText;
    public float lifetime = 2f;

    private Transform followTarget;

    public void Initialize(string message, Transform target, float duration = 2f)
    {
        if (messageText != null)
            messageText.text = message;
        followTarget = target;
        lifetime = duration;
    }

    private void Update()
    {
        lifetime -= Time.deltaTime;
        if (lifetime <= 0f)
            Destroy(gameObject);

        // Follow the target if needed (optional if already a child)
        if (followTarget != null)
        {
            transform.position = followTarget.position;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtTrigger.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public enum ThoughtTrigger
{
    Hungry,
    Eating,
    HealthLow,
    Fleeing,
    Pooping,
    // Add more triggers as needed
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\WaveDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/WaveDefinition.cs
using UnityEngine;
using System.Collections.Generic;

// Enum WaveSpawnLocationType remains the same
public enum WaveSpawnLocationType
{
    GlobalSpawnArea,
    RandomNearPlayer,
    Offscreen
}

// Class WaveSpawnEntry remains the same
[System.Serializable]
public class WaveSpawnEntry
{
    [Tooltip("Optional description for this specific spawn group within the wave.")]
    public string description = "Spawn Group";
    [Tooltip("The type of animal to spawn.")]
    public AnimalDefinition animalDefinition;
    [Tooltip("How many of this animal to spawn in this specific entry.")]
    [Min(1)]
    public int spawnCount = 1;
    [Tooltip("Delay (in seconds) AFTER the designated wave spawn time (e.g. Day 50%) before *this entry* begins spawning.")] // Clarified Tooltip
    [Min(0)]
    public float delayAfterSpawnTime = 0f; // Renamed from delayAfterWaveStart
    [Tooltip("Time (in seconds) between spawning each individual animal in this entry (0 = spawn all instantly).")]
    [Min(0)]
    public float spawnInterval = 0.5f;
    [Tooltip("Where these animals should spawn.")]
    public WaveSpawnLocationType spawnLocationType = WaveSpawnLocationType.GlobalSpawnArea;
    [Tooltip("Radius used for spawning (e.g., if Spawn Location Type is RandomNearPlayer).")]
    [Min(0)]
    public float spawnRadius = 5f;
}

// WaveDefinition ScriptableObject is simplified further
[CreateAssetMenu(fileName = "Wave_", menuName = "Ecosystem/Wave Definition")]
public class WaveDefinition : ScriptableObject
{
    [Header("Wave Identification")]
    [Tooltip("Editor-only name for this wave.")]
    public string waveName = "New Wave";

    [Header("Wave Content")]
    [Tooltip("Define the groups of animals that spawn during this wave.")]
    public List<WaveSpawnEntry> spawnEntries = new List<WaveSpawnEntry>();

    // REMOVED all timing, duration, end condition, delay fields.
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\WaveManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Managers/WaveManager.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine.UI;

public enum WaveManagerState
{
    PausedBeforeRun,     // Initial state, game logic paused
    WaitingForSpawnTime, // Run started, waiting for correct time in cycle
    WaveInProgress,      // Spawning triggered for this cycle, counting down day cycles
    SequenceComplete     // All waves done
}

public class WaveManager : MonoBehaviour
{
    public static WaveManager Instance { get; private set; }

    [Header("Core Dependencies")]
    [SerializeField] private FaunaManager faunaManager;
    [SerializeField] private WeatherManager weatherManager;
    [SerializeField] private Camera mainCamera;

    [Header("Wave Sequence")]
    [SerializeField] private List<WaveDefinition> wavesSequence;

    [Header("Wave Timing & Spawning (Global)")]
    [Tooltip("How many full Day+Night cycles each wave lasts.")]
    [SerializeField][Range(1, 10)] private int waveDurationInDayCycles = 1;
    [Tooltip("The phase during which spawning should occur each cycle.")]
    [SerializeField] private WeatherManager.CyclePhase spawnStartPhase = WeatherManager.CyclePhase.Day;
    [Tooltip("The percentage progress within the Spawn Start Phase when spawning triggers (0-100).")]
    [SerializeField][Range(0f, 100f)] private float spawnStartPercentage = 50f;
    [SerializeField] private bool loopSequence = false;
    [Tooltip("If checked, animals from the previous wave are destroyed when a new wave starts.")]
    [SerializeField] private bool deletePreviousWaveAnimals = true;

    [Header("UI & Feedback")]
    [SerializeField] private TextMeshProUGUI waveStatusText;
    [SerializeField] private Button startRunButton;
    [SerializeField] private TextMeshProUGUI timeTrackerText;

    [Header("State (Read Only)")]
    [SerializeField] private WaveManagerState currentState = WaveManagerState.PausedBeforeRun;
    [SerializeField] private int currentWaveIndex = -1;

    // --- Runtime State ---
    private WaveDefinition activeWaveDefinition = null;
    private int dayCyclesRemainingForWave = 0;
    private bool hasSpawnedThisCycle = false;
    private bool isInitialPause = true; // <<< NEW: Flag for initial pause

    // --- Public Accessors ---
    public WaveManagerState CurrentState => currentState;
    public int CurrentWaveNumber => currentWaveIndex + 1;
    public int TotalWaves => wavesSequence != null ? wavesSequence.Count : 0;
    public bool IsRunActive => currentState != WaveManagerState.PausedBeforeRun && currentState != WaveManagerState.SequenceComplete;

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Validations (same as before)
        if (faunaManager == null) Debug.LogError("[WaveManager] FaunaManager missing!", this);
        if (weatherManager == null) Debug.LogError("[WaveManager] WeatherManager missing!", this);
        if (mainCamera == null) Debug.LogError("[WaveManager] Main Camera missing!", this);
        if (waveStatusText == null) Debug.LogWarning("[WaveManager] Wave Status Text missing.", this);
        if (timeTrackerText == null) Debug.LogWarning("[WaveManager] Time Tracker Text missing.", this);
        if (wavesSequence == null || wavesSequence.Count == 0) Debug.LogWarning("[WaveManager] Wave Sequence empty.", this);
        if (startRunButton == null) Debug.LogWarning("[WaveManager] Start Run Button missing.", this);
        else startRunButton.onClick.AddListener(TryStartRun);

        // <<< SET INITIAL PAUSE >>>
        Debug.Log("[WaveManager Awake] Setting initial Time.timeScale = 0");
        Time.timeScale = 0f;
        isInitialPause = true;
        // -------------------------
    }

    void Start()
    {
        if (weatherManager != null) weatherManager.OnPhaseChanged += HandleWeatherPhaseChange;
        InitializeManager(); // Sets state, updates button
    }

     void OnDestroy()
    {
        if (weatherManager != null) weatherManager.OnPhaseChanged -= HandleWeatherPhaseChange;
        if (startRunButton != null) startRunButton.onClick.RemoveListener(TryStartRun);
        // Ensure timescale is reset if manager is destroyed
        if(isInitialPause || Time.timeScale != 1f) Time.timeScale = 1f;
    }

    void InitializeManager()
    {
        currentWaveIndex = -1;
        activeWaveDefinition = null;
        dayCyclesRemainingForWave = 0;
        hasSpawnedThisCycle = false;
        // Don't set timescale here anymore, Awake handles initial pause
        SetState(WaveManagerState.PausedBeforeRun);
    }

    void Update()
    {
        // Always update UI if possible
        if (weatherManager != null) UpdateTimeTrackerUI();

        // Skip logic if paused initially OR dependencies missing
        if (isInitialPause || faunaManager == null || weatherManager == null || mainCamera == null)
        {
            // Still need to manage button state even if paused initially
             if (currentState == WaveManagerState.PausedBeforeRun && startRunButton != null)
             {
                  startRunButton.gameObject.SetActive(true);
                  startRunButton.interactable = true;
             }
             return;
        }

        // State Machine Update (only runs after initial pause is over)
        switch (currentState)
        {
            case WaveManagerState.WaitingForSpawnTime: Update_WaitingForSpawnTime(); break;
            case WaveManagerState.WaveInProgress: /* Handled by event */ break;
            case WaveManagerState.SequenceComplete: Update_IdleReady(); break;
             // PausedBeforeRun is handled above
        }
    }

    // --- Event Handler (HandleWeatherPhaseChange) --- (Unchanged)
    void HandleWeatherPhaseChange(WeatherManager.CyclePhase newPhase) { if (currentState == WaveManagerState.PausedBeforeRun || isInitialPause) return; if (newPhase == WeatherManager.CyclePhase.TransitionToDay) { if (currentState == WaveManagerState.WaveInProgress) { dayCyclesRemainingForWave--; hasSpawnedThisCycle = false; if(Debug.isDebugBuild) Debug.Log($"[WaveManager] Day cycle complete. Cycles remaining: {dayCyclesRemainingForWave}"); if (dayCyclesRemainingForWave <= 0) { EndWaveGameplay(); } else { SetState(WaveManagerState.WaitingForSpawnTime); UpdateWaveStatusText(); } } else if (currentState == WaveManagerState.WaitingForSpawnTime) { hasSpawnedThisCycle = false; } } else if (newPhase == spawnStartPhase && currentState == WaveManagerState.WaitingForSpawnTime && !hasSpawnedThisCycle) { Update_WaitingForSpawnTime(); } }


    // --- State Update Methods ---

    void Update_WaitingForSpawnTime() // (Unchanged)
    { if (hasSpawnedThisCycle || weatherManager == null) return; WeatherManager.CyclePhase currentPhase = weatherManager.CurrentPhase; float totalPhaseTime = weatherManager.CurrentTotalPhaseTime; float remainingPhaseTime = weatherManager.CurrentPhaseTimer; float progressPercent = (totalPhaseTime > 0) ? (1f - (remainingPhaseTime / totalPhaseTime)) * 100f : 0f; if (currentPhase == spawnStartPhase && progressPercent >= spawnStartPercentage) { StartWaveSpawning(); } }

    void Update_IdleReady() // (Now only manages button for looping)
    {
         if (startRunButton != null)
         {
            bool showButton = (currentState == WaveManagerState.SequenceComplete && loopSequence);
            startRunButton.gameObject.SetActive(showButton);
            startRunButton.interactable = showButton;
         }
    }

    void UpdateTimeTrackerUI() // (Unchanged)
    { if (timeTrackerText == null || weatherManager == null) return; WeatherManager.CyclePhase phase = weatherManager.CurrentPhase; float total = weatherManager.CurrentTotalPhaseTime; float remaining = weatherManager.CurrentPhaseTimer; float progressPercent = (total > 0) ? (1f - (remaining / total)) * 100f : 0f; string phaseName = phase.ToString().Replace("Transition", ""); timeTrackerText.text = $"{phaseName} [{progressPercent:F0}%]"; if (Time.timeScale == 0f && isInitialPause) timeTrackerText.text += " (Paused)"; } // Show paused during initial pause

    void UpdateWaveStatusText() // (Added PausedBeforeRun case)
    {
         if (waveStatusText == null) return;
         switch(currentState)
         {
             case WaveManagerState.PausedBeforeRun: waveStatusText.text = "Press Start Run"; break;
             case WaveManagerState.WaitingForSpawnTime: waveStatusText.text = $"Wave {CurrentWaveNumber} - Waiting..."; break;
             case WaveManagerState.WaveInProgress: waveStatusText.text = $"Wave {CurrentWaveNumber} [{dayCyclesRemainingForWave} cycles left]"; break;
            case WaveManagerState.SequenceComplete: waveStatusText.text = loopSequence ? "Sequence Done. Start Again?" : "All Waves Cleared!"; break;
             default: waveStatusText.text = ""; break;
         }
    }

    // --- State Transition and Action Methods ---

    void SetState(WaveManagerState newState) // (Removed weather pause logic)
    {
        if (currentState == newState) return;
        if(Debug.isDebugBuild) Debug.Log($"[WaveManager] State Change: {currentState} -> {newState}");
        currentState = newState;

        // Update Button State
        if (startRunButton != null)
        {
            bool showButton = (newState == WaveManagerState.PausedBeforeRun) || (newState == WaveManagerState.SequenceComplete && loopSequence);
            startRunButton.gameObject.SetActive(showButton);
            startRunButton.interactable = showButton;
        }

        // Update Status Text
        UpdateWaveStatusText();
    }

    public void TryStartRun() // <<< MODIFIED
    {
        // Only allow starting from PausedBeforeRun OR SequenceComplete if looping
        if (currentState != WaveManagerState.PausedBeforeRun && !(currentState == WaveManagerState.SequenceComplete && loopSequence))
        {
             if(Debug.isDebugBuild) Debug.Log($"[WaveManager] Cannot start run. State: {currentState}, Looping: {loopSequence}");
             return;
        }

        Debug.Log("[WaveManager] Starting Run...");

        // <<< RESUME TIME >>>
        if (isInitialPause || Time.timeScale != 1f)
        {
            Debug.Log("[WaveManager] Setting Time.timeScale = 1");
            Time.timeScale = 1f;
            isInitialPause = false; // Mark initial pause as over
        }
        // ----------------

        InitializeRun(); // Prepare first wave state
        SetState(WaveManagerState.WaitingForSpawnTime); // Transition state
    }

    void InitializeRun() // (Unchanged)
    { currentWaveIndex = 0; if (wavesSequence == null || wavesSequence.Count == 0 || wavesSequence[currentWaveIndex] == null) { Debug.LogError("[WaveManager] Cannot initialize run: Bad wave sequence!"); SetState(WaveManagerState.SequenceComplete); return; } if(deletePreviousWaveAnimals && currentState == WaveManagerState.SequenceComplete && loopSequence) { ClearAllActiveAnimals(); } activeWaveDefinition = wavesSequence[currentWaveIndex]; dayCyclesRemainingForWave = waveDurationInDayCycles; hasSpawnedThisCycle = false; Debug.Log($"[WaveManager] Run initialized. Starting Wave {CurrentWaveNumber}. Duration: {dayCyclesRemainingForWave} cycles."); }

    void StartWaveSpawning() // (Unchanged)
    { if (activeWaveDefinition == null || currentState != WaveManagerState.WaitingForSpawnTime) { return; } Debug.Log($"[WaveManager] Wave {CurrentWaveNumber} - Spawning Triggered (Phase: {spawnStartPhase} >= {spawnStartPercentage}%)"); hasSpawnedThisCycle = true; SetState(WaveManagerState.WaveInProgress); if (faunaManager != null) faunaManager.ExecuteSpawnWave(activeWaveDefinition); else Debug.LogError("[WaveManager] Cannot execute spawn wave, FaunaManager missing!"); }

    void EndWaveGameplay() // (Unchanged)
    { Debug.Log($"[WaveManager] Wave {CurrentWaveNumber} Gameplay Ended (Duration Met)."); if (faunaManager != null) faunaManager.StopAllSpawnCoroutines(); if (deletePreviousWaveAnimals) { ClearAllActiveAnimals(); } activeWaveDefinition = null; currentWaveIndex++; if (currentWaveIndex >= wavesSequence.Count) { if (loopSequence) { Debug.Log("[WaveManager] Looping back."); InitializeRun(); SetState(WaveManagerState.WaitingForSpawnTime); } else { Debug.Log("[WaveManager] Sequence complete."); SetState(WaveManagerState.SequenceComplete); } } else { if (wavesSequence[currentWaveIndex] == null) { Debug.LogError($"[WaveManager] Wave definition {currentWaveIndex} NULL!"); SetState(WaveManagerState.SequenceComplete); return; } activeWaveDefinition = wavesSequence[currentWaveIndex]; dayCyclesRemainingForWave = waveDurationInDayCycles; hasSpawnedThisCycle = false; Debug.Log($"[WaveManager] Preparing Wave {CurrentWaveNumber}. Duration: {dayCyclesRemainingForWave} cycles."); SetState(WaveManagerState.WaitingForSpawnTime); } }

    void ClearAllActiveAnimals() // (Unchanged)
    { if(Debug.isDebugBuild) Debug.Log("[WaveManager] Clearing all active animals."); AnimalController[] activeAnimals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None); int count = 0; foreach(AnimalController animal in activeAnimals) { if(animal != null) { Destroy(animal.gameObject); count++; } } if(Debug.isDebugBuild) Debug.Log($"[WaveManager] Destroyed {count} animals."); }

    public Camera GetMainCamera() { return mainCamera; } // (Unchanged)
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Effects\FireflyController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Rendering.Universal;
using System.Collections.Generic;

public class FireflyController : MonoBehaviour
{
    [Header("References (Optional)")]
    [Tooltip("Optional Light2D component for local glow.")]
    [SerializeField] private Light2D pointLight;
    [Tooltip("SpriteRenderer for flickering emission and alpha fade.")]
    [SerializeField] private SpriteRenderer spriteRenderer;

    [Header("Movement")]
    [Tooltip("Min/Max movement speed")]
    [SerializeField] private Vector2 speedRange = new Vector2(0.5f, 1.5f);
    [Tooltip("How often (in seconds) the firefly changes direction while wandering")]
    [SerializeField] private float directionChangeInterval = 2.0f;
    [Tooltip("Chance (0-1) that the firefly will pause when changing direction")]
    [SerializeField] [Range(0f, 1f)] private float pauseChance = 0.2f;
    [Tooltip("Min/Max duration (in seconds) for pauses")]
    [SerializeField] private Vector2 pauseDurationRange = new Vector2(0.5f, 1.5f);

    [Header("Lifetime & Fade")]
    [Tooltip("Min/Max lifetime (in seconds) before the firefly despawns")]
    [SerializeField] private Vector2 lifetimeRange = new Vector2(8f, 18f);
    [Tooltip("Duration (in seconds) of the fade-in effect when spawning")]
    [SerializeField] private float fadeInDuration = 0.75f;
    [Tooltip("Duration (in seconds) of the fade-out effect before despawning")]
    [SerializeField] private float fadeOutDuration = 1.5f;

    [Header("Normal Glow Flicker")]
    [Tooltip("If true, the firefly will have a subtle flickering effect during its lifetime")]
    [SerializeField] private bool enableFlicker = true;
    [Tooltip("Min/Max intensity values for normal flickering")]
    [SerializeField] private Vector2 intensityRange = new Vector2(1.5f, 3.0f);
    [Tooltip("Speed of normal flickering (cycles per second) - higher values create more rapid changes")]
    [SerializeField] private float flickerSpeed = 5.0f;

    [Header("Spawn Flicker Effect")]
    [Tooltip("If true, the firefly will have a special flickering effect when first spawned")]
    [SerializeField] private bool enableSpawnEffect = true;
    [Tooltip("Duration (in seconds) of the special spawn effect")]
    [SerializeField] private float spawnEffectDuration = 0.5f;
    [Tooltip("Base brightness to gradually increase to during spawn effect")]
    [SerializeField] private float spawnBaseIntensity = 2.0f;
    [Tooltip("Probability (0-1) of short blackout flickers during spawn effect")]
    [SerializeField] [Range(0f, 1f)] private float spawnBlackoutChance = 0.3f;
    [Tooltip("Min/Max duration (in seconds) of blackout flickers during spawn")]
    [SerializeField] private Vector2 blackoutDurationRange = new Vector2(0.01f, 0.08f);
    [Tooltip("Min/Max spacing (in seconds) between blackout flickers")]
    [SerializeField] private Vector2 blackoutSpacingRange = new Vector2(0.05f, 0.2f);

    [Header("Scent Attraction")]
    [Tooltip("How often (in seconds) the firefly checks for nearby scent sources.")]
    [SerializeField] private float scentCheckInterval = 1.0f;
    [Tooltip("Maximum distance squared the OverlapCircle will check.")]
    [SerializeField] private float scentOverlapCheckRadius = 10f;
    [Tooltip("How strongly the firefly steers towards the scent target.")]
    [SerializeField] private float attractionStrength = 2.0f;
    [Tooltip("Preferred distance to orbit the scent source.")]
    [SerializeField] private float orbitDistance = 0.8f;
    [Tooltip("How much randomness/wobble in the attracted movement.")]
    [SerializeField] private float attractionWobble = 0.5f;
    [Tooltip("Which Scent Definitions attract this firefly.")]
    [SerializeField] private List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();

    // --- Public Accessor ---
    public Transform AttractionTarget => attractionTarget;

    // --- Internal State ---
    private FireflyManager manager;
    private Vector2 currentVelocity;
    private float currentSpeed;
    private float stateTimer;
    private bool isPaused;
    private float lifetime;
    private float age = 0f;
    private float currentAlpha = 0f; // Overall transparency/fade progress
    private float flickerOffset;
    private Material spriteMaterialInstance; // Instanced material for modification

    // Scent State
    private Transform attractionTarget = null;
    private float scentCheckTimer;
    private ScentDefinition currentTargetScentDef = null;

    // Movement Bounds
    private Vector2 minBounds;
    private Vector2 maxBounds;

    // Store the original emission color *without* intensity scaling from the material asset
    private Color baseEmissionColor = Color.black; // Default to black if reading fails
    
    // New fields for tracking the improved spawn effect
    private float nextBlackoutTime = 0f;
    private float blackoutEndTime = 0f;
    private bool isInBlackout = false;

    void Awake()
    {
        if (spriteRenderer == null) spriteRenderer = GetComponent<SpriteRenderer>();
        if (spriteRenderer != null && spriteRenderer.material != null) {
            // Create instance BEFORE reading base emission
            spriteMaterialInstance = spriteRenderer.material;
            // Try to read the base emission color set in the material asset
            if (spriteMaterialInstance.HasProperty("_EmissionColor")) {
                 // Important: Get the color value directly. If it's HDR, this value
                 // might already have some intensity baked in, depending on how it was set.
                 // Ideally, set the material's emission color to the desired *hue/saturation*
                 // with an intensity of 1 in the editor, and control brightness purely via script.
                 baseEmissionColor = spriteMaterialInstance.GetColor("_EmissionColor");
                 // If the color read already has intensity > 1 baked in, we might need to normalize it.
                 // For simplicity, let's assume the user sets the base color correctly.
                 // Example normalization (if needed):
                 // float currentIntensity = Mathf.Max(baseEmissionColor.r, baseEmissionColor.g, baseEmissionColor.b);
                 // if (currentIntensity > 1.0f) baseEmissionColor /= currentIntensity;
            } else {
                 Debug.LogWarning($"[{gameObject.name}] Material '{spriteMaterialInstance.name}' does not have an '_EmissionColor' property.", gameObject);
            }
        } else if (spriteRenderer == null || spriteRenderer.material == null) {
            Debug.LogWarning($"[{gameObject.name}] FireflyController: Cannot modify material properties (flicker/fade), SpriteRenderer or its material is missing.", gameObject);
            enableFlicker = false;
            enableSpawnEffect = false;
        }

        flickerOffset = Random.Range(0f, 100f);
    }

    public void Initialize(FireflyManager owner, Vector2 minB, Vector2 maxB)
    {
        manager = owner; 
        minBounds = minB; 
        maxBounds = maxB;
        
        lifetime = Random.Range(lifetimeRange.x, lifetimeRange.y);
        age = 0f; 
        currentAlpha = 0f;
        
        attractionTarget = null; 
        currentTargetScentDef = null;
        scentCheckTimer = Random.Range(0, scentCheckInterval);
        
        // Initialize blackout effect timing based on spawnBlackoutChance
        isInBlackout = false;
        
        // Only schedule blackouts if the chance is above zero
        if (Random.value < spawnBlackoutChance) {
            float initialDelay = Random.Range(0.01f, 0.1f); // Small random delay before first blackout
            nextBlackoutTime = Time.time + initialDelay;
        } else {
            // Set to a time after spawn effect is over if we don't want blackouts for this instance
            nextBlackoutTime = Time.time + spawnEffectDuration + 1f;
        }
        blackoutEndTime = 0f;
        
        PickNewWanderState();
        // Apply initial state (fully transparent, potentially zero intensity)
        ApplyVisualState(0f);
    }

    void Update()
    {
        age += Time.deltaTime;

        HandleLifetimeAndFade(); // Calculates currentAlpha
        if (currentAlpha <= 0f && age > fadeInDuration) { Die(); return; }

        HandleScentDetection();
        HandleMovement();
        HandleGlowAndFlicker(); // Calculates target intensity & calls ApplyVisualState
    }

    void HandleLifetimeAndFade()
    {
        // Calculate target alpha based on age and lifetime
        if (age < fadeInDuration) {
            currentAlpha = Mathf.Clamp01(age / fadeInDuration); // Fade In
        } else if (lifetime - age < fadeOutDuration) {
            currentAlpha = Mathf.Clamp01((lifetime - age) / fadeOutDuration); // Fade Out
        } else {
            currentAlpha = 1.0f; // Fully Visible
        }

        // Check if lifetime naturally expired
        if (age >= lifetime && currentAlpha > 0) {
             currentAlpha = Mathf.Clamp01((lifetime - age + fadeOutDuration) / fadeOutDuration);
             if(currentAlpha <= 0) Die();
        }
    }

    void HandleScentDetection()
    {
        scentCheckTimer -= Time.deltaTime;
        if (scentCheckTimer <= 0f) { FindAttractionTarget(); scentCheckTimer = scentCheckInterval; }
        if (attractionTarget != null) { if (!attractionTarget.gameObject.activeInHierarchy || !attractionTarget.TryGetComponent<ScentSource>(out var currentScent) || currentScent.definition != currentTargetScentDef || (attractionTarget.position - transform.position).sqrMagnitude > (currentScent.EffectiveRadius * currentScent.EffectiveRadius) ) { attractionTarget = null; currentTargetScentDef = null; } }
    }

    void FindAttractionTarget()
    {
        Transform bestTarget = null; ScentDefinition bestScentDef = null; float bestScore = -1f;
        Collider2D[] hits = Physics2D.OverlapCircleAll(transform.position, scentOverlapCheckRadius);
        foreach (Collider2D hit in hits) {
            if (hit.TryGetComponent<ScentSource>(out ScentSource scent) && scent.definition != null) {
                if (attractiveScentDefinitions.Contains(scent.definition)) {
                    float distSq = (hit.transform.position - transform.position).sqrMagnitude; float scentRadiusSq = scent.EffectiveRadius * scent.EffectiveRadius;
                    if (distSq <= scentRadiusSq) { float score = 1.0f / (distSq + 0.01f); if (score > bestScore) { bestScore = score; bestTarget = hit.transform; bestScentDef = scent.definition; } }
                }
            }
        }
        if (bestTarget != attractionTarget) { attractionTarget = bestTarget; currentTargetScentDef = bestScentDef; if (attractionTarget != null) { isPaused = false; } }
    }

    void HandleMovement()
    {
        stateTimer -= Time.deltaTime;
        if (attractionTarget != null) {
            Vector2 directionToTarget = (attractionTarget.position - transform.position); float distanceToTarget = directionToTarget.magnitude; if (distanceToTarget > 0.01f) { directionToTarget /= distanceToTarget; }
            Vector2 orbitOffsetDir = new Vector2(-directionToTarget.y, directionToTarget.x) * Mathf.Sign(currentSpeed + 0.1f); Vector2 desiredDirection = directionToTarget * attractionStrength;
            if (distanceToTarget <= orbitDistance) { desiredDirection += orbitOffsetDir * (currentSpeed * 0.5f); } desiredDirection += Random.insideUnitCircle * attractionWobble;
            currentVelocity = Vector2.Lerp(currentVelocity.normalized, desiredDirection.normalized, Time.deltaTime * 5f) * currentSpeed;
        } else { if (stateTimer <= 0f) { PickNewWanderState(); } }
        if (!isPaused) {
             Vector2 currentPos = transform.position; Vector2 newPos = currentPos + currentVelocity * Time.deltaTime; bool clampedX = false; bool clampedY = false;
             if (newPos.x <= minBounds.x || newPos.x >= maxBounds.x) { clampedX = true; newPos.x = Mathf.Clamp(newPos.x, minBounds.x, maxBounds.x); } if (newPos.y <= minBounds.y || newPos.y >= maxBounds.y) { clampedY = true; newPos.y = Mathf.Clamp(newPos.y, minBounds.y, maxBounds.y); }
             if (clampedX || clampedY) { Vector2 reflectionNormal = Vector2.zero; if(clampedX) reflectionNormal.x = -Mathf.Sign(currentVelocity.x); if(clampedY) reflectionNormal.y = -Mathf.Sign(currentVelocity.y); currentVelocity = Vector2.Reflect(currentVelocity, reflectionNormal.normalized + Random.insideUnitCircle * 0.1f).normalized * currentSpeed; if (currentVelocity.sqrMagnitude < 0.01f) { currentVelocity = Random.insideUnitCircle.normalized * currentSpeed; } PickNewWanderState(true); }
            transform.position = newPos;
        }
    }

    void PickNewWanderState(bool forceMove = false)
    {
        if (attractionTarget != null && !forceMove) return;
        if (!forceMove && Random.value < pauseChance) { isPaused = true; currentVelocity = Vector2.zero; stateTimer = Random.Range(pauseDurationRange.x, pauseDurationRange.y); }
        else { isPaused = false; currentSpeed = Random.Range(speedRange.x, speedRange.y); if(currentVelocity.sqrMagnitude < 0.01f || forceMove) currentVelocity = Random.insideUnitCircle.normalized * currentSpeed; else currentVelocity = (currentVelocity.normalized + Random.insideUnitCircle * 0.5f).normalized * currentSpeed; stateTimer = directionChangeInterval * Random.Range(0.7f, 1.3f); }
    }

    void HandleGlowAndFlicker()
    {
        float targetFlickerIntensity;

        // New spawn flickering effect that simulates a fluorescent tube turning on
        if (enableSpawnEffect && age < spawnEffectDuration) 
        {
            // Base linear brightening from 0 to spawnBaseIntensity based on progress
            float progress = age / spawnEffectDuration;
            float baseIntensity = Mathf.Lerp(0f, spawnBaseIntensity, progress);
            
            // Blackout flickering logic - Check if we need to schedule a new blackout
            if (Time.time >= nextBlackoutTime && !isInBlackout) 
            {
                // Start a new blackout with probability based on spawnBlackoutChance
                if (Random.value < spawnBlackoutChance) {
                    isInBlackout = true;
                    float blackoutDuration = Random.Range(blackoutDurationRange.x, blackoutDurationRange.y);
                    blackoutEndTime = Time.time + blackoutDuration;
                    
                    // Schedule the next potential blackout check
                    float spacingTime = Random.Range(blackoutSpacingRange.x, blackoutSpacingRange.y);
                    nextBlackoutTime = blackoutEndTime + spacingTime;
                } else {
                    // No blackout this time, but schedule next check
                    float spacingTime = Random.Range(blackoutSpacingRange.x, blackoutSpacingRange.y);
                    nextBlackoutTime = Time.time + spacingTime;
                }
            }
            
            // Update blackout state
            if (isInBlackout && Time.time > blackoutEndTime) 
            {
                isInBlackout = false;
            }
            
            // Apply blackout if active
            targetFlickerIntensity = isInBlackout ? 0f : baseIntensity;
        }
        else if (enableFlicker) 
        {
            // Normal runtime flickering (unchanged)
            float noise = Mathf.PerlinNoise(Time.time * flickerSpeed, flickerOffset);
            targetFlickerIntensity = Mathf.Lerp(intensityRange.x, intensityRange.y, noise);
        }
        else 
        {
            // Steady state if flickering disabled
            targetFlickerIntensity = intensityRange.x;
        }

        // Apply the calculated intensity and the current fade alpha
        ApplyVisualState(targetFlickerIntensity);
    }

    /// <summary>
    /// Applies the visual state based on calculated flicker intensity and fade alpha.
    /// </summary>
    /// <param name="flickerIntensity">The target brightness intensity for emission/light.</param>
    void ApplyVisualState(float flickerIntensity)
    {
        // 1. Apply overall transparency (Alpha Fade) to the SpriteRenderer's base color alpha
        if (spriteMaterialInstance != null)
        {
            // Ensure _Color property exists before trying to set it
            if (spriteMaterialInstance.HasProperty("_Color"))
            {
                Color baseColor = spriteMaterialInstance.GetColor("_Color");
                baseColor.a = currentAlpha; // Apply fade alpha
                spriteMaterialInstance.SetColor("_Color", baseColor);
            }

            // 2. Apply Flicker Intensity to Emission Color's brightness
            if (spriteMaterialInstance.HasProperty("_EmissionColor"))
            {
                 // Apply intensity to the base emission color we stored in Awake
                 // Use LinearToGammaSpace if in Linear color space for more visually correct intensity scalinG
                 Color finalEmissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(flickerIntensity);
                 // Alternative if baseEmissionColor already has intensity: Multiply directly
                 // Color finalEmissionColor = baseEmissionColor * flickerIntensity;
                 spriteMaterialInstance.SetColor("_EmissionColor", finalEmissionColor);
            }
        }

        // 3. Apply Flicker Intensity (modulated by alpha fade) to Light2D
        if (pointLight != null)
        {
            // Light intensity should reflect both flicker and fade
            pointLight.intensity = flickerIntensity * currentAlpha;
        }
    }

    void Die()
    {
        if (manager != null) manager.ReportFireflyDespawned(this);
        currentAlpha = 0f; ApplyVisualState(0f); // Ensure visuals are off
        Destroy(gameObject);
    }

    void OnDestroy() 
    { 
        if (spriteMaterialInstance != null) Destroy(spriteMaterialInstance); 
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Effects\FireflyManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Effects/FireflyManager.cs

using UnityEngine;
using UnityEngine.Rendering.Universal;
using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif

public class FireflyManager : MonoBehaviour
{
    public static FireflyManager Instance { get; private set; }

    [Header("Core Dependencies")]
    [SerializeField] private WeatherManager weatherManager;
    [SerializeField] private GameObject fireflyPrefab;
    [SerializeField] private Transform fireflyParent;

    // (Keep Spawning Settings, Spawn Area, Movement Bounds, Photosynthesis Bonus)
    [Header("Spawning Settings")]
    [SerializeField] private int maxFireflies = 50;
    [SerializeField] private float spawnInterval = 0.5f;
    [SerializeField] [Range(0f, 1f)] private float nightThreshold = 0.25f;

    [Header("Spawn Area")]
    [SerializeField] private Vector2 spawnCenter = Vector2.zero;
    [SerializeField] private Vector2 spawnAreaSize = new Vector2(20f, 10f);

    [Header("Movement Bounds (for Fireflies)")]
    [SerializeField] private Vector2 movementMinBounds = new Vector2(-12f, -7f);
    [SerializeField] private Vector2 movementMaxBounds = new Vector2(12f, 7f);

    [Header("Photosynthesis Bonus Settings")]
    public float photosynthesisRadius = 3f;
    public float photosynthesisIntensityPerFly = 0.05f;
    public float maxPhotosynthesisBonus = 0.5f;


    [Header("Debugging")]
    [Tooltip("Show attraction lines in Game View during runtime.")]
    [SerializeField] private bool showAttractionLinesRuntime = false;
    [SerializeField] private Color attractionLineColorRuntime = Color.magenta; // Renamed for Gizmo
    [SerializeField] private bool logGizmoCalls = false;
    [Space] // Add space for visual separation
    [Tooltip("Prefab used to draw attraction lines at runtime.")]
    [SerializeField] private GameObject lineVisualizerPrefab; // <<< ADDED
    [Tooltip("Parent transform for instantiated line visualizers.")]
    [SerializeField] private Transform lineContainer; // <<< ADDED

    // --- Public Accessor ---
    public bool ShowAttractionLinesRuntime => showAttractionLinesRuntime;

    // --- Internal State ---
    private List<FireflyController> activeFireflies = new List<FireflyController>();
    private float spawnTimer;
    private bool isNight = false;
    
    

    // Dictionary to track line visualizers per firefly
    private Dictionary<FireflyController, LineRenderer> activeLineVisualizers = new Dictionary<FireflyController, LineRenderer>();

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;
        // Validate Core Dependencies
        if (weatherManager == null) { Debug.LogError($"[{nameof(FireflyManager)}] WeatherManager missing!", this); enabled = false; return; }
        if (fireflyPrefab == null) { Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing!", this); enabled = false; return; }
        if (fireflyPrefab.GetComponent<FireflyController>() == null) { Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing Controller script!", this); enabled = false; return; }
        if (fireflyParent == null) { fireflyParent = transform; }

        // Validate Debug Dependencies
        if (lineVisualizerPrefab == null) { Debug.LogError($"[{nameof(FireflyManager)}] Line Visualizer Prefab is not assigned!", this); }
        if (lineContainer == null) { Debug.LogError($"[{nameof(FireflyManager)}] Line Container transform is not assigned!", this); }
    }

    void Update()
    {
        isNight = weatherManager.sunIntensity <= nightThreshold;

        if (isNight) {
            spawnTimer -= Time.deltaTime;
            if (spawnTimer <= 0f) { TrySpawnFirefly(); spawnTimer = spawnInterval; }
        } else { spawnTimer = spawnInterval; }

        // Update runtime visualizers in Update
        UpdateRuntimeLineVisualizers();
    }

    void TrySpawnFirefly()
    {
        if (activeFireflies.Count >= maxFireflies) return;

        float spawnX = spawnCenter.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
        float spawnY = spawnCenter.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
        Vector2 spawnPos = new Vector2(spawnX, spawnY);

        GameObject fireflyGO = Instantiate(fireflyPrefab, spawnPos, Quaternion.identity, fireflyParent);
        FireflyController controller = fireflyGO.GetComponent<FireflyController>();

        if (controller != null) {
            controller.Initialize(this, movementMinBounds, movementMaxBounds);
            activeFireflies.Add(controller);
            // Don't create line visualizer here, do it in Update when needed
        } else { /* LogError, Destroy */ }
    }

    public void ReportFireflyDespawned(FireflyController firefly)
    {
        activeFireflies.Remove(firefly);

        // Clean up associated line visualizer
        if (activeLineVisualizers.TryGetValue(firefly, out LineRenderer line))
        {
            if (line != null) Destroy(line.gameObject); // Destroy the visualizer GO
            activeLineVisualizers.Remove(firefly);
        }
    }

    // --- Runtime Visualizer Update ---
    void UpdateRuntimeLineVisualizers()
    {
        if (!Application.isPlaying) return; // Only run in play mode

        // Check if lines should be shown globally
        bool showLines = showAttractionLinesRuntime && lineVisualizerPrefab != null && lineContainer != null;

        // --- Update existing lines and create new ones ---
        // Use a temporary list to avoid modifying dictionary while iterating
        List<FireflyController> firefliesToRemoveLine = new List<FireflyController>();

        foreach (var kvp in activeLineVisualizers)
        {
            FireflyController firefly = kvp.Key;
            LineRenderer line = kvp.Value;

            if (firefly == null || line == null) // Firefly or line destroyed unexpectedly
            {
                firefliesToRemoveLine.Add(firefly); // Mark for removal
                if(line != null) Destroy(line.gameObject); // Destroy orphan line
                continue;
            }

            Transform target = firefly.AttractionTarget;

            if (showLines && target != null) // Should be visible and has target
            {
                line.enabled = true;
                line.SetPosition(0, firefly.transform.position);
                line.SetPosition(1, target.position);
                
                // IMPORTANT: Ensure the color is set properly
                if (line.startColor != attractionLineColorRuntime || line.endColor != attractionLineColorRuntime)
                {
                    line.startColor = attractionLineColorRuntime;
                    line.endColor = attractionLineColorRuntime;
                    
                    if (Debug.isDebugBuild)
                        Debug.Log($"[FireflyManager] Set line color to {attractionLineColorRuntime}", line.gameObject);
                }
            }
            else // Should be hidden or lost target
            {
                line.enabled = false;
            }
        }

        // Remove entries whose fireflies are gone
        foreach (var firefly in firefliesToRemoveLine)
        {
            activeLineVisualizers.Remove(firefly);
        }


        // --- Add lines for fireflies that don't have one yet ---
        if (showLines)
        {
            foreach (FireflyController firefly in activeFireflies)
            {
                if (firefly == null || activeLineVisualizers.ContainsKey(firefly)) continue; // Skip nulls or those already processed

                Transform target = firefly.AttractionTarget;
                if (target != null) // Only create if it has a target AND should be shown
                {
                    GameObject lineGO = Instantiate(lineVisualizerPrefab, lineContainer); // Instantiate under container
                    LineRenderer newLine = lineGO.GetComponent<LineRenderer>();
                    if (newLine != null)
                    {
                        // Configure initial points (will be updated next frame anyway)
                        newLine.SetPosition(0, firefly.transform.position);
                        newLine.SetPosition(1, target.position);
                        
                        // IMPORTANT: Set the line color correctly
                        newLine.startColor = attractionLineColorRuntime;
                        newLine.endColor = attractionLineColorRuntime;
                        
                        newLine.enabled = true;
                        activeLineVisualizers.Add(firefly, newLine); // Add to tracking dictionary
                        
                        if (Debug.isDebugBuild)
                            Debug.Log($"[FireflyManager] Created new line with color {attractionLineColorRuntime}", newLine.gameObject);
                    }
                    else
                    {
                         Debug.LogError($"Line Visualizer Prefab '{lineVisualizerPrefab.name}' is missing LineRenderer component!", lineVisualizerPrefab);
                         Destroy(lineGO); // Destroy invalid instance
                    }
                }
            }
        }
        // --- Hide/Destroy lines if global flag turned off ---
        else if (!showLines && activeLineVisualizers.Count > 0)
        {
             // Destroy all active line visualizers if the flag is off
             foreach (var kvp in activeLineVisualizers)
             {
                 if (kvp.Value != null) Destroy(kvp.Value.gameObject);
             }
             activeLineVisualizers.Clear();
        }
    }


    // (Keep GetNearbyFireflyCount)
     public int GetNearbyFireflyCount(Vector3 position, float radius)
    {
        int count = 0; float radiusSq = radius * radius;
        for (int i = activeFireflies.Count - 1; i >= 0; i--)
        {
            if (activeFireflies[i] == null) { activeFireflies.RemoveAt(i); continue; }
            if ((activeFireflies[i].transform.position - position).sqrMagnitude <= radiusSq) { count++; }
        }
        return count;
    }

    // --- Gizmos (Editor Visualization - Unchanged) ---
    #if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.green; Gizmos.DrawWireCube(spawnCenter, spawnAreaSize);
        Gizmos.color = Color.blue;
        Vector3 boundsCenter = (movementMinBounds + movementMaxBounds) / 2f;
        Vector3 boundsSize = movementMaxBounds - movementMinBounds;
        Gizmos.DrawWireCube(boundsCenter, boundsSize);

        // Gizmo drawing for attraction lines
        if (showAttractionLinesRuntime && Application.isPlaying) {
             if (logGizmoCalls) { /*...*/ }
             bool didDrawLine = false;
             Gizmos.color = attractionLineColorRuntime; // Use Gizmo color
             foreach (FireflyController firefly in activeFireflies) {
                if (firefly == null) continue;
                Transform target = firefly.AttractionTarget;
                if (target != null) { Gizmos.DrawLine(firefly.transform.position, target.position); didDrawLine = true; }
             }
             if (logGizmoCalls && !didDrawLine && activeFireflies.Count > 0) { /*...*/ }
        }
    }
    #endif
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\AnimalDiet.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;

// Simplified Preference: Links FoodType to satiation amount and behavior priority
[System.Serializable]
public class DietPreferenceSimplified
{
    [Tooltip("The specific FoodType this preference applies to.")]
    public FoodType foodType;

    [Tooltip("How much satiation (hunger reduction) is gained when this food is eaten.")]
    public float satiationAmount = 5f;

    [Tooltip("Priority for seeking this food (higher value = higher priority). Used for choosing between nearby valid foods.")]
    [Range(0.1f, 5f)]
    public float preferencePriority = 1f;
}


// Simplified Diet: Defines hunger stats and list of preferences
[CreateAssetMenu(fileName = "Diet_", menuName = "Ecosystem/Animal Diet (Simplified)")]
public class AnimalDiet : ScriptableObject
{
    [Header("Diet Preferences")]
    [Tooltip("List of foods this animal can eat and how much they satisfy hunger.")]
    public List<DietPreferenceSimplified> acceptableFoods = new List<DietPreferenceSimplified>();

    [Header("Hunger Mechanics")]
    [Tooltip("Maximum hunger level.")]
    public float maxHunger = 20f;
    [Tooltip("Rate at which hunger increases per second.")]
    public float hungerIncreaseRate = 0.5f;
    [Tooltip("Hunger level above which the animal will actively seek food.")]
    public float hungerThreshold = 10f;

    // Removed starvation for simplicity, can be added back later if needed
    // [Header("Starvation")]
    // public float starvationDamageRate = 0.5f;

    /// <summary>
    /// Checks if a specific FoodType is included in this diet's acceptable foods.
    /// </summary>
    public bool CanEat(FoodType food)
    {
        if (food == null) return false;
        return acceptableFoods.Any(pref => pref.foodType == food);
    }

    /// <summary>
    /// Gets the DietPreferenceSimplified entry for a specific FoodType.
    /// </summary>
    public DietPreferenceSimplified GetPreference(FoodType food)
    {
         if (food == null) return null;
         return acceptableFoods.FirstOrDefault(p => p.foodType == food);
    }

    /// <summary>
    /// Gets the satiation amount provided by a specific FoodType for this diet.
    /// </summary>
    public float GetSatiationValue(FoodType food)
    {
        var pref = GetPreference(food);
        return pref != null ? pref.satiationAmount : 0f;
    }

    /// <summary>
    /// Finds the best food target from nearby colliders based on preference and distance.
    /// </summary>
    public GameObject FindBestFood(Collider2D[] nearbyColliders, Vector3 animalPosition)
    {
        GameObject bestTarget = null;
        float highestScore = -1f; // Start below any possible score

        foreach (var collider in nearbyColliders)
        {
            if (collider == null) continue;

            FoodItem foodItem = collider.GetComponent<FoodItem>();

            // Must have FoodItem and its FoodType must be edible by this diet
            if (foodItem != null && foodItem.foodType != null && CanEat(foodItem.foodType))
            {
                DietPreferenceSimplified pref = GetPreference(foodItem.foodType);
                if (pref == null) continue; // Should be caught by CanEat, but safe check

                float distance = Vector3.Distance(animalPosition, collider.transform.position);
                // Simple score: Higher preference is better, closer is better.
                // Avoid division by zero or very small distances inflating score excessively.
                float score = pref.preferencePriority / (1f + distance); // Inverse distance weighting

                if (score > highestScore)
                {
                    highestScore = score;
                    bestTarget = collider.gameObject;
                }
            }
        }
        return bestTarget;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[RequireComponent(typeof(Collider2D))] // Still need collider for detection
public class FoodItem : MonoBehaviour
{
    [Header("Food Identification")]
    [Tooltip("Reference to the ScriptableObject defining what type of food this is.")]
    public FoodType foodType;

    private void Start()
    {
        // Simple validation
        if (foodType == null)
        {
            Debug.LogWarning($"FoodItem on GameObject '{gameObject.name}' is missing its FoodType reference!", gameObject);
            // Optionally disable the collider so it can't be detected as food
            // Collider2D col = GetComponent<Collider2D>();
            // if (col != null) col.enabled = false;
            enabled = false; // Disable script if not configured
        }
        // No health, no consume logic needed here anymore.
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodType.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "FoodType_", menuName = "Ecosystem/Food Type (Simplified)")]
public class FoodType : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Identifying name for this food type (e.g., 'Leaf', 'Fruit').")]
    public string foodName = "Default Food";
    [Tooltip("Icon used in UI or debugging.")]
    public Sprite icon;

    // Keep category for potential filtering later, but not actively used by core logic yet
    public enum FoodCategory { Plant_Leaf, Plant_Fruit, Plant_Stem, Plant_Seed, Other }
    [Header("Categorization")]
    [Tooltip("General category this food falls into.")]
    public FoodCategory category = FoodCategory.Other;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Scents\ScentDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Scents/ScentDefinition.cs
using UnityEngine;

[CreateAssetMenu(fileName = "Scent_", menuName = "Ecosystem/Scent Definition")]
public class ScentDefinition : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Unique identifier used internally and potentially for node effects.")]
    public string scentID = "default_scent"; // Still useful for debugging/lookup
    [Tooltip("Display name for UI or debugging.")]
    public string displayName = "Default Scent";

    // [Header("Gameplay Properties")] - Removed scentType enum field

    [Tooltip("Base radius for this scent type if not modified by nodes.")]
    public float baseRadius = 1f;
    [Tooltip("Base strength for this scent type if not modified by nodes.")]
    public float baseStrength = 1f;

    [Header("Visuals (Optional)")]
    [Tooltip("Particle effect prefab to instantiate when this scent is active.")]
    public GameObject particleEffectPrefab;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Scents\ScentLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Scents/ScentLibrary.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "ScentLibrary", menuName = "Ecosystem/Scent Library")]
public class ScentLibrary : ScriptableObject
{
    public List<ScentDefinition> scents;

    // Helper method to find a scent by its ID (still potentially useful)
    public ScentDefinition GetScentByID(string id)
    {
        if (string.IsNullOrEmpty(id) || scents == null) return null;
        return scents.FirstOrDefault(s => s != null && s.scentID == id);
    }

    // Helper to get the actual list of definitions
    public List<ScentDefinition> GetAllDefinitions()
    {
        // Return a copy or filter out nulls
        return scents?.Where(s => s != null).ToList() ?? new List<ScentDefinition>();
    }

}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public List<NodeEffectData> effects = new List<NodeEffectData>();
    public int orderIndex;

    // Runtime flags
    [HideInInspector] // Don't show in NodeDefinition inspector, set at runtime
    public bool canBeDeleted = true; // <<< NEW FLAG (Defaults to true)

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
        // Ensure default deletability on creation
        canBeDeleted = true;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeDefinition.cs
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    [Header("Display")]
    public string displayName;
    [TextArea]
    public string description;
    public Sprite thumbnail;
    [Tooltip("Tint color applied to the thumbnail image.")]
    public Color thumbnailTintColor = Color.white;
    [Tooltip("Background color for the Node View representation.")]
    public Color backgroundColor = Color.gray;

    [Header("Prefab & Effects")]
    [Tooltip("Optional: Specific NodeView prefab for this node type. If null, the default from NodeEditorGridController is used.")]
    public GameObject nodeViewPrefab;
    [Tooltip("List of effects this node applies. Configure these effects carefully.")]
    public List<NodeEffectData> effects; // This is the list configured in the Inspector

    /// <summary>
    /// Creates a deep copy of the effects list configured in this NodeDefinition asset.
    /// This ensures that runtime NodeData instances get their own copies of effects.
    /// </summary>
    /// <returns>A new list containing copies of the NodeEffectData.</returns>
    public List<NodeEffectData> CloneEffects()
    {
        List<NodeEffectData> copy = new List<NodeEffectData>();
        if (effects == null) {
            // Debug.LogWarning($"NodeDefinition '{this.name}' has a null effects list."); // Optional warning
            return copy; // Handle null list
        }

        foreach (var originalEffect in effects)
        {
            if (originalEffect == null) {
                 Debug.LogWarning($"NodeDefinition '{this.name}' contains a null effect in its list."); // Optional warning
                 continue; // Skip null effects
            }

            // Create a new instance and copy ALL relevant fields
            NodeEffectData newEffect = new NodeEffectData()
            {
                effectType = originalEffect.effectType,
                primaryValue = originalEffect.primaryValue,
                secondaryValue = originalEffect.secondaryValue,
                isPassive = originalEffect.isPassive,
                // --- FIXED: Copy the ScentDefinition reference ---
                scentDefinitionReference = originalEffect.scentDefinitionReference
                // --------------------------------------------------
            };
            copy.Add(newEffect);
        }
        return copy;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System; // Needed for [Serializable]

// Define the configuration for a single initial node
[Serializable] // Make it visible and editable in the Inspector
public struct InitialNodeConfig
{
    [Tooltip("The Node Definition to spawn.")]
    public NodeDefinition nodeDefinition;

    [Tooltip("The zero-based index of the cell where this node should spawn (0 is the leftmost cell).")]
    [Min(0)]
    public int cellIndex;

    [Tooltip("Can the player drag this initial node to other cells?")]
    public bool canMove;

    [Tooltip("Can the player delete this initial node using the Delete key?")]
    public bool canDelete;
}


[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    [Header("Available Node Definitions")]
    [Tooltip("List of all Node Definitions available in the dropdown menu.")]
    public List<NodeDefinition> definitions; // Your existing list

    [Header("Initial Node Layout")]
    [Tooltip("Nodes to automatically spawn in specific slots when the grid initializes.")]
    public List<InitialNodeConfig> initialNodes; // <<< NEW LIST ADDED
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeEffectData.cs
using System;
using UnityEngine;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;

    [Tooltip("Primary numeric value for the effect (e.g., Amount, Duration, Radius Bonus).")] // Updated tooltip
    public float primaryValue;
    [Tooltip("Secondary numeric value for the effect (e.g., Speed, Intensity, Strength Bonus).")] // Updated tooltip
    public float secondaryValue;

    [Tooltip("If TRUE, effect runs once during growth. If FALSE, effect executes during mature cycles.")]
    public bool isPassive = false;

    // --- Scent Specific ---
    // [Tooltip("Identifier (scentID from ScentDefinition) of the scent to apply. Used only if effectType is ScentModifier.")]
    // public string scentIdentifier; // <<< REMOVED

    [Tooltip("The Scent Definition to apply/modify. Used only if effectType is ScentModifier.")]
    public ScentDefinition scentDefinitionReference; // <<< ADDED: Direct reference
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeEffectType.cs
using System;
using UnityEngine;

public enum NodeEffectType
{
    // --- Passive / Growth Phase Effects (isPassive = true) ---
    // These typically run once at the start to define the plant's structure and base stats.

    // [Tooltip("Base cost calculation (Not currently implemented in PlantGrowth execution).")]
    // ManaCost, // REMOVED
    [Tooltip("Determines the maximum energy the plant can store.")]
    EnergyStorage,
    [Tooltip("Determines the base rate of energy generation through photosynthesis per leaf.")]
    EnergyPhotosynthesis,
    [Tooltip("A required marker effect for a node chain to be spawnable as a plant.")]
    SeedSpawn,
    [Tooltip("Modifies the minimum and maximum potential length of the main stem.")]
    StemLength,
    [Tooltip("Modifies the time interval between each step of stem/leaf growth.")]
    GrowthSpeed,
    [Tooltip("Modifies the number of stem segments between leaf spawns.")]
    LeafGap,
    [Tooltip("Sets the pattern in which leaves are spawned (e.g., Parallel, Alternating).")]
    LeafPattern,
    [Tooltip("Modifies the chance for the stem to grow diagonally instead of straight up.")]
    StemRandomness,
    [Tooltip("Modifies the base time duration between Mature Phase execution cycles.")]
    Cooldown,
    [Tooltip("Modifies the base time delay between executing the effects of sequential nodes within a Mature Phase cycle.")]
    CastDelay,
    [Tooltip("Allows the plant to absorb poop within a radius and regrow eaten leaves or gain energy. PrimaryValue=Detection Radius, SecondaryValue=Energy Added.")]
    PoopFertilizer,


    // --- Active / Mature Phase Effects (isPassive = false) ---
    // These execute periodically after the plant has finished growing.

    [Tooltip("Energy cost deducted from the plant when this node's active effects are executed during the mature cycle.")]
    EnergyCost, // <<< RENAMED/ADDED
    [Tooltip("Triggers the spawning of a projectile or other output effect (requires OutputNodeEffect component).")]
    Output,
    [Tooltip("Modifies the damage potential of subsequent 'Output' effects in the same cycle.")]
    Damage,
    [Tooltip("Causes the plant to attempt to spawn a berry in an available adjacent slot during the mature cycle.")]
    GrowBerry,
    // Add potentially more active effects: Heal, ApplyStatus, AreaEffect, etc.
    
    
    [Tooltip("Modifies the scent emitted by the next spawned carrier (Berry, Projectile). PrimaryValue=Radius Add, SecondaryValue=Strength Add.")]
    ScentModifier,
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\OutputNodeEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/OutputNodeEffect.cs
using UnityEngine;
using System.Collections.Generic; // Required for Dictionary

public class OutputNodeEffect : MonoBehaviour
{
    [Header("References")]
    [Tooltip("Prefab for the projectile to spawn.")]
    public GameObject projectilePrefab;

    [Header("Settings")]
    public Vector2 spawnOffset = Vector2.up;

    // Store reference needed to call ApplyScentDataToObject
    private PlantGrowth parentPlantGrowth;

    void Awake()
    {
        // Get reference to parent PlantGrowth to access ApplyScentDataToObject helper
        parentPlantGrowth = GetComponentInParent<PlantGrowth>();
        if (parentPlantGrowth == null)
        {
            // This is a critical error if scent application is expected
            Debug.LogError($"[{nameof(OutputNodeEffect)}] Could not find parent PlantGrowth component! Scent application will fail.", gameObject);
        }
    }

    /// <summary>
    /// Activated by PlantGrowth during the Mature Execution Cycle.
    /// Spawns a projectile and applies accumulated effects (damage, scent).
    /// </summary>
    /// <param name="damageMultiplier">Contextual damage modifier calculated from the node chain.</param>
    /// <param name="scentRadiusBonuses">Accumulated radius bonuses per ScentDefinition.</param> // <<< UPDATED PARAM TYPE
    /// <param name="scentStrengthBonuses">Accumulated strength bonuses per ScentDefinition.</param> // <<< UPDATED PARAM TYPE
    public void Activate(float damageMultiplier,
                         Dictionary<ScentDefinition, float> scentRadiusBonuses, // <<< UPDATED TYPE
                         Dictionary<ScentDefinition, float> scentStrengthBonuses) // <<< UPDATED TYPE
    {
        // --- Validations ---
        if (projectilePrefab == null) {
            Debug.LogError($"[{nameof(OutputNodeEffect)}] Projectile Prefab not assigned!", gameObject);
            return;
        }
        
         if (parentPlantGrowth == null) { // Check again in case Awake failed silently
              Debug.LogError($"[{nameof(OutputNodeEffect)}] Cannot activate, parent PlantGrowth reference is missing. Scent application will fail.", gameObject);
             // Decide if we should still spawn projectile without scent or just return
             // return; // Option: Abort if scent cannot be applied
         }

        // Debug.Log($"[OutputNodeEffect] Activate called. Damage Multiplier: {damageMultiplier}. Spawning projectile.");

        // --- Spawn Projectile ---
        Vector2 spawnPos = (Vector2)transform.position + spawnOffset;
        GameObject projGO = Instantiate(projectilePrefab, spawnPos, transform.rotation); // Use plant's rotation or aim logic

        // --- Apply Accumulated Scents to Projectile ---
        // Call the public helper method on the parent PlantGrowth instance
        if (parentPlantGrowth != null) // Check if reference exists before calling
        {
            // Debug.Log($"[{gameObject.name} Activate] Calling ApplyScentDataToObject for {projGO.name}. Passing {scentStrengthsBonuses?.Count ?? 0} scent strength entries."); /////////// here
            
             // Call the public helper with the NEW dictionaries
             parentPlantGrowth.ApplyScentDataToObject(projGO, scentRadiusBonuses, scentStrengthBonuses);
        }
        // -----------------------------------------------

        // --- Initialize Projectile Stats ---
        SpellProjectile spellProj = projGO.GetComponent<SpellProjectile>();
        if(spellProj != null)
        {
            // TODO: Get base damage/speed from effects or projectile definition?
            float baseDamage = 10f; // Example base value
            float baseSpeed = 5f; // Example base value

            float finalDamage = baseDamage * damageMultiplier; // Apply accumulated multiplier
            float finalSpeed = baseSpeed; // TODO: Apply speed modifiers if implemented

            spellProj.Initialize(finalDamage, finalSpeed);
            // Set other properties like friendly fire based on plant context?
        }
        // else { Debug.LogWarning($"[{nameof(OutputNodeEffect)}] Spawned projectile '{projGO.name}' is missing SpellProjectile component.", projGO); }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Runtime/NodeExecutor.cs
using System.Collections.Generic;
using UnityEngine;
using TMPro;
using System.Linq;

public class NodeExecutor : MonoBehaviour
{
    [Header("UI Graph Source")]
    [SerializeField] private NodeEditorGridController nodeEditorGrid;

    [Header("Plant Spawning")]
    [SerializeField] private GameObject plantPrefab;
    [SerializeField] private GardenerController gardener;

    [Header("Debugging")]
    [SerializeField] private TMP_Text debugOutput;

    private void Update()
    {
        // NOTE: Direct planting with spacebar was removed in favor of the tool-based planting system
        // Plants are now created through the PlantPlacementManager when using the SeedPouch tool
    }

    public void SpawnPlantFromUIGraph()
    {
        // --- Validations ---
        if (nodeEditorGrid == null) { DebugLogError("Node Editor Grid Controller not assigned!"); return; }
        if (plantPrefab == null) { DebugLogError("Plant prefab not assigned!"); return; }
        if (gardener == null) { DebugLogError("Gardener Controller not assigned!"); return; }

        // Get the current graph state from the UI grid
        NodeGraph graphToSpawn = nodeEditorGrid.GetCurrentUIGraph();

        if (graphToSpawn == null || graphToSpawn.nodes == null || graphToSpawn.nodes.Count == 0) {
             DebugLog("No nodes in UI graph to spawn.");
             return;
        }

        // Validate if the graph is spawnable (e.g., requires a SeedSpawn effect)
        bool seedFound = graphToSpawn.nodes.Any(node => node != null && node.effects != null && node.effects.Any(eff => eff != null && eff.effectType == NodeEffectType.SeedSpawn && eff.isPassive));
        if (!seedFound) {
            DebugLog("Cannot spawn plant: Node chain lacks a passive SeedSpawn effect.");
            return;
        }

        DebugLog($"Spawning plant from UI graph with {graphToSpawn.nodes.Count} nodes...");

        // Determine spawn position and parent
        Vector2 spawnPos = gardener.GetPlantingPosition();
        Transform plantParent = EcosystemManager.Instance?.plantParent; // Use optional chaining

        // Instantiate the plant prefab
        GameObject plantObj = Instantiate(plantPrefab, spawnPos, Quaternion.identity, plantParent); // Assign parent during instantiate

        // Get the PlantGrowth component
        PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
        if (growthComponent != null)
        {
            // --- Create a DEEP COPY of the NodeGraph ---
            // This is crucial so modifications to the UI graph don't affect running plants,
            // and vice-versa.
            NodeGraph graphCopy = new NodeGraph();
            graphCopy.nodes = new List<NodeData>(graphToSpawn.nodes.Count); // Initialize with capacity

            foreach(NodeData originalNodeData in graphToSpawn.nodes)
            {
                // Ensure original node data is not null
                if (originalNodeData == null) {
                    DebugLogWarning("Encountered null NodeData in UI graph during copy. Skipping.");
                    continue;
                }

                 // Create a new NodeData instance
                 NodeData newNodeData = new NodeData {
                    nodeId = originalNodeData.nodeId, // Copy ID (or generate new one?)
                    nodeDisplayName = originalNodeData.nodeDisplayName,
                    orderIndex = originalNodeData.orderIndex,
                    canBeDeleted = originalNodeData.canBeDeleted, // Copy runtime flags if needed
                    // Create a deep copy of the effects list using the *updated* helper method
                    effects = CloneEffectsList(originalNodeData.effects)
                };
                graphCopy.nodes.Add(newNodeData);
            }

            // Initialize the plant with the deep copy
            growthComponent.InitializeAndGrow(graphCopy);
            DebugLog("Plant spawned and initialized.");
        }
        else
        {
             // Log error and destroy invalid object if PlantGrowth is missing
             DebugLogError($"Prefab '{plantPrefab.name}' missing PlantGrowth component! Destroying spawned object.");
             Destroy(plantObj);
        }
    }

    /// <summary>
    /// Creates a deep copy of a list of NodeEffectData, including the ScentDefinition reference.
    /// </summary>
    private List<NodeEffectData> CloneEffectsList(List<NodeEffectData> originalList)
    {
        if (originalList == null) return new List<NodeEffectData>(); // Handle null input list

        List<NodeEffectData> newList = new List<NodeEffectData>(originalList.Count);
        foreach(var originalEffect in originalList)
        {
            // Ensure original effect data is not null
            if(originalEffect == null) {
                DebugLogWarning("Encountered null NodeEffectData in list during copy. Skipping.");
                continue;
            }

             // Create a new NodeEffectData instance and copy all relevant fields
             NodeEffectData newEffect = new NodeEffectData {
                 effectType = originalEffect.effectType,
                 primaryValue = originalEffect.primaryValue,
                 secondaryValue = originalEffect.secondaryValue,
                 isPassive = originalEffect.isPassive,
                 // <<< FIXED: Explicitly copy the ScentDefinition reference >>>
                 scentDefinitionReference = originalEffect.scentDefinitionReference
             };
             newList.Add(newEffect);
        }
        return newList;
    }

    // Helper methods for logging
    private void DebugLog(string msg) {
        Debug.Log($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += msg + "\n";
    }
    private void DebugLogError(string msg) {
        Debug.LogError($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += $"ERROR: {msg}\n";
    }
     private void DebugLogWarning(string msg) {
        Debug.LogWarning($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += $"WARNING: {msg}\n";
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes = new List<NodeData>();
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\ColorExtensions.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public static class ColorExtensions
{
    public static Color WithAlpha(this Color c, float alpha)
    {
        return new Color(c.r, c.g, c.b, alpha);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\DeselectOnClickOutside.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems; // Required for IPointerClickHandler

// Add this script to an invisible, fullscreen background UI Image
// Make sure it's the first child of the Canvas to render behind everything else
public class DeselectOnClickOutside : MonoBehaviour, IPointerClickHandler
{
    public void OnPointerClick(PointerEventData eventData)
    {
        // Check if the click was with the left mouse button
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            // If the background is clicked, clear the current node selection
            // Debug.Log("Background Clicked. Clearing Node Selection.");
            NodeCell.ClearSelection();
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeCell.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
// Remove IPointerClickHandler interface from here
// Keep IDropHandler for dropping onto the cell background
public class NodeCell : MonoBehaviour, IPointerClickHandler, IDropHandler // Keep IPointerClickHandler for RIGHT click on empty
{
    public static NodeCell CurrentlySelectedCell { get; private set; }
    public int CellIndex { get; private set; }

    private NodeEditorGridController _controller;
    private NodeData _nodeData;
    private NodeView _nodeView;
    private Image _backgroundImage;

    // --- Init remains the same ---
    public void Init(int index, NodeEditorGridController gridController, Image bgImage)
    {
        CellIndex = index;
        _controller = gridController;
        _backgroundImage = bgImage;

        if (_backgroundImage != null && _controller != null)
        {
            _backgroundImage.color = _controller.EmptyCellColor;
            _backgroundImage.enabled = true;
        }
    }

    // --- HasNode, Getters remain the same ---
    public bool HasNode() => _nodeData != null && _nodeView != null;
    public NodeData GetNodeData() => _nodeData;
    public NodeView GetNodeView() => _nodeView;

    // --- AssignNode, AssignNodeView remain the same ---
     public void AssignNode(NodeDefinition def)
    {
        if (def == null || _controller == null) return;
        RemoveNode();

        _nodeData = new NodeData() { /* ... data setup ... */
            nodeId = System.Guid.NewGuid().ToString(),
            nodeDisplayName = def.displayName,
            effects = def.CloneEffects(),
            orderIndex = this.CellIndex
        };

        GameObject prefabToInstantiate = def.nodeViewPrefab != null ? def.nodeViewPrefab : _controller.NodeViewPrefab;
        if (prefabToInstantiate == null) { /* ... error handling ... */ Debug.LogError($"..."); _nodeData = null; return; }

        GameObject nodeViewGO = Instantiate(prefabToInstantiate, transform);
        _nodeView = nodeViewGO.GetComponent<NodeView>();
        if (_nodeView == null) { /* ... error handling ... */ Debug.LogError($"..."); Destroy(nodeViewGO); _nodeData = null; return; }

        _nodeView.Initialize(_nodeData, def, _controller); // Init NodeView

        NodeDraggable draggable = _nodeView.GetComponent<NodeDraggable>();
        if (draggable == null) draggable = _nodeView.gameObject.AddComponent<NodeDraggable>();
        draggable.Initialize(_controller, this); // Init Draggable

        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }
     public void AssignNodeView(NodeView view, NodeData data)
    {
         RemoveNode();
         _nodeView = view;
         _nodeData = data;
         if (_nodeView != null) {
             _nodeView.transform.SetParent(transform, false);
             if (_nodeData != null) _nodeData.orderIndex = this.CellIndex;
             // Parent ref will be updated by NodeDraggable.SnapToCell which calls NodeView.UpdateParent...
         }
         if(_backgroundImage != null) _backgroundImage.enabled = true;
    }


    // --- RemoveNode, ClearNodeReference remain the same ---
    public void RemoveNode()
    {
        bool wasSelected = (CurrentlySelectedCell == this);
        if (_nodeView != null) {
            if (wasSelected) {
                 _nodeView.Unhighlight();
                 CurrentlySelectedCell = null;
            }
            Destroy(_nodeView.gameObject);
        }
        _nodeView = null; _nodeData = null;
        if (wasSelected && CurrentlySelectedCell == this) CurrentlySelectedCell = null;
        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }
     public void ClearNodeReference()
    {
        _nodeView = null; _nodeData = null;
        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }

    // --- Selection Handling (SelectCell, ClearSelection) remains the same ---
     public static void SelectCell(NodeCell cellToSelect)
    {
        if (cellToSelect == null || !cellToSelect.HasNode()) { ClearSelection(); return; }
        if (CurrentlySelectedCell == cellToSelect) return;
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Unhighlight();
        }
        CurrentlySelectedCell = cellToSelect;
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Highlight();
        }
    }
     public static void ClearSelection()
    {
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Unhighlight();
        }
        CurrentlySelectedCell = null;
    }

    // --- Event Handlers UPDATED ---

    /// <summary>
    /// Handles clicks on the CELL BACKGROUND image.
    /// Left Click: Does nothing (NodeView handles selection).
    /// Right Click: Opens add node menu ONLY if the cell is currently empty.
    /// </summary>
    public void OnPointerClick(PointerEventData eventData)
    {
        // This click is on the NodeCell's background image

        if (eventData.button == PointerEventData.InputButton.Right)
        {
            // Right Click: Only allow opening the dropdown if the cell is currently EMPTY.
            if (!HasNode())
            {
                // Debug.Log($"NodeCell Background Clicked (Right) on Empty Cell {CellIndex}. Opening dropdown.");
                ClearSelection(); // Clear selection before showing add menu
                _controller?.OnEmptyCellRightClicked(this, eventData);
            }
            // If right-clicking the background of an occupied cell, do nothing.
        }
        // Left click on the background does nothing regarding selection now.
    }


    // --- OnDrop remains the same ---
    public void OnDrop(PointerEventData eventData)
    {
        GameObject draggedObject = eventData.pointerDrag;
        if (draggedObject != null) {
            NodeDraggable draggedNode = draggedObject.GetComponent<NodeDraggable>();
            if (draggedNode != null && _controller != null) {
                 _controller.HandleNodeDrop(draggedNode, draggedNode.OriginalCell, eventData.position);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeDraggable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
public class NodeDraggable : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
    private RectTransform _rectTransform;
    private CanvasGroup _canvasGroup;
    private Vector2 _originalAnchoredPosition;
    private Transform _originalParent;
    private NodeCell _originalCell;
    private NodeEditorGridController _gridController;
    private Canvas _rootCanvas;

    // No _isDragging flag needed if managed carefully by events

    public NodeCell OriginalCell => _originalCell;

    void Awake()
    {
        _rectTransform = GetComponent<RectTransform>();
        _canvasGroup = GetComponent<CanvasGroup>();
        if (_canvasGroup == null)
        {
            _canvasGroup = gameObject.AddComponent<CanvasGroup>();
        }
        // CRITICAL: Default state MUST allow interactions (clicks, hovers)
        _canvasGroup.blocksRaycasts = true;
        _canvasGroup.alpha = 1f; // Ensure fully visible
    }

    public void Initialize(NodeEditorGridController controller, NodeCell startingCell)
    {
        _gridController = controller;
        _originalCell = startingCell;
        _rootCanvas = GetComponentInParent<Canvas>()?.rootCanvas;
        if (_rootCanvas == null) Debug.LogError("[NodeDraggable] Could not find root Canvas!");

        // Ensure initial state after initialization
        if (_canvasGroup != null) {
             _canvasGroup.blocksRaycasts = true;
             _canvasGroup.alpha = 1f;
        }
    }

    public void OnBeginDrag(PointerEventData eventData)
    {
        if (eventData.button != PointerEventData.InputButton.Left) return;
        if (_gridController == null || _rootCanvas == null) return;

        _originalParent = transform.parent;
        _originalCell = _originalParent?.GetComponent<NodeCell>();
        _originalAnchoredPosition = _rectTransform.anchoredPosition;

        // Become transparent and STOP blocking raycasts so underlying cells can be detected
        _canvasGroup.alpha = 0.6f;
        _canvasGroup.blocksRaycasts = false;

        // Reparent for top rendering
        transform.SetParent(_rootCanvas.transform, true);
        transform.SetAsLastSibling();
         // Debug.Log($"[NodeDraggable OnBeginDrag] Started drag. blocksRaycasts: {_canvasGroup.blocksRaycasts}", gameObject);
    }

    public void OnDrag(PointerEventData eventData)
    {
        // Only process drag if it's the left button and dragging is conceptually active (raycasts blocked)
        if (eventData.button != PointerEventData.InputButton.Left || _canvasGroup == null || _canvasGroup.blocksRaycasts) return;
        if (_gridController == null || _rootCanvas == null) return;

        // Move logic (unchanged)
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
             _rootCanvas.transform as RectTransform, eventData.position,
             _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera, out Vector2 currentLocalPoint);
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
            _rootCanvas.transform as RectTransform, eventData.position - eventData.delta,
            _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera, out Vector2 previousLocalPoint);
        Vector2 localDelta = currentLocalPoint - previousLocalPoint;
        _rectTransform.localPosition += (Vector3)localDelta;
    }

    public void OnEndDrag(PointerEventData eventData)
    {
         // Debug.Log($"[NodeDraggable OnEndDrag] Drag ended. Button: {eventData.button}", gameObject);

        // Ensure visuals and raycast blocking are reset REGARDLESS of button, BEFORE handling drop
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true; // CRITICAL: Re-enable raycasts immediately
             // Debug.Log($"--> Reset alpha and blocksRaycasts to: {_canvasGroup.blocksRaycasts}");
        }

        // Only handle the drop logic if the drag was initiated by the left button
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            if (_gridController != null) {
                _gridController.HandleNodeDrop(this, _originalCell, eventData.position);
            } else {
                 // No controller, attempt reset
                 ResetPosition();
            }
        }
        else
        {
             // If drag ended via another button (unlikely but possible), ensure reset
             ResetPosition();
        }
    }

    public void ResetPosition()
    {
        // Debug.Log($"[NodeDraggable ResetPosition] Resetting {gameObject.name}", gameObject);
        // Reset parent and position
        transform.SetParent(_originalParent, false);
        _rectTransform.anchoredPosition = _originalAnchoredPosition;
        _originalCell = _originalParent?.GetComponent<NodeCell>(); // Update cell ref

        // Ensure visuals and raycasts are correct after reset
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
        }

        // Update parent cell reference on the NodeView
        NodeView view = GetComponent<NodeView>();
        view?.UpdateParentCellReference();
    }

    public void SnapToCell(NodeCell targetCell)
    {
        // Debug.Log($"[NodeDraggable SnapToCell] Snapping {gameObject.name} to Cell {targetCell?.CellIndex}", gameObject);
        if (targetCell == null) { ResetPosition(); return; }

        // Set Parent and Position
        transform.SetParent(targetCell.transform, false);
        _rectTransform.anchoredPosition = Vector2.zero;

        // Update Internal Draggable References
        _originalParent = targetCell.transform;
        _originalCell = targetCell;
        _originalAnchoredPosition = Vector2.zero;

        // Ensure visuals and raycasts are correct after snap
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
        }

        // Update the NodeView's parent reference
        NodeView view = GetComponent<NodeView>();
        view?.UpdateParentCellReference();
    }

    // OnDisable might not be strictly needed now but can be kept as safety
    void OnDisable()
    {
        // If it was disabled mid-drag (blocksRaycasts == false), reset state
        if (_canvasGroup != null && !_canvasGroup.blocksRaycasts)
        {
             Debug.LogWarning($"[NodeDraggable] Disabled while dragging {gameObject.name}. Resetting CanvasGroup.", gameObject);
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
            // Resetting position might be desired but complex here, ensure visuals are ok.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeEditorGridController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using TMPro;
using System.Linq;

[RequireComponent(typeof(RectTransform))]
public class NodeEditorGridController : MonoBehaviour // Keep this script on the persistent "UIManager" or similar object
{
    public static NodeEditorGridController Instance { get; private set; }

    [Header("Grid Layout & Appearance")]
    [SerializeField][Min(1)] private int emptyCellsCount = 8;
    [SerializeField] private Vector2 cellSize = new Vector2(64f, 64f);
    [SerializeField] private float cellMargin = 10f;

    [Header("Empty Cell Visuals")]
    [SerializeField] private Sprite emptyCellSprite;
    [SerializeField] private Color emptyCellColor = Color.white;
    [SerializeField] private Vector3 emptyCellScale = Vector3.one; // Still potentially useful for cell GO scale

    [Header("Node Visuals")]
    [SerializeField] private GameObject nodeViewPrefab;
    [SerializeField] private Vector3 nodeImageScale = Vector3.one; // For the image *inside* the node view
    [SerializeField] private Color selectedNodeBackgroundColor = new Color(0.9f, 0.9f, 0.7f, 1f);

    [Header("Node Definitions & Interaction")]
    [SerializeField] private NodeDefinitionLibrary definitionLibrary;
    [SerializeField] private TMP_Dropdown nodeDropdown;

    [Header("UI References")]
    [Tooltip("The UI GameObject (Panel) that gets toggled visible/hidden.")]
    [SerializeField] private GameObject gridUIParent; // The Panel to show/hide
    [Tooltip("The Transform within the UI Panel where cell GameObjects should be created.")]
    [SerializeField] private Transform cellContainer; // The container for cell GOs (e.g., 'GridContainer')


    private List<NodeCell> nodeCells = new List<NodeCell>();
    // Removed _rectTransform as it's less relevant now the script isn't on the grid panel itself
    private Canvas _rootCanvas;
    private NodeGraph _uiGraphRepresentation = new NodeGraph();


    public GameObject NodeViewPrefab => nodeViewPrefab;
    public Vector3 NodeImageScale => nodeImageScale;
    public NodeDefinitionLibrary DefinitionLibrary => definitionLibrary;
    public Color SelectedNodeBackgroundColor => selectedNodeBackgroundColor;
    public Color EmptyCellColor => emptyCellColor;
    public NodeGraph GetCurrentUIGraph() => _uiGraphRepresentation;


    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Get components relative to this script's GameObject
        _rootCanvas = GetComponentInParent<Canvas>(); // Find the root canvas
        if (_rootCanvas == null) Debug.LogError("[NodeEditorGridController] Root Canvas not found!", gameObject);

        // Validate essential references
        if (gridUIParent == null) Debug.LogError("[NodeEditorGridController] Grid UI Parent (the panel to toggle) not assigned.", gameObject);
        if (cellContainer == null) Debug.LogError("[NodeEditorGridController] Cell Container (parent for cells) not assigned.", gameObject);
        if (nodeDropdown == null) Debug.LogWarning("[NodeEditorGridController] Node Dropdown not assigned.", gameObject);
        if (definitionLibrary == null) Debug.LogError("[NodeEditorGridController] Node Definition Library not assigned!", gameObject);
    }

    void OnDestroy()
    {
        if (Instance == this) Instance = null;
    }

    void Start()
    {
        if (nodeDropdown != null) nodeDropdown.gameObject.SetActive(false);

        // Check if references are set before proceeding
        if (cellContainer != null && definitionLibrary != null)
        {
            CreateCells();
            SpawnInitialNodes(); // Call after cells are created
            RefreshGraph(); // Refresh after potentially spawning initial nodes
        }
        else
        {
            Debug.LogError("[NodeEditorGridController] Cannot initialize grid - Cell Container or Definition Library is missing.", gameObject);
        }
    }

    private void CreateCells()
    {
        // Ensure cellContainer is assigned
        if (cellContainer == null)
        {
            Debug.LogError("[NodeEditorGridController] Cannot create cells - Cell Container is not assigned.", gameObject);
            return;
        }

        // Clear existing cells from the container
        foreach (Transform child in cellContainer) // Iterate through the actual container
        {
            if (child.GetComponent<NodeCell>() != null)
            {
                Destroy(child.gameObject);
            }
        }
        nodeCells.Clear();
        NodeCell.ClearSelection();

        // Layout calculations (assuming cellContainer uses appropriate layout components or manual positioning)
        // If using GridLayoutGroup on cellContainer, positioning is automatic.
        // If positioning manually based on cellContainer's RectTransform:
        RectTransform containerRect = cellContainer.GetComponent<RectTransform>();
        if (containerRect == null)
        {
             Debug.LogError("[NodeEditorGridController] Cell Container needs a RectTransform for manual layout calculations.", cellContainer.gameObject);
             return; // Cannot proceed with manual layout
        }

        // Example Manual Layout (adjust based on containerRect's pivot/anchors):
        // Assuming center pivot (0.5, 0.5) for the container
        float totalWidth = (emptyCellsCount * cellSize.x) + ((emptyCellsCount - 1) * cellMargin);
        float startX = -(totalWidth / 2f) + (cellSize.x / 2f);
        float startY = 0; // Assuming horizontal layout centered vertically

        for (int i = 0; i < emptyCellsCount; i++)
        {
            GameObject cellGO = new GameObject($"Cell_{i}");
            RectTransform rt = cellGO.AddComponent<RectTransform>();

            // *** Parent to the designated cellContainer ***
            cellGO.transform.SetParent(cellContainer, false);

            // --- Manual Positioning --- (Comment out if using GridLayoutGroup)
            // Set anchors and pivot (e.g., center) for the cell itself
            rt.anchorMin = new Vector2(0.5f, 0.5f);
            rt.anchorMax = new Vector2(0.5f, 0.5f);
            rt.pivot = new Vector2(0.5f, 0.5f);
            rt.sizeDelta = cellSize;

            // Calculate position relative to container
            float xPos = startX + i * (cellSize.x + cellMargin);
            float yPos = startY;
            rt.anchoredPosition = new Vector2(xPos, yPos);
            // --- End Manual Positioning ---

            // Apply scale if needed
            rt.localScale = emptyCellScale;

            Image cellImage = cellGO.AddComponent<Image>();
            cellImage.sprite = emptyCellSprite;
            cellImage.color = emptyCellColor;
            cellImage.raycastTarget = true;

            NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
            cellLogic.Init(i, this, cellImage);
            nodeCells.Add(cellLogic);

            // If using GridLayoutGroup on cellContainer, you might not need manual positioning.
            // The GridLayoutGroup component handles size and spacing. Just ensure cellGO has a LayoutElement if needed.
            // Example (if using GridLayout):
            // LayoutElement le = cellGO.GetComponent<LayoutElement>() ?? cellGO.AddComponent<LayoutElement>();
            // le.preferredWidth = cellSize.x;
            // le.preferredHeight = cellSize.y;
        }
    }

    private void SpawnInitialNodes()
    {
        if (definitionLibrary == null || definitionLibrary.initialNodes == null)
        {
            return;
        }
        if (nodeCells.Count == 0)
        {
             Debug.LogWarning("[NodeEditorGridController] Cannot spawn initial nodes - cells haven't been created yet (check for earlier errors).");
             return;
        }

        foreach (var config in definitionLibrary.initialNodes)
        {
            if (config.nodeDefinition == null)
            {
                Debug.LogWarning($"Initial node config has null NodeDefinition. Skipping.");
                continue;
            }

            if (config.cellIndex < 0 || config.cellIndex >= nodeCells.Count)
            {
                Debug.LogWarning($"Initial node config for '{config.nodeDefinition.name}' has invalid cell index ({config.cellIndex}). Max index is {nodeCells.Count - 1}. Skipping.");
                continue;
            }

            NodeCell targetCell = nodeCells[config.cellIndex];
            if (targetCell.HasNode())
            {
                Debug.LogWarning($"Initial node config for '{config.nodeDefinition.name}' targets cell {config.cellIndex}, but it's already occupied. Skipping.");
                continue;
            }

            targetCell.AssignNode(config.nodeDefinition);

            NodeView spawnedView = targetCell.GetNodeView();
            if (spawnedView != null)
            {
                NodeDraggable draggable = spawnedView.GetComponent<NodeDraggable>();
                if (draggable != null)
                {
                    draggable.enabled = config.canMove;
                } else if (config.canMove) {
                     Debug.LogWarning($"Initial node '{config.nodeDefinition.name}' in cell {config.cellIndex} is set to 'canMove=true' but its prefab is missing the NodeDraggable component.", spawnedView.gameObject);
                }

                NodeData spawnedData = targetCell.GetNodeData();
                if (spawnedData != null)
                {
                    spawnedData.canBeDeleted = config.canDelete;
                }
            }
        }
    }


    void Update()
    {
        // UI Toggle
        if (Input.GetKeyDown(KeyCode.Tab))
        {
             ToggleGridUI(); // This should now work correctly
        }

        // Delete Node Handling
        if (Input.GetKeyDown(KeyCode.Delete))
        {
            if (NodeCell.CurrentlySelectedCell != null)
            {
                NodeCell selected = NodeCell.CurrentlySelectedCell;
                NodeData data = selected.GetNodeData();

                if (data != null && data.canBeDeleted)
                {
                    selected.RemoveNode();
                    RefreshGraph();
                }
                else if (data != null && !data.canBeDeleted)
                {
                     Debug.Log($"Node '{data.nodeDisplayName}' cannot be deleted.");
                }
            }
        }

        // Dropdown Escape Handling
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf)
            {
                HideDropdown();
            }
             else if (NodeCell.CurrentlySelectedCell != null) {
                 NodeCell.ClearSelection();
             }
        }
    }

    public void ToggleGridUI()
    {
        if (gridUIParent != null)
        {
            bool currentState = gridUIParent.activeSelf;
            gridUIParent.SetActive(!currentState); // This toggles the assigned panel

            if (!gridUIParent.activeSelf) // If hiding UI
            {
                 if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) HideDropdown();
                 NodeCell.ClearSelection(); // Deselect nodes when UI hides
            }
        }
        else Debug.LogWarning("[NodeEditorGridController] Grid UI Parent not assigned.");
    }

    public void OnEmptyCellRightClicked(NodeCell cell, PointerEventData eventData)
    {
        if (nodeDropdown == null) { Debug.LogError("[NodeEditorGridController] Node Dropdown not assigned."); return; }
        if (definitionLibrary == null || definitionLibrary.definitions == null) { Debug.LogError("[NodeEditorGridController] Node Definition Library not assigned or has no definitions."); return; }

        StopCoroutine("ShowDropdownCoroutine");
        StartCoroutine(ShowDropdownCoroutine(cell, eventData));
    }

     private IEnumerator ShowDropdownCoroutine(NodeCell cell, PointerEventData eventData)
     {
         List<TMP_Dropdown.OptionData> options = new List<TMP_Dropdown.OptionData>();
         options.Add(new TMP_Dropdown.OptionData("Select Node..."));
         var sortedDefinitions = definitionLibrary.definitions
                                     .Where(def => def != null)
                                     .OrderBy(def => def.displayName)
                                     .ToList();
         foreach (var def in sortedDefinitions) {
             TMP_Dropdown.OptionData option = new TMP_Dropdown.OptionData();
             option.text = def.displayName;
             option.image = def.thumbnail;
             options.Add(option);
         }
         nodeDropdown.ClearOptions();
         nodeDropdown.AddOptions(options);

         nodeDropdown.onValueChanged.RemoveAllListeners();
         nodeDropdown.onValueChanged.AddListener((selectedIndex) => {
             OnDropdownValueChanged(selectedIndex, cell, sortedDefinitions);
         });

         RectTransform dropdownRect = nodeDropdown.GetComponent<RectTransform>();
         RectTransformUtility.ScreenPointToLocalPointInRectangle(
             dropdownRect.parent as RectTransform,
             eventData.position,
             _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera,
             out Vector2 localPos);
         dropdownRect.localPosition = localPos;

         if (!nodeDropdown.gameObject.activeSelf) nodeDropdown.gameObject.SetActive(true);

         yield return null;

         try {
             if (nodeDropdown.template == null) {
                 Debug.LogError("Dropdown template is not assigned in the Inspector!", nodeDropdown.gameObject);
                 HideDropdown();
                 yield break;
             }
             nodeDropdown.Show();
         } catch (System.NullReferenceException nre) {
              Debug.LogError($"Error showing dropdown: {nre.Message}", nodeDropdown.gameObject);
             HideDropdown();
             yield break;
         }

         nodeDropdown.value = 0;
         nodeDropdown.RefreshShownValue();
     }

     private void OnDropdownValueChanged(int selectedIndex, NodeCell targetCell, List<NodeDefinition> sortedDefs)
     {
         HideDropdown();

         if (selectedIndex > 0) {
             int definitionIndex = selectedIndex - 1;
             if (definitionIndex >= 0 && definitionIndex < sortedDefs.Count) {
                 NodeDefinition selectedDef = sortedDefs[definitionIndex];
                 if (selectedDef != null) {
                     targetCell.AssignNode(selectedDef);
                     NodeCell.SelectCell(targetCell);
                     RefreshGraph();
                 }
             } else {
                  Debug.LogError($"Dropdown selection index ({selectedIndex}) resulted in an out-of-bounds index ({definitionIndex}) for the definition list.");
             }
         }
     }

    public void HideDropdown()
    {
        if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf)
        {
            nodeDropdown.Hide();
            nodeDropdown.gameObject.SetActive(false);
        }
    }

    public void RefreshGraph()
    {
        if (_uiGraphRepresentation == null) _uiGraphRepresentation = new NodeGraph();
        _uiGraphRepresentation.nodes.Clear();
        // Ensure cells are ordered correctly by index when building the graph
        foreach (var cell in nodeCells.OrderBy(c => c.CellIndex))
        {
            NodeData data = cell.GetNodeData();
            if (data != null)
            {
                data.orderIndex = cell.CellIndex;
                _uiGraphRepresentation.nodes.Add(data);
            }
        }
    }

     public bool HandleNodeDrop(NodeDraggable draggedDraggable, NodeCell originalCell, Vector2 screenPosition)
     {
         NodeCell targetCell = FindCellAtScreenPosition(screenPosition);
         bool changed = false;

         if (targetCell != null && originalCell != null)
         {
             NodeView draggedView = draggedDraggable.GetComponent<NodeView>();
             NodeData draggedData = draggedView?.GetNodeData();

             if (draggedView == null || draggedData == null) {
                 Debug.LogError("Dragged object missing NodeView or NodeData!", draggedDraggable.gameObject);
                 draggedDraggable.ResetPosition();
                 return false;
             }

             if (targetCell == originalCell) {
                 draggedDraggable.ResetPosition();
                 NodeCell.SelectCell(targetCell);
                 return false;
             }

             NodeView existingViewInTarget = targetCell.GetNodeView();
             NodeData existingDataInTarget = targetCell.GetNodeData();

             NodeCell.ClearSelection();

             originalCell.ClearNodeReference();

             if (existingViewInTarget != null && existingDataInTarget != null) {
                 NodeDraggable existingDraggable = existingViewInTarget.GetComponent<NodeDraggable>();
                 originalCell.AssignNodeView(existingViewInTarget, existingDataInTarget);
                 if (existingDraggable != null) existingDraggable.SnapToCell(originalCell);
             }

             targetCell.AssignNodeView(draggedView, draggedData);
             draggedDraggable.SnapToCell(targetCell);

             NodeCell.SelectCell(targetCell);
             changed = true;
         }
         else
         {
             draggedDraggable.ResetPosition();
             if (originalCell != null && originalCell.HasNode()) {
                 NodeCell.SelectCell(originalCell);
             } else {
                 NodeCell.ClearSelection();
             }
         }

         if (changed) RefreshGraph();

         return changed;
     }

     private NodeCell FindCellAtScreenPosition(Vector2 screenPosition)
     {
         NodeCell foundCell = null;
         if (cellContainer == null) return null; // Cannot find cells if container is missing

         // Check all NodeCell components *within the specified container*
         foreach (Transform cellTransform in cellContainer)
         {
             NodeCell cell = cellTransform.GetComponent<NodeCell>();
             if (cell == null) continue; // Skip if child isn't a NodeCell

             RectTransform cellRect = cell.GetComponent<RectTransform>();
             if (cellRect == null) continue; // Skip if cell doesn't have a RectTransform

             bool contains = RectTransformUtility.RectangleContainsScreenPoint(
                 cellRect,
                 screenPosition,
                 _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera
             );
             if (contains) {
                 foundCell = cell;
                 break;
             }
         }
         return foundCell;
     }

     #if UNITY_EDITOR
     void OnDrawGizmos()
     {
         // Draw gizmos only in the editor and when not playing
         // Check if cellContainer is assigned before drawing
         if (!Application.isPlaying && cellContainer != null && cellContainer.TryGetComponent<RectTransform>(out var containerRect))
         {
             Gizmos.color = new Color(0f, 1f, 0f, 0.5f); // Semi-transparent green

             // Use the same layout logic as CreateCells (example for manual layout)
             float totalWidth = (emptyCellsCount * cellSize.x) + ((emptyCellsCount - 1) * cellMargin);
             float startX_for_gizmo = -(totalWidth / 2f) + (cellSize.x / 2f); // Relative to container center pivot
             float startY_for_gizmo = 0;

             // Store original matrix
             Matrix4x4 originalMatrix = Gizmos.matrix;

             for (int i = 0; i < emptyCellsCount; i++)
             {
                 // Calculate center position of the cell in container's local space
                 float xOffset = startX_for_gizmo + i * (cellSize.x + cellMargin);
                 Vector3 localCellCenter = new Vector3(xOffset, startY_for_gizmo, 0);

                 // Transform local center to world space using the CELL CONTAINER's transform
                 Vector3 worldCellCenter = cellContainer.TransformPoint(localCellCenter);

                 // Calculate gizmo size based on CELL CONTAINER's lossy scale
                 Vector3 gizmoSize = new Vector3(cellSize.x * cellContainer.lossyScale.x, cellSize.y * cellContainer.lossyScale.y, 0.1f);

                 // Set Gizmos matrix to handle CELL CONTAINER's rotation
                 Gizmos.matrix = Matrix4x4.TRS(worldCellCenter, cellContainer.rotation, Vector3.one);

                 // Draw wire cube centered at the transformed position
                 Gizmos.DrawWireCube(Vector3.zero, gizmoSize);
             }
             // Restore original Gizmos matrix
             Gizmos.matrix = originalMatrix;
         }
         // Optional: Draw a box around the container itself
         // else if (!Application.isPlaying && cellContainer != null && cellContainer.TryGetComponent<RectTransform>(out containerRect)) {
         //     Gizmos.color = Color.yellow;
         //     // Simplified world space box based on container rect
         //     Vector3[] corners = new Vector3[4];
         //     containerRect.GetWorldCorners(corners);
         //     Vector3 center = (corners[0] + corners[2]) * 0.5f;
         //     Vector3 size = new Vector3(Mathf.Abs(corners[0].x - corners[2].x), Mathf.Abs(corners[0].y - corners[2].y), 0.1f);
         //     Gizmos.matrix = Matrix4x4.TRS(center, containerRect.rotation, Vector3.one);
         //     Gizmos.DrawWireCube(Vector3.zero, size);
         //     Gizmos.matrix = Matrix4x4.identity;
         // }
     }
     #endif
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeSelectable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

public class NodeSelectable : MonoBehaviour, IPointerClickHandler
{
    public static GameObject CurrentSelected { get; set; }

    public void OnPointerClick(PointerEventData eventData)
    {
        Select(gameObject);
    }

    public static void Select(GameObject node)
    {
        if (CurrentSelected != null && CurrentSelected != node)
        {
            // (Optional) Remove highlight from previously selected node.
        }
        CurrentSelected = node;
        // (Optional) Add highlight effect here.
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeView.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.EventSystems;
using System.Collections.Generic;
using System.Text;

[RequireComponent(typeof(RectTransform))]
public class NodeView : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler
{
    // --- Fields remain the same ---
    [Header("UI Elements (Assign in Prefab)")]
    [SerializeField] private Image thumbnailImage;
    [SerializeField] private Image backgroundImage;
    [SerializeField] private GameObject tooltipPanel;
    [SerializeField] private TMP_Text tooltipText;
    [SerializeField] private TMP_Text nodeNameText;
    [Header("Configuration")]
    [SerializeField] private bool displayNodeName = false;

    private NodeData _nodeData;
    private NodeDefinition _nodeDefinition;
    private NodeEditorGridController _controller;
    private NodeCell _parentCell;
    private Color _originalBackgroundColor;

    // --- Initialize, UpdateParentCellReference, Getters, Highlight, Unhighlight remain the same ---
     public void Initialize(NodeData data, NodeDefinition definition, NodeEditorGridController controller)
    { /* ... as before ... */
         _nodeData = data; _nodeDefinition = definition; _controller = controller;
         UpdateParentCellReference();
         if (_nodeData == null || _nodeDefinition == null || _controller == null || _parentCell == null) { gameObject.SetActive(false); return; }
         if (thumbnailImage != null) { thumbnailImage.sprite = _nodeDefinition.thumbnail; thumbnailImage.color = _nodeDefinition.thumbnailTintColor; thumbnailImage.rectTransform.localScale = _controller.NodeImageScale; thumbnailImage.enabled = (thumbnailImage.sprite != null); if (!thumbnailImage.raycastTarget) thumbnailImage.raycastTarget = true; }
         if (backgroundImage != null) { _originalBackgroundColor = _nodeDefinition.backgroundColor; backgroundImage.color = _originalBackgroundColor; backgroundImage.enabled = true; if (!backgroundImage.raycastTarget) backgroundImage.raycastTarget = true; }
         if (tooltipPanel != null) tooltipPanel.SetActive(false);
         if (nodeNameText != null) { nodeNameText.text = _nodeData.nodeDisplayName; nodeNameText.gameObject.SetActive(displayNodeName); }
    }
     public void UpdateParentCellReference() { _parentCell = GetComponentInParent<NodeCell>(); /* ... null check ... */ }
     public NodeData GetNodeData() => _nodeData;
     public NodeDefinition GetNodeDefinition() => _nodeDefinition;
     public NodeCell GetParentCell() => _parentCell;
     public void Highlight() { if (backgroundImage != null && _controller != null) backgroundImage.color = _controller.SelectedNodeBackgroundColor; }
     public void Unhighlight() { if (backgroundImage != null) backgroundImage.color = _originalBackgroundColor; }


    // --- Tooltip Handling with Logging ---
    public void OnPointerEnter(PointerEventData eventData)
    {
        // --- Add Log ---
        Debug.Log($"[NodeView OnPointerEnter] Fired on {gameObject.name}. Tooltip Panel assigned: {tooltipPanel != null}", gameObject);

        // Ensure the CanvasGroup allows raycasts IF it exists
        CanvasGroup cg = GetComponent<CanvasGroup>();
        if (cg != null && cg.blocksRaycasts == false)
        {
             Debug.LogWarning($"--> PointerEnter detected but CanvasGroup is blocking raycasts! Drag state might be stuck?", gameObject);
             // Optionally force it: cg.blocksRaycasts = true;
        }


        if (tooltipPanel != null && tooltipText != null && _nodeDefinition != null && _nodeData != null)
        {
            // --- Add Log ---
            // Debug.Log("--> Activating Tooltip Panel");
            tooltipPanel.SetActive(true);
            tooltipText.text = BuildTooltipString();
        }
         else if (tooltipPanel == null) {
             // Debug.LogWarning("--> Tooltip Panel is not assigned in Inspector.", gameObject);
         }
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        // --- Add Log ---
        // Debug.Log($"[NodeView OnPointerExit] Fired on {gameObject.name}", gameObject);

        if (tooltipPanel != null)
        {
             // Debug.Log("--> Deactivating Tooltip Panel");
            tooltipPanel.SetActive(false);
        }
    }

    // --- Pointer Down remains the same ---
    public void OnPointerDown(PointerEventData eventData) { /* ... as before ... */
         // Debug.Log($"[NodeView OnPointerDown] Fired on: {gameObject.name} in Cell: {_parentCell?.CellIndex} | Button: {eventData.button}", gameObject);
        if (eventData.button == PointerEventData.InputButton.Left) {
            if (_parentCell != null) {
                 // Debug.Log($"--> Left Click Confirmed. Requesting SelectCell for {_parentCell.CellIndex}");
                NodeCell.SelectCell(_parentCell);
            } else { UpdateParentCellReference(); if (_parentCell != null) NodeCell.SelectCell(_parentCell); else Debug.LogError("[NodeView] ParentCell null on PointerDown!", gameObject); }
        }
    }

    // --- BuildTooltipString remains the same ---
    private string BuildTooltipString() { /* ... as before ... */
         StringBuilder sb = new StringBuilder(); sb.Append("<b>").Append(_nodeData.nodeDisplayName).Append("</b>\n"); if (!string.IsNullOrEmpty(_nodeDefinition.description)) sb.Append(_nodeDefinition.description).Append("\n"); if (_nodeData.effects != null && _nodeData.effects.Count > 0) { sb.Append("<i>Effects:</i>\n"); foreach (var eff in _nodeData.effects) { sb.Append("- ").Append(eff.effectType.ToString()).Append(": "); sb.Append(eff.primaryValue.ToString("G3")); if (eff.secondaryValue != 0) sb.Append(" / ").Append(eff.secondaryValue.ToString("G3")); sb.Append("\n"); } } return sb.ToString().TrimEnd();
     }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Player\GardenerController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Player/GardenerController.cs
using UnityEngine;
using System;
using System.Collections.Generic;

// No longer requires ToolSwitcher on the same GameObject
public class GardenerController : MonoBehaviour
{
    // --- Fields ---
    [Header("Movement Settings")]
    public float moveSpeed = 5f;
    
    [Header("Speed Modifiers")]
    [Tooltip("Current speed including all active modifiers (read-only)")]
    [SerializeField] private float currentMoveSpeed;
    private float baseMoveSpeed;
    private List<float> activeSpeedMultipliers = new List<float>();
    
    [Header("Planting Settings")]
    public Vector2 seedPlantingOffset = new Vector2(0f, -0.5f);

    [Header("Tool References")] // <<< NEW HEADER
    [Tooltip("Assign the SpriteRenderer used to display the current tool's icon.")]
    [SerializeField] private SpriteRenderer toolIconRenderer;
    [Tooltip("Assign the GameObject or Component containing the ToolSwitcher script.")] // <<< NEW TOOLTIP
    [SerializeField] private ToolSwitcher toolSwitcherInstance; // <<< CHANGED: Reference field

    [Header("Visual Settings")]
    public bool flipSpriteWhenMovingLeft = true;
    public bool flipHorizontalDirection = true;

    [Header("Animation Settings")]
    public bool useAnimations = true;
    public string runningParameterName = "isRunning";
    public string plantingParameterName = "isPlanting";
    public float plantingDuration = 0.25f;

    // Private references
    private Rigidbody2D rb;
    private Vector2 movement;
    private SortableEntity sortableEntity;
    private SpriteRenderer spriteRenderer;
    private Animator animator;
    // ToolSwitcher reference is now toolSwitcherInstance (assigned via inspector)

    // Private variables
    private bool isPlanting = false;
    private float plantingTimer = 0f;
    private bool wasMovingBeforePlanting = false;

    void Awake()
    {
        // Store original components and references
        rb = GetComponent<Rigidbody2D>();
        sortableEntity = GetComponent<SortableEntity>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        animator = GetComponent<Animator>();

        // Store base movement speed for multiplier system
        baseMoveSpeed = moveSpeed;
        currentMoveSpeed = moveSpeed;
    
        // Initialize speed multipliers list
        activeSpeedMultipliers = new List<float>();

        if (sortableEntity == null)
            sortableEntity = gameObject.AddComponent<SortableEntity>();

        // Validations for other components
        if (spriteRenderer == null)
            Debug.LogWarning("[GardenerController Awake] Main SpriteRenderer component not found.", gameObject);
    
        if (animator == null && useAnimations)
            Debug.LogWarning("[GardenerController Awake] Animator component not found but useAnimations is true.", gameObject);

        if (toolSwitcherInstance == null)
        {
            Debug.LogError("[GardenerController Awake] Tool Switcher Instance is not assigned in the Inspector! Tool switching and icon display will not function.", gameObject);
        }

        if (toolIconRenderer == null)
            Debug.LogError("[GardenerController Awake] Tool Icon Renderer is not assigned in the Inspector! Tool icons will not display.", gameObject);
        else
        {
            Debug.Log("[GardenerController Awake] Tool Icon Renderer found. Initializing as hidden.", gameObject);
            toolIconRenderer.enabled = false;
        }
    }

    private void Start()
    {
        // Subscribe ONLY if toolSwitcherInstance was assigned in the inspector
        if (toolSwitcherInstance != null)
        {
            Debug.Log("[GardenerController Start] ToolSwitcherInstance assigned. Subscribing to ToolSwitcher.OnToolChanged.", gameObject);
            toolSwitcherInstance.OnToolChanged += HandleToolChanged;

            // Manually trigger the handler once at the start
            Debug.Log("[GardenerController Start] Manually calling HandleToolChanged for initial tool.", gameObject);
            HandleToolChanged(toolSwitcherInstance.CurrentTool);
        }
        else
        {
             // Error logged in Awake, no need for more logs here.
        }
    }

    private void OnDestroy()
    {
        // Clear speed multipliers list
        activeSpeedMultipliers.Clear();
        // Unsubscribe ONLY if toolSwitcherInstance was assigned and we subscribed
        if (toolSwitcherInstance != null)
        {
            Debug.Log("[GardenerController OnDestroy] Unsubscribing from ToolSwitcher.OnToolChanged.", gameObject);
            toolSwitcherInstance.OnToolChanged -= HandleToolChanged;
        }
    }

    // --- Update, FixedUpdate, UpdateAnimations, UpdateSpriteDirection, Start/EndPlantingAnimation, GetPlantingPosition, SetPlantingDuration, Plant methods remain the same ---
    private void Update()
    {
        if (!isPlanting)
        {
            movement.x = Input.GetAxisRaw("Horizontal");
            movement.y = Input.GetAxisRaw("Vertical");
            bool isMoving = movement.sqrMagnitude > 0.01f;
            if (isMoving) wasMovingBeforePlanting = true;
        }
        else
        {
            movement = Vector2.zero;
            plantingTimer -= Time.deltaTime;
            if (plantingTimer <= 0) EndPlantingAnimation();
        }
        UpdateAnimations();
        UpdateSpriteDirection();
    }
    
    public void ApplySpeedMultiplier(float multiplier)
    {
        if (!activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Add(multiplier);
            UpdateMovementSpeed();
        
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Applied speed multiplier: {multiplier}. New speed: {currentMoveSpeed}");
            }
        }
    }
    
    private void UpdateMovementSpeed()
    {
        // Start with base speed
        float newSpeed = baseMoveSpeed;
    
        // Apply all active multipliers
        if (activeSpeedMultipliers.Count > 0)
        {
            // Use the most restrictive (lowest) multiplier
            float lowestMultiplier = 1.0f;
            foreach (float multiplier in activeSpeedMultipliers)
            {
                if (multiplier < lowestMultiplier)
                {
                    lowestMultiplier = multiplier;
                }
            }
        
            newSpeed *= lowestMultiplier;
        }
    
        // Update the current move speed
        currentMoveSpeed = newSpeed;
    }
    
    public void RemoveSpeedMultiplier(float multiplier)
    {
        if (activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Remove(multiplier);
            UpdateMovementSpeed();
        
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Removed speed multiplier: {multiplier}. New speed: {currentMoveSpeed}");
            }
        }
    }
    
    
    void FixedUpdate()
    {
        if (!isPlanting)
        {
            // Use currentMoveSpeed (with modifiers) instead of moveSpeed
            rb.MovePosition(rb.position + movement.normalized * currentMoveSpeed * Time.fixedDeltaTime);
        }
    }
    private void UpdateAnimations() { if (!useAnimations || animator == null) return; bool isMoving = movement.sqrMagnitude > 0.01f; animator.SetBool(runningParameterName, isMoving); }
    private void UpdateSpriteDirection() { if (spriteRenderer == null || !flipSpriteWhenMovingLeft) return; if (movement.x != 0) { bool shouldFlip = (movement.x < 0); if (flipHorizontalDirection) { spriteRenderer.flipX = shouldFlip; } else { Vector3 scale = transform.localScale; scale.x = shouldFlip ? -Mathf.Abs(scale.x) : Mathf.Abs(scale.x); transform.localScale = scale; } } }
    public void StartPlantingAnimation() { if (!useAnimations || isPlanting) return; isPlanting = true; plantingTimer = plantingDuration; wasMovingBeforePlanting = movement.sqrMagnitude > 0.01f; if (animator != null) { animator.SetBool(plantingParameterName, true); animator.SetBool(runningParameterName, false); } }
    private void EndPlantingAnimation() { isPlanting = false; if (animator != null) { animator.SetBool(plantingParameterName, false); movement.x = Input.GetAxisRaw("Horizontal"); movement.y = Input.GetAxisRaw("Vertical"); bool shouldResumeRunning = movement.sqrMagnitude > 0.01f; animator.SetBool(runningParameterName, shouldResumeRunning); } }
    public Vector2 GetPlantingPosition() { return (Vector2)transform.position + seedPlantingOffset; }
    public void SetPlantingDuration(float duration) { plantingDuration = Mathf.Max(0.1f, duration); }
    public void Plant() { StartPlantingAnimation(); }
    // ---------------------------------

    // --- HandleToolChanged remains the same (uses toolSwitcherInstance implicitly via Start/OnDestroy) ---
    private void HandleToolChanged(ToolDefinition newTool)
    {
        string toolName = newTool != null ? newTool.displayName : "NULL";
        Debug.Log($"[HandleToolChanged] Received tool: {toolName}", gameObject);

        if (toolIconRenderer == null)
        {
            Debug.LogError("[HandleToolChanged] toolIconRenderer is NULL. Cannot update icon.", gameObject);
            return;
        }

        if (newTool != null)
        {
            string iconName = newTool.icon != null ? newTool.icon.name : "NULL";
            Debug.Log($"[HandleToolChanged] Tool '{toolName}' has icon: {iconName}", gameObject);

            if (newTool.icon != null)
            {
                Debug.Log($"[HandleToolChanged] Assigning sprite '{newTool.icon.name}' and color '{newTool.iconTint}' to toolIconRenderer.", gameObject);
                toolIconRenderer.sprite = newTool.icon;
                toolIconRenderer.color = newTool.iconTint;
                Debug.Log($"[HandleToolChanged] Enabling toolIconRenderer. Current state before: {toolIconRenderer.enabled}", gameObject);
                toolIconRenderer.enabled = true;
                Debug.Log($"[HandleToolChanged] toolIconRenderer.enabled is now: {toolIconRenderer.enabled}", gameObject);
                Debug.Log($"[HandleToolChanged] toolIconRenderer.sprite is now: {toolIconRenderer.sprite?.name ?? "NULL"}", gameObject);
            }
            else
            {
                Debug.LogWarning($"[HandleToolChanged] Tool '{toolName}' has a NULL icon. Hiding renderer.", gameObject);
                toolIconRenderer.enabled = false;
                toolIconRenderer.sprite = null;
            }
        }
        else
        {
            Debug.Log("[HandleToolChanged] newTool is NULL. Hiding renderer.", gameObject);
            toolIconRenderer.enabled = false;
            toolIconRenderer.sprite = null;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlantGrowthModifierManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

public class PlantGrowthModifierManager : MonoBehaviour
{
    public static PlantGrowthModifierManager Instance { get; private set; }

    [System.Serializable]
    public class TileGrowthModifier
    {
        [Tooltip("The tile definition this modifier applies to")]
        public TileDefinition tileDefinition;

        [Tooltip("Multiplier for plant growth speed when on this tile (1.0 = normal)")]
        [Range(0.1f, 3.0f)]
        public float growthSpeedMultiplier = 1.0f;

        [Tooltip("Multiplier for energy recharge speed when on this tile (1.0 = normal)")]
        [Range(0.1f, 3.0f)]
        public float energyRechargeMultiplier = 1.0f;
    }

    [Header("Default Settings")]
    [Tooltip("Default multiplier for tiles that aren't specifically configured")]
    [Range(0.1f, 3.0f)]
    public float defaultGrowthSpeedMultiplier = 1.0f;

    [Tooltip("Default multiplier for energy recharge on tiles that aren't specifically configured")]
    [Range(0.1f, 3.0f)]
    public float defaultEnergyRechargeMultiplier = 1.0f;

    [Header("Tile Update Settings")]
    [Tooltip("How often (in seconds) to check if plants are on different tiles")]
    [Range(0.5f, 5.0f)]
    public float tileUpdateInterval = 1.0f;

    [Header("Tile Growth Modifiers")]
    [Tooltip("Define growth and energy recharge multipliers for specific tiles")]
    public List<TileGrowthModifier> tileModifiers = new List<TileGrowthModifier>();

    [Header("References")]
    [SerializeField] private TileInteractionManager tileInteractionManager;

    [Header("Debug")]
    [SerializeField] private bool showDebugMessages = true;
    [SerializeField] private bool showTileChangeMessages = true;

    // Dictionary for faster lookup of modifiers by tile definition
    private Dictionary<TileDefinition, TileGrowthModifier> modifierLookup = new Dictionary<TileDefinition, TileGrowthModifier>();

    // Dictionary to track what tile each plant is on
    private Dictionary<PlantGrowth, TileDefinition> plantTiles = new Dictionary<PlantGrowth, TileDefinition>();
    
    // Timer for tile updates
    private float tileUpdateTimer = 0f;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // Build lookup dictionary for faster access
        BuildModifierLookup();
    }

    private void Start()
    {
        // Find TileInteractionManager if not assigned
        if (tileInteractionManager == null)
        {
            tileInteractionManager = TileInteractionManager.Instance;
            if (tileInteractionManager == null && showDebugMessages)
            {
                Debug.LogWarning("PlantGrowthModifierManager: TileInteractionManager not found!");
            }
        }
        
        // Start with a tile update
        tileUpdateTimer = 0f;
    }

    private void Update()
    {
        // Update timer
        tileUpdateTimer -= Time.deltaTime;
        
        // Check if it's time to update tiles
        if (tileUpdateTimer <= 0f)
        {
            UpdateAllPlantTiles();
            tileUpdateTimer = tileUpdateInterval;
        }
    }

    // Check all plants to see if their tiles have changed
    private void UpdateAllPlantTiles()
    {
        if (tileInteractionManager == null)
        {
            return;
        }
        
        // We need to copy the keys to avoid modifying the dictionary during iteration
        List<PlantGrowth> plantsToCheck = new List<PlantGrowth>(plantTiles.Keys);
        
        foreach (PlantGrowth plant in plantsToCheck)
        {
            if (plant == null)
            {
                // Plant has been destroyed, remove from dictionary
                plantTiles.Remove(plant);
                continue;
            }
            
            // Convert plant position to grid position
            Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
            
            // Get current tile definition at this position
            TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
            
            // Get previously stored tile definition
            TileDefinition previousTileDef = plantTiles[plant];
            
            // Check if tile has changed
            if (currentTileDef != previousTileDef)
            {
                // Update stored tile
                plantTiles[plant] = currentTileDef;
                
                if (showTileChangeMessages)
                {
                    string previousTileName = previousTileDef != null ? previousTileDef.displayName : "None";
                    string currentTileName = currentTileDef != null ? currentTileDef.displayName : "None";
                    Debug.Log($"Plant tile changed: {previousTileName} -> {currentTileName}");
                }
            }
        }
    }

    private void BuildModifierLookup()
    {
        modifierLookup.Clear();
        foreach (var modifier in tileModifiers)
        {
            if (modifier.tileDefinition != null && !modifierLookup.ContainsKey(modifier.tileDefinition))
            {
                modifierLookup.Add(modifier.tileDefinition, modifier);
            }
        }

        if (showDebugMessages)
        {
            Debug.Log($"PlantGrowthModifierManager: Built lookup with {modifierLookup.Count} tile modifiers");
        }
    }

    // Call this when a plant is created to register its tile
    public void RegisterPlantTile(PlantGrowth plant, TileDefinition tileDef)
    {
        if (plant == null)
            return;

        plantTiles[plant] = tileDef;

        if (showDebugMessages)
        {
            string tileName = tileDef != null ? tileDef.displayName : "Unknown Tile";
            Debug.Log($"Registered plant {plant.name} on tile {tileName}");
        }
    }

    // Call this when a plant is destroyed to clean up
    public void UnregisterPlant(PlantGrowth plant)
    {
        if (plant == null)
            return;

        if (plantTiles.ContainsKey(plant))
        {
            plantTiles.Remove(plant);
        }
    }

    // Get growth speed multiplier for a plant based on its tile
    public float GetGrowthSpeedMultiplier(PlantGrowth plant)
    {
        if (plant == null)
            return defaultGrowthSpeedMultiplier;
        
        // If plant not in dictionary, register it with its current tile
        if (!plantTiles.ContainsKey(plant))
        {
            RegisterNewPlant(plant);
        }
        
        TileDefinition tileDef = plantTiles[plant];
        if (tileDef == null)
        {
            return defaultGrowthSpeedMultiplier;
        }

        if (modifierLookup.TryGetValue(tileDef, out TileGrowthModifier modifier))
        {
            return modifier.growthSpeedMultiplier;
        }

        return defaultGrowthSpeedMultiplier;
    }

    // Get energy recharge multiplier for a plant based on its tile
    public float GetEnergyRechargeMultiplier(PlantGrowth plant)
    {
        if (plant == null)
            return defaultEnergyRechargeMultiplier;
        
        // If plant not in dictionary, register it with its current tile
        if (!plantTiles.ContainsKey(plant))
        {
            RegisterNewPlant(plant);
        }
        
        TileDefinition tileDef = plantTiles[plant];
        if (tileDef == null)
        {
            return defaultEnergyRechargeMultiplier;
        }

        if (modifierLookup.TryGetValue(tileDef, out TileGrowthModifier modifier))
        {
            return modifier.energyRechargeMultiplier;
        }

        return defaultEnergyRechargeMultiplier;
    }
    
    // Helper method to register a new plant with its current tile
    private void RegisterNewPlant(PlantGrowth plant)
    {
        if (plant == null || tileInteractionManager == null)
            return;
            
        Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
        TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
        
        plantTiles[plant] = currentTileDef;
        
        if (showDebugMessages)
        {
            string tileName = currentTileDef != null ? currentTileDef.displayName : "Unknown Tile";
            Debug.Log($"Auto-registered plant {plant.name} on tile {tileName}");
        }
    }

    // For editor support - rebuild lookup when modifiers change
    public void OnValidate()
    {
        BuildModifierLookup();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlantPlacementManagement.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

public class PlantPlacementManager : MonoBehaviour
{
    public static PlantPlacementManager Instance { get; private set; }

    [Header("References")]
    [SerializeField] private GameObject plantPrefab;
    [SerializeField] private NodeEditorGridController nodeEditorGrid;
    [SerializeField] private Transform plantParent;
    [SerializeField] private TileInteractionManager tileInteractionManager;
    [SerializeField] private PlantGrowthModifierManager growthModifierManager;

    [Header("Planting Settings")]
    [Tooltip("Maximum radius from cell center for random seed placement (in units)")]
    [SerializeField] private float spawnRadius = 0.25f;
    
    [Tooltip("Increment for position randomization (in pixels, for pixel-perfect placement)")]
    [SerializeField] private float spawnRadiusIncrement = 4f;

    [Header("Tile Restrictions")]
    [Tooltip("List of tiles that cannot be planted on")]
    [SerializeField] private List<TileDefinition> invalidPlantingTiles = new List<TileDefinition>();

    [Header("Debug")]
    [SerializeField] private bool showDebugMessages = true;
    
    // Cache for quick lookup of invalid tiles
    private HashSet<TileDefinition> invalidTilesSet = new HashSet<TileDefinition>();
    
    // Dictionary to track plant positions (using grid cell positions as keys)
    private Dictionary<Vector3Int, GameObject> plantsByGridPosition = new Dictionary<Vector3Int, GameObject>();
    
    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        
        // Build the set of invalid tiles for faster lookup
        RebuildInvalidTilesSet();
    }

    private void Start()
    {
        // Initialize references if not set in inspector
        if (plantParent == null && EcosystemManager.Instance != null)
        {
            plantParent = EcosystemManager.Instance.plantParent;
        }
        
        if (nodeEditorGrid == null)
        {
            nodeEditorGrid = NodeEditorGridController.Instance;
        }
        
        if (tileInteractionManager == null)
        {
            tileInteractionManager = TileInteractionManager.Instance;
        }
        
        if (growthModifierManager == null)
        {
            growthModifierManager = PlantGrowthModifierManager.Instance;
        }
    }
    
    private void RebuildInvalidTilesSet()
    {
        invalidTilesSet.Clear();
        foreach (var tile in invalidPlantingTiles)
        {
            if (tile != null)
            {
                invalidTilesSet.Add(tile);
            }
        }
        
        if (showDebugMessages)
        {
            Debug.Log($"PlantPlacementManager: Built invalid tiles set with {invalidTilesSet.Count} entries");
        }
    }
    
    private void OnValidate()
    {
        // Rebuild the set when changed in Inspector
        RebuildInvalidTilesSet();
    }

    // Check if a grid position is occupied by a plant
    public bool IsPositionOccupied(Vector3Int gridPosition)
    {
        // If we have a reference, check if it's still valid (not destroyed)
        if (plantsByGridPosition.TryGetValue(gridPosition, out GameObject plant))
        {
            if (plant == null)
            {
                // Plant has been destroyed, remove from dictionary
                plantsByGridPosition.Remove(gridPosition);
                return false;
            }
            return true;
        }
        return false;
    }
    
    // Check if a tile is valid for planting
    public bool IsTileValidForPlanting(TileDefinition tileDef)
    {
        // If the tile is null, it's not valid
        if (tileDef == null)
            return false;
            
        // Check if this tile is in our invalid set
        return !invalidTilesSet.Contains(tileDef);
    }

    // Clean up destroyed plants from our dictionary (call periodically if needed)
    public void CleanupDestroyedPlants()
    {
        List<Vector3Int> keysToRemove = new List<Vector3Int>();
        
        foreach (var kvp in plantsByGridPosition)
        {
            if (kvp.Value == null)
            {
                keysToRemove.Add(kvp.Key);
            }
        }
        
        foreach (var key in keysToRemove)
        {
            plantsByGridPosition.Remove(key);
        }
        
        if (showDebugMessages && keysToRemove.Count > 0)
        {
            Debug.Log($"PlantPlacementManager: Removed {keysToRemove.Count} destroyed plant references.");
        }
    }

    // Try to plant a seed at the given grid position
    public bool TryPlantSeed(Vector3Int gridPosition, Vector3 worldPosition)
    {
        // Clean up any destroyed plants first
        CleanupDestroyedPlants();
        
        // Return false if position is already occupied
        if (IsPositionOccupied(gridPosition))
        {
            if (showDebugMessages)
            {
                Debug.Log($"Cannot plant: Position {gridPosition} already has a plant.");
            }
            return false;
        }
        
        // Get the tile at this position
        TileDefinition tileDef = null;
        if (tileInteractionManager != null)
        {
            tileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
            
            // Check if the tile is valid for planting
            if (!IsTileValidForPlanting(tileDef))
            {
                if (showDebugMessages)
                {
                    string tileName = tileDef != null ? tileDef.displayName : "Unknown";
                    Debug.Log($"Cannot plant: Tile {tileName} is not valid for planting.");
                }
                return false;
            }
        }

        // Get the current graph from the NodeEditorGridController
        if (nodeEditorGrid == null)
        {
            nodeEditorGrid = NodeEditorGridController.Instance;
            if (nodeEditorGrid == null)
            {
                Debug.LogError("Cannot plant: NodeEditorGridController not found.");
                return false;
            }
        }

        NodeGraph graphToSpawn = nodeEditorGrid.GetCurrentUIGraph();
        if (graphToSpawn == null || graphToSpawn.nodes == null || graphToSpawn.nodes.Count == 0)
        {
            if (showDebugMessages)
            {
                Debug.Log("Cannot plant: No nodes in UI graph to spawn.");
            }
            return false;
        }
        
        // Validate graph has a seed node
        bool seedFound = false;
        foreach (var node in graphToSpawn.nodes)
        {
            if (node != null && node.effects != null)
            {
                foreach (var effect in node.effects)
                {
                    if (effect != null && effect.effectType == NodeEffectType.SeedSpawn && effect.isPassive)
                    {
                        seedFound = true;
                        break;
                    }
                }
            }
            if (seedFound) break;
        }

        if (!seedFound)
        {
            if (showDebugMessages)
            {
                Debug.Log("Cannot plant: Node graph lacks a SeedSpawn effect.");
            }
            return false;
        }

        // Calculate randomized planting position based on our settings
        Vector3 plantingPosition = GetRandomizedPlantingPosition(worldPosition);
        
        // Spawn the plant at the randomized position
        GameObject plantObj = SpawnPlant(graphToSpawn, plantingPosition);
        if (plantObj != null)
        {
            // Track the plant position
            plantsByGridPosition[gridPosition] = plantObj;
            
            // Register the plant with the growth modifier manager
            if (growthModifierManager != null)
            {
                PlantGrowth plantGrowth = plantObj.GetComponent<PlantGrowth>();
                if (plantGrowth != null)
                {
                    growthModifierManager.RegisterPlantTile(plantGrowth, tileDef);
                    
                    if (showDebugMessages)
                    {
                        string tileDebugName = tileDef != null ? tileDef.displayName : "Unknown";
                        Debug.Log($"Plant registered with tile: {tileDebugName}");
                    }
                }
            }
            
            return true;
        }
        return false;
    }

    // Spawn a plant using the given node graph at the specified position
    private GameObject SpawnPlant(NodeGraph graphToSpawn, Vector3 position)
    {
        if (plantPrefab == null)
        {
            Debug.LogError("Cannot spawn plant: Plant prefab not assigned.");
            return null;
        }

        Debug.Log($"SpawnPlant called with position: {position}");
    
        // Instantiate the plant prefab
        GameObject plantObj = Instantiate(plantPrefab, position, Quaternion.identity, plantParent);
    
        // Verify the position was actually applied
        Debug.Log($"Plant instantiated at position: {plantObj.transform.position}");

        // Get the PlantGrowth component
        PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
        if (growthComponent != null)
        {
            // Create a deep copy of the node graph to prevent modifications affecting the original
            NodeGraph graphCopy = CloneNodeGraph(graphToSpawn);

            // Initialize the plant with the deep copy
            growthComponent.InitializeAndGrow(graphCopy);
            return plantObj;
        }
        else
        {
            Debug.LogError("Plant prefab missing PlantGrowth component! Destroying spawned object.");
            Destroy(plantObj);
            return null;
        }
    }

    // Create a deep copy of a NodeGraph
    private NodeGraph CloneNodeGraph(NodeGraph original)
    {
        NodeGraph copy = new NodeGraph();
        copy.nodes = new List<NodeData>();

        foreach (NodeData originalNode in original.nodes)
        {
            if (originalNode == null) continue;

            NodeData newNode = new NodeData
            {
                nodeId = originalNode.nodeId,
                nodeDisplayName = originalNode.nodeDisplayName,
                orderIndex = originalNode.orderIndex,
                canBeDeleted = originalNode.canBeDeleted
            };

            // Deep copy effects
            newNode.effects = CloneEffectsList(originalNode.effects);
            copy.nodes.Add(newNode);
        }

        return copy;
    }

    // Create a deep copy of a list of NodeEffectData
    private List<NodeEffectData> CloneEffectsList(List<NodeEffectData> originalList)
    {
        if (originalList == null) return new List<NodeEffectData>();

        List<NodeEffectData> newList = new List<NodeEffectData>();
        foreach (var originalEffect in originalList)
        {
            if (originalEffect == null) continue;

            NodeEffectData newEffect = new NodeEffectData
            {
                effectType = originalEffect.effectType,
                primaryValue = originalEffect.primaryValue,
                secondaryValue = originalEffect.secondaryValue,
                isPassive = originalEffect.isPassive,
                scentDefinitionReference = originalEffect.scentDefinitionReference
            };
            newList.Add(newEffect);
        }
        return newList;
    }
    
    // Generate a randomized position within the given radius, with simple increments
    // Generate a randomized position within the given radius
    private Vector3 GetRandomizedPlantingPosition(Vector3 centerPosition)
    {
        // First, let's add comprehensive debugging
        Debug.Log($"Starting position randomization from center: {centerPosition}, radius: {spawnRadius}, increment: {spawnRadiusIncrement}");
    
        // Critical check - if radius is too small, just return the center
        if (spawnRadius < 0.01f)
        {
            Debug.LogWarning("Spawn radius too small (<0.01), using center position");
            return centerPosition;
        }
    
        // Generate a random angle in radians (0 to 2π)
        float randomAngle = Random.Range(0f, 2f * Mathf.PI);
        Debug.Log($"Random angle: {randomAngle} radians ({randomAngle * Mathf.Rad2Deg} degrees)");
    
        // Convert angle to direction vector
        Vector2 direction = new Vector2(Mathf.Cos(randomAngle), Mathf.Sin(randomAngle));
        Debug.Log($"Direction vector: {direction}");
    
        // Get a random distance within spawn radius
        float randomDistance = Random.Range(0.05f, spawnRadius);
        Debug.Log($"Random distance: {randomDistance}");
    
        // Calculate actual offset
        float offsetX = direction.x * randomDistance;
        float offsetY = direction.y * randomDistance;
        Debug.Log($"Raw offset: ({offsetX}, {offsetY})");
    
        // Apply increment if needed
        if (spawnRadiusIncrement > 0.001f)
        {
            float originalX = offsetX;
            float originalY = offsetY;
        
            offsetX = Mathf.Round(offsetX / spawnRadiusIncrement) * spawnRadiusIncrement;
            offsetY = Mathf.Round(offsetY / spawnRadiusIncrement) * spawnRadiusIncrement;
        
            Debug.Log($"Snapped offset: ({offsetX}, {offsetY}) from ({originalX}, {originalY})");
        }
    
        // Create the final position
        Vector3 randomizedPosition = centerPosition + new Vector3(offsetX, offsetY, 0f);
        Debug.Log($"FINAL randomized position: {randomizedPosition}");
    
        return randomizedPosition;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlayerTileInteractor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[RequireComponent(typeof(ToolSwitcher))]
public class PlayerTileInteractor : MonoBehaviour
{
    private ToolSwitcher toolSwitcher;

    private void Awake()
    {
        toolSwitcher = GetComponent<ToolSwitcher>();
        if (toolSwitcher == null)
            Debug.LogError("PlayerTileInteractor: No ToolSwitcher found on this GameObject!");
    }

    private void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            if (TileInteractionManager.Instance == null)
            {
                Debug.LogError("No TileInteractionManager in scene!");
                return;
            }

            ToolDefinition currentTool = toolSwitcher.CurrentTool;
            if (currentTool == null)
            {
                Debug.Log("No tool is currently selected.");
                return;
            }

            // Attempt to apply the tool
            TileInteractionManager.Instance.ApplyToolAction(currentTool);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Tilemaps;

[CreateAssetMenu(fileName = "TileDefinition", menuName = "Tiles/Tile Definition")]
public class TileDefinition : ScriptableObject
{
    [Header("Basic Identification")]
    [Tooltip("Display name for this tile type (used in UI and debugging)")]
    public string displayName;    // e.g. "Grass", "Dirt", "Wet Dirt"
    
    [Header("Visual Properties")]
    [Tooltip("Optional tint color to apply to the RenderTilemap")]
    public Color tintColor = Color.white;
    
    [Header("Auto-Reversion (optional)")]
    [Tooltip("If > 0, after this many seconds, the tile reverts to 'revertToTile'.")]
    public float revertAfterSeconds = 0f;

    [Tooltip("If revertAfterSeconds > 0, tile reverts to this tile definition.")]
    public TileDefinition revertToTile;

    [Header("Overlay Option")]
    [Tooltip("If true, this tile will be placed on top without removing the tile underneath ")]
    public bool keepBottomTile = false;
    
    [Header("Special Properties")]
    [Tooltip("If true, this tile will use water reflection shader")]
    public bool isWaterTile = false;

#if UNITY_EDITOR
    // This method will be called from the custom editor
    public void UpdateColor()
    {
        // Find the TileInteractionManager in the scene using the non-deprecated method
        var manager = UnityEngine.Object.FindAnyObjectByType<TileInteractionManager>();
        if (manager == null) return;

        foreach (var mapping in manager.tileDefinitionMappings)
        {
            if (mapping.tileDef == this && mapping.tilemapModule != null)
            {
                Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                if (renderTilemapTransform != null)
                {
                    Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
                    if (renderTilemap != null)
                    {
                        renderTilemap.color = tintColor;
                        UnityEditor.EditorUtility.SetDirty(renderTilemap);
                    }
                }
            }
        }
    }
#endif
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Data/TileInteractionLibrary.cs
using System.Collections.Generic;
using UnityEngine;
using System; // Needed for [Serializable]

// --- NEW: Define the structure for a refill rule ---
[Serializable] // Make it visible in the Inspector
public class ToolRefillRule
{
    [Tooltip("The tool that can be refilled.")]
    public ToolDefinition toolToRefill;

    [Tooltip("The tile that must be interacted with to trigger the refill.")]
    public TileDefinition refillSourceTile;
}
// ----------------------------------------------------

[CreateAssetMenu(fileName = "TileInteractionLibrary", menuName = "Tiles/Tile Interaction Library")]
public class TileInteractionLibrary : ScriptableObject
{
    [Header("Standard Tile Transformations")]
    [Tooltip("List of rules: (Tool, fromTile) => toTile.")]
    public List<TileInteractionRule> rules; // Existing transformation rules

    [Header("Tool Refill Rules")] // <<< NEW HEADER
    [Tooltip("List of rules defining how tools are refilled.")]
    public List<ToolRefillRule> refillRules; // <<< NEW LIST FOR REFILLS
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Data/TileInteractionManager.cs
using System.Collections;
using UnityEngine;
using UnityEngine.Tilemaps;
using skner.DualGrid; // Assuming this is the correct namespace for your DualGrid package
using System.Collections.Generic;
using System.Linq;
using TMPro;
#if UNITY_EDITOR
using UnityEditor; // Correct placement for editor-specific using directive
#endif

public class TileInteractionManager : MonoBehaviour
{
    public static TileInteractionManager Instance { get; private set; }
    [System.Serializable] public class TileDefinitionMapping { public TileDefinition tileDef; public DualGridTilemapModule tilemapModule; }
    [Header("Tile Definition Mappings")] public List<TileDefinitionMapping> tileDefinitionMappings;
    [Header("Interaction Library")] public TileInteractionLibrary interactionLibrary; // Now contains both rule types
    [Header("Grid & Scene References")] public Grid interactionGrid; public Camera mainCamera; public Transform player; public float hoverRadius = 3f; public GameObject hoverHighlightObject;
    [Header("Tilemap Rendering Settings")] public int baseSortingOrder = 0;
    [Header("Debug / UI")] public bool debugLogs = false; public TextMeshProUGUI hoveredTileText; public TextMeshProUGUI currentToolText;
    private Dictionary<TileDefinition, DualGridTilemapModule> moduleByDefinition;
    private Dictionary<DualGridTilemapModule, TileDefinition> definitionByModule;
    private Vector3Int? currentlyHoveredCell = null;
    private TileDefinition hoveredTileDef = null;
    private struct TimedTileState { public TileDefinition tileDef; public float timeLeft; }
    private Dictionary<Vector3Int, TimedTileState> timedCells = new Dictionary<Vector3Int, TimedTileState>();
    private ToolSwitcher playerToolSwitcher;

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Initialize dictionaries here
        moduleByDefinition = new Dictionary<TileDefinition, DualGridTilemapModule>();
        definitionByModule = new Dictionary<DualGridTilemapModule, TileDefinition>();

        SetupTilemaps(); // Setup tilemaps after dictionaries are created
    }

    void Start()
    {
        // Ensure dictionaries are populated if something went wrong in Awake or for runtime recompiles
        if (moduleByDefinition == null || moduleByDefinition.Count == 0 || definitionByModule == null || definitionByModule.Count == 0)
        {
            Debug.LogWarning("[TileInteractionManager Start] Dictionaries were empty or null, re-running SetupTilemaps.");
            SetupTilemaps();
        }

        // Find the Player's ToolSwitcher
        if (player != null)
        {
            // Use GetComponentInChildren to find it even if it's nested
            playerToolSwitcher = player.GetComponentInChildren<ToolSwitcher>(true); // Include inactive just in case
            if (playerToolSwitcher == null)
            {
                Debug.LogError("[TileInteractionManager Start] Could not find ToolSwitcher component on Player or its children!", player);
            }
            else
            {
                 if(debugLogs) Debug.Log("[TileInteractionManager Start] Found Player ToolSwitcher.", playerToolSwitcher.gameObject);
            }
        }
        else
        {
            Debug.LogError("[TileInteractionManager Start] Player Transform reference is not assigned in the Inspector!", this);
        }
    }

    private void SetupTilemaps()
    {
        // Clear dictionaries before rebuilding
        moduleByDefinition.Clear();
        definitionByModule.Clear();

        if (tileDefinitionMappings == null)
        {
            Debug.LogError("[TileInteractionManager SetupTilemaps] Tile Definition Mappings list is null!", this);
            return;
        }

        for (int i = 0; i < tileDefinitionMappings.Count; i++)
        {
            var mapping = tileDefinitionMappings[i];
            if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null)
            {
                 Debug.LogWarning($"[TileInteractionManager SetupTilemaps] Skipping null or incomplete mapping at index {i}.");
                 continue;
            }

            // Add to dictionaries
            if (!moduleByDefinition.ContainsKey(mapping.tileDef))
            {
                moduleByDefinition[mapping.tileDef] = mapping.tilemapModule;
                // *** CORRECTED ASSIGNMENT HERE ***
                definitionByModule[mapping.tilemapModule] = mapping.tileDef;

                // Find the RenderTilemap child
                Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                if (renderTilemapTransform != null)
                {
                    // Set Sorting Order
                    TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
                    if (renderer != null)
                    {
                        renderer.sortingOrder = baseSortingOrder - i;
                        if (debugLogs) Debug.Log($"Setting sorting order for {mapping.tileDef.displayName} to {renderer.sortingOrder}");
                    }
                    else { Debug.LogWarning($"RenderTilemap for {mapping.tileDef.displayName} missing TilemapRenderer.", renderTilemapTransform); }

                    // Set Initial Color
                    Tilemap tilemap = renderTilemapTransform.GetComponent<Tilemap>();
                    if (tilemap != null)
                    {
                        tilemap.color = mapping.tileDef.tintColor;
                        if (debugLogs) Debug.Log($"Setting color for {mapping.tileDef.displayName} to {tilemap.color}");
                    }
                     else { Debug.LogWarning($"RenderTilemap for {mapping.tileDef.displayName} missing Tilemap component.", renderTilemapTransform); }
                }
                 else { Debug.LogWarning($"Could not find 'RenderTilemap' child for module of {mapping.tileDef.displayName}.", mapping.tilemapModule.gameObject); }

                if (debugLogs) Debug.Log($"[Mapping] Added: {mapping.tileDef.displayName} => {mapping.tilemapModule.gameObject.name}");
            }
            else
            {
                Debug.LogWarning($"[TileInteractionManager SetupTilemaps] Duplicate TileDefinition '{mapping.tileDef.displayName}' found in mappings. Ignoring subsequent entries.", mapping.tileDef);
            }
        }
         if (debugLogs) Debug.Log($"[TileInteractionManager SetupTilemaps] Setup complete. {moduleByDefinition.Count} definitions mapped.");
    }

    // Method for editor button: Update Sorting Order
    public void UpdateSortingOrder()
    {
        if (tileDefinitionMappings == null) return;
        for (int i = 0; i < tileDefinitionMappings.Count; i++)
        {
            var mapping = tileDefinitionMappings[i];
            if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;

            Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
            if (renderTilemapTransform != null)
            {
                TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
                if (renderer != null)
                {
                    renderer.sortingOrder = baseSortingOrder - i;
#if UNITY_EDITOR
                    if (!Application.isPlaying) EditorUtility.SetDirty(renderer);
#endif
                    if (debugLogs) Debug.Log($"Updated sorting order for {mapping.tileDef.displayName} to {renderer.sortingOrder}");
                }
            }
        }
    }

    // Method for editor button: Update All Colors
    public void UpdateAllColors()
    {
        if (tileDefinitionMappings == null) return;
        foreach (var mapping in tileDefinitionMappings)
        {
            if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;

            Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
            if (renderTilemapTransform != null)
            {
                Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
                if (renderTilemap != null)
                {
                    renderTilemap.color = mapping.tileDef.tintColor;
#if UNITY_EDITOR
                    if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
                    if (debugLogs) Debug.Log($"Updated color for {mapping.tileDef.displayName} to {renderTilemap.color}");
                }
            }
        }
    }

    void Update()
    {
        HandleTileHover();
        UpdateReversion();
        UpdateDebugUI(); // Update UI every frame
    }

    private void UpdateReversion()
    {
        if (timedCells.Count == 0) return;

        List<Vector3Int> cellsToRevert = null; // Initialize null

        // Iterate over a temporary copy to allow modification
        foreach (var kvp in timedCells.ToList())
        {
            Vector3Int cellPos = kvp.Key;
            TimedTileState state = kvp.Value;

            // Check if the state's tile definition is still valid (safety check)
            if (state.tileDef == null) {
                timedCells.Remove(cellPos); // Clean up invalid entry
                continue;
            }

            state.timeLeft -= Time.deltaTime;

            if (state.timeLeft <= 0f)
            {
                if (cellsToRevert == null) cellsToRevert = new List<Vector3Int>();
                cellsToRevert.Add(cellPos);
            }
            else
            {
                timedCells[cellPos] = state; // Update time left
            }
        }

        if (cellsToRevert != null)
        {
            foreach (var cellPos in cellsToRevert)
            {
                // Check if the entry still exists before processing
                if (timedCells.TryGetValue(cellPos, out TimedTileState stateToRevert))
                {
                    timedCells.Remove(cellPos); // Remove before acting

                    // Always remove the reverting tile itself
                    RemoveTile(stateToRevert.tileDef, cellPos);

                    // Place the revert-to tile *if specified*
                    if (stateToRevert.tileDef.revertToTile != null)
                    {
                        if (debugLogs) Debug.Log($"Reverting tile at {cellPos} from {stateToRevert.tileDef.displayName} to {stateToRevert.tileDef.revertToTile.displayName}");
                        PlaceTile(stateToRevert.tileDef.revertToTile, cellPos);
                    } else {
                        if (debugLogs) Debug.Log($"Tile {stateToRevert.tileDef.displayName} at {cellPos} expired and removed (no revert target).");
                    }
                }
            }
        }
    }

    private void RegisterTimedTile(Vector3Int cellPos, TileDefinition tileDef)
    {
        // Only register if revert time is positive
        // RevertToTile check is now handled during reversion itself
        if (tileDef != null && tileDef.revertAfterSeconds > 0f)
        {
            TimedTileState newState = new TimedTileState
            {
                tileDef = tileDef,
                timeLeft = tileDef.revertAfterSeconds
            };
            timedCells[cellPos] = newState;
            if (debugLogs) Debug.Log($"Registered timed reversion for {tileDef.displayName} at {cellPos} ({tileDef.revertAfterSeconds}s).");
        }
         // Clear any existing timer if revertAfterSeconds is 0 or less
         else if (timedCells.ContainsKey(cellPos))
         {
              timedCells.Remove(cellPos);
              if (debugLogs) Debug.Log($"Cleared timed reversion for {cellPos} because revert time is not positive.");
         }
    }

    public void PlaceTile(TileDefinition tileDef, Vector3Int cellPos)
    {
        if (tileDef == null) { Debug.LogWarning($"PlaceTile: Attempted to place a NULL TileDefinition at {cellPos}."); return; }

        if (moduleByDefinition == null || !moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) || module == null)
        {
            Debug.LogWarning($"PlaceTile: No mapped module found for TileDefinition '{tileDef.displayName}'. Cannot place tile.");
            return;
        }

        // Handle removing existing tiles based on the new tile's 'keepBottomTile' flag
        if (!tileDef.keepBottomTile)
        {
            TileDefinition existingDef = FindWhichTileDefinitionAt(cellPos);
            if (existingDef != null && existingDef != tileDef)
            {
                 if (debugLogs) Debug.Log($"Placing '{tileDef.displayName}' (KeepBottom=false), removing existing '{existingDef.displayName}' at {cellPos}.");
                 RemoveTile(existingDef, cellPos);
            }
        } else {
             if (debugLogs) Debug.Log($"Placing '{tileDef.displayName}' (KeepBottom=true) over whatever is at {cellPos}.");
        }

        // Set the tile on the correct module's DataTilemap
        if (module.DataTilemap != null)
        {
            // Using a basic Tile asset is fine for the data layer
            TileBase dataTile = ScriptableObject.CreateInstance<Tile>();
            module.DataTilemap.SetTile(cellPos, dataTile);
        } else { Debug.LogWarning($"Module for '{tileDef.displayName}' has no DataTilemap assigned.", module.gameObject); }

        // Update RenderTilemap color immediately
        Transform renderTilemapTransform = module.transform.Find("RenderTilemap");
        if (renderTilemapTransform != null)
        {
            Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
            if (renderTilemap != null)
            {
                renderTilemap.color = tileDef.tintColor;
#if UNITY_EDITOR
                if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
            }
        }

        // Register for timed reversion if applicable
        RegisterTimedTile(cellPos, tileDef);
    }

    public void RemoveTile(TileDefinition tileDef, Vector3Int cellPos)
    {
        if (tileDef == null) { Debug.LogWarning($"RemoveTile: Attempted to remove a NULL TileDefinition at {cellPos}."); return; }

        if (moduleByDefinition == null || !moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) || module == null)
        {
            if (debugLogs) Debug.LogWarning($"RemoveTile: No mapped module found for TileDefinition '{tileDef.displayName}'. Cannot remove tile.");
            return;
        }

        // Remove from the module's DataTilemap
        if (module.DataTilemap != null)
        {
             // Check if the tile actually exists before removing
             if (module.DataTilemap.HasTile(cellPos)) {
                 module.DataTilemap.SetTile(cellPos, null);
                 if (debugLogs) Debug.Log($"Removed '{tileDef.displayName}' from DataTilemap at {cellPos}.");
             } else {
                 if (debugLogs) Debug.Log($"RemoveTile: Tile '{tileDef.displayName}' not found on DataTilemap at {cellPos}, skipping removal.");
             }
        } else { Debug.LogWarning($"Module for '{tileDef.displayName}' has no DataTilemap assigned.", module.gameObject); }

        // Also remove from timed reversion tracking if it matches
        if (timedCells.TryGetValue(cellPos, out TimedTileState timedState) && timedState.tileDef == tileDef)
        {
            timedCells.Remove(cellPos);
            if (debugLogs) Debug.Log($"Cleared timed reversion for {tileDef.displayName} at {cellPos} during removal.");
        }
    }

    public TileDefinition FindWhichTileDefinitionAt(Vector3Int cellPos)
    {
        if (definitionByModule == null || tileDefinitionMappings == null) {
             Debug.LogError("[FindWhichTileDefinitionAt] Dictionaries not initialized!");
             return null;
        }

        TileDefinition foundDef = null;

        // Prioritize checking overlay tiles first (those with keepBottomTile = true)
        // Iterate mappings list directly to check the flag easily
        foreach (var mapping in tileDefinitionMappings)
        {
             if (mapping?.tileDef != null && mapping.tilemapModule?.DataTilemap != null && mapping.tileDef.keepBottomTile)
             {
                 if (mapping.tilemapModule.DataTilemap.HasTile(cellPos))
                 {
                     foundDef = mapping.tileDef;
                     break; // Found the top overlay tile
                 }
             }
        }

        // If no overlay found, check non-overlay tiles
        if (foundDef == null)
        {
             // Use the definitionByModule dictionary which maps modules back to definitions
             foreach (var kvp in definitionByModule)
             {
                 DualGridTilemapModule module = kvp.Key;
                 TileDefinition def = kvp.Value;

                 // Ensure it's not an overlay tile (we already checked those) and the module/tilemap are valid
                 if (module?.DataTilemap != null && def != null && !def.keepBottomTile)
                 {
                     if (module.DataTilemap.HasTile(cellPos))
                     {
                         foundDef = def;
                         break; // Found the base tile
                     }
                 }
             }
        }

        // if (debugLogs && foundDef != null) Debug.Log($"[FindWhichTileDefinitionAt] Found '{foundDef.displayName}' at {cellPos}");
        // else if (debugLogs && foundDef == null) Debug.Log($"[FindWhichTileDefinitionAt] Found no tile at {cellPos}");

        return foundDef;
    }

    private void HandleTileHover()
    {
        if (mainCamera == null || player == null) return;

        Vector3 mouseWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
        mouseWorldPos.z = 0f; // Ensure Z is 0 for 2D comparison
        Vector3Int cellPos = WorldToCell(mouseWorldPos);

        // Check distance only if player reference exists
        float distance = (player != null) ? Vector2.Distance(player.position, CellCenterWorld(cellPos)) : float.MaxValue;

        TileDefinition foundTile = FindWhichTileDefinitionAt(cellPos);

        // Only update hover state if within radius
        if (distance <= hoverRadius)
        {
            bool changedCell = !currentlyHoveredCell.HasValue || currentlyHoveredCell.Value != cellPos;
            currentlyHoveredCell = cellPos;
            hoveredTileDef = foundTile;

            if (hoverHighlightObject != null)
            {
                hoverHighlightObject.SetActive(true);
                hoverHighlightObject.transform.position = CellCenterWorld(cellPos);
            }
            //if (debugLogs && changedCell) Debug.Log($"[Hover Enter] Cell={cellPos}, Tile={foundTile?.displayName ?? "None"}, Dist={distance:F2}");
        }
        else
        {
            bool changedCell = currentlyHoveredCell.HasValue;
            currentlyHoveredCell = null;
            hoveredTileDef = null;
            if (hoverHighlightObject != null)
            {
                hoverHighlightObject.SetActive(false);
            }
            //if (debugLogs && changedCell) Debug.Log($"[Hover Exit] Cell outside radius ({distance:F2} > {hoverRadius})");
        }
    }

    private void UpdateDebugUI()
    {
        // Hovered Tile Text
        if (hoveredTileText != null)
        {
            string tileName = hoveredTileDef != null ? hoveredTileDef.displayName : "None";
            hoveredTileText.text = $"Hover: {tileName}";
        }

        // Current Tool Text (includes uses)
        if (currentToolText != null)
        {
            if (playerToolSwitcher != null && playerToolSwitcher.CurrentTool != null)
            {
                ToolDefinition tool = playerToolSwitcher.CurrentTool;
                string toolString = $"Tool: {tool.displayName}";
                if (tool.limitedUses)
                {
                    int uses = playerToolSwitcher.CurrentRemainingUses;
                    toolString += $" ({uses})"; // Show remaining uses
                }
                currentToolText.text = toolString;
            }
            else
            {
                currentToolText.text = "Tool: None";
            }
        }
    }

    public Vector3Int WorldToCell(Vector3 worldPos)
    {
        if (interactionGrid != null) return interactionGrid.WorldToCell(worldPos);

        // Fallback: Try to get grid from the first valid mapping
        if (tileDefinitionMappings != null && tileDefinitionMappings.Count > 0) {
             foreach(var mapping in tileDefinitionMappings) {
                 if (mapping?.tilemapModule?.DataTilemap?.layoutGrid != null) {
                     return mapping.tilemapModule.DataTilemap.layoutGrid.WorldToCell(worldPos);
                 }
             }
        }

        Debug.LogWarning("[WorldToCell] No valid interactionGrid or mapped Tilemap found to determine cell position.");
        return Vector3Int.zero;
    }

    private Vector3 CellCenterWorld(Vector3Int cellPos)
    {
         if (interactionGrid != null) return interactionGrid.GetCellCenterWorld(cellPos);

         // Fallback: Try to get grid from the first valid mapping
         if (tileDefinitionMappings != null && tileDefinitionMappings.Count > 0) {
             foreach(var mapping in tileDefinitionMappings) {
                 if (mapping?.tilemapModule?.DataTilemap?.layoutGrid != null) {
                     return mapping.tilemapModule.DataTilemap.layoutGrid.GetCellCenterWorld(cellPos);
                 }
             }
        }

        Debug.LogWarning("[CellCenterWorld] No valid interactionGrid or mapped Tilemap found to determine cell center.");
        return Vector3.zero; // Or grid.CellToWorld(cellPos) + grid.cellSize * 0.5f if grid guaranteed?
    }

    private void HandleSeedPlanting(Vector3Int cellPosition)
    {
        PlantPlacementManager plantManager = PlantPlacementManager.Instance;
        if (plantManager == null) { Debug.LogError("Cannot plant: PlantPlacementManager not found!"); return; }

        TileDefinition tileDef = FindWhichTileDefinitionAt(cellPosition);
        if (!plantManager.IsTileValidForPlanting(tileDef))
        {
            if (debugLogs) Debug.Log($"Cannot plant on {tileDef?.displayName ?? "Unknown"} - invalid tile.");
            // Maybe add player feedback here (sound/visual)
            return;
        }

        GardenerController gardener = player?.GetComponent<GardenerController>();
        if (gardener == null) { Debug.LogError("Cannot plant: GardenerController not found on player!"); return; }

        Vector3 worldPosition = CellCenterWorld(cellPosition); // Plant near cell center

        gardener.Plant(); // Trigger animation
        StartCoroutine(PlantAfterAnimation(gardener, plantManager, cellPosition, worldPosition));
    }

    private IEnumerator PlantAfterAnimation(GardenerController gardener, PlantPlacementManager plantManager, Vector3Int cellPosition, Vector3 worldPosition)
    {
        // Ensure gardener and duration are valid
        float waitTime = (gardener != null) ? gardener.plantingDuration : 0.1f;
        yield return new WaitForSeconds(waitTime);

        if (plantManager != null) // Check again in case it was destroyed
        {
            bool planted = plantManager.TryPlantSeed(cellPosition, worldPosition);
            if (debugLogs) Debug.Log(planted ? $"Planted seed successfully at {cellPosition}" : $"Failed to plant seed at {cellPosition}");
        }
    }

    // --- ApplyToolAction is MODIFIED ---
    public void ApplyToolAction(ToolDefinition toolDef)
    {
        // --- Initial Checks (unchanged) ---
        if (toolDef == null) { Debug.LogWarning("ApplyToolAction called with a NULL toolDef."); return; }
        if (!currentlyHoveredCell.HasValue) return;
        if (hoveredTileDef == null) { if (debugLogs) Debug.Log("ApplyToolAction: No recognized tile at hovered cell."); return; }
        if (playerToolSwitcher == null) { Debug.LogError("ApplyToolAction: ToolSwitcher reference is missing! Cannot apply tool."); return; }
        float distance = Vector2.Distance(player.position, CellCenterWorld(currentlyHoveredCell.Value));
        if (distance > hoverRadius) { if (debugLogs) Debug.Log($"ApplyToolAction: Cell too far ({distance:F2} > {hoverRadius})."); return; }
        if (playerToolSwitcher.CurrentTool != toolDef) { Debug.LogWarning($"ApplyToolAction: Tool passed ({toolDef.displayName}) does not match current tool ({playerToolSwitcher.CurrentTool?.displayName}). Aborting."); return; }
        // ---------------------------------

        // --- Consume Use Attempt ---
        // We *attempt* to consume first. If it fails (out of uses), we stop.
        // If it succeeds, we proceed to check for refill or transformation.
        bool consumed = playerToolSwitcher.TryConsumeUse();
        // --- Note: We don't stop here even if consumed is false, because a refill action might still be possible even if uses are 0 (e.g. refill an empty can) ---
        // --- UPDATE: Actually, let's only proceed if consumed is TRUE OR if a refill rule applies ---

        if (debugLogs) Debug.Log($"[ApplyToolAction] Using Tool='{toolDef.toolType}', On Tile='{hoveredTileDef.displayName}', At Cell={currentlyHoveredCell.Value}. Consumed Use: {consumed}");


        // --- Check for REFILL Action FIRST ---
        bool wasRefillAction = false;
        if (interactionLibrary != null && interactionLibrary.refillRules != null)
        {
            foreach (var refillRule in interactionLibrary.refillRules)
            {
                // Check if rule matches the current tool and hovered tile
                if (refillRule != null && refillRule.toolToRefill == toolDef && refillRule.refillSourceTile == hoveredTileDef)
                {
                    // Match found! Attempt to refill.
                    if (debugLogs) Debug.Log($"Refill rule matched: Tool '{toolDef.displayName}' on Tile '{hoveredTileDef.displayName}'.");
                    playerToolSwitcher.RefillCurrentTool(); // Call the refill method
                    wasRefillAction = true;
                    break; // Stop checking refill rules once one matches
                }
            }
        }
        // If it was a refill action, we are done. Don't proceed to tile transformation.
        if (wasRefillAction)
        {
            // Note: The use was already consumed before the refill check.
            // If you want to *not* consume a use when refilling, you'd need
            // to add a RefundUse() method to ToolSwitcher and call it here,
            // or move the TryConsumeUse() call *after* the refill check.
            // Current logic: Click on water consumes 1 use, then refills to max.
            return;
        }
        // --------------------------------------


        // --- Proceed ONLY if use was successfully consumed AND it wasn't a refill ---
        if (!consumed)
        {
            if (debugLogs) Debug.Log($"ApplyToolAction: Tool '{toolDef.displayName}' could not be used (out of uses) and no refill rule applied.");
            return; // Stop if out of uses and not refilling
        }


        // --- Handle Standard Tile Transformation ---

        // Special case: SeedPouch (check again after use consumption)
        if (toolDef.toolType == ToolType.SeedPouch)
        {
            HandleSeedPlanting(currentlyHoveredCell.Value);
            return; // Seed planting handles its own logic
        }

        // Find standard matching rule
        if (interactionLibrary == null || interactionLibrary.rules == null) { Debug.LogWarning("Interaction Library or its standard rules list is null!"); return; }
        TileInteractionRule rule = interactionLibrary.rules.FirstOrDefault(r => r != null && r.tool == toolDef && r.fromTile == hoveredTileDef);

        if (rule == null)
        {
            if (debugLogs) Debug.Log($"No standard interaction rule found for tool '{toolDef.toolType}' on tile '{hoveredTileDef.displayName}'.");
            // Since a use was consumed but no action taken, maybe refund here?
            // playerToolSwitcher.RefundUse(); // Requires implementation
            return;
        }

        // Apply the standard rule
        if (rule.toTile != null) // If there's a tile to change TO
        {
            if (debugLogs) Debug.Log($"Applying standard rule: '{hoveredTileDef.displayName}' -> '{rule.toTile.displayName}'");
            if (!rule.toTile.keepBottomTile)
            {
                RemoveTile(hoveredTileDef, currentlyHoveredCell.Value);
            }
            PlaceTile(rule.toTile, currentlyHoveredCell.Value);
        }
        else // If the rule specifies removing the tile (toTile is null)
        {
            if (debugLogs) Debug.Log($"Applying standard rule: Remove '{hoveredTileDef.displayName}'");
            RemoveTile(hoveredTileDef, currentlyHoveredCell.Value);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionRule.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

[Serializable]
public class TileInteractionRule
{
    [Header("Tool Condition")]
    [Tooltip("Which tool triggers this rule.")]
    public ToolDefinition tool;

    [Header("Tile Transformation")]
    [Tooltip("Which tile must be present to apply the rule.")]
    public TileDefinition fromTile;
    [Tooltip("Which tile to transform into.")]
    public TileDefinition toTile;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Editor\TileDefinitionEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(TileDefinition))]
public class TileDefinitionEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
        
        TileDefinition tileDefinition = (TileDefinition)target;
        
        EditorGUILayout.Space();
        if (GUILayout.Button("UPDATE COLOR IN SCENE", GUILayout.Height(30)))
        {
            tileDefinition.UpdateColor();
        }
    }
}
#endif


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Editor\TileInteractionManagerEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(TileInteractionManager))]
public class TileInteractionManagerEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
        
        TileInteractionManager manager = (TileInteractionManager)target;
        
        EditorGUILayout.Space();
        EditorGUILayout.BeginHorizontal();
        
        if (GUILayout.Button("UPDATE SORTING ORDER", GUILayout.Height(30)))
        {
            manager.UpdateSortingOrder();
            EditorUtility.SetDirty(manager);
        }
        
        if (GUILayout.Button("UPDATE ALL COLORS", GUILayout.Height(30)))
        {
            manager.UpdateAllColors();
            EditorUtility.SetDirty(manager);
        }
        
        EditorGUILayout.EndHorizontal();
        
        EditorGUILayout.HelpBox("Order: First item in list gets highest sorting order value (" + 
                                manager.baseSortingOrder + "). Each subsequent item is " + 
                                (manager.baseSortingOrder - 1) + ", " + 
                                (manager.baseSortingOrder - 2) + ", etc.", MessageType.Info);
    }
}
#endif


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Tools/ToolDefinition.cs
using UnityEngine;

[CreateAssetMenu(fileName = "ToolDefinition", menuName = "Tiles/Tool Definition")]
public class ToolDefinition : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Which tool type this represents (e.g. Hoe, WateringCan).")]
    public ToolType toolType;
    [Tooltip("Human-readable name (for debugging/UI).")]
    public string displayName;

    [Header("Visuals")]
    [Tooltip("Icon sprite for the tool.")]
    public Sprite icon;
    [Tooltip("Tint color to apply to the icon sprite.")]
    public Color iconTint = Color.white;

    [Header("Usage Limits")] // <<< NEW HEADER
    [Tooltip("If true, this tool has a limited number of uses.")]
    public bool limitedUses = false; // <<< NEW FIELD (Defaults to unlimited)
    [Tooltip("The number of uses the tool starts with (only relevant if Limited Uses is true).")]
    [Min(0)] // Ensure it's not negative
    public int initialUses = 10; // <<< NEW FIELD
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolSwitcher.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Tools/ToolSwitcher.cs
using UnityEngine;
using System;

public class ToolSwitcher : MonoBehaviour
{
    [Tooltip("All available tool definitions, e.g. Hoe, WateringCan, etc.")]
    public ToolDefinition[] toolDefinitions;

    private int currentIndex = 0;

    // --- Public Properties ---
    public ToolDefinition CurrentTool { get; private set; } = null;
    /// <summary>
    /// Gets the remaining uses for the current tool. Returns -1 if the tool has unlimited uses.
    /// </summary>
    public int CurrentRemainingUses { get; private set; } = -1; // <<< NEW: Track remaining uses (-1 for unlimited)

    // --- Events ---
    public event Action<ToolDefinition> OnToolChanged;
    /// <summary>
    /// Event fired when the remaining uses of the current tool changes. Passes the new remaining count (-1 for unlimited).
    /// </summary>
    public event Action<int> OnUsesChanged; // <<< NEW EVENT for UI updates

    private void Awake()
    {
        // Debug logs from previous step can be kept or removed
        // Debug.Log("[ToolSwitcher Awake] Initializing...");
    }

    private void Start()
    {
        InitializeToolState(true); // Initialize and fire events
    }

    private void Update()
    {
        if (toolDefinitions == null || toolDefinitions.Length == 0) return;

        bool toolChanged = false;
        int previousIndex = currentIndex;

        if (Input.GetKeyDown(KeyCode.Q))
        {
            currentIndex--;
            if (currentIndex < 0)
                currentIndex = toolDefinitions.Length - 1;
            toolChanged = true;
        }
        else if (Input.GetKeyDown(KeyCode.E))
        {
            currentIndex++;
            if (currentIndex >= toolDefinitions.Length)
                currentIndex = 0;
            toolChanged = true;
        }

        if (toolChanged)
        {
            // Ensure the new index points to a valid definition before updating state
            if (currentIndex >= 0 && currentIndex < toolDefinitions.Length && toolDefinitions[currentIndex] != null)
            {
                InitializeToolState(false); // Update state for the new tool and fire events
            }
            else
            {
                 Debug.LogError($"[ToolSwitcher Update] Attempted to switch to an invalid/NULL tool definition at index {currentIndex}. Reverting.");
                 currentIndex = previousIndex; // Revert to the last valid index
                 // No state change, no events needed here
            }
        }
    }

    /// <summary>
    /// Sets the CurrentTool and resets CurrentRemainingUses based on the tool's definition.
    /// Optionally fires OnToolChanged and OnUsesChanged events.
    /// </summary>
    /// <param name="isInitialSetup">If true, forces event firing even if tool doesn't technically change.</param>
    private void InitializeToolState(bool isInitialSetup)
    {
        ToolDefinition previousTool = CurrentTool; // Store previous tool for change check
        int previousUses = CurrentRemainingUses; // Store previous uses

        if (toolDefinitions == null || toolDefinitions.Length == 0 || currentIndex < 0 || currentIndex >= toolDefinitions.Length || toolDefinitions[currentIndex] == null)
        {
            // Handle cases with no tools or invalid selection
            CurrentTool = null;
            CurrentRemainingUses = -1; // No tool = unlimited uses conceptually
        }
        else
        {
            // Valid tool selected
            CurrentTool = toolDefinitions[currentIndex];
            if (CurrentTool.limitedUses)
            {
                CurrentRemainingUses = CurrentTool.initialUses;
            }
            else
            {
                CurrentRemainingUses = -1; // Mark as unlimited
            }
        }
        
        

        LogToolChange("[ToolSwitcher InitializeToolState]"); // Log the state after update

        // Fire events if state actually changed or if it's the initial setup
        bool toolActuallyChanged = previousTool != CurrentTool;
        bool usesActuallyChanged = previousUses != CurrentRemainingUses;

        if (isInitialSetup || toolActuallyChanged)
        {
             Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnToolChanged for tool: {CurrentTool?.displayName ?? "NULL"}");
             OnToolChanged?.Invoke(CurrentTool);
        }
        if (isInitialSetup || usesActuallyChanged || toolActuallyChanged) // Fire uses changed if tool changed too (to reset UI)
        {
             Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnUsesChanged with value: {CurrentRemainingUses}");
             OnUsesChanged?.Invoke(CurrentRemainingUses);
        }
    }


    /// <summary>
    /// Refills the current tool to its maximum capacity if it's a limited-use tool.
    /// </summary>
    public void RefillCurrentTool() // <<< NEW METHOD
    {
        if (CurrentTool == null)
        {
            Debug.LogWarning("[ToolSwitcher RefillCurrentTool] Cannot refill: No tool selected.");
            return;
        }

        if (!CurrentTool.limitedUses)
        {
            Debug.LogWarning($"[ToolSwitcher RefillCurrentTool] Cannot refill tool '{CurrentTool.displayName}': It has unlimited uses.");
            return;
        }

        // Check if already full to avoid unnecessary event firing
        if (CurrentRemainingUses == CurrentTool.initialUses)
        {
            if(Debug.isDebugBuild) Debug.Log($"[ToolSwitcher RefillCurrentTool] Tool '{CurrentTool.displayName}' is already full ({CurrentRemainingUses} uses).");
            return;
        }

        // Set uses back to initial amount
        int previousUses = CurrentRemainingUses;
        CurrentRemainingUses = CurrentTool.initialUses;

        Debug.Log($"[ToolSwitcher RefillCurrentTool] Refilled tool '{CurrentTool.displayName}' to {CurrentRemainingUses} uses (was {previousUses}).");

        // Notify listeners that uses changed
        OnUsesChanged?.Invoke(CurrentRemainingUses);
    }
    
    /// <summary>
    /// Attempts to consume one use of the current tool.
    /// </summary>
    /// <returns>True if a use was consumed or if the tool has unlimited uses. False if the tool has limited uses and is out of uses.</returns>
    public bool TryConsumeUse()
    {
        if (CurrentTool == null)
        {
            Debug.LogWarning("[ToolSwitcher TryConsumeUse] Cannot consume use: No tool selected.");
            return false; // Cannot use a non-existent tool
        }

        if (!CurrentTool.limitedUses || CurrentRemainingUses == -1)
        {
            // Tool is unlimited, consumption always succeeds
            // Debug.Log($"[ToolSwitcher TryConsumeUse] Tool '{CurrentTool.displayName}' has unlimited uses."); // Optional log
            return true;
        }

        // Tool has limited uses
        if (CurrentRemainingUses > 0)
        {
            CurrentRemainingUses--;
            Debug.Log($"[ToolSwitcher TryConsumeUse] Consumed use for '{CurrentTool.displayName}'. Remaining: {CurrentRemainingUses}");
            OnUsesChanged?.Invoke(CurrentRemainingUses); // Notify listeners
            return true;
        }
        else
        {
            // Out of uses
            Debug.Log($"[ToolSwitcher TryConsumeUse] Tool '{CurrentTool.displayName}' is out of uses (0 remaining).");
            // Optionally play an 'empty click' sound here
            return false;
        }
    }

    // Added prefix parameter for context
    private void LogToolChange(string prefix = "[ToolSwitcher]")
    {
        string toolName = (CurrentTool != null && !string.IsNullOrEmpty(CurrentTool.displayName))
                          ? CurrentTool.displayName
                          : "(none)";
        string usesSuffix = "";
        if (CurrentTool != null && CurrentTool.limitedUses && CurrentRemainingUses >= 0)
        {
            usesSuffix = $" ({CurrentRemainingUses}/{CurrentTool.initialUses})";
        }
        else if (CurrentTool != null && !CurrentTool.limitedUses)
        {
            // usesSuffix = " (Unlimited)"; // Optional: Indicate unlimited
        }

        Debug.Log($"{prefix} Switched tool to: {toolName}{usesSuffix} (Index: {currentIndex})");
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolType.cs
////////////////////////////////////////////////////////////////////////////////
﻿public enum ToolType
{
    None,
    Hoe,
    WateringCan,
    SeedPouch // New tool type
    // etc.
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\NightColorPostProcess.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

// Ensure this script is attached to a GameObject in your scene
public class NightColorPostProcess : MonoBehaviour
{
    [Header("Core References")]
    [Tooltip("Assign the WeatherManager controlling the day/night cycle.")]
    public WeatherManager weatherManager;
    [Tooltip("Assign the Global Post Processing Volume.")]
    public Volume globalVolume;

    // --- Private references to the Volume Overrides ---
    private ColorAdjustments colorAdjustments;
    private FilmGrain filmGrain;
    private Vignette vignette;
    // private Bloom bloom; // Example if you wanted to add Bloom later

    [Header("Color Adjustments")]
    [Tooltip("The color filter at full day (sunIntensity = 1).")]
    public Color dayColorFilter = Color.white;
    [Tooltip("The color filter at full night (sunIntensity ~ 0).")]
    public Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);
    [Tooltip("Daytime Post-Exposure (Higher = brighter).")]
    public float dayPostExposure = 0f;
    [Tooltip("Nighttime Post-Exposure (Lower = darker).")]
    public float nightPostExposure = -0.5f;
    [Tooltip("Saturation at full day (0 = no change, <0 desaturates, >0 saturates).")]
    public float daySaturation = 0f;
    [Tooltip("Saturation at full night (e.g., -50 for more desaturation).")]
    public float nightSaturation = -50f;

    [Header("Film Grain")]
    [Tooltip("Film grain intensity at full day (0 = none).")]
    [Range(0f, 1f)] public float dayFilmGrainIntensity = 0.1f;
    [Tooltip("Film grain intensity at full night (e.g., 0.5 for noticeable grain).")]
    [Range(0f, 1f)] public float nightFilmGrainIntensity = 0.5f;
    // Note: You could also control FilmGrain.response if desired

    [Header("Vignette")]
    [Tooltip("Vignette intensity at full day (0 = none, higher = stronger effect).")]
    [Range(0f, 1f)] public float dayVignetteIntensity = 0.2f;
    [Tooltip("Vignette intensity at full night (e.g., 0.5 for darker edges).")]
    [Range(0f, 1f)] public float nightVignetteIntensity = 0.5f;
    [Tooltip("Vignette smoothness at full day (higher = softer edge).")]
    [Range(0.01f, 1f)] public float dayVignetteSmoothness = 0.2f;
    [Tooltip("Vignette smoothness at full night.")]
    [Range(0.01f, 1f)] public float nightVignetteSmoothness = 0.3f;
    // Note: You could also control Vignette.color or Vignette.rounded if desired


    private void Start()
    {
        // --- Validate Core References ---
        if (!weatherManager)
        {
            Debug.LogError($"[{nameof(NightColorPostProcess)}] WeatherManager not assigned!", this);
            enabled = false; // Disable script if core references are missing
            return;
        }
        if (!globalVolume)
        {
            Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume not assigned!", this);
            enabled = false;
            return;
        }
        if (globalVolume.profile == null)
        {
             Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume has no profile assigned!", this);
             enabled = false;
             return;
        }

        // --- Attempt to Get Volume Overrides ---
        // It's okay if some aren't found, the Update loop will check for null
        if (!globalVolume.profile.TryGet<ColorAdjustments>(out colorAdjustments))
        {
            Debug.LogWarning($"[{nameof(NightColorPostProcess)}] ColorAdjustments override not found in Volume profile.", this);
        }
        if (!globalVolume.profile.TryGet<FilmGrain>(out filmGrain))
        {
             Debug.LogWarning($"[{nameof(NightColorPostProcess)}] FilmGrain override not found in Volume profile.", this);
        }
        if (!globalVolume.profile.TryGet<Vignette>(out vignette))
        {
             Debug.LogWarning($"[{nameof(NightColorPostProcess)}] Vignette override not found in Volume profile.", this);
        }
        // Example for Bloom:
        // if (!globalVolume.profile.TryGet<Bloom>(out bloom))
        // {
        //      Debug.LogWarning($"[{nameof(NightColorPostProcess)}] Bloom override not found in Volume profile.", this);
        // }

        // --- Ensure Overrides are Active ---
        // Make sure the overrides you intend to use are actually enabled on the Volume component itself.
        // You might need to manually check the boxes in the Inspector for ColorAdjustments, FilmGrain, and Vignette.
        // Alternatively, you could force them active here, but it's usually better to configure in the editor:
        // if (colorAdjustments != null) colorAdjustments.active = true;
        // if (filmGrain != null) filmGrain.active = true;
        // if (vignette != null) vignette.active = true;
    }

    private void Update()
    {
        // No need to check weatherManager, Start() already disables if null
        // Check if any overrides are available before proceeding
        if (colorAdjustments == null && filmGrain == null && vignette == null)
            return; // Nothing to update if no overrides were found

        // Get the sun intensity (0 = night, 1 = day) and calculate interpolation factor t
        float sun = Mathf.Clamp01(weatherManager.sunIntensity);
        float t = 1f - sun;  // t=0 at day, t=1 at night

        // --- Interpolate and Apply Color Adjustments ---
        if (colorAdjustments != null)
        {
            colorAdjustments.colorFilter.value = Color.Lerp(dayColorFilter, nightColorFilter, t);
            colorAdjustments.postExposure.value = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
            colorAdjustments.saturation.value = Mathf.Lerp(daySaturation, nightSaturation, t);
        }

        // --- Interpolate and Apply Film Grain ---
        if (filmGrain != null)
        {
            filmGrain.intensity.value = Mathf.Lerp(dayFilmGrainIntensity, nightFilmGrainIntensity, t);
            // You can add Lerp for filmGrain.response here if needed
        }

        // --- Interpolate and Apply Vignette ---
        if (vignette != null)
        {
            vignette.intensity.value = Mathf.Lerp(dayVignetteIntensity, nightVignetteIntensity, t);
            vignette.smoothness.value = Mathf.Lerp(dayVignetteSmoothness, nightVignetteSmoothness, t);
             // You can add Lerp for vignette.color or vignette.rounded here if needed
        }

        // --- Example for Bloom ---
        // if (bloom != null)
        // {
        //     bloom.intensity.value = Mathf.Lerp(dayBloomIntensity, nightBloomIntensity, t);
        // }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\OutlinePartController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/OutlinePartController.cs
using UnityEngine;

[RequireComponent(typeof(SpriteRenderer))]
public class OutlinePartController : MonoBehaviour
{
    private SpriteRenderer outlineRenderer;
    private SpriteRenderer sourcePlantPartRenderer; // The plant part this outline mimics

    [HideInInspector] public Vector2Int gridCoord; // The coordinate *this outline* lives at

    void Awake()
    {
        outlineRenderer = GetComponent<SpriteRenderer>();
        if (outlineRenderer != null)
        {
            outlineRenderer.drawMode = SpriteDrawMode.Simple;
            outlineRenderer.enabled = false;
        }
        else
        {
            Debug.LogError($"[{gameObject.name}] OutlinePartController is missing SpriteRenderer component!", this);
        }
    }

    public void Initialize(SpriteRenderer sourceRenderer, Vector2Int myCoord, PlantOutlineController controller)
    {
        if (sourceRenderer == null || controller == null) 
        { 
            Debug.LogError($"[{gameObject.name}] Initialization failed! Source renderer or controller is null!", this);
            Destroy(gameObject); 
            return; 
        }
        
        sourcePlantPartRenderer = sourceRenderer; // Store initial source
        gridCoord = myCoord;
        
        if (outlineRenderer == null)
        {
            outlineRenderer = GetComponent<SpriteRenderer>();
            if (outlineRenderer == null)
            {
                Debug.LogError($"[{gameObject.name}] Initialize: Cannot find SpriteRenderer component!", this);
                Destroy(gameObject);
                return;
            }
        }
        
        // Set layer & color properties
        outlineRenderer.sortingLayerID = controller.OutlineSortingLayer;
        outlineRenderer.sortingOrder = controller.OutlineSortingOrder;
        outlineRenderer.color = controller.OutlineColor;
        
        // Set parent & position
        transform.SetParent(controller.transform, true); // Parent to controller's transform
        
        // Set initial position based on grid coordinate (controller handles spacing)
        float spacing = controller.GetComponentInParent<PlantGrowth>()?.GetCellSpacing() ?? 0.08f; // Get spacing
        transform.localPosition = (Vector2)myCoord * spacing;

        // Set visibility based on source renderer's state
        outlineRenderer.enabled = IsSourceRendererValid() && 
                                  sourcePlantPartRenderer.enabled && 
                                  sourcePlantPartRenderer.sprite != null;
        
        SyncSpriteAndTransform(); // Initial sync
    }

    void LateUpdate()
    {
        // Skip update if not visible
        if (outlineRenderer == null || !outlineRenderer.enabled) return;

        // Check if source is still valid
        if (!IsSourceRendererValid())
        {
            SetVisibility(false);
            return;
        }
        
        // Check if source is still enabled and has a sprite
        if (!sourcePlantPartRenderer.enabled || sourcePlantPartRenderer.sprite == null)
        {
            SetVisibility(false);
            return;
        }

        // If we are enabled and source is valid, sync visuals
        SyncSpriteAndTransform();
    }

    // Public method to check if the source renderer still exists
    public bool IsSourceRendererValid()
    {
        // Unity overloads null check for destroyed objects
        if (sourcePlantPartRenderer == null)
            return false;
            
        // Additional check: is the gameObject actually active/valid
        if (!sourcePlantPartRenderer.gameObject.activeInHierarchy)
            return false;
            
        return true;
    }

    // Public method to update the source renderer if the original was destroyed
    public void UpdateSourceRenderer(SpriteRenderer newSource)
    {
        if (newSource != null)
        {
            sourcePlantPartRenderer = newSource;
            
            // Ensure visibility state is correct after source update
            SetVisibility(
                outlineRenderer != null && 
                sourcePlantPartRenderer.enabled && 
                sourcePlantPartRenderer.sprite != null
            );
            
            // Immediately sync sprite/transform after updating source
            SyncSpriteAndTransform();
            
            // Debug.Log($"Updated outline at {gridCoord} with new source renderer: {newSource.gameObject.name}");
        } 
        else 
        {
            Debug.LogWarning($"Attempted to update source renderer for outline at {gridCoord} with null.", gameObject);
            // If no valid new source, hide this outline
            SetVisibility(false);
        }
    }

    // Sync sprite and transform data
    public void SyncSpriteAndTransform()
    {
        // Safety checks
        if (!IsSourceRendererValid() || outlineRenderer == null) 
            return;

        // Sync sprite
        if (outlineRenderer.sprite != sourcePlantPartRenderer.sprite)
        {
            outlineRenderer.sprite = sourcePlantPartRenderer.sprite;
        }
        
        // Sync other visual properties
        transform.localScale = sourcePlantPartRenderer.transform.localScale;
        outlineRenderer.flipX = sourcePlantPartRenderer.flipX;
        outlineRenderer.flipY = sourcePlantPartRenderer.flipY;
        
        // Note: Position is set in Initialize and doesn't need to track source renderer's parent offset
    }

    public void SetVisibility(bool isVisible)
    {
        if (outlineRenderer != null && outlineRenderer.enabled != isVisible)
        {
            outlineRenderer.enabled = isVisible;
        }
    }

    public void DestroyOutlinePart()
    {
        if (this != null && gameObject != null)
        {
            if (Application.isPlaying)
            {
                Destroy(gameObject);
            }
            else
            {
                DestroyImmediate(gameObject);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\PlantOutlineController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/PlantOutlineController.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[RequireComponent(typeof(RectTransform))]
public class PlantOutlineController : MonoBehaviour
{
    // --- Fields ---
    [Header("Outline Settings")]
    [SerializeField] private Color outlineColor = Color.black;
    [SerializeField] private bool excludeOuterCorners = false;
    [SerializeField] private bool excludeBaseCell = true;
    [SerializeField] private GameObject outlinePartPrefab;
    
    [Header("Sorting")]
    [SerializeField] private string outlineSortingLayerName = "Default";
    [SerializeField] private int outlineSortingOrder = -1;

    [Header("Debugging")]
    [SerializeField] private bool debugLogging = false;

    // Public accessors
    public Color OutlineColor => outlineColor;
    public int OutlineSortingLayer => outlineSortingLayerID;
    public int OutlineSortingOrder => outlineSortingOrder;

    // Internal State
    private int outlineSortingLayerID;
    private PlantGrowth parentPlantGrowth;
    private Dictionary<Vector2Int, OutlinePartController> outlinePartMap = new Dictionary<Vector2Int, OutlinePartController>();
    private HashSet<Vector2Int> plantCellCoords = new HashSet<Vector2Int>();
    
    // Neighbor offsets - 8 directions around a cell
    private static readonly Vector2Int[] neighborOffsets = new Vector2Int[]
    {
        new Vector2Int(-1, -1), // Down-Left
        new Vector2Int(0, -1),  // Down
        new Vector2Int(1, -1),  // Down-Right
        new Vector2Int(-1, 0),  // Left
        new Vector2Int(1, 0),   // Right
        new Vector2Int(-1, 1),  // Up-Left
        new Vector2Int(0, 1),   // Up
        new Vector2Int(1, 1),   // Up-Right
    };

    // Just the cardinal directions (for certain operations)
    private static readonly Vector2Int[] cardinalOffsets = new Vector2Int[]
    {
        new Vector2Int(0, -1),  // Down
        new Vector2Int(-1, 0),  // Left
        new Vector2Int(1, 0),   // Right
        new Vector2Int(0, 1),   // Up
    };

    void Awake()
    {
        parentPlantGrowth = GetComponentInParent<PlantGrowth>();
        if (parentPlantGrowth == null)
        {
            Debug.LogError($"[{gameObject.name} Awake] Missing PlantGrowth parent!", gameObject);
            enabled = false;
            return;
        }
        
        if (outlinePartPrefab == null)
        {
            Debug.LogError($"[{gameObject.name} Awake] Outline Part Prefab not assigned!", gameObject);
            enabled = false;
            return;
        }
        
        // Get the proper sorting layer ID from the name
        outlineSortingLayerID = SortingLayer.NameToID(outlineSortingLayerName);
        if (outlineSortingLayerID == 0 && outlineSortingLayerName != "Default")
        {
            Debug.LogWarning($"[{gameObject.name} Awake] Sorting Layer '{outlineSortingLayerName}' not found, using 'Default'.");
            outlineSortingLayerID = SortingLayer.NameToID("Default");
        }
        
        // Zero out local transform values to avoid unexpected visual glitches
        transform.localPosition = Vector3.zero;
        transform.localRotation = Quaternion.identity;
        transform.localScale = Vector3.one;
        
        if (debugLogging)
            Debug.Log($"[{gameObject.name} Awake] Initialized outline controller for {parentPlantGrowth.gameObject.name}");
    }

    // --- Methods Called by PlantGrowth ---

    // OnPlantCellAdded - Called when a new plant cell is added
    public void OnPlantCellAdded(Vector2Int plantCoord, GameObject plantCellGO)
    {
        if (plantCellGO == null)
        {
            if (debugLogging)
                Debug.LogWarning($"[{gameObject.name}] OnPlantCellAdded: Null GameObject at {plantCoord}");
            return;
        }
        
        // Add to our plant cells set
        plantCellCoords.Add(plantCoord);
        
        // Remove any existing outline at the plant location (should be clear already, but safety)
        RemoveOutlinePartIfExists(plantCoord);
        
        // Get the SpriteRenderer from the plant cell
        SpriteRenderer plantRenderer = plantCellGO.GetComponentInChildren<SpriteRenderer>();
        if (plantRenderer == null)
        {
            Debug.LogWarning($"Plant cell added at {plantCoord} missing SpriteRenderer.", plantCellGO);
            return;
        }
        
        // Check all neighboring coordinates around this plant cell
        foreach (Vector2Int offset in neighborOffsets)
        {
            Vector2Int neighborCoord = plantCoord + offset;
            
            // Only create outline parts where:
            // 1. There's no plant cell
            // 2. There's no outline part already
            // 3. It passes any exclusion rules
            if (!plantCellCoords.Contains(neighborCoord) && 
                !outlinePartMap.ContainsKey(neighborCoord))
            {
                if (ShouldExcludeOutlineAt(neighborCoord))
                    continue;
                    
                CreateOutlinePart(neighborCoord, plantRenderer);
            }
        }
        
        if (debugLogging)
            Debug.Log($"[{gameObject.name}] Added cell at {plantCoord}, now tracking {plantCellCoords.Count} cells and {outlinePartMap.Count} outline parts");
    }

    // OnPlantCellRemoved - Called when a plant cell is removed
    public void OnPlantCellRemoved(Vector2Int plantCoord)
    {
        if (!plantCellCoords.Contains(plantCoord))
        {
            if (debugLogging)
                Debug.LogWarning($"[{gameObject.name}] OnPlantCellRemoved: Coordinate {plantCoord} not found in plant cells!");
            return;
        }
        
        // Remove the coordinate from our internal tracking
        plantCellCoords.Remove(plantCoord);
        
        if (debugLogging)
            Debug.Log($"[{gameObject.name}] Removed cell at {plantCoord}, now have {plantCellCoords.Count} cells");
        
        // 1. Check if outline should appear *at the removed location*
        if (!outlinePartMap.ContainsKey(plantCoord))
        {
            if (HasPlantNeighbor(plantCoord))
            {
                SpriteRenderer sourceRenderer = FindValidNeighborRenderer(plantCoord);
                if (sourceRenderer != null && !ShouldExcludeOutlineAt(plantCoord))
                {
                    CreateOutlinePart(plantCoord, sourceRenderer);
                    if (debugLogging)
                        Debug.Log($"[{gameObject.name}] Created new outline at removed cell position {plantCoord}");
                }
            }
        }
        
        // 2. Re-evaluate all neighboring coordinates
        foreach (Vector2Int offset in neighborOffsets)
        {
            Vector2Int neighborCoord = plantCoord + offset;
            
            // Check if an outline exists at this neighbor
            if (outlinePartMap.TryGetValue(neighborCoord, out OutlinePartController outlinePart))
            {
                // Safety check for destroyed outline part
                if (outlinePart == null)
                {
                    outlinePartMap.Remove(neighborCoord);
                    if (debugLogging)
                        Debug.Log($"[{gameObject.name}] Removed null outline at {neighborCoord} from dictionary");
                    continue;
                }
                
                // Check if this neighbor still needs an outline
                bool neighborStillHasPlantNeighbor = HasPlantNeighbor(neighborCoord);
                
                if (!neighborStillHasPlantNeighbor)
                {
                    // No longer has any plant neighbors, remove it
                    RemoveOutlinePartIfExists(neighborCoord);
                    if (debugLogging)
                        Debug.Log($"[{gameObject.name}] Removed orphaned outline at {neighborCoord}");
                }
                else if (!outlinePart.IsSourceRendererValid())
                {
                    // Outline's source was likely the removed cell, update it
                    SpriteRenderer newSource = FindValidNeighborRenderer(neighborCoord);
                    if (newSource != null)
                    {
                        outlinePart.UpdateSourceRenderer(newSource);
                        outlinePart.SyncSpriteAndTransform();
                        if (debugLogging)
                            Debug.Log($"[{gameObject.name}] Updated source for outline at {neighborCoord}");
                    }
                    else
                    {
                        // This case is unlikely but could happen in complex removals
                        if (debugLogging)
                            Debug.LogWarning($"[{gameObject.name}] Outline at {neighborCoord} lost source but HasPlantNeighbor=true. Removing.");
                        RemoveOutlinePartIfExists(neighborCoord);
                    }
                }
            }
            // If no outline at this neighbor, but there should be one (e.g., it was excluded before)
            else if (!plantCellCoords.Contains(neighborCoord) && HasPlantNeighbor(neighborCoord))
            {
                if (!ShouldExcludeOutlineAt(neighborCoord))
                {
                    SpriteRenderer sourceRenderer = FindValidNeighborRenderer(neighborCoord);
                    if (sourceRenderer != null)
                    {
                        CreateOutlinePart(neighborCoord, sourceRenderer);
                        if (debugLogging)
                            Debug.Log($"[{gameObject.name}] Created new outline at neighbor {neighborCoord} after cell removal");
                    }
                }
            }
        }
    }

    // --- Internal Helper Methods ---

    // CreateOutlinePart - Creates an outline part at the specified coordinates
    private void CreateOutlinePart(Vector2Int coord, SpriteRenderer sourceRenderer)
    {
        if (outlinePartPrefab == null)
        {
            Debug.LogError($"[{gameObject.name}] CreateOutlinePart: outlinePartPrefab is null!");
            return;
        }
        
        if (sourceRenderer == null)
        {
            Debug.LogWarning($"[{gameObject.name}] CreateOutlinePart: sourceRenderer is null for coord {coord}");
            return;
        }
        
        // Check if already exists (safety)
        if (outlinePartMap.ContainsKey(coord))
        {
            if (debugLogging)
                Debug.LogWarning($"[{gameObject.name}] CreateOutlinePart: Outline already exists at {coord}");
            return;
        }
        
        // Instantiate the outline part
        GameObject outlineInstance = Instantiate(outlinePartPrefab, transform);
        if (outlineInstance == null)
        {
            Debug.LogError($"[{gameObject.name}] CreateOutlinePart: Failed to instantiate outline prefab!");
            return;
        }
        
        // Set position using PlantGrowth's cell spacing
        float spacing = parentPlantGrowth.GetCellSpacing();
        outlineInstance.transform.localPosition = (Vector2)coord * spacing;
        
        // Get the controller and initialize it
        OutlinePartController outlineController = outlineInstance.GetComponent<OutlinePartController>();
        if (outlineController != null)
        {
            outlineController.Initialize(sourceRenderer, coord, this);
            outlineController.SetVisibility(true);
            outlinePartMap.Add(coord, outlineController);
            
            if (debugLogging)
                Debug.Log($"[{gameObject.name}] Created outline part at {coord} using source {sourceRenderer.gameObject.name}");
        }
        else
        {
            Debug.LogError($"[{gameObject.name}] Outline Part Prefab missing OutlinePartController script!", outlinePartPrefab);
            Destroy(outlineInstance);
        }
    }

    // RemoveOutlinePartIfExists - Removes an outline part if it exists at the specified coordinates
    private void RemoveOutlinePartIfExists(Vector2Int coord)
    {
        if (outlinePartMap.TryGetValue(coord, out OutlinePartController outlinePart))
        {
            if (outlinePart != null)
            {
                outlinePart.DestroyOutlinePart();
                if (debugLogging)
                    Debug.Log($"[{gameObject.name}] Destroyed outline part at {coord}");
            }
            outlinePartMap.Remove(coord);
        }
    }

    // HasPlantNeighbor - Checks if the specified coordinates have any plant neighbors
    private bool HasPlantNeighbor(Vector2Int coord)
    {
        foreach (Vector2Int offset in neighborOffsets)
        {
            if (plantCellCoords.Contains(coord + offset))
            {
                return true;
            }
        }
        return false;
    }

    // FindValidNeighborRenderer - Finds a valid SpriteRenderer from a neighboring plant cell
    private SpriteRenderer FindValidNeighborRenderer(Vector2Int coord)
    {
        foreach (Vector2Int offset in neighborOffsets)
        {
            Vector2Int neighborCoord = coord + offset;
            
            // Check if there's a plant cell at this coordinate
            if (plantCellCoords.Contains(neighborCoord))
            {
                // Get the GameObject from PlantGrowth
                GameObject plantGO = parentPlantGrowth.GetCellGameObjectAt(neighborCoord);
                if (plantGO != null)
                {
                    SpriteRenderer renderer = plantGO.GetComponentInChildren<SpriteRenderer>();
                    if (renderer != null)
                    {
                        if (debugLogging)
                            Debug.Log($"[{gameObject.name}] Found valid renderer at {neighborCoord} for outline at {coord}");
                        return renderer;
                    }
                }
            }
        }
        
        if (debugLogging)
            Debug.LogWarning($"[{gameObject.name}] Could not find any valid neighbor renderer for {coord}");
        return null;
    }

    // ShouldExcludeOutlineAt - Checks if an outline should be excluded at the specified coordinates
    private bool ShouldExcludeOutlineAt(Vector2Int coord)
    {
        // Exclude base cell (e.g., under the seed) if enabled
        if (excludeBaseCell && coord == Vector2Int.down && plantCellCoords.Contains(Vector2Int.zero))
        {
            return true;
        }
        
        // Exclude outer corners if enabled
        if (excludeOuterCorners && IsOuterCornerCandidate(coord))
        {
            return true;
        }
        
        return false;
    }

    // IsOuterCornerCandidate - Checks if the coordinate is a potential outer corner
    private bool IsOuterCornerCandidate(Vector2Int coord)
    {
        // If it's a plant cell, it's not an outer corner
        if (plantCellCoords.Contains(coord))
            return false;
            
        // Count the number of plant neighbors
        int plantNeighborCount = 0;
        foreach (Vector2Int offset in neighborOffsets)
        {
            if (plantCellCoords.Contains(coord + offset)) {
                plantNeighborCount++;
            }
        }
        
        // In typical 2D grid outline detection, an outer corner has 3 neighbors
        return plantNeighborCount == 3;
    }

    void OnDestroy()
    {
        // Clean up resources when destroyed
        foreach (var kvp in outlinePartMap)
        {
            if (kvp.Value != null)
            {
                kvp.Value.DestroyOutlinePart();
            }
        }
        outlinePartMap.Clear();
        plantCellCoords.Clear();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\PlantShadowController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/PlantShadowController.cs
using UnityEngine;
using System.Collections.Generic;

public class PlantShadowController : MonoBehaviour
{
    [Header("Global Shadow Settings")]
    [SerializeField] private Color shadowColor = new Color(0f, 0f, 0f, 0.5f);
    [SerializeField] [Range(0.1f, 2f)] [Tooltip("Vertical squash factor (1 = none, <1 = flatter, >1 = taller)")]
    private float squashFactor = 0.6f;
    [SerializeField] [Range(0f, 360f)] [Tooltip("Rotation angle of the shadow around the plant's base (0 = right, 90 = up, 180 = left, 270 = down)")]
    private float shadowAngleDegrees = 270f; // Default to directly downwards
    [SerializeField] [Tooltip("Flip the shadow horizontally?")]
    private bool flipShadow = false;
    // Removed: lightSourceDirection
    // Removed: shadowDistance
    // Removed: skewAngleDegrees (replaced by shadowAngleDegrees for direction)
    
    [Header("Distance Fade")]
    [Tooltip("Enable fading parts based on distance from the root.")]
    [SerializeField] private bool enableDistanceFade = true;
    [Tooltip("Distance from the root where the shadow part starts fading.")]
    [SerializeField] private float fadeStartDistance = 1.5f;
    [Tooltip("Distance from the root where the shadow part is fully faded (alpha 0).")]
    [SerializeField] private float fadeEndDistance = 3.0f;
    [Tooltip("Minimum alpha value even when fully faded (e.g., 0.1 for slight visibility).")]
    [SerializeField] [Range(0f, 1f)] private float minFadeAlpha = 0.0f;

    [Header("Sorting")]
    [SerializeField] [Tooltip("Name of the Sorting Layer for shadows (e.g., 'Shadows')")]
    private string shadowSortingLayerName = "Default";
    [SerializeField] [Tooltip("Sorting Order within the layer (lower values are rendered first)")]
    private int shadowSortingOrder = -1;

    // --- Internal ID ---
    private int shadowSortingLayerID;

    // Public accessors for ShadowPartController
    public Color ShadowColor => shadowColor;
    public int ShadowSortingLayer => shadowSortingLayerID;
    public int ShadowSortingOrder => shadowSortingOrder;

    // <<< NEW ACCESSORS for Fade >>>
    public bool EnableDistanceFade => enableDistanceFade;
    public float FadeStartDistance => fadeStartDistance;
    public float FadeEndDistance => fadeEndDistance;
    public float MinFadeAlpha => minFadeAlpha;
    
    // Cached base transform values
    private Vector3 baseLocalScale;
    private Quaternion baseLocalRotation;
    private Vector3 baseLocalPosition;

    // Dictionary to manage shadow parts (unchanged)
    private Dictionary<SpriteRenderer, ShadowPartController> shadowPartMap = new Dictionary<SpriteRenderer, ShadowPartController>();

    void Awake()
    {
        // Convert layer name to ID (unchanged)
        shadowSortingLayerID = SortingLayer.NameToID(shadowSortingLayerName);
        if (shadowSortingLayerID == 0 && shadowSortingLayerName != "Default")
        {
            Debug.LogWarning($"Sorting Layer '{shadowSortingLayerName}' not found. Shadow will use 'Default'.", this);
            shadowSortingLayerID = SortingLayer.NameToID("Default");
        }

        // Cache initial transform state (unchanged)
        baseLocalScale = transform.localScale;
        baseLocalRotation = transform.localRotation;
        // --- IMPORTANT: Ensure _ShadowRoot starts at local position (0,0,0) relative to the Plant root ---
        baseLocalPosition = transform.localPosition;
        if (baseLocalPosition != Vector3.zero) {
             Debug.LogWarning($"'{gameObject.name}' initial localPosition is not zero ({baseLocalPosition}). Shadow origin might be slightly offset from plant root.", gameObject);
        }
    }

    void LateUpdate()
    {
        // 1. Set Position: Keep the shadow root at the plant's origin (relative to parent)
        // We don't apply any offset anymore.
        transform.localPosition = baseLocalPosition; // Should typically be Vector3.zero

        // 2. Set Rotation based on the angle slider
        // Apply the rotation relative to the initial orientation
        Quaternion angleRotation = Quaternion.Euler(0, 0, shadowAngleDegrees);
        transform.localRotation = baseLocalRotation * angleRotation;

        // 3. Calculate and Apply Scale (Squash + Flip)
        Vector3 finalScale = baseLocalScale; // Start with original scale
        // Apply squash factor (typically affects the Y-axis before rotation)
        // To apply squash along the *rotated* Y-axis is more complex.
        // Let's keep the simpler approach: squash the local Y scale.
        finalScale.y *= squashFactor;

        // Apply horizontal flip if checked (affects the X-axis)
        if (flipShadow)
        {
            finalScale.x *= -1f;
        }
        // Apply the calculated scale
        transform.localScale = finalScale;

    }

    // --- Methods for PlantGrowth Integration (Unchanged) ---

    public void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject shadowPartPrefab)
    {
        if (plantPartRenderer == null || shadowPartPrefab == null) return;
        if (shadowPartMap.ContainsKey(plantPartRenderer)) return;
        GameObject shadowInstance = Instantiate(shadowPartPrefab, transform);
        ShadowPartController shadowController = shadowInstance.GetComponent<ShadowPartController>();
        if (shadowController != null) { shadowController.Initialize(plantPartRenderer, this); shadowPartMap.Add(plantPartRenderer, shadowController); }
        else { Debug.LogError($"Shadow Part Prefab '{shadowPartPrefab.name}' missing ShadowPartController.", shadowPartPrefab); Destroy(shadowInstance); }
    }

    public void UnregisterPlantPart(SpriteRenderer plantPartRenderer)
    {
        if (plantPartRenderer != null && shadowPartMap.TryGetValue(plantPartRenderer, out ShadowPartController shadowController)) {
            if (shadowController != null) { shadowController.OnPlantPartDestroyed(); }
            shadowPartMap.Remove(plantPartRenderer);
        }
    }

    void OnDestroy()
    {
        shadowPartMap.Clear(); // Prevent memory leaks
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\RuntimeCircleDrawer.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/RuntimeCircleDrawer.cs

using UnityEngine;

/// <summary>
/// Draws a circle outline using a LineRenderer attached to the same GameObject.
/// Requires a LineRenderer component.
/// </summary>
[RequireComponent(typeof(LineRenderer))]
public class RuntimeCircleDrawer : MonoBehaviour
{
    [Range(3, 60)]
    public int segments = 30; // Number of line segments to approximate the circle
    public float radius = 1.0f;
    public float lineWidth = 0.02f;
    public Color color = Color.yellow;
    public Material lineMaterial; // Assign the same material used for firefly lines, or a specific one

    private LineRenderer lineRenderer;
    private bool needsRedraw = true; // Flag to force redraw on first UpdateCircle call or when params change
    private float currentRadius = -1f; // Store current values to detect changes
    private Color currentColor = Color.clear;

    void Awake()
    {
        lineRenderer = GetComponent<LineRenderer>();
        if (lineRenderer == null) { // Should not happen with RequireComponent
            Debug.LogError($"[{gameObject.name}] RuntimeCircleDrawer: Missing required LineRenderer component!");
            enabled = false; // Disable script if component missing
            return;
        }
        ConfigureLineRendererDefaults();
        lineRenderer.enabled = false; // Start hidden
    }

    // Sets initial parameters that don't change often
    void ConfigureLineRendererDefaults()
    {
        lineRenderer.useWorldSpace = false; // Draw relative to this object's transform
        lineRenderer.loop = true; // Connect the last point to the first
        lineRenderer.startWidth = lineWidth;
        lineRenderer.endWidth = lineWidth;
        
        // Only set material if one was provided and lineRenderer doesn't have one
        if (lineMaterial != null && lineRenderer.material == null)
        {
            lineRenderer.material = lineMaterial;
        }
        
        // Don't set color here - UpdateCircle will handle that

        // Attempt to match sorting with parent sprite
        SpriteRenderer parentSprite = GetComponentInParent<SpriteRenderer>();
        if (parentSprite != null) {
            lineRenderer.sortingLayerName = parentSprite.sortingLayerName;
            lineRenderer.sortingOrder = parentSprite.sortingOrder + 1; // Draw slightly in front
        } else {
            // Default sorting if no parent sprite found
            lineRenderer.sortingLayerName = "Default";
            lineRenderer.sortingOrder = 1;
        }
    }

    // Call this method to update the circle's appearance and make it visible
    public void UpdateCircle(float newRadius, Color newColor)
    {
        // Check if parameters have actually changed
        bool radiusChanged = !Mathf.Approximately(currentRadius, newRadius);
        bool colorChanged = currentColor != newColor;
        
        if (!needsRedraw && !radiusChanged && !colorChanged)
        {
            // Ensure it's enabled if it wasn't already
            if (!lineRenderer.enabled) lineRenderer.enabled = true;
            return; // No change needed
        }

        // Update stored values
        currentRadius = newRadius;
        radius = newRadius; // Update public field for potential inspector viewing
        currentColor = newColor;
        color = newColor; // Update public field

        // IMPORTANT: Update LineRenderer colors
        lineRenderer.startColor = currentColor;
        lineRenderer.endColor = currentColor;
        
        // Log color change for debugging
        if (colorChanged && Debug.isDebugBuild)
        {
            Debug.Log($"[RuntimeCircleDrawer] Updated color to: {newColor}", gameObject);
        }
        
        // Update width if you add properties for it too
        // lineRenderer.startWidth = newWidth;
        // lineRenderer.endWidth = newWidth;

        DrawCircle(); // Recalculate points
        lineRenderer.enabled = true; // Ensure it's visible
        needsRedraw = false; // Mark as drawn
    }

    // Call this to hide the circle
    public void HideCircle()
    {
        if (lineRenderer != null && lineRenderer.enabled)
        {
            lineRenderer.enabled = false;
            needsRedraw = true; // Needs redraw next time it's shown
        }
    }

    void DrawCircle()
    {
        if (lineRenderer == null || segments <= 2 || radius <= 0f) {
            lineRenderer.positionCount = 0; // Clear points if invalid params
            return;
        };

        // Only resize array if segment count changes (optimization)
        if (lineRenderer.positionCount != segments + 1) {
            lineRenderer.positionCount = segments + 1;
        }

        float angleStep = 360f / segments;
        Vector3[] points = new Vector3[segments + 1];

        for (int i = 0; i <= segments; i++)
        {
            float currentAngle = Mathf.Deg2Rad * (i * angleStep);
            float x = Mathf.Cos(currentAngle) * radius;
            float y = Mathf.Sin(currentAngle) * radius;
            points[i] = new Vector3(x, y, 0); // Z is 0 for local space relative to transform
        }

        lineRenderer.SetPositions(points);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\ShadowPartController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/ShadowPartController.cs
using UnityEngine;
// using UnityEngine.Rendering; // Not needed for this simple fade

[RequireComponent(typeof(SpriteRenderer))]
public class ShadowPartController : MonoBehaviour
{
    private SpriteRenderer shadowRenderer;
    private SpriteRenderer plantPartRenderer;
    private Transform plantPartTransform;
    private Transform shadowRootTransform;
    private PlantShadowController mainShadowController;
    // Removed: initialLocalPosition - not needed for distance calc

    void Awake()
    {
        shadowRenderer = GetComponent<SpriteRenderer>();
        shadowRenderer.drawMode = SpriteDrawMode.Simple;
        shadowRenderer.enabled = false;
    }

    public void Initialize(SpriteRenderer targetPlantPartRenderer, PlantShadowController controller)
    {
        if (targetPlantPartRenderer == null || controller == null) { Destroy(gameObject); return; }
        plantPartRenderer = targetPlantPartRenderer;
        plantPartTransform = targetPlantPartRenderer.transform;
        mainShadowController = controller;
        shadowRootTransform = controller.transform;

        shadowRenderer.sortingLayerID = mainShadowController.ShadowSortingLayer;
        shadowRenderer.sortingOrder = mainShadowController.ShadowSortingOrder;
        // Color is now set in LateUpdate to include fade alpha

        transform.SetParent(shadowRootTransform, true); // Parent first

        shadowRenderer.enabled = plantPartRenderer.enabled && plantPartRenderer.sprite != null;
        // Initialize color with potentially full alpha
        UpdateColorAndFade();
    }

    void LateUpdate()
    {
        if (plantPartRenderer == null || !plantPartRenderer.enabled || plantPartRenderer.sprite == null || shadowRenderer == null || mainShadowController == null)
        {
            if (shadowRenderer != null) shadowRenderer.enabled = false;
            return;
        }

        shadowRenderer.enabled = true;

        // 1. Sync Sprite
        shadowRenderer.sprite = plantPartRenderer.sprite;

        // 2. Sync Position & Rotation (Relative to Shadow Root) - Unchanged
        Vector3 plantPartPosRelativeToPlantRoot = plantPartTransform.parent.InverseTransformPoint(plantPartTransform.position);
        transform.localPosition = plantPartPosRelativeToPlantRoot;
        transform.localRotation = plantPartTransform.localRotation;

        // 3. Sync Flip - Unchanged
        shadowRenderer.flipX = plantPartRenderer.flipX;
        shadowRenderer.flipY = plantPartRenderer.flipY;

        // 4. Sync Scale (relative to parent) - Unchanged
        transform.localScale = plantPartTransform.localScale;

        // 5. Update Color & Apply Distance Fade
        UpdateColorAndFade();
    }

    // <<< NEW METHOD >>>
    private void UpdateColorAndFade()
    {
        if(mainShadowController == null || shadowRenderer == null) return;

        Color baseShadowColor = mainShadowController.ShadowColor;
        float finalAlpha = baseShadowColor.a; // Start with the controller's base alpha

        // Apply distance fade if enabled
        if (mainShadowController.EnableDistanceFade)
        {
            float distance = Vector3.Distance(transform.position, shadowRootTransform.position); // Distance from shadow part to shadow root

            float fadeStart = mainShadowController.FadeStartDistance;
            float fadeEnd = mainShadowController.FadeEndDistance;
            float minAlpha = mainShadowController.MinFadeAlpha;

            if (distance >= fadeEnd)
            {
                finalAlpha *= minAlpha; // Apply min alpha
            }
            else if (distance > fadeStart)
            {
                // Calculate interpolation factor (0 at start, 1 at end)
                float t = Mathf.InverseLerp(fadeStart, fadeEnd, distance);
                // Lerp between 1 (full alpha multiplier) and minAlpha
                float distanceAlphaMultiplier = Mathf.Lerp(1f, minAlpha, t);
                finalAlpha *= distanceAlphaMultiplier; // Modulate base alpha
            }
            // Else (distance <= fadeStart), finalAlpha remains baseShadowColor.a
        }

        // Set the final color with calculated alpha
        shadowRenderer.color = new Color(baseShadowColor.r, baseShadowColor.g, baseShadowColor.b, finalAlpha);
    }
    // <<< END NEW METHOD >>>


    public void OnPlantPartDestroyed() // Unchanged
    {
         if (this != null && gameObject != null) { if (Application.isPlaying) { Destroy(gameObject); } else { DestroyImmediate(gameObject); } }
    }
}

