UNITY PROJECT SCRIPTS - COMPRESSED FORMAT
Compression Stats: 517,858 → 352,681 chars (31.9% reduction)
Estimated tokens saved: ~41,294

This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my Unity game project.

 When you're tasked with editing: return each changed method in full; if edits touch ≤3 methods list those blocks only, else output the entire script—always copy-paste ready.

 This file is optimized for AI/LLM token efficiency. The following compression is applied:
- Removed: excess whitespace, common using statements, XML docs, attributes
- Preserved: code structure, important comments, logic flow

IMPORTANT FOR AI: When editing/creating scripts from this reference:
1. Re-add standard Unity using statements (System, UnityEngine, etc.)
2. Format with proper indentation and spacing
3. Add back regions and documentation as needed
4. Ensure proper C# code style

Common using statements (add these back when needed):
using System;

[Unknown]
  PixelPerfectSetup (Assets\Scripts\Core/) L29
  RunManager (Assets\Scripts\Core/) L70
  SortableEntity (Assets\Scripts\Core/) L213
  UIManager (Assets\Scripts\Core/) L280
  WeatherManager (Assets\Scripts\Core/) L647
  AnimalController (Assets\Scripts\Ecosystem\Animals/) L872
  AnimalDefinition (Assets\Scripts\Ecosystem\Animals/) L1480
  AnimalLibrary (Assets\Scripts\Ecosystem\Animals/) L1522
  AnimalSpawnData (Assets\Scripts\Ecosystem\Animals/) L1531
  AnimalThoughtLibrary (Assets\Scripts\Ecosystem\Animals/) L1544
  FireflyController (Assets\Scripts\Ecosystem\Effects/) L1561
  FireflyDefinition (Assets\Scripts\Ecosystem\Effects/) L1876
  FireflyManager (Assets\Scripts\Ecosystem\Effects/) L1905
  PoopController (Assets\Scripts\Ecosystem\Environment/) L2166
  ScentDefinition (Assets\Scripts\Ecosystem\Environment/) L2234
  ScentLibrary (Assets\Scripts\Ecosystem\Environment/) L2249
  ScentSource (Assets\Scripts\Ecosystem\Environment/) L2268
  SlowdownZone (Assets\Scripts\Ecosystem\Environment/) L2326
  DietPreferenceSimplified (Assets\Scripts\Ecosystem\Food/) L2462
  FoodItem (Assets\Scripts\Ecosystem\Food/) L2526
  FoodType (Assets\Scripts\Ecosystem\Food/) L2543
  EcosystemManager (Assets\Scripts\Ecosystem\Management/) L2556
  FaunaManager (Assets\Scripts\Ecosystem\Management/) L2585
  FloraManager (Assets\Scripts\Ecosystem\Management/) L2793
  WaveManager (Assets\Scripts\Ecosystem\Management/) L3023
  WaveSpawnEntry (Assets\Scripts\Ecosystem\Spawning/) L3304
  ThoughtBubbleController (Assets\Scripts\Ecosystem\UI/) L3333
  ThoughtTrigger (Assets\Scripts\Ecosystem\UI/) L3363
  NodeDefinitionAutoAdder (Assets\Scripts\Editor/) L3376
  NodeDefinitionCreator (Assets\Scripts\Editor/) L3404
  NodeDefinitionEditor (Assets\Scripts\Editor/) L3465
  NodeDefinitionLibraryEditor (Assets\Scripts\Editor/) L3510
  NodeDefinitionPostprocessor (Assets\Scripts\Editor/) L3561
  NodeEffectDrawer (Assets\Scripts\Editor/) L3595
  RadiusPatternTesterEditor (Assets\Scripts\Editor/) L3818
  TileDefinitionEditor (Assets\Scripts\Editor/) L3879
  TileInteractionManagerEditor (Assets\Scripts\Editor/) L3899
  LeafData (Assets\Scripts\PlantSystem\Data/) L3934
  NodeData (Assets\Scripts\PlantSystem\Data/) L3949
  NodeDefinition (Assets\Scripts\PlantSystem\Data/) L4034
  InitialNodeConfig (Assets\Scripts\PlantSystem\Data/) L4260
  NodeEffectData (Assets\Scripts\PlantSystem\Data/) L4283
  NodeEffectType (Assets\Scripts\PlantSystem\Data/) L4336
  NodeGraph (Assets\Scripts\PlantSystem\Data/) L4365
  SeedSpawnData (Assets\Scripts\PlantSystem\Data/) L4374
  NodeExecutor (Assets\Scripts\PlantSystem\Execution/) L4399
  OutputNodeEffect (Assets\Scripts\PlantSystem\Growth/) L4567
  PlantCell (Assets\Scripts\PlantSystem\Growth/) L4606
  PlantCellManager (Assets\Scripts\PlantSystem\Growth/) L4630
  PlantEnergySystem (Assets\Scripts\PlantSystem\Growth/) L4832
  PlantGrowth (Assets\Scripts\PlantSystem\Growth/) L4912
  PlantGrowthLogic (Assets\Scripts\PlantSystem\Growth/) L5134
  PlantNodeExecutor (Assets\Scripts\PlantSystem\Growth/) L5379
  PlantVisualManager (Assets\Scripts\PlantSystem\Growth/) L5604
  InventoryBarController (Assets\Scripts\PlantSystem\UI/) L5748
  InventoryBarItem (Assets\Scripts\PlantSystem\UI/) L6046
  InventoryGridController (Assets\Scripts\PlantSystem\UI/) L6113
  ItemView (Assets\Scripts\PlantSystem\UI/) L6419
  NodeCell (Assets\Scripts\PlantSystem\UI/) L6538
  NodeDraggable (Assets\Scripts\PlantSystem\UI/) L6742
  NodeEditorGridController (Assets\Scripts\PlantSystem\UI/) L6876
  OutlinePartController (Assets\Scripts\PlantSystem\Visual/) L7196
  PlantOutlineController (Assets\Scripts\PlantSystem\Visual/) L7332
  PlantShadowController (Assets\Scripts\PlantSystem\Visual/) L7625
  ShadowPartController (Assets\Scripts\PlantSystem\Visual/) L7713
  GridDebugVisualizer (Assets\Scripts\Ticks/) L7814
  GridSnapStartup (Assets\Scripts\Ticks/) L7915
  TickDebugMonitor (Assets\Scripts\Ticks/) L7981
  TurnPhaseManager (Assets\Scripts\Ticks/) L8152
  TooltipTrigger (Assets\Scripts\UI\Tooltips/) L8268
  ITooltipDataProvider (Assets\Scripts\UI\Tooltips/) L8337
  ColorExtensions (Assets\Scripts\UI\Utilities/) L8568
  PrefabOrigin (Assets\Scripts\UI\Utilities/) L8579
  NightColorPostProcess (Assets\Scripts\Visual\Effects/) L8608
  RuntimeCircleDrawer (Assets\Scripts\Visual\Effects/) L8704
  WaterReflection (Assets\Scripts\Visual\Effects/) L8809
  WaterReflectionManager (Assets\Scripts\Visual\Effects/) L9204
  PlantGrowthModifierManager (Assets\Scripts\WorldInteraction\Placement/) L9240
  PlantPlacementManager (Assets\Scripts\WorldInteraction\Placement/) L9430
  PlayerTileInteractor (Assets\Scripts\WorldInteraction\Placement/) L9572
  GardenerController (Assets\Scripts\WorldInteraction\Player/) L9690
  PlayerActionManager (Assets\Scripts\WorldInteraction\Player/) L9834
  TileDefinition (Assets\Scripts\WorldInteraction\Tiles/) L10039
  ToolRefillRule (Assets\Scripts\WorldInteraction\Tiles/) L10079
  TileInteractionRule (Assets\Scripts\WorldInteraction\Tiles/) L10099
  ToolDefinition (Assets\Scripts\WorldInteraction\Tools/) L10111
  ToolSwitcher (Assets\Scripts\WorldInteraction\Tools/) L10146
  ToolType (Assets\Scripts\WorldInteraction\Tools/) L10305

[WegoSystem]
  GridEntity (Assets\Scripts\Ticks/) L10315
  GridPosition (Assets\Scripts\Ticks/) L10466
  GridPositionManager (Assets\Scripts\Ticks/) L10567
  GridRadiusUtility (Assets\Scripts\Ticks/) L10918
  TickConfiguration (Assets\Scripts\Ticks/) L11062
  ITickUpdateable (Assets\Scripts\Ticks/) L11168

[for]
  TileInteractionManager (Assets\Scripts\WorldInteraction\Tiles/) L11330

================================================================================
SCRIPTS
================================================================================

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\PixelPerfectSetup.cs

﻿using UnityEngine;
using UnityEngine.U2D;

pub cls PixelPerfectSetup : MonoBehaviour {
[SerializeField] int referenceResolutionX = 320; // Your base game width
[SerializeField] int referenceResolutionY = 180; // Your base game height

[SerializeField] int pixelsPerUnit = 6; // Since 1 game pixel = 6x6 real pixels

PixelPerfectCamera pixelPerfectCamera;
Camera cam;

void Awake() {
cam = GetComponent<Camera>();
pixelPerfectCamera = GetComponent<PixelPerfectCamera>();

SetupPixelPerfectCamera();
}

void SetupPixelPerfectCamera() {
pixelPerfectCamera.assetsPPU = pixelsPerUnit;
pixelPerfectCamera.refResolutionX = referenceResolutionX;
pixelPerfectCamera.refResolutionY = referenceResolutionY;
pixelPerfectCamera.upscaleRT = true;
pixelPerfectCamera.pixelSnapping = true;
pixelPerfectCamera.cropFrameX = false;
pixelPerfectCamera.cropFrameY = false;
pixelPerfectCamera.stretchFill = false;

Debug.Log($"[PixelPerfectSetup] Configured for {referenceResolutionX}x{referenceResolutionY} at {pixelsPerUnit} PPU");
}

void Start() {
float expectedCameraSize = (float)referenceResolutionY / (2f * pixelsPerUnit);
Debug.Log($"[PixelPerfectSetup] Expected camera orthographic size: {expectedCameraSize}");
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\RunManager.cs

﻿using UnityEngine;
using WegoSystem;

pub enum RunState {
Planning,
GrowthAndThreat
}

pub cls RunManager : MonoBehaviour {
pub stat RunManager Instance { get; set; }

[SerializeField] bool useWegoSystem = true;
[SerializeField] RunState currentState = RunState.Planning;
[SerializeField] int currentRoundNumber = 1;

[SerializeField] WeatherManager weatherManager;
[SerializeField] WaveManager waveManager;

pub RunState CurrentState => currentState;
pub int CurrentRoundNumber => currentRoundNumber;
pub event Action<RunState> OnRunStateChanged;
pub event Action<int> OnRoundChanged;

void Awake() {
if (Instance != null && Instance != this) {
Debug.LogWarning($"[RunManager] Duplicate instance found on {gameObject.name}. Destroying this one.", gameObject);
Destroy(gameObject);
return;
}
Instance = this;

SetState(RunState.Planning, true);
}

void Start() {
if (useWegoSystem && TurnPhaseManager.Instance != null) {
TurnPhaseManager.Instance.OnPhaseChanged += HandleWegoPhaseChanged;
}
}

void OnDestroy() {
if (TurnPhaseManager.Instance != null) {
TurnPhaseManager.Instance.OnPhaseChanged -= HandleWegoPhaseChanged;
}
}

void HandleWegoPhaseChanged(TurnPhase oldPhase, TurnPhase newPhase) {
if (!useWegoSystem) return;

switch (newPhase) {
case TurnPhase.Planning:
if (currentState == RunState.GrowthAndThreat) {
if (waveManager != null && waveManager.IsCurrentWaveDefeated()) {
StartNewRound();
}
}
break;

case TurnPhase.Execution:
if (currentState == RunState.Planning) {
StartGrowthAndThreatPhase();
}
break;
}
}

void SetState(RunState newState, bool force = false) {
if (currentState == newState && !force) return;

currentState = newState;
Debug.Log($"[RunManager] State changed to: {currentState}");

switch (currentState) {
case RunState.Planning:
weatherManager?.PauseCycleAtDay();
break;

case RunState.GrowthAndThreat:
weatherManager?.ResumeCycle();
waveManager?.StartWaveForRound(currentRoundNumber);
break;
}

OnRunStateChanged?.Invoke(currentState);
}

pub void StartGrowthAndThreatPhase() {
if (currentState == RunState.Planning) {
Debug.Log($"[RunManager] Starting Growth & Threat for Round {currentRoundNumber}");
SetState(RunState.GrowthAndThreat);

if (useWegoSystem && TurnPhaseManager.Instance != null) {
if (TurnPhaseManager.Instance.CurrentPhase == TurnPhase.Planning) {
TurnPhaseManager.Instance.EndPlanningPhase();
}
}
}
}

pub void StartRecoveryPhase() {
Debug.Log("[RunManager] StartRecoveryPhase called - transitioning to Planning instead");
StartNewPlanningPhase();
}

pub void StartNewPlanningPhase() {
Debug.Log("[RunManager] Starting new planning phase");

if (currentState != RunState.Planning) {
StartNewRound();
}
}

void StartNewRound() {
currentRoundNumber++;
Debug.Log($"[RunManager] Starting new round: {currentRoundNumber}");

waveManager?.ResetForNewRound();

SetState(RunState.Planning);

if (useWegoSystem && TurnPhaseManager.Instance != null) {
TurnPhaseManager.Instance.TransitionToPhase(TurnPhase.Planning);
}

OnRoundChanged?.Invoke(currentRoundNumber);
}

pub void ManualStartGrowthPhase() {
StartGrowthAndThreatPhase();
}

pub void SetWegoSystem(bool enabled) {
useWegoSystem = enabled;
}

pub bool IsWegoSystemEnabled() {
ret useWegoSystem;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\SortableEntity.cs

﻿using UnityEngine;

pub cls SortableEntity : MonoBehaviour {
[SerializeField] float sortingLayerYOffset = 0f;

[SerializeField] bool useParentYCoordinate = false;

pub bool debugSorting = false;

SpriteRenderer spriteRenderer;

void Awake() {
spriteRenderer = GetComponent<SpriteRenderer>();

if (spriteRenderer == null)
spriteRenderer = GetComponentInChildren<SpriteRenderer>();

if (spriteRenderer == null) {
Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
}
}

void Start() {
UpdateSortingOrder();
}

void LateUpdate() {
UpdateSortingOrder();
}

pub void UpdateSortingOrder() {
if (spriteRenderer == null) return;

float yPositionForSorting = useParentYCoordinate && transform.parent != null
? transform.parent.position.y
: transform.position.y;

int sortOrder = CalculateSortOrder(yPositionForSorting);
spriteRenderer.sortingOrder = sortOrder;

if (debugSorting) {
Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
}
}

int CalculateSortOrder(float yPosition) {
ret Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
}

pub int GetCurrentSortOrder() {
if (spriteRenderer == null) ret 0;
ret spriteRenderer.sortingOrder;
}

pub void SetSortingOrder(int order) {
if (spriteRenderer != null)
spriteRenderer.sortingOrder = order;
}

pub void SetUseParentYCoordinate(bool value) {
useParentYCoordinate = value;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\UIManager.cs

﻿// Assets\Scripts\Core\UIManager.cs
using TMPro;
using WegoSystem;

pub cls UIManager : MonoBehaviour {
pub stat UIManager Instance { get; set; }

[SerializeField] GameObject planningPanel;
[SerializeField] GameObject growthAndThreatPanel;
[SerializeField] GameObject recoveryPanel;
[SerializeField] GameObject nodeEditorPanel;

[SerializeField] Button startGrowthPhaseButton;
[SerializeField] Button startRecoveryPhaseButton;
[SerializeField] Button startNewPlanningPhaseButton;

[SerializeField] GameObject wegoControlPanel;
[SerializeField] Button endPlanningPhaseButton;
[SerializeField] Toggle autoAdvanceToggle; // Obsolete but kept for reference
[SerializeField] Slider tickSpeedSlider; // Obsolete but kept for reference
[SerializeField] TextMeshProUGUI currentPhaseText;
[SerializeField] TextMeshProUGUI tickCounterText;
[SerializeField] TextMeshProUGUI phaseProgressText;
[SerializeField] Button advanceTickButton;

[SerializeField] Toggle wegoSystemToggle;
[SerializeField] TextMeshProUGUI systemModeText;

bool isWegoMode = true;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void Start() {
if (RunManager.Instance == null) {
Debug.LogError("[UIManager] RunManager.Instance not found! UI will not fn correctly.");
return;
}

RunManager.Instance.OnRunStateChanged += HandleRunStateChanged;

if (TurnPhaseManager.Instance != null) {
TurnPhaseManager.Instance.OnPhaseChanged += HandleWegoPhaseChanged;
}

if (TickManager.Instance != null) {
TickManager.Instance.OnTickAdvanced += HandleTickAdvanced;
}

SetupButtons();
SetupWegoControls();
HandleRunStateChanged(RunManager.Instance.CurrentState);
UpdateWegoUI();
}

void OnDestroy() {
if (RunManager.Instance != null) {
RunManager.Instance.OnRunStateChanged -= HandleRunStateChanged;
}

if (TurnPhaseManager.Instance != null) {
TurnPhaseManager.Instance.OnPhaseChanged -= HandleWegoPhaseChanged;
}

if (TickManager.Instance != null) {
TickManager.Instance.OnTickAdvanced -= HandleTickAdvanced;
}
}

void Update() {
if (!isWegoMode) return;

if (Input.GetKeyDown(KeyCode.Space)) {
if (TurnPhaseManager.Instance?.IsInPlanningPhase == true) {
OnEndPlanningPhaseClicked();
}
else {
Debug.Log("[UIManager] Time only advances through player actions!");
}
}

if (Input.GetKeyDown(KeyCode.R)) {
if (Application.isEditor || Debug.isDebugBuild) {
TurnPhaseManager.Instance?.ForcePhase(TurnPhase.Planning);
}
}

if (Time.frameCount % 10 == 0) // Update every 10 frames to reduce overhead {
UpdateWegoUI();
}
}

void SetupButtons() {
if (startGrowthPhaseButton != null)
startGrowthPhaseButton.onClick.AddListener(OnStartGrowthPhaseClicked);
if (startRecoveryPhaseButton != null)
startRecoveryPhaseButton.onClick.AddListener(OnStartRecoveryPhaseClicked);
if (startNewPlanningPhaseButton != null)
startNewPlanningPhaseButton.onClick.AddListener(OnStartNewPlanningPhaseClicked);

if (endPlanningPhaseButton != null)
endPlanningPhaseButton.onClick.AddListener(OnEndPlanningPhaseClicked);
if (advanceTickButton != null)
advanceTickButton.onClick.AddListener(OnAdvanceTickClicked);
}

void SetupWegoControls() {
if (wegoSystemToggle != null) {
wegoSystemToggle.isOn = isWegoMode;
wegoSystemToggle.onValueChanged.AddListener(OnWegoSystemToggled);
}

if (autoAdvanceToggle != null) {
autoAdvanceToggle.gameObject.SetActive(false);
}

if (tickSpeedSlider != null) {
tickSpeedSlider.gameObject.SetActive(false);
}
}

void HandleRunStateChanged(RunState newState) {
if (planningPanel != null) planningPanel.SetActive(newState == RunState.Planning);
if (growthAndThreatPanel != null) growthAndThreatPanel.SetActive(newState == RunState.GrowthAndThreat);

if (recoveryPanel != null) {
recoveryPanel.SetActive(false);
}

if (nodeEditorPanel != null) nodeEditorPanel.SetActive(newState == RunState.Planning);

if (InventoryGridController.Instance != null) {
InventoryGridController.Instance.gameObject.SetActive(newState == RunState.Planning);
}

if (newState == RunState.GrowthAndThreat) {
if (InventoryBarController.Instance != null)
StartCoroutine(ShowInventoryBarDelayed());
}
else {
if (InventoryBarController.Instance != null)
InventoryBarController.Instance.HideBar();
}

UpdateButtonStates(newState);
UpdateWegoUI();
}

void HandleWegoPhaseChanged(TurnPhase oldPhase, TurnPhase newPhase) {
UpdateWegoUI();
}

void HandleTickAdvanced(int currentTick) {
UpdateWegoUI();
}

void UpdateButtonStates(RunState state) {
if (startGrowthPhaseButton != null) {
startGrowthPhaseButton.interactable = (state == RunState.Planning);
}

if (startRecoveryPhaseButton != null) {
startRecoveryPhaseButton.gameObject.SetActive(false);
}

if (startNewPlanningPhaseButton != null) {
startNewPlanningPhaseButton.interactable = (state == RunState.GrowthAndThreat);
}

if (endPlanningPhaseButton != null && TurnPhaseManager.Instance != null) {
endPlanningPhaseButton.interactable = TurnPhaseManager.Instance.IsInPlanningPhase;
}

if (advanceTickButton != null && TurnPhaseManager.Instance != null) {
advanceTickButton.interactable = !TurnPhaseManager.Instance.IsInPlanningPhase;
}
}

pub void SetWegoMovement(bool enabled) {
Debug.Log($"[UIManager] SetWegoMovement called with: {enabled}. This method is now obsolete.");
}

void UpdateWegoUI() {
if (systemModeText != null) {
systemModeText.text = isWegoMode ? "Wego Mode" : "Real-Time Mode";
}

if (wegoControlPanel != null) {
wegoControlPanel.SetActive(isWegoMode);
}

if (!isWegoMode) return;

if (currentPhaseText != null && TurnPhaseManager.Instance != null) {
TurnPhase currentPhase = TurnPhaseManager.Instance.CurrentPhase;
currentPhaseText.text = $"Phase: {currentPhase}";
}

if (tickCounterText != null && TickManager.Instance != null) {
tickCounterText.text = $"Tick: {TickManager.Instance.CurrentTick}";
}

if (phaseProgressText != null && TurnPhaseManager.Instance != null) {
int currentPhaseTicks = TurnPhaseManager.Instance.CurrentPhaseTicks;

phaseProgressText.text = $"Phase Ticks: {currentPhaseTicks}";
}

UpdateButtonStates(RunManager.Instance?.CurrentState ?? RunState.Planning);
}

IEnumerator ShowInventoryBarDelayed() {
yield ret null; // Wait one frame
InventoryBarController.Instance?.ShowBar();
}

void AutoReturnSeedFromEditorSlot() {
if (NodeEditorGridController.Instance == null || InventoryGridController.Instance == null) return;

var editor = NodeEditorGridController.Instance;
var seedCell = editor.SeedSlotCell;

if (seedCell == null || !seedCell.HasItem()) return;

editor.RefreshGraphAndUpdateSeed();

ItemView seedView = seedCell.GetItemView();
NodeData seedData = seedCell.GetNodeData();
if (seedView == null || seedData == null) return;

editor.UnloadSeedFromSlot();

InventoryGridController.Instance.ReturnGeneToInventory(seedView, seedData);

seedCell.ClearNodeReference();
Debug.Log($"[UIManager] Auto-returned seed \"{seedData.nodeDisplayName}\" to inventory.");
}

void OnStartGrowthPhaseClicked() {
AutoReturnSeedFromEditorSlot();
RunManager.Instance?.StartGrowthAndThreatPhase();
}

void OnStartRecoveryPhaseClicked() {
RunManager.Instance?.StartRecoveryPhase();
}

void OnStartNewPlanningPhaseClicked() {
RunManager.Instance?.StartNewPlanningPhase();
}

void OnEndPlanningPhaseClicked() {
if (TurnPhaseManager.Instance != null) {
AutoReturnSeedFromEditorSlot();
TurnPhaseManager.Instance.EndPlanningPhase();
}
}

void OnAdvanceTickClicked() {
TickManager.Instance?.DebugAdvanceTick();
}

void OnWegoSystemToggled(bool enabled) {
isWegoMode = enabled;

if (RunManager.Instance != null) {
RunManager.Instance.SetWegoSystem(enabled);
}

if (WeatherManager.Instance != null) {
WeatherManager.Instance.SetWegoSystem(enabled);
}

foreach (var plant in PlantGrowth.AllActivePlants) {
if (plant != null) {
plant.SetWegoSystem(enabled);
}
}

UpdateWegoUI();

Debug.Log($"[UIManager] Switched to {(enabled ? "Wego" : "Real-Time")} mode");
}

pub void SetWegoMode(bool enabled) {
if (wegoSystemToggle != null) {
wegoSystemToggle.isOn = enabled;
}
else {
OnWegoSystemToggled(enabled);
}
}

pub bool IsWegoMode() {
ret isWegoMode;
}

pub void ShowNotification(string message, float duration = 3f) {
StartCoroutine(ShowNotificationCoroutine(message, duration));
}

IEnumerator ShowNotificationCoroutine(string message, float duration) {
GameObject notification = new GameObject("Notification");
notification.transform.SetParent(transform, false);

var canvasGroup = notification.AddComponent<CanvasGroup>();
var rectTransform = notification.AddComponent<RectTransform>();
var image = notification.AddComponent<Image>();
var text = notification.AddComponent<TextMeshProUGUI>();

rectTransform.anchorMin = new Vector2(0.5f, 0.8f);
rectTransform.anchorMax = new Vector2(0.5f, 0.8f);
rectTransform.sizeDelta = new Vector2(300, 60);

image.color = new Color(0, 0, 0, 0.8f);
text.text = message;
text.color = Color.white;
text.alignment = TextAlignmentOptions.Center;
text.fontSize = 16;

float elapsedTime = 0f;
while (elapsedTime < 0.5f) {
canvasGroup.alpha = elapsedTime / 0.5f;
elapsedTime += Time.deltaTime;
yield ret null;
}
canvasGroup.alpha = 1f;

yield ret new WaitForSeconds(duration - 1f);

elapsedTime = 0f;
while (elapsedTime < 0.5f) {
canvasGroup.alpha = 1f - (elapsedTime / 0.5f);
elapsedTime += Time.deltaTime;
yield ret null;
}

Destroy(notification);
}

pub void DebugToggleWegoMode() {
if (Application.isEditor || Debug.isDebugBuild) {
SetWegoMode(!isWegoMode);
}
}

pub void DebugForcePhase(TurnPhase phase) {
if (Application.isEditor || Debug.isDebugBuild) {
TurnPhaseManager.Instance?.ForcePhase(phase);
}
}

pub void DebugAdvanceMultipleTicks(int count) {
if (Application.isEditor || Debug.isDebugBuild) {
TickManager.Instance?.AdvanceMultipleTicks(count);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\WeatherManager.cs

﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using WegoSystem;

pub cls WeatherManager : MonoBehaviour, ITickUpdateable {
pub stat WeatherManager Instance { get; set; }

[SerializeField] bool useWegoSystem = true;

pub enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }

pub bool dayNightCycleEnabled = true;
pub AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);
pub float sunIntensity = 1f;
pub float fixedSunIntensity = 1f;
pub SpriteRenderer fadeSprite;
pub float minAlpha = 0f;
pub float maxAlpha = 1f;

pub bool IsPaused { get; set; } = false;

int currentPhaseTicks = 0;
int totalPhaseTicksTarget = 0;
bool forceDaylight = false;

pub CyclePhase CurrentPhase => currentPhase;
pub event Action<CyclePhase> OnPhaseChanged;

CyclePhase currentPhase = CyclePhase.Day;

pub float CurrentTotalPhaseTime => totalPhaseTicksTarget * (TickManager.Instance?.Config?.GetRealSecondsPerTick() ?? 0.5f);
pub float CurrentPhaseTimer => (totalPhaseTicksTarget - currentPhaseTicks) * (TickManager.Instance?.Config?.GetRealSecondsPerTick() ?? 0.5f);

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void Start() {
if (useWegoSystem && TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}

EnterPhase(CyclePhase.Day, true);
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
if (!useWegoSystem || !dayNightCycleEnabled || IsPaused) return;

if (TickManager.Instance?.Config != null) {
float dayProgress = TickManager.Instance.Config.GetDayProgressNormalized(currentTick);

CyclePhase newPhase = currentPhase;

if (dayProgress < 0.4f) {
newPhase = CyclePhase.Day;
sunIntensity = 1f;
} else if (dayProgress < 0.5f) {
newPhase = CyclePhase.TransitionToNight;
float transitionProgress = (dayProgress - 0.4f) / 0.1f;
sunIntensity = Mathf.Lerp(1f, 0f, transitionCurve.Evaluate(transitionProgress));
} else if (dayProgress < 0.9f) {
newPhase = CyclePhase.Night;
sunIntensity = 0f;
} else {
newPhase = CyclePhase.TransitionToDay;
float transitionProgress = (dayProgress - 0.9f) / 0.1f;
sunIntensity = Mathf.Lerp(0f, 1f, transitionCurve.Evaluate(transitionProgress));
}

if (newPhase != currentPhase) {
currentPhase = newPhase;
if (Debug.isDebugBuild) Debug.Log($"[WeatherManager] Phase Changed To: {currentPhase}");
OnPhaseChanged?.Invoke(currentPhase);
}
}

UpdateFadeSprite();
}

void Update() {
if (!IsPaused && !forceDaylight && !useWegoSystem) {
UpdateSunIntensity();
}
UpdateFadeSprite();
}

void AdvanceToNextPhase() {
CyclePhase nextPhase = currentPhase;
switch (currentPhase) {
case CyclePhase.Day: nextPhase = CyclePhase.TransitionToNight; break;
case CyclePhase.TransitionToNight: nextPhase = CyclePhase.Night; break;
case CyclePhase.Night: nextPhase = CyclePhase.TransitionToDay; break;
case CyclePhase.TransitionToDay: nextPhase = CyclePhase.Day; break;
}
EnterPhase(nextPhase);
}

void EnterPhase(CyclePhase nextPhase, bool forceEvent = false) {
CyclePhase previousPhase = currentPhase;
currentPhase = nextPhase;

if (TickManager.Instance?.Config != null) {
var config = TickManager.Instance.Config;
switch (nextPhase) {
case CyclePhase.Day:
totalPhaseTicksTarget = config.dayPhaseTicks;
break;
case CyclePhase.Night:
totalPhaseTicksTarget = config.nightPhaseTicks;
break;
case CyclePhase.TransitionToNight:
case CyclePhase.TransitionToDay:
totalPhaseTicksTarget = config.transitionTicks;
break;
}
currentPhaseTicks = 0;
}

UpdateSunIntensity();

if (previousPhase != currentPhase || forceEvent) {
if (Debug.isDebugBuild) Debug.Log($"[WeatherManager] Phase Changed To: {currentPhase}");
OnPhaseChanged?.Invoke(currentPhase);
}
}

void UpdateSunIntensity() {
if (forceDaylight && IsPaused) {
sunIntensity = 1.0f;
return;
}

float progress = totalPhaseTicksTarget > 0 ? (float)currentPhaseTicks / totalPhaseTicksTarget : 0f;

switch (currentPhase) {
case CyclePhase.Day:
sunIntensity = 1f;
break;
case CyclePhase.TransitionToNight:
sunIntensity = Mathf.Lerp(1f, 0f, transitionCurve.Evaluate(progress));
break;
case CyclePhase.Night:
sunIntensity = 0f;
break;
case CyclePhase.TransitionToDay:
sunIntensity = Mathf.Lerp(0f, 1f, transitionCurve.Evaluate(progress));
break;
}
sunIntensity = Mathf.Clamp01(sunIntensity);
}

void UpdateFadeSprite() {
if (fadeSprite != null) {
float alpha = Mathf.Lerp(maxAlpha, minAlpha, sunIntensity);
Color c = fadeSprite.color;
c.a = alpha;
fadeSprite.color = c;
}
}

pub void PauseCycleAtDay() {
Debug.Log("[WeatherManager] PauseCycleAtDay called.");
IsPaused = true;
forceDaylight = true;
sunIntensity = 1.0f;
UpdateFadeSprite();
OnPhaseChanged?.Invoke(CyclePhase.Day);
}

pub void ResumeCycle() {
Debug.Log("[WeatherManager] ResumeCycle called.");
IsPaused = false;
forceDaylight = false;
}

pub void PauseCycle() {
Debug.Log("[WeatherManager] PauseCycle called.");
IsPaused = true;
forceDaylight = false;
}

pub void SetWegoSystem(bool enabled) {
bool wasEnabled = useWegoSystem;
useWegoSystem = enabled;

if (enabled && !wasEnabled && TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
} else if (!enabled && wasEnabled && TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

pub float GetPhaseProgress() {
ret totalPhaseTicksTarget > 0 ? (float)currentPhaseTicks / totalPhaseTicksTarget : 0f;
}

pub int GetCurrentPhaseTicks() {
ret currentPhaseTicks;
}

pub int GetTotalPhaseTicksTarget() {
ret totalPhaseTicksTarget;
}

pub void ForcePhase(CyclePhase phase) {
if (Application.isEditor || Debug.isDebugBuild) {
EnterPhase(phase, true);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalController.cs

﻿using UnityEngine;
using TMPro;
using WegoSystem;

pub cls AnimalController : MonoBehaviour, ITickUpdateable {
[SerializeField] pub AnimalDefinition definition;
[SerializeField] GameObject thoughtBubblePrefab;
[SerializeField] Transform bubbleSpawnTransform;
[SerializeField] Transform poopSpawnPoint;
[SerializeField] List<GameObject> poopPrefabs;
[SerializeField] Animator animator;

[SerializeField] TextMeshProUGUI hpText;
[SerializeField] TextMeshProUGUI hungerText;
[SerializeField] KeyCode showStatsKey = KeyCode.LeftAlt;

AnimalDiet animalDiet;
GridEntity gridEntity;
AnimalThoughtLibrary thoughtLibrary;

pub int thinkingTickInterval = 3;  // Add this field

GridPosition targetPosition;
GameObject currentTargetFood = null;
bool hasPlannedAction = false;
int lastThinkTick = 0;
List<GridPosition> currentPath = new List<GridPosition>();
int currentPathIndex = 0;

int hungerTick = 0;
int poopDelayTick = 0;
int currentPoopCooldownTick = 0;
int thoughtCooldownTick = 0;
int eatRemainingTicks = 0;
int starvationTick = 0;
int deathFadeRemainingTicks = 0;
int flashRemainingTicks = 0;
int wanderPauseTicks = 0;

float currentHealth;
float currentHunger;
bool isEating = false;
bool isPooping = false;
bool hasPooped = true;
bool isDying = false;
bool isWanderPaused = false;
bool isFlashing = false;

bool isSeekingScreenCenter = false;
Vector2 screenCenterTarget;
Vector2 minBounds;
Vector2 maxBounds;

Rigidbody2D rb;
SpriteRenderer spriteRenderer;
Collider2D animalCollider;
Color originalColor;

pub float CurrentHealth => currentHealth;
pub string SpeciesName => definition ? definition.animalName : "Uninitialized";

void Awake() {
ValidateComponents();
CacheComponents();
}

void Start() {
if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
Debug.Log($"[AnimalController] {gameObject.name} snapped to grid position {gridEntity.Position}");
}

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

void ValidateComponents() {
if (definition == null) {
Debug.LogError($"[{gameObject.name}] Missing AnimalDefinition!", this);
enabled = false;
return;
}

animalDiet = definition.diet;
if (animalDiet == null) {
Debug.LogError($"[{gameObject.name}] AnimalDefinition missing diet!", this);
enabled = false;
return;
}
}

void CacheComponents() {
rb = GetComponent<Rigidbody2D>();
spriteRenderer = GetComponentInChildren<SpriteRenderer>();
animalCollider = GetComponent<Collider2D>();
gridEntity = GetComponent<GridEntity>();

if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}

if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}

if (animalCollider == null) {
Debug.LogError($"[{gameObject.name}] Missing Collider2D!", this);
enabled = false;
}
}

pub void Initialize(AnimalDefinition def, Vector2 shiftedMinBounds, Vector2 shiftedMaxBounds, bool spawnedOffscreen = false) {
definition = def;
if (definition == null) {
Destroy(gameObject);
return;
}

ValidateComponents();

currentHealth = definition.maxHealth;
currentHunger = 0f;
hasPooped = true;

poopDelayTick = Random.Range(definition.minPoopDelayTicks, definition.maxPoopDelayTicks);
thoughtCooldownTick = 0;

minBounds = shiftedMinBounds;
maxBounds = shiftedMaxBounds;
screenCenterTarget = (minBounds + maxBounds) / 2f;

isSeekingScreenCenter = spawnedOffscreen;
if (isSeekingScreenCenter && gridEntity != null) {
GridPosition targetGridPos = GridPositionManager.Instance.WorldToGrid(screenCenterTarget);
hasPlannedAction = true;
targetPosition = targetGridPos;
}

EnsureUITextReferences();
SetStatsTextVisibility(false);
UpdateUI();
}

pub void OnTickUpdate(int currentTick) {
if (isDying) return;

hungerTick++;
if (poopDelayTick > 0) poopDelayTick--;
if (thoughtCooldownTick > 0) thoughtCooldownTick--;
if (currentPoopCooldownTick > 0) currentPoopCooldownTick--;
if (eatRemainingTicks > 0) eatRemainingTicks--;
if (wanderPauseTicks > 0) wanderPauseTicks--;
if (flashRemainingTicks > 0) flashRemainingTicks--;

if (TickManager.Instance?.Config != null) {
if (hungerTick >= TickManager.Instance.Config.animalHungerTickInterval) {
UpdateHungerTick();
hungerTick = 0;
}
}

if (currentHunger >= animalDiet.maxHunger) {
starvationTick++;
if (starvationTick >= definition.starvationDamageTickInterval) {
ApplyStarvationDamage();
starvationTick = 0;
}
}

if (isEating && eatRemainingTicks <= 0) {
FinishEating();
}

if (!hasPooped && poopDelayTick <= 0 && currentPoopCooldownTick <= 0 && !isEating) {
TryPoop();
}

if (currentTick - lastThinkTick >= definition.thinkingTickInterval) {
MakeDecision();
lastThinkTick = currentTick;
}

if (hasPlannedAction && !isEating && !isPooping && wanderPauseTicks <= 0) {
ExecutePlannedAction();
}

if (deathFadeRemainingTicks > 0) {
deathFadeRemainingTicks--;
UpdateDeathFade();
if (deathFadeRemainingTicks <= 0) {
Destroy(gameObject);
}
}

UpdateAnimations();
UpdateFlashEffect();
}

void MakeDecision() {
if (isSeekingScreenCenter) {
HandleScreenCenterSeeking();
return;
}

if (currentHunger >= animalDiet.hungerThreshold) {
PlanFoodSeeking();
} else {
PlanWandering();
}
}

void HandleScreenCenterSeeking() {
if (gridEntity == null) return;

Vector2 currentPos = transform.position;
bool centerWithinBounds = currentPos.x >= minBounds.x && currentPos.x <= maxBounds.x &&
currentPos.y >= minBounds.y && currentPos.y <= maxBounds.y;

if (centerWithinBounds) {
isSeekingScreenCenter = false;
hasPlannedAction = false;
} else {
GridPosition currentGridPos = gridEntity.Position;
GridPosition targetGridPos = GridPositionManager.Instance.WorldToGrid(screenCenterTarget);
PlanMovementToward(targetGridPos);
}
}

void PlanFoodSeeking() {
if (CanShowThought()) ShowThought(ThoughtTrigger.Hungry);

GameObject nearestFood = FindNearestFoodInGrid();
if (nearestFood != null) {
currentTargetFood = nearestFood;
GridPosition foodGridPos = GridPositionManager.Instance.WorldToGrid(nearestFood.transform.position);

currentPath = GridPositionManager.Instance.GetPath(gridEntity.Position, foodGridPos);
currentPathIndex = 0;

if (currentPath.Count > 0) {
hasPlannedAction = true;
targetPosition = currentPath[0];
} else {
PlanMovementToward(foodGridPos);
}
} else {
PlanWandering();
}
}

void PlanWandering() {
if (gridEntity == null) return;

if (Random.Range(0, 100) < definition.wanderPauseTickChance) {
isWanderPaused = true;
wanderPauseTicks = Random.Range(definition.minWanderPauseTicks, definition.maxWanderPauseTicks);
hasPlannedAction = false;
return;
}

GridPosition currentPos = gridEntity.Position;
GridPosition[] directions = {
GridPosition.Up, GridPosition.Down,
GridPosition.Left, GridPosition.Right
};

for (int i = 0; i < 3; i++) {
GridPosition randomDir = directions[Random.Range(0, directions.Length)];
GridPosition targetPos = currentPos + randomDir;

if (IsValidMove(targetPos)) {
targetPosition = targetPos;
hasPlannedAction = true;
wanderPauseTicks = Random.Range(definition.minWanderMoveTicks, definition.maxWanderMoveTicks);
break;
}
}
}

void PlanMovementToward(GridPosition target) {
if (gridEntity == null) return;

GridPosition currentPos = gridEntity.Position;
int dx = Mathf.Clamp(target.x - currentPos.x, -1, 1);
int dy = Mathf.Clamp(target.y - currentPos.y, -1, 1);

if (dx != 0 && dy != 0) {
GridPosition diagonalTarget = currentPos + new GridPosition(dx, dy);
if (IsValidMove(diagonalTarget)) {
targetPosition = diagonalTarget;
hasPlannedAction = true;
return;
}
}

if (dx != 0) {
GridPosition horizontalTarget = currentPos + new GridPosition(dx, 0);
if (IsValidMove(horizontalTarget)) {
targetPosition = horizontalTarget;
hasPlannedAction = true;
return;
}
}

if (dy != 0) {
GridPosition verticalTarget = currentPos + new GridPosition(0, dy);
if (IsValidMove(verticalTarget)) {
targetPosition = verticalTarget;
hasPlannedAction = true;
return;
}
}

PlanWandering();
}

bool IsValidMove(GridPosition pos) {
ret GridPositionManager.Instance.IsPositionValid(pos) &&
!GridPositionManager.Instance.IsPositionOccupied(pos);
}

void ExecutePlannedAction() {
if (gridEntity == null) return;

if (currentTargetFood != null && targetPosition == gridEntity.Position) {
GridPosition foodPos = GridPositionManager.Instance.WorldToGrid(currentTargetFood.transform.position);
int distance = gridEntity.Position.ManhattanDistance(foodPos);

if (distance <= definition.eatDistanceTiles) {
StartEating();
return;
}
}

if (targetPosition != gridEntity.Position) {
gridEntity.SetPosition(targetPosition);

if (currentPath.Count > 0 && currentPathIndex < currentPath.Count - 1) {
currentPathIndex++;
targetPosition = currentPath[currentPathIndex];
hasPlannedAction = true;
return;
}
}

hasPlannedAction = false;
}

GameObject FindNearestFoodInGrid() {
if (animalDiet == null) ret null;

var tilesInRange = GridRadiusUtility.GetTilesInCircle(gridEntity.Position, definition.searchRadiusTiles);

GameObject bestFood = null;
float bestScore = -1f;

if (GridDebugVisualizer.Instance != null && Debug.isDebugBuild) {
GridDebugVisualizer.Instance.VisualizeAnimalSearchRadius(this, gridEntity.Position, definition.searchRadiusTiles);
}

foreach (var tilePos in tilesInRange) {
var entitiesAtTile = GridPositionManager.Instance.GetEntitiesAt(tilePos);

foreach (var entity in entitiesAtTile) {
if (entity == null || entity.gameObject == this.gameObject) continue;

FoodItem foodItem = entity.GetComponent<FoodItem>();
if (foodItem != null && foodItem.foodType != null && animalDiet.CanEat(foodItem.foodType)) {
var pref = animalDiet.GetPreference(foodItem.foodType);
if (pref == null) continue;

float distance = entity.Position.ManhattanDistance(gridEntity.Position);
float score = pref.preferencePriority / (1f + distance);

if (score > bestScore) {
bestScore = score;
bestFood = entity.gameObject;
}
}
}
}

ret bestFood;
}

void StartEating() {
isEating = true;
eatRemainingTicks = definition.eatDurationTicks;
if (CanShowThought()) ShowThought(ThoughtTrigger.Eating);
}

void FinishEating() {
isEating = false;

if (currentTargetFood == null) return;

FoodItem foodItem = currentTargetFood.GetComponent<FoodItem>();
if (foodItem != null && foodItem.foodType != null) {
float satiationGain = animalDiet.GetSatiationValue(foodItem.foodType);
currentHunger -= satiationGain;
currentHunger = Mathf.Max(0f, currentHunger);

Destroy(currentTargetFood);
hasPooped = false;
poopDelayTick = Random.Range(definition.minPoopDelayTicks, definition.maxPoopDelayTicks);
currentTargetFood = null;
UpdateUI();
}
}

void UpdateHungerTick() {
if (animalDiet == null) return;

currentHunger += animalDiet.hungerIncreaseRate;
currentHunger = Mathf.Min(currentHunger, animalDiet.maxHunger);
UpdateUI();
}

void TryPoop() {
if (isEating || isPooping) return;

isPooping = true;
currentPoopCooldownTick = definition.poopCooldownTicks;
SpawnPoop();
hasPooped = true;
isPooping = false;

if (CanShowThought()) ShowThought(ThoughtTrigger.Pooping);
}

void SpawnPoop() {
if (poopPrefabs == null || poopPrefabs.Count == 0) return;

int index = Random.Range(0, poopPrefabs.Count);
GameObject prefab = poopPrefabs[index];
if (prefab == null) return;

Transform spawnT = poopSpawnPoint ? poopSpawnPoint : transform;
GameObject poopObj = Instantiate(prefab, spawnT.position, Quaternion.identity);

SpriteRenderer sr = poopObj.GetComponent<SpriteRenderer>();
if (sr != null) {
sr.flipX = Random.value > 0.5f;
Color c = sr.color;
float v = definition.poopColorVariation;
sr.color = new Color(
Mathf.Clamp01(c.r + Random.Range(-v, v)),
Mathf.Clamp01(c.g + Random.Range(-v, v)),
Mathf.Clamp01(c.b + Random.Range(-v, v)),
c.a
);
}

PoopController pc = poopObj.GetComponent<PoopController>() ?? poopObj.AddComponent<PoopController>();
pc.Initialize();
}

void ApplyStarvationDamage() {
currentHealth -= definition.damagePerStarvationTick;
currentHealth = Mathf.Max(0f, currentHealth);

if (!isFlashing) {
flashRemainingTicks = definition.damageFlashTicks;
isFlashing = true;
}

UpdateUI();

if (currentHealth <= 0f) {
Die(CauseOfDeath.Starvation);
}
}

void UpdateFlashEffect() {
if (flashRemainingTicks > 0 && spriteRenderer != null) {
spriteRenderer.color = definition.damageFlashColor;
} else if (isFlashing && spriteRenderer != null) {
spriteRenderer.color = originalColor;
isFlashing = false;
}
}

pub enum CauseOfDeath { Unknown, Starvation, EatenByPredator }

void Die(CauseOfDeath cause) {
Debug.Log($"[{SpeciesName}] died: {cause}", gameObject);
isDying = true;
deathFadeRemainingTicks = definition.deathFadeTicks;
}

void UpdateDeathFade() {
if (spriteRenderer != null && definition.deathFadeTicks > 0) {
float alpha = (float)deathFadeRemainingTicks / definition.deathFadeTicks;
Color c = spriteRenderer.color;
c.a = alpha;
spriteRenderer.color = c;
}
}

bool CanShowThought() {
ret thoughtLibrary != null && thoughtBubblePrefab != null && thoughtCooldownTick <= 0;
}

void ShowThought(ThoughtTrigger trigger) {
if (thoughtLibrary == null || thoughtLibrary.allThoughts == null) return;

var entry = thoughtLibrary.allThoughts.FirstOrDefault(t =>
t != null && t.speciesName == SpeciesName && t.trigger == trigger
);

if (entry != null && entry.lines != null && entry.lines.Count > 0) {
string line = entry.lines[Random.Range(0, entry.lines.Count)];
Transform spawnT = bubbleSpawnTransform ? bubbleSpawnTransform : transform;
GameObject bubbleGO = Instantiate(thoughtBubblePrefab, spawnT.position, Quaternion.identity, spawnT);

ThoughtBubbleController bubble = bubbleGO.GetComponent<ThoughtBubbleController>();
if (bubble) {
bubble.Initialize(line, spawnT, 2f);
thoughtCooldownTick = definition.thoughtCooldownTicks;
} else {
Destroy(bubbleGO);
}
}
}

void Update() {
if (!enabled || isDying) return;

bool showStats = Input.GetKey(showStatsKey);
SetStatsTextVisibility(showStats);

UpdateSpriteFlipping();
}

void UpdateSpriteFlipping() {
if (spriteRenderer != null && gridEntity != null && gridEntity.IsMoving) {
Vector3 currentPos = transform.position;
Vector3 targetPos = GridPositionManager.Instance.GridToWorld(targetPosition);
Vector2 moveDirection = (targetPos - currentPos).normalized;

if (Mathf.Abs(moveDirection.x) > 0.01f) {
spriteRenderer.flipX = moveDirection.x < 0;
}
}
}

void UpdateAnimations() {
if (animator == null) return;
bool isMoving = gridEntity != null && gridEntity.IsMoving && !isEating && !isPooping;
animator.SetBool("IsMoving", isMoving);
animator.SetBool("IsEating", isEating);
}

void UpdateUI() {
UpdateHpText();
UpdateHungerText();
}

void UpdateHpText() {
if (hpText == null || definition == null) return;
hpText.text = $"HP: {Mathf.FloorToInt(currentHealth)}/{Mathf.FloorToInt(definition.maxHealth)}";
}

void UpdateHungerText() {
if (hungerText == null || animalDiet == null) return;
hungerText.text = $"Hunger: {Mathf.FloorToInt(currentHunger)}/{Mathf.FloorToInt(animalDiet.maxHunger)}";
}

void EnsureUITextReferences() {
if (hpText == null) {
hpText = GetComponentInChildren<TextMeshProUGUI>(true);
if (hpText != null && hpText.gameObject.name.Contains("Hunger")) {
hungerText = hpText;
hpText = null;
}
}

if (hungerText == null) {
TextMeshProUGUI[] allTexts = GetComponentsInChildren<TextMeshProUGUI>(true);
foreach (var text in allTexts) {
if (text != hpText) {
hungerText = text;
break;
}
}
}
}

void SetStatsTextVisibility(bool visible) {
if (hpText != null) hpText.gameObject.SetActive(visible);
if (hungerText != null) hungerText.gameObject.SetActive(visible);
}

pub GridPosition GetCurrentGridPosition() {
ret gridEntity?.Position ?? GridPosition.Zero;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs

﻿using UnityEngine;

pub cls AnimalDefinition : ScriptableObject {
pub string animalName = "DefaultAnimal";
pub GameObject prefab;

pub float maxHealth = 10f;
pub float movementSpeed = 2f; // Grid units per tick

pub int thinkingTickInterval = 3;
pub int wanderPauseTickChance = 30; // Percentage
pub int minWanderMoveTicks = 2;
pub int maxWanderMoveTicks = 6;
pub int minWanderPauseTicks = 1;
pub int maxWanderPauseTicks = 4;

pub int searchRadiusTiles = 5; // In grid tiles
pub int eatDistanceTiles = 1; // Must be adjacent

pub int eatDurationTicks = 3;
pub int thoughtCooldownTicks = 10;
pub int starvationDamageTickInterval = 4;
pub float damagePerStarvationTick = 2f;
pub int deathFadeTicks = 3;

pub int minPoopDelayTicks = 10;
pub int maxPoopDelayTicks = 20;
pub int poopCooldownTicks = 2;

pub float poopColorVariation = 0.1f;
pub Color damageFlashColor = Color.red;
pub int damageFlashTicks = 1;

pub AnimalDiet diet;

pub List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();
pub List<ScentDefinition> repellentScentDefinitions = new List<ScentDefinition>();
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs

﻿using UnityEngine;

pub cls AnimalLibrary : ScriptableObject {
pub List<AnimalDefinition> animals;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalSpawnData.cs

﻿using UnityEngine;

pub cls AnimalSpawnData {
pub AnimalDefinition animalDefinition;
pub float spawnRateMultiplier = 1f;
pub int maximumSpawned = 0;

pub float spawnTimer = 0f;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalThoughtLibrary.cs

﻿using System.Collections.Generic;

pub cls AnimalThoughtLibrary : ScriptableObject {
pub List<AnimalThoughtLine> allThoughts;
}

pub cls AnimalThoughtLine {
pub string speciesName; // e.g. "Bunny", "Fox", "Bird"

pub ThoughtTrigger trigger;

pub List<string> lines;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyController.cs

﻿// Assets\Scripts\Ecosystem\Effects\FireflyController.cs
using WegoSystem;
using UnityEngine.Rendering.Universal;

pub cls FireflyController : MonoBehaviour, ITickUpdateable {
[SerializeField] FireflyDefinition definition;
[SerializeField] Light2D glowLight;
[SerializeField] SpriteRenderer spriteRenderer;
[SerializeField] TrailRenderer trailRenderer;
[SerializeField] ParticleSystem glowParticles;

GridEntity gridEntity;
int currentAgeTicks = 0;
int lifetimeTicks;
int lastMovementTick = 0;
int spawnEffectRemainingTicks = 0;

Vector3 currentTileCenter;
Vector3 localTargetPosition;
float localMovementAngle;
float currentLocalSpeed;
float tileSize = 1f;
float maxLocalOffset;

float baseGlowIntensity;
float currentGlowIntensity;
float glowFlickerTime;

Color originalColor;

pub bool IsAlive { get; set; } = true;
pub Transform AttractionTarget { get; set; }

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}

if (glowLight != null) {
baseGlowIntensity = glowLight.intensity;
currentGlowIntensity = baseGlowIntensity;
}

if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}

}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

pub void Initialize() {
if (definition == null) {
Debug.LogError("[FireflyController] No FireflyDefinition assigned!", this);
enabled = false;
return;
}

lifetimeTicks = Random.Range(definition.minLifetimeTicks, definition.maxLifetimeTicks + 1);

if (definition.useSpawnEffect) {
spawnEffectRemainingTicks = definition.spawnEffectTicks;
}

if (GridPositionManager.Instance != null) {
var grid = GridPositionManager.Instance.GetTilemapGrid();
if (grid != null) {
tileSize = grid.cellSize.x; // Assuming square tiles
maxLocalOffset = tileSize * definition.localMovementRadius;
}
}

UpdateTileCenter();
localMovementAngle = Random.Range(0f, 360f);
UpdateLocalTargetPosition();

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
}

ApplyVisualState(0f);
}

pub void OnTickUpdate(int currentTick) {
if (!IsAlive) return;

currentAgeTicks++;

if (currentAgeTicks >= lifetimeTicks) {
Die();
return;
}

UpdateLifetimeFade();

if (spawnEffectRemainingTicks > 0) {
spawnEffectRemainingTicks--;
}

if (currentTick - lastMovementTick >= definition.movementTickInterval) {
MakeMovementDecision();
lastMovementTick = currentTick;
}
}

void Update() {
if (!IsAlive) return;
UpdateLocalMovement();
HandleGlowAndFlicker();
}

void MakeMovementDecision() {
GridPosition bestPosition = gridEntity.Position;
float bestScore = EvaluateTile(gridEntity.Position);

var nearbyPositions = GridRadiusUtility.GetTilesInCircle(gridEntity.Position, definition.tileSearchRadius, true);

foreach (var pos in nearbyPositions) {
if (!GridPositionManager.Instance.IsPositionValid(pos) ||
GridPositionManager.Instance.IsPositionOccupied(pos)) {
continue;
}

float score = EvaluateTile(pos);
if (score > bestScore) {
bestScore = score;
bestPosition = pos;
}
}

if (bestPosition != gridEntity.Position) {
gridEntity.SetPosition(bestPosition);
UpdateTileCenter();
}
}

float EvaluateTile(GridPosition tilePos) {
float score = Random.Range(0f, 1f); // Base randomness

var tilesInRange = GridRadiusUtility.GetTilesInCircle(tilePos, definition.tileSearchRadius);

Transform bestTarget = null;
float bestTargetScore = 0f;

foreach (var checkPos in tilesInRange) {
Vector3 worldPos = GridPositionManager.Instance.GridToWorld(checkPos);
Collider2D[] hits = Physics2D.OverlapPointAll(worldPos);

foreach (var hit in hits) {
ScentSource scent = hit.GetComponent<ScentSource>();
if (scent != null && scent.definition != null &&
definition.attractiveScentDefinitions.Contains(scent.definition)) {
GridPosition scentGridPos = GridPositionManager.Instance.WorldToGrid(hit.transform.position);
int distance = tilePos.ManhattanDistance(scentGridPos);
float distanceScore = 1f - (distance / (float)definition.tileSearchRadius);
float scentScore = distanceScore * scent.EffectiveStrength;

if (scentScore > bestTargetScore) {
bestTargetScore = scentScore;
bestTarget = hit.transform;
}
}

PlantGrowth plant = hit.GetComponent<PlantGrowth>();
if (plant != null && plant.CurrentState == PlantState.Growing) {
score += definition.growingPlantAttraction;
}
}
}

this.AttractionTarget = bestTarget;
score += bestTargetScore * definition.scentAttractionWeight;

ret score;
}

void UpdateTileCenter() {
if (GridPositionManager.Instance != null) {
currentTileCenter = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
}
}

void UpdateLocalTargetPosition() {
localMovementAngle += Random.Range(-definition.localMovementTurnSpeed, definition.localMovementTurnSpeed) * Time.deltaTime;

Vector2 direction = new Vector2(Mathf.Cos(localMovementAngle * Mathf.Deg2Rad),
Mathf.Sin(localMovementAngle * Mathf.Deg2Rad));

float targetDistance = Random.Range(maxLocalOffset * 0.5f, maxLocalOffset);
localTargetPosition = currentTileCenter + (Vector3)(direction * targetDistance);

currentLocalSpeed = Random.Range(definition.minLocalSpeed, definition.maxLocalSpeed);
}

void UpdateLocalMovement() {
Vector3 toTarget = localTargetPosition - transform.position;
float distanceToTarget = toTarget.magnitude;

if (distanceToTarget < 0.1f) {
UpdateLocalTargetPosition();
}
else {
Vector3 movement = toTarget.normalized * currentLocalSpeed * Time.deltaTime;
Vector3 newPosition = transform.position + movement;
Vector3 fromCenter = newPosition - currentTileCenter;

if (fromCenter.magnitude > maxLocalOffset) {
fromCenter = fromCenter.normalized * maxLocalOffset;
newPosition = currentTileCenter + fromCenter;
UpdateLocalTargetPosition();
}
transform.position = newPosition;
}
}

void UpdateLifetimeFade() {
if (currentAgeTicks < definition.fadeInTicks) {
float fadeProgress = (float)currentAgeTicks / definition.fadeInTicks;
ApplyVisualState(fadeProgress);
}
else if (currentAgeTicks > lifetimeTicks - definition.fadeOutTicks) {
int fadeOutTicksElapsed = currentAgeTicks - (lifetimeTicks - definition.fadeOutTicks);
float fadeProgress = 1f - ((float)fadeOutTicksElapsed / definition.fadeOutTicks);
ApplyVisualState(fadeProgress);
}
else {
ApplyVisualState(1f);
}
}

void ApplyVisualState(float intensity) {
if (spriteRenderer != null) {
Color color = originalColor;
color.a = originalColor.a * intensity;
spriteRenderer.color = color;
}

if (glowLight != null) {
glowLight.intensity = baseGlowIntensity * intensity;
currentGlowIntensity = glowLight.intensity;
}

if (trailRenderer != null) {
Color startColor = trailRenderer.startColor;
Color endColor = trailRenderer.endColor;
startColor.a = intensity * 0.5f;
endColor.a = 0f;
trailRenderer.startColor = startColor;
trailRenderer.endColor = endColor;
}

if (glowParticles != null) {
var main = glowParticles.main;
Color particleColor = main.startColor.color;
particleColor.a = intensity * 0.7f;
main.startColor = particleColor;
}
}

void HandleGlowAndFlicker() {
if (glowLight == null || definition.glowFlickerAmount <= 0f) return;

glowFlickerTime += Time.deltaTime * definition.glowFlickerSpeed;
float flicker = Mathf.PerlinNoise(glowFlickerTime, 0f) * 2f - 1f;
glowLight.intensity = currentGlowIntensity + (flicker * definition.glowFlickerAmount);
}

void Die() {
IsAlive = false;

if (FireflyManager.Instance != null) {
FireflyManager.Instance.ReportFireflyDespawned(this);
}

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}

if (glowParticles != null) {
glowParticles.Stop();
Destroy(gameObject, glowParticles.main.duration);
}
else {
Destroy(gameObject);
}
}

void OnDrawGizmosSelected() {
if (definition == null) return;

Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
Gizmos.DrawWireSphere(transform.position, definition.tileSearchRadius * tileSize);

Gizmos.color = new Color(0f, 1f, 1f, 0.5f);
Gizmos.DrawWireSphere(currentTileCenter, maxLocalOffset);

Gizmos.color = Color.yellow;
Gizmos.DrawLine(transform.position, localTargetPosition);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyDefinition.cs

﻿// Assets\Scripts\Ecosystem\Effects\FireflyDefinition.cs

pub cls FireflyDefinition : ScriptableObject {
pub int movementTickInterval = 5;    // How often firefly decides to move tiles
pub int tileSearchRadius = 3;        // How far to look for attraction targets

pub float localMovementRadius = 0.4f; // Fraction of tile size for wander radius
pub float localMovementTurnSpeed = 90f; // Degrees per second
pub float minLocalSpeed = 0.5f;       // Units per second within tile
pub float maxLocalSpeed = 1.0f;       // Units per second within tile

pub int minLifetimeTicks = 40;
pub int maxLifetimeTicks = 90;
pub int fadeInTicks = 4;
pub int fadeOutTicks = 8;

pub float glowFlickerAmount = 0.2f;  // Intensity variance from base
pub float glowFlickerSpeed = 5.0f;   // How fast the glow flickers
pub bool useSpawnEffect = true;      // Use a visual effect on spawn
pub int spawnEffectTicks = 3;        // How long the spawn effect lasts

pub List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();
pub float scentAttractionWeight = 2.0f; // Multiplier for scent scores
pub float growingPlantAttraction = 1.0f; // Bonus score for being near a growing plant
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyManager.cs

﻿// Assets\Scripts\Ecosystem\Effects\FireflyManager.cs
using WegoSystem;

pub cls FireflyManager : MonoBehaviour, ITickUpdateable {
pub stat FireflyManager Instance { get; set; }

[SerializeField] WeatherManager weatherManager;
[SerializeField] GameObject fireflyPrefab;
[SerializeField] FireflyDefinition defaultFireflyDefinition;
[SerializeField] Transform fireflyParent;

[SerializeField] int maxFireflies = 50;
[SerializeField] int spawnIntervalTicks = 3;
[SerializeField] [Range(0f, 1f)] float nightThreshold = 0.25f;

[SerializeField] Vector2 spawnCenter = Vector2.zero;
[SerializeField] Vector2 spawnAreaSize = new Vector2(20f, 10f);

pub float photosynthesisRadius = 3f;
pub float photosynthesisIntensityPerFly = 0.05f;
pub float maxPhotosynthesisBonus = 0.5f;

[SerializeField] bool showAttractionLinesRuntime = false;
[SerializeField] Color attractionLineColorRuntime = Color.magenta;
[SerializeField] GameObject lineVisualizerPrefab;
[SerializeField] Transform lineContainer;

List<FireflyController> activeFireflies = new List<FireflyController>();
Dictionary<FireflyController, LineRenderer> activeLineVisualizers = new Dictionary<FireflyController, LineRenderer>();

int spawnTickCounter = 0;
bool isNight = false;

pub bool ShowAttractionLinesRuntime => showAttractionLinesRuntime;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

ValidateReferences();
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void OnDestroy() {
if (Instance == this) Instance = null;

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}

CleanupVisualizers();
}

void ValidateReferences() {
if (weatherManager == null) {
Debug.LogError($"[{nameof(FireflyManager)}] WeatherManager not assigned!", this);
enabled = false;
return;
}

if (fireflyPrefab == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab not assigned!", this);
enabled = false;
return;
}

if (defaultFireflyDefinition == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Default Firefly Definition not assigned!", this);
enabled = false;
return;
}

FireflyController controller = fireflyPrefab.GetComponent<FireflyController>();
if (controller == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing FireflyController script!", this);
enabled = false;
return;
}

if (fireflyParent == null) {
fireflyParent = transform;
}
}

pub void OnTickUpdate(int currentTick) {
isNight = weatherManager.sunIntensity <= nightThreshold;

if (isNight) {
spawnTickCounter++;
if (spawnTickCounter >= spawnIntervalTicks) {
TrySpawnFirefly();
spawnTickCounter = 0;
}
}
else {
spawnTickCounter = 0;
}

activeFireflies.RemoveAll(f => f == null || !f.IsAlive);
}

void Update() {
UpdateRuntimeLineVisualizers();
}

void TrySpawnFirefly() {
if (activeFireflies.Count >= maxFireflies) return;

GridPosition spawnGridPos = FindValidSpawnPosition();
if (spawnGridPos == GridPosition.Zero) return;

Vector3 spawnWorldPos = GridPositionManager.Instance.GridToWorld(spawnGridPos);

GameObject fireflyGO = Instantiate(fireflyPrefab, spawnWorldPos, Quaternion.identity, fireflyParent);
FireflyController controller = fireflyGO.GetComponent<FireflyController>();

if (controller != null) {
controller.Initialize(); // Corrected call with no parameters
activeFireflies.Add(controller);
}
}

GridPosition FindValidSpawnPosition() {
Vector2 minBounds = spawnCenter - spawnAreaSize * 0.5f;
Vector2 maxBounds = spawnCenter + spawnAreaSize * 0.5f;

GridPosition minGrid = GridPositionManager.Instance.WorldToGrid(minBounds);
GridPosition maxGrid = GridPositionManager.Instance.WorldToGrid(maxBounds);

for (int i = 0; i < 10; i++) // Try 10 times to find a spot {
int x = Random.Range(minGrid.x, maxGrid.x + 1);
int y = Random.Range(minGrid.y, maxGrid.y + 1);
GridPosition pos = new GridPosition(x, y);

if (GridPositionManager.Instance.IsPositionValid(pos) &&
!GridPositionManager.Instance.IsPositionOccupied(pos)) {
ret pos;
}
}

ret GridPosition.Zero; // Failed to find a spot
}

pub void ReportFireflyDespawned(FireflyController firefly) {
activeFireflies.Remove(firefly);

if (activeLineVisualizers.TryGetValue(firefly, out LineRenderer line)) {
if (line != null) Destroy(line.gameObject);
activeLineVisualizers.Remove(firefly);
}
}

pub int GetNearbyFireflyCount(Vector3 position, float radius) {
int count = 0;
float radiusSq = radius * radius;

for (int i = activeFireflies.Count - 1; i >= 0; i--) {
if (activeFireflies[i] == null) {
activeFireflies.RemoveAt(i);
continue;
}

if ((activeFireflies[i].transform.position - position).sqrMagnitude <= radiusSq) {
count++;
}
}

ret count;
}

void UpdateRuntimeLineVisualizers() {
if (!Application.isPlaying || !showAttractionLinesRuntime) {
CleanupVisualizers();
return;
}

var toRemove = new List<FireflyController>();
foreach (var kvp in activeLineVisualizers) {
if (kvp.Key == null || kvp.Value == null) {
toRemove.Add(kvp.Key);
continue;
}

Transform target = kvp.Key.AttractionTarget;
if (target != null) {
kvp.Value.enabled = true;
kvp.Value.SetPosition(0, kvp.Key.transform.position);
kvp.Value.SetPosition(1, target.position);
kvp.Value.startColor = attractionLineColorRuntime;
kvp.Value.endColor = attractionLineColorRuntime;
}
else {
kvp.Value.enabled = false;
}
}

foreach (var firefly in toRemove) {
if (activeLineVisualizers.TryGetValue(firefly, out var line) && line != null) {
Destroy(line.gameObject);
}
activeLineVisualizers.Remove(firefly);
}

if (lineVisualizerPrefab != null && lineContainer != null) {
foreach (var firefly in activeFireflies) {
if (firefly == null || activeLineVisualizers.ContainsKey(firefly)) continue;

if (firefly.AttractionTarget != null) {
GameObject lineGO = Instantiate(lineVisualizerPrefab, lineContainer);
LineRenderer newLine = lineGO.GetComponent<LineRenderer>();

if (newLine != null) {
newLine.SetPosition(0, firefly.transform.position);
newLine.SetPosition(1, firefly.AttractionTarget.position);
newLine.startColor = attractionLineColorRuntime;
newLine.endColor = attractionLineColorRuntime;
newLine.enabled = true;
activeLineVisualizers.Add(firefly, newLine);
}
else {
Debug.LogError($"Line Visualizer Prefab missing LineRenderer!", lineVisualizerPrefab);
Destroy(lineGO);
}
}
}
}
}

void CleanupVisualizers() {
foreach (var kvp in activeLineVisualizers) {
if (kvp.Value != null) Destroy(kvp.Value.gameObject);
}
activeLineVisualizers.Clear();
}

void OnDrawGizmosSelected() {
Gizmos.color = Color.green;
Gizmos.DrawWireCube(spawnCenter, spawnAreaSize);

if (showAttractionLinesRuntime && Application.isPlaying) {
Gizmos.color = attractionLineColorRuntime;
foreach (var firefly in activeFireflies) {
if (firefly != null && firefly.AttractionTarget != null) {
Gizmos.DrawLine(firefly.transform.position, firefly.AttractionTarget.position);
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\PoopController.cs

﻿using UnityEngine;
using TMPro;

[RequireComponent(typeof(Collider2D))] // Add RequireComponent for Collider2D
pub cls PoopController : MonoBehaviour {
pub float lifetime = 10f;
pub float fadeDuration = 2f;
pub AnimationCurve fadeCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);

SpriteRenderer sr;
float timer = 0f;
Color initialColor;
Collider2D poopCollider; // Reference to the collider

void Awake() {
sr = GetComponent<SpriteRenderer>();
if (sr != null) {
initialColor = sr.color;
}

poopCollider = GetComponent<Collider2D>();
if (poopCollider == null) {
poopCollider = gameObject.AddComponent<CircleCollider2D>();
Debug.Log($"Added CircleCollider2D to {gameObject.name} for poop detection", gameObject);
}

poopCollider.isTrigger = true;
}

void Update() {
timer += Time.deltaTime;
if (timer >= lifetime) {
Destroy(gameObject);
return;
}

float remaining = lifetime - timer;
if (remaining < fadeDuration && sr != null) {
float t = 1f - (remaining / fadeDuration);
float alphaMultiplier = fadeCurve.Evaluate(t);
Color newColor = initialColor;
newColor.a = alphaMultiplier;
sr.color = newColor;
}
}

pub void Initialize(float lifetimeValue = -1f, float fadeDurationValue = -1f) {
if (lifetimeValue > 0f)
lifetime = lifetimeValue;
if (fadeDurationValue > 0f)
fadeDuration = fadeDurationValue;
timer = 0f;
if (sr != null)
initialColor = sr.color;

if (poopCollider == null) {
poopCollider = GetComponent<Collider2D>();
if (poopCollider == null) {
poopCollider = gameObject.AddComponent<CircleCollider2D>();
}
poopCollider.isTrigger = true;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentDefinition.cs

﻿using UnityEngine;

pub cls ScentDefinition : ScriptableObject {
pub string scentID = "default_scent"; // Still useful for debugging/lookup
pub string displayName = "Default Scent";

pub float baseRadius = 1f;
pub float baseStrength = 1f;

pub GameObject particleEffectPrefab;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentLibrary.cs

﻿using UnityEngine;

pub cls ScentLibrary : ScriptableObject {
pub List<ScentDefinition> scents;

pub ScentDefinition GetScentByID(string id) {
if (string.IsNullOrEmpty(id) || scents == null) ret null;
ret scents.FirstOrDefault(s => s != null && s.scentID == id);
}

pub List<ScentDefinition> GetAllDefinitions() {
ret scents?.Where(s => s != null).ToList() ?? new List<ScentDefinition>();
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentSource.cs

﻿using UnityEngine;
using WegoSystem;

pub cls ScentSource : MonoBehaviour {
pub ScentDefinition definition;
pub float radiusModifier = 0f;
pub float strengthModifier = 0f;

GridEntity gridEntity;

pub float EffectiveRadius => Mathf.Max(0f, (definition != null ? definition.baseRadius : 0f) + radiusModifier);
pub float EffectiveStrength => Mathf.Max(0f, (definition != null ? definition.baseStrength : 0f) + strengthModifier);

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}
}

void OnDrawGizmosSelected() {
if (definition == null || !Application.isPlaying) return;

if (gridEntity == null) gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) return;

int effectiveRadiusTiles = Mathf.RoundToInt(EffectiveRadius);
if (effectiveRadiusTiles <= 0) return;

var affectedTiles = GridRadiusUtility.GetTilesInCircle(gridEntity.Position, effectiveRadiusTiles);

Random.State prevState = Random.state;
Random.InitState(definition.name.GetHashCode());
Color gizmoColor = Random.ColorHSV(0f, 1f, 0.7f, 0.9f, 0.8f, 1f);
gizmoColor.a = 0.3f;
Random.state = prevState;

Gizmos.color = gizmoColor;

foreach (var tile in affectedTiles) {
Vector3 tileWorld = GridPositionManager.Instance.GridToWorld(tile);
Gizmos.DrawCube(tileWorld, Vector3.one * 0.9f); // Slightly smaller than full tile
}

var outlineTiles = GridRadiusUtility.GetCircleOutline(gridEntity.Position, effectiveRadiusTiles);
gizmoColor.a = 0.8f;
Gizmos.color = gizmoColor;

foreach (var tile in outlineTiles) {
Vector3 tileWorld = GridPositionManager.Instance.GridToWorld(tile);
Gizmos.DrawWireCube(tileWorld, Vector3.one);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\SlowdownZone.cs

﻿// Assets/Scripts/Ecosystem/Environment/SlowdownZone.cs

using WegoSystem;

pub cls SlowdownZone : MonoBehaviour {
[SerializeField] int additionalTickCost = 1;
[SerializeField] bool affectsAnimals = true;
[SerializeField] bool affectsPlayer = true;

pub bool AffectsPlayer => affectsPlayer;
pub bool AffectsAnimals => affectsAnimals;

[SerializeField] bool showVisualIndicator = true;
[SerializeField] float colliderShrinkAmount = 0.2f;
[SerializeField] Color zoneColor = new Color(0.5f, 0.5f, 1f, 0.3f);
[SerializeField] bool showDebugMessages = false;

Collider2D zoneCollider;
BoxCollider2D boxCollider; // Kept for shrink logic compatibility
Vector2 originalSize;
SpriteRenderer visualRenderer;
c float SHRINK_EPSILON = 0.001f;

void Awake() {
zoneCollider = GetComponent<Collider2D>();
if (zoneCollider == null) {
Debug.LogError($"SlowdownZone on '{gameObject.name}' requires a Collider2D component!", gameObject);
enabled = false;
return;
}

if (!zoneCollider.isTrigger) {
zoneCollider.isTrigger = true;
}

boxCollider = zoneCollider as BoxCollider2D;
if (boxCollider != null) {
originalSize = boxCollider.size;
if (colliderShrinkAmount > SHRINK_EPSILON) {
ShrinkCollider();
}
}

SetupVisualIndicator();
}

pub bool IsPositionInZone(Vector3 worldPosition) {
if (zoneCollider != null) {
ret zoneCollider.OverlapPoint(worldPosition);
}
ret false;
}

pub int GetAdditionalTickCost() {
ret additionalTickCost;
}

void SetupVisualIndicator() {
if (visualRenderer == null) {
Transform existingVisual = transform.Find("ZoneVisual");
if (existingVisual != null) {
visualRenderer = existingVisual.GetComponent<SpriteRenderer>();
}
}

if (!showVisualIndicator) {
if (visualRenderer != null) {
visualRenderer.gameObject.SetActive(false);
}
return;
}

if (visualRenderer == null) {
GameObject visualObj = new GameObject("ZoneVisual");
visualObj.transform.SetParent(transform);

visualRenderer = visualObj.AddComponent<SpriteRenderer>();
visualRenderer.sprite = CreateSquareSprite();
visualRenderer.sortingOrder = -10; // Render behind most things
}

visualRenderer.gameObject.SetActive(true);

visualRenderer.color = zoneColor;

if (zoneCollider != null) {
Bounds bounds = zoneCollider.bounds;
visualRenderer.transform.position = bounds.center;
visualRenderer.transform.localScale = bounds.size;
}
}

Sprite CreateSquareSprite() {
Texture2D tex = new Texture2D(1, 1);
tex.SetPixel(0, 0, Color.white);
tex.Apply();
tex.wrapMode = TextureWrapMode.Clamp;
ret Sprite.Create(tex, new Rect(0, 0, 1, 1), new Vector2(0.5f, 0.5f), 1);
}

void ShrinkCollider() {
if (boxCollider == null) return;

Vector2 newSize = new Vector2(
Mathf.Max(0.1f, originalSize.x - (colliderShrinkAmount * 2f)),
Mathf.Max(0.1f, originalSize.y - (colliderShrinkAmount * 2f))
);

boxCollider.size = newSize;

if (showDebugMessages) {
Debug.Log($"SlowdownZone on '{gameObject.name}': Shrunk BoxCollider2D from {originalSize} to {newSize}");
}
}

void OnValidate() {
if (Application.isEditor) {
UnityEditor.EditorApplication.delayCall += () => {
if (this != null && gameObject != null) {
SetupVisualIndicator();
}
};
}
}

void OnDrawGizmos() {
if (zoneCollider != null) {
Gizmos.color = new Color(0.5f, 0.5f, 1f, 0.8f);
Gizmos.DrawWireCube(zoneCollider.bounds.center, zoneCollider.bounds.size);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\AnimalDiet.cs

﻿using UnityEngine;

pub cls DietPreferenceSimplified {
pub FoodType foodType;

pub float satiationAmount = 5f;

pub float preferencePriority = 1f;
}

pub cls AnimalDiet : ScriptableObject {
pub List<DietPreferenceSimplified> acceptableFoods = new List<DietPreferenceSimplified>();

pub float maxHunger = 20f;
pub float hungerIncreaseRate = 0.5f;
pub float hungerThreshold = 10f;

pub bool CanEat(FoodType food) {
if (food == null) ret false;
ret acceptableFoods.Any(pref => pref.foodType == food);
}

pub DietPreferenceSimplified GetPreference(FoodType food) {
if (food == null) ret null;
ret acceptableFoods.FirstOrDefault(p => p.foodType == food);
}

pub float GetSatiationValue(FoodType food) {
var pref = GetPreference(food);
ret pref != null ? pref.satiationAmount : 0f;
}

pub GameObject FindBestFood(Collider2D[] nearbyColliders, Vector3 animalPosition) {
GameObject bestTarget = null;
float highestScore = -1f; // Start below any possible score

foreach (var collider in nearbyColliders) {
if (collider == null) continue;

PoopController poopController = collider.GetComponent<PoopController>();
if (poopController != null) continue;

FoodItem foodItem = collider.GetComponent<FoodItem>();

if (foodItem != null && foodItem.foodType != null && CanEat(foodItem.foodType)) {
DietPreferenceSimplified pref = GetPreference(foodItem.foodType);
if (pref == null) continue; // Should be caught by CanEat, but safe check

float distance = Vector3.Distance(animalPosition, collider.transform.position);
float score = pref.preferencePriority / (1f + distance); // Inverse distance weighting

if (score > highestScore) {
highestScore = score;
bestTarget = collider.gameObject;
}
}
}
ret bestTarget;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\FoodItem.cs

﻿using UnityEngine;

[RequireComponent(typeof(Collider2D))] // Still need collider for detection
pub cls FoodItem : MonoBehaviour {
pub FoodType foodType;

void Start() {
if (foodType == null) {
Debug.LogWarning($"FoodItem on GameObject '{gameObject.name}' is missing its FoodType reference!", gameObject);
enabled = false; // Disable script if not configured
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\FoodType.cs

﻿using UnityEngine;

pub cls FoodType : ScriptableObject {
pub string foodName = "Default Food";
pub Sprite icon;

pub enum FoodCategory { Plant_Leaf, Plant_Fruit, Plant_Stem, Plant_Seed, Other }
pub FoodCategory category = FoodCategory.Other;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\EcosystemManager.cs

﻿using UnityEngine;

pub cls EcosystemManager : MonoBehaviour {
pub stat EcosystemManager Instance { get; set; }

pub Transform animalParent;
pub Transform plantParent;

pub ScentLibrary scentLibrary; // <<< ADDED

pub bool sortAnimalsBySpecies = true;
pub bool sortPlantsBySpecies = true;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (scentLibrary == null) {
Debug.LogWarning($"[{nameof(EcosystemManager)}] Scent Library not assigned! Scent effects will not work.", this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\FaunaManager.cs

﻿using UnityEngine;

pub cls FaunaManager : MonoBehaviour {
[SerializeField] Vector2 spawnCenter = Vector2.zero;
[SerializeField] Vector2 spawnAreaSize = new Vector2(20f, 10f);

[SerializeField] Transform ecosystemParent;
[SerializeField][Min(0f)] float screenBoundsPadding = 0.5f;
[SerializeField][Min(0f)] float offscreenSpawnMargin = 2.0f;

[SerializeField] bool showBoundsGizmos = false;

[SerializeField][Range(-10f, 10f)] float boundsOffsetX = 0f;
[SerializeField][Range(-10f, 10f)] float boundsOffsetY = 0f;

List<Coroutine> activeSpawnCoroutines = new List<Coroutine>();
Camera mainCamera; // Ensure this is assigned or found

void Start() {
InitializeManager();
}

void InitializeManager() {
activeSpawnCoroutines.Clear();
if (WaveManager.Instance != null) mainCamera = WaveManager.Instance.GetMainCamera();
if (mainCamera == null) mainCamera = Camera.main;
if (mainCamera == null) Debug.LogError("[FaunaManager] Cannot find Main Camera!", this);

if (ecosystemParent == null) {
if (EcosystemManager.Instance != null && EcosystemManager.Instance.animalParent != null) {
ecosystemParent = EcosystemManager.Instance.animalParent;
Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned from EcosystemManager.animalParent.", this);
}
else {
ecosystemParent = transform;
Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned to self as fallback.", this);
}
}
}

pub void ExecuteSpawnWave(WaveDefinition waveDef) {
if (waveDef == null) { Debug.LogError("[FaunaManager] ExecuteSpawnWave called with null WaveDefinition!", this); return; }
if (waveDef.spawnEntries == null || waveDef.spawnEntries.Count == 0) { Debug.LogWarning($"[FaunaManager] Wave '{waveDef.waveName}' has no spawn entries.", this); return; }

Debug.Log($"[FaunaManager] Executing spawn for Wave: '{waveDef.waveName}'");
StopAllSpawnCoroutines(); // Ensures only one waveDef's entries are spawning at a time from this manager

foreach (WaveSpawnEntry entry in waveDef.spawnEntries) {
if (entry.animalDefinition == null) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', null AnimalDefinition for wave '{waveDef.waveName}'."); continue; }
if (entry.spawnCount <= 0) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', Spawn Count <= 0 for wave '{waveDef.waveName}'."); continue; }

if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat) {
Debug.Log($"[FaunaManager] Halting further spawn entry processing for wave '{waveDef.waveName}', RunManager not in GrowthAndThreat state.");
break; // Don't start new coroutines if not in the correct game state
}

WaveSpawnEntry currentEntry = entry; // Closure capture
Coroutine spawnCoroutine = StartCoroutine(SpawnWaveEntryCoroutine(currentEntry, waveDef.waveName));
activeSpawnCoroutines.Add(spawnCoroutine);
}
Debug.Log($"[FaunaManager] Started {activeSpawnCoroutines.Count} spawn entry coroutine(s) for '{waveDef.waveName}'.");
}

pub void StopAllSpawnCoroutines() {
if (activeSpawnCoroutines.Count > 0) {
Debug.Log($"[FaunaManager] Stopping all ({activeSpawnCoroutines.Count}) active spawn coroutines.");
foreach (Coroutine co in activeSpawnCoroutines) {
if (co != null) StopCoroutine(co);
}
activeSpawnCoroutines.Clear();
}
}

IEnumerator SpawnWaveEntryCoroutine(WaveSpawnEntry entry, string waveNameForDebug) {
if (entry.delayAfterSpawnTime > 0) {
yield ret new WaitForSeconds(entry.delayAfterSpawnTime);
}

for (int i = 0; i < entry.spawnCount; i++) {
if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat) {
Debug.Log($"[FaunaManager] Halting spawn for entry '{entry.description}' in wave '{waveNameForDebug}', RunManager no longer in GrowthAndThreat state.");
break; // Exit loop if game state changed
}

Vector2 spawnPos = CalculateSpawnPosition(entry.spawnLocationType, entry.spawnRadius);
bool isOffscreen = entry.spawnLocationType == WaveSpawnLocationType.Offscreen;
GameObject spawnedAnimal = SpawnAnimal(entry.animalDefinition, spawnPos, isOffscreen);

if (entry.spawnInterval > 0 && i < entry.spawnCount - 1) // Don't wait after the last one {
yield ret new WaitForSeconds(entry.spawnInterval);
}
}
}

Vector2 CalculateSpawnPosition(WaveSpawnLocationType locationType, float radius) {
if (mainCamera == null) { Debug.LogError("[FaunaManager] Missing Main Camera for CalculateSpawnPosition!"); ret spawnCenter; }

Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

Vector2 spawnPos = Vector2.zero;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;

switch (locationType) {
case WaveSpawnLocationType.Offscreen:
float marginMinX = effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin;
float marginMaxX = effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin;
float marginMinY = effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin;
float marginMaxY = effectiveCamPos.y + camHeight / 2f + offscreenSpawnMargin;
float extraOffset = 0.1f;
int edge = Random.Range(0, 4);
if (edge == 0) { spawnPos.x = marginMinX - extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
else if (edge == 1) { spawnPos.x = marginMaxX + extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
else if (edge == 2) { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMinY - extraOffset; }
else { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMaxY + extraOffset; }
break;

case WaveSpawnLocationType.RandomNearPlayer:
Transform playerT = FindPlayerTransform();
if (playerT != null) {
spawnPos = (Vector2)playerT.position + Random.insideUnitCircle * radius;
} else {
Debug.LogWarning("[FaunaManager] Player not found for RandomNearPlayer. Falling back to Global.");
goto case WaveSpawnLocationType.GlobalSpawnArea;
}
break;

case WaveSpawnLocationType.GlobalSpawnArea:
default:
spawnPos.x = effectiveCamPos.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
spawnPos.y = effectiveCamPos.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
break;
}
ret spawnPos;
}

Transform FindPlayerTransform() {
GameObject playerGO = GameObject.FindGameObjectWithTag("Player");
if (playerGO != null) ret playerGO.transform;

PlayerTileInteractor pti = FindAnyObjectByType<PlayerTileInteractor>();
if (pti != null) ret pti.transform;

GardenerController gc = FindAnyObjectByType<GardenerController>();
if (gc != null) ret gc.transform;

ret null;
}

GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position, bool isOffscreenSpawn) {
if (definition == null || definition.prefab == null) { Debug.LogError("[FaunaManager] Cannot spawn animal: null definition or prefab."); ret null; }
if (mainCamera == null) { Debug.LogError("[FaunaManager] Missing Main Camera for SpawnAnimal bounds calculation!"); ret null; }

Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

Vector2 minPaddedBounds, maxPaddedBounds;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;

minPaddedBounds.x = effectiveCamPos.x - camWidth / 2f + screenBoundsPadding;
maxPaddedBounds.x = effectiveCamPos.x + camWidth / 2f - screenBoundsPadding;
minPaddedBounds.y = effectiveCamPos.y - camHeight / 2f + screenBoundsPadding;
maxPaddedBounds.y = effectiveCamPos.y + camHeight / 2f - screenBoundsPadding;

GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

if (ecosystemParent != null) {
Transform speciesParent = ecosystemParent;
if (EcosystemManager.Instance != null && EcosystemManager.Instance.sortAnimalsBySpecies && !string.IsNullOrEmpty(definition.animalName)) {
speciesParent = ecosystemParent.Find(definition.animalName);
if (speciesParent == null) {
GameObject subParentGO = new GameObject(definition.animalName);
subParentGO.transform.SetParent(ecosystemParent);
speciesParent = subParentGO.transform;
}
}
animalObj.transform.SetParent(speciesParent);
}

AnimalController controller = animalObj.GetComponent<AnimalController>();
if (controller != null) {
controller.Initialize(definition, minPaddedBounds, maxPaddedBounds, isOffscreenSpawn);
} else { Debug.LogError($"[FaunaManager] Spawned animal prefab '{definition.prefab.name}' missing AnimalController script!", animalObj); Destroy(animalObj); ret null; }
ret animalObj;
}

void OnDrawGizmos() {
if (!showBoundsGizmos || mainCamera == null) return;
Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;
Vector2 paddedMin = new Vector2(effectiveCamPos.x - camWidth / 2f + screenBoundsPadding, effectiveCamPos.y - camHeight / 2f + screenBoundsPadding);
Vector2 paddedMax = new Vector2(effectiveCamPos.x + camWidth / 2f - screenBoundsPadding, effectiveCamPos.y + camHeight / 2f - screenBoundsPadding);
DrawWireRectangleGizmo(paddedMin, paddedMax, Color.green);
Vector2 marginMin = new Vector2(effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin, effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin);
Vector2 marginMax = new Vector2(effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin, effectiveCamPos.y + camHeight / 2f - offscreenSpawnMargin);
DrawWireRectangleGizmo(marginMin, marginMax, Color.red);
}

void DrawWireRectangleGizmo(Vector2 min, Vector2 max, Color color) { Gizmos.color = color; Gizmos.DrawLine(new Vector3(min.x, min.y, 0), new Vector3(max.x, min.y, 0)); Gizmos.DrawLine(new Vector3(max.x, min.y, 0), new Vector3(max.x, max.y, 0)); Gizmos.DrawLine(new Vector3(max.x, max.y, 0), new Vector3(min.x, max.y, 0)); Gizmos.DrawLine(new Vector3(min.x, max.y, 0), new Vector3(min.x, min.y, 0)); }
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\FloraManager.cs

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

pub cls FloraManager : MonoBehaviour {
pub stat FloraManager Instance { get; set; }

[SerializeField] bool showScentRadiiRuntime = false;
[SerializeField] Color scentRadiusColorRuntime = Color.yellow;

[SerializeField] bool showPoopAbsorptionRadiiRuntime = false;
[SerializeField] Color poopAbsorptionRadiusColorRuntime = new Color(0.6f, 0.4f, 0.2f, 0.5f); // Brown-ish color

[SerializeField] GameObject circleVisualizerPrefab;
[SerializeField] Transform circleContainer;

[SerializeField] bool logGizmoCalls = false;

pub bool ShowScentRadiiRuntime => showScentRadiiRuntime;
pub Color ScentRadiusColorRuntime => scentRadiusColorRuntime;
pub bool ShowPoopAbsorptionRadiiRuntime => showPoopAbsorptionRadiiRuntime;
pub Color PoopAbsorptionRadiusColorRuntime => poopAbsorptionRadiusColorRuntime;

ro Dictionary<ScentSource, RuntimeCircleDrawer> _activeCircleVisualizers = new Dictionary<ScentSource, RuntimeCircleDrawer>();
ro Dictionary<PlantGrowth, RuntimeCircleDrawer> _activePoopAbsorptionCircleVisualizers = new Dictionary<PlantGrowth, RuntimeCircleDrawer>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (circleVisualizerPrefab == null) { Debug.LogError($"[{nameof(FloraManager)}] Circle Visualizer Prefab is not assigned!", this); }
if (circleContainer == null) { Debug.LogError($"[{nameof(FloraManager)}] Circle Container transform is not assigned!", this); }
}

void OnDestroy() {
if (Instance == this) Instance = null;

foreach (var kvp in _activeCircleVisualizers) {
if (kvp.Value != null) Destroy(kvp.Value.gameObject);
}
_activeCircleVisualizers.Clear();

foreach (var kvp in _activePoopAbsorptionCircleVisualizers) {
if (kvp.Value != null) Destroy(kvp.Value.gameObject);
}
_activePoopAbsorptionCircleVisualizers.Clear();
}

void Update() {
if (!Application.isPlaying) return;
UpdateRuntimeCircleVisualizers();
UpdatePoopAbsorptionCircleVisualizers();
}

void UpdatePoopAbsorptionCircleVisualizers() {
if (!Application.isPlaying) return;

bool showCircles = showPoopAbsorptionRadiiRuntime && circleVisualizerPrefab != null && circleContainer != null;

if (!showCircles) {
foreach (var kvp in _activePoopAbsorptionCircleVisualizers) {
if (kvp.Value != null) Destroy(kvp.Value.gameObject);
}
_activePoopAbsorptionCircleVisualizers.Clear();
return;
}

var currentPlantsSet = new HashSet<PlantGrowth>(PlantGrowth.AllActivePlants);

var plantsToRemove = new List<PlantGrowth>();

foreach (var kvp in _activePoopAbsorptionCircleVisualizers) {
PlantGrowth plant = kvp.Key;
RuntimeCircleDrawer drawer = kvp.Value;

if (plant == null || drawer == null || !plant.gameObject.activeInHierarchy || !currentPlantsSet.Contains(plant)) {
plantsToRemove.Add(plant);
if (drawer != null) Destroy(drawer.gameObject);
continue;
}

float poopRadius = GetPlantPoopDetectionRadius(plant);
bool shouldShowThis = showCircles && poopRadius > 0.01f;

if (shouldShowThis) {
drawer.transform.position = plant.transform.position;
drawer.UpdateCircle(poopRadius, poopAbsorptionRadiusColorRuntime);
}
else {
drawer.HideCircle();
plantsToRemove.Add(plant); // If radius is too small or zero, remove the visualizer
}
}

foreach (var plant in plantsToRemove) {
if (_activePoopAbsorptionCircleVisualizers.TryGetValue(plant, out var drawer)) {
if (drawer != null) Destroy(drawer.gameObject);
_activePoopAbsorptionCircleVisualizers.Remove(plant);
}
}

foreach (PlantGrowth plant in PlantGrowth.AllActivePlants) {
if (plant == null || _activePoopAbsorptionCircleVisualizers.ContainsKey(plant)) continue;

float poopRadius = GetPlantPoopDetectionRadius(plant);
if (poopRadius <= 0.01f) continue;

GameObject circleGO = Instantiate(circleVisualizerPrefab, plant.transform.position, Quaternion.identity, circleContainer);
var newDrawer = circleGO.GetComponent<RuntimeCircleDrawer>();

if (newDrawer != null) {
newDrawer.UpdateCircle(poopRadius, poopAbsorptionRadiusColorRuntime);
_activePoopAbsorptionCircleVisualizers.Add(plant, newDrawer);
}
else {
Debug.LogError($"Circle Visualizer Prefab '{circleVisualizerPrefab.name}' missing RuntimeCircleDrawer script!", circleVisualizerPrefab);
Destroy(circleGO);
}
}
}

float GetPlantPoopDetectionRadius(PlantGrowth plant) {
if (plant == null) ret 0f;
ret plant.GetPoopDetectionRadius();
}

void UpdateRuntimeCircleVisualizers() {
if (!Application.isPlaying) return;

bool showCircles = showScentRadiiRuntime && circleVisualizerPrefab != null && circleContainer != null;
var sourcesToRemove = new List<ScentSource>();

foreach (var kvp in _activeCircleVisualizers) {
ScentSource source = kvp.Key;
RuntimeCircleDrawer line = kvp.Value;

if (source == null || line == null || !source.gameObject.activeInHierarchy) {
sourcesToRemove.Add(source);
if (line != null) Destroy(line.gameObject);
continue;
}

bool shouldShowThis = showCircles && source.enabled && source.definition != null && source.EffectiveRadius > 0.01f;

if (shouldShowThis) {
line.transform.position = source.transform.position;
line.transform.rotation = source.transform.rotation;
line.UpdateCircle(source.EffectiveRadius, scentRadiusColorRuntime);
}
else {
line.HideCircle();
}
}

foreach (var source in sourcesToRemove) {
if (_activeCircleVisualizers.TryGetValue(source, out var drawer) && drawer != null)
Destroy(drawer.gameObject);
_activeCircleVisualizers.Remove(source);
}

if (showCircles) {
ScentSource[] currentSources = FindObjectsByType<ScentSource>(FindObjectsSortMode.None);
foreach (ScentSource source in currentSources) {
if (source == null || _activeCircleVisualizers.ContainsKey(source) || !source.enabled ||
source.definition == null || source.EffectiveRadius <= 0.01f) continue;

GameObject circleGO = Instantiate(circleVisualizerPrefab, source.transform.position, source.transform.rotation, circleContainer);
var newDrawer = circleGO.GetComponent<RuntimeCircleDrawer>();

if (newDrawer != null) {
newDrawer.UpdateCircle(source.EffectiveRadius, scentRadiusColorRuntime);
_activeCircleVisualizers.Add(source, newDrawer);
}
else {
Debug.LogError($"Circle Visualizer Prefab '{circleVisualizerPrefab.name}' is missing RuntimeCircleDrawer script!", circleVisualizerPrefab);
Destroy(circleGO);
}
}
}
else if (!showCircles && _activeCircleVisualizers.Count > 0) {
foreach (var kvp in _activeCircleVisualizers) {
if (kvp.Value != null) Destroy(kvp.Value.gameObject);
}
_activeCircleVisualizers.Clear();
}
}

#if UNITY_EDITOR
void OnDrawGizmosSelected() {
if (showScentRadiiRuntime) {
Gizmos.color = scentRadiusColorRuntime;
ScentSource[] scentSources = FindObjectsByType<ScentSource>(FindObjectsSortMode.None);
foreach (ScentSource source in scentSources) {
if (source == null || !source.enabled || source.definition == null) continue;
float radius = source.EffectiveRadius;
if (radius > 0.01f) {
Gizmos.DrawWireSphere(source.transform.position, radius);
}
}
}

if (showPoopAbsorptionRadiiRuntime) {
Gizmos.color = poopAbsorptionRadiusColorRuntime;
PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
int drawnCount = 0;

foreach (PlantGrowth plant in plants) {
if (plant == null) continue;
float radius = GetPlantPoopDetectionRadius(plant);
if (radius > 0.01f) {
Gizmos.DrawWireSphere(plant.transform.position, radius);
drawnCount++;
}
}

if (logGizmoCalls && drawnCount > 0) {
Debug.Log($"[FloraManager] Drew {drawnCount} poop absorption radius gizmos");
}
}
}
#endif
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\WaveManager.cs

﻿using UnityEngine;
using TMPro;
using WegoSystem;

pub enum InternalWaveState {
Idle,
WaitingForSpawnTime,
SpawningInProgress,
WaveActive
}

pub cls WaveManager : MonoBehaviour {
pub stat WaveManager Instance { get; set; }

[SerializeField] FaunaManager faunaManager;
[SerializeField] WeatherManager weatherManager;
[SerializeField] Camera mainCamera;

[SerializeField] List<WaveDefinition> wavesSequence;

[SerializeField][Range(1, 10)] int waveDurationInDayCycles = 1;
[SerializeField] WeatherManager.CyclePhase spawnStartPhase = WeatherManager.CyclePhase.Day;
[SerializeField][Range(0f, 100f)] float spawnStartPercentage = 50f;
[SerializeField] bool deletePreviousWaveAnimals = true;

[SerializeField] TextMeshProUGUI waveStatusText;
[SerializeField] TextMeshProUGUI timeTrackerText;

[SerializeField] InternalWaveState currentInternalState = InternalWaveState.Idle;
[SerializeField] int activeWaveDefinitionIndex = -1;

WaveDefinition currentActiveWaveDef = null;
bool hasSpawnedForThisWeatherCycle = false;
Coroutine activeWaveExecutionCoroutine;

int waveStartTick = 0;
int waveEndTick = 0;

pub bool IsCurrentWaveDefeated() {
if (currentInternalState == InternalWaveState.Idle && activeWaveDefinitionIndex != -1) {
ret true;
}

if (currentActiveWaveDef != null && TickManager.Instance != null) {
int currentTick = TickManager.Instance.CurrentTick;
ret currentTick >= waveEndTick;
}

ret false;
}

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;

if (faunaManager == null) Debug.LogError("[WaveManager] FaunaManager missing!", this);
if (weatherManager == null) Debug.LogError("[WaveManager] WeatherManager missing!", this);
if (wavesSequence == null || wavesSequence.Count == 0) Debug.LogWarning("[WaveManager] Wave Sequence empty. No waves will spawn.", this);

if (TickManager.Instance != null) {
TickManager.Instance.OnTickAdvanced += OnTickAdvanced;
}
}

void Start() {
if (weatherManager != null) weatherManager.OnPhaseChanged += HandleWeatherPhaseChange;
SetInternalState(InternalWaveState.Idle);
}

void OnDestroy() {
if (weatherManager != null) weatherManager.OnPhaseChanged -= HandleWeatherPhaseChange;
if (TickManager.Instance != null) {
TickManager.Instance.OnTickAdvanced -= OnTickAdvanced;
}
StopAllCoroutines();
}

void OnTickAdvanced(int currentTick) {
if (currentActiveWaveDef != null && currentTick >= waveEndTick) {
EndCurrentWave();
}
}

int GetWaveDurationTicks() {
var config = TickManager.Instance?.Config;
if (config == null) ret 50;

ret config.wavesDependOnDayCycle ?
config.ticksPerDay * waveDurationInDayCycles :
config.ticksPerWave;
}

void SetInternalState(InternalWaveState newState) {
if (currentInternalState == newState) return;
if (Debug.isDebugBuild) Debug.Log($"[WaveManager] Internal State Change: {currentInternalState} -> {newState}");
currentInternalState = newState;
UpdateLegacyWaveStatusText();
}

pub void StartWaveForRound(int roundNumber) {
if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat) {
Debug.LogWarning("[WaveManager] Attempted to StartWaveForRound, but RunManager not in GrowthAndThreat state.");
return;
}

activeWaveDefinitionIndex = roundNumber - 1;

if (wavesSequence == null || activeWaveDefinitionIndex < 0 || activeWaveDefinitionIndex >= wavesSequence.Count) {
Debug.LogWarning($"[WaveManager] No WaveDefinition for round {roundNumber} (index {activeWaveDefinitionIndex}). Max index: {(wavesSequence?.Count - 1) ?? -1}. No wave will start.");
currentActiveWaveDef = null;
SetInternalState(InternalWaveState.Idle);
return;
}

currentActiveWaveDef = wavesSequence[activeWaveDefinitionIndex];
if (currentActiveWaveDef == null) {
Debug.LogError($"[WaveManager] WaveDefinition at index {activeWaveDefinitionIndex} for round {roundNumber} is NULL.");
SetInternalState(InternalWaveState.Idle);
return;
}

if (deletePreviousWaveAnimals) {
ClearAllActiveAnimals();
}

waveStartTick = TickManager.Instance.CurrentTick;
int waveDuration = GetWaveDurationTicks();
waveEndTick = waveStartTick + waveDuration;

Debug.Log($"[WaveManager] Starting wave '{currentActiveWaveDef.waveName}' for Round {roundNumber}. Duration: {waveDuration} ticks (ends at tick {waveEndTick}).");

hasSpawnedForThisWeatherCycle = false;
SetInternalState(InternalWaveState.WaitingForSpawnTime);
Update_WaitingForSpawnTimeCheck();
}

void EndCurrentWave() {
Debug.Log($"[WaveManager] Ending wave '{currentActiveWaveDef?.waveName}'");

StopCurrentWaveSpawning();
currentActiveWaveDef = null;
SetInternalState(InternalWaveState.Idle);

if (RunManager.Instance != null) {
RunManager.Instance.StartNewPlanningPhase();
}

if (TurnPhaseManager.Instance != null &&
TurnPhaseManager.Instance.CurrentPhase != TurnPhase.Planning) {
TurnPhaseManager.Instance.TransitionToPhase(TurnPhase.Planning);
}
}

pub void StopCurrentWaveSpawning() {
Debug.Log("[WaveManager] StopCurrentWaveSpawning called (e.g., round ending).");
if (activeWaveExecutionCoroutine != null) {
StopCoroutine(activeWaveExecutionCoroutine);
activeWaveExecutionCoroutine = null;
}
faunaManager?.StopAllSpawnCoroutines();
SetInternalState(InternalWaveState.Idle);
}

void HandleWeatherPhaseChange(WeatherManager.CyclePhase newPhase) {
if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat || currentActiveWaveDef == null) return;

if (newPhase == WeatherManager.CyclePhase.TransitionToDay) {
hasSpawnedForThisWeatherCycle = false;
}
else if (newPhase == spawnStartPhase && (currentInternalState == InternalWaveState.WaitingForSpawnTime || currentInternalState == InternalWaveState.WaveActive)) {
Update_WaitingForSpawnTimeCheck();
}
}

void Update_WaitingForSpawnTimeCheck() {
if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat || currentActiveWaveDef == null) return;
if (currentInternalState != InternalWaveState.WaitingForSpawnTime && currentInternalState != InternalWaveState.WaveActive) return;
if (hasSpawnedForThisWeatherCycle) return;

if (weatherManager == null) return;
WeatherManager.CyclePhase currentPhase = weatherManager.CurrentPhase;
float totalPhaseTime = weatherManager.CurrentTotalPhaseTime;
float remainingPhaseTime = weatherManager.CurrentPhaseTimer;
float progressPercent = (totalPhaseTime > 0) ? (1f - (remainingPhaseTime / totalPhaseTime)) * 100f : 0f;

if (currentPhase == spawnStartPhase && progressPercent >= spawnStartPercentage) {
TriggerFaunaSpawning();
}
}

void TriggerFaunaSpawning() {
if (currentActiveWaveDef == null) return;
if (faunaManager == null) { Debug.LogError("[WaveManager] FaunaManager missing, cannot spawn!"); return; }

Debug.Log($"[WaveManager] Spawning animals for WaveDefinition: '{currentActiveWaveDef.waveName}' (Phase: {spawnStartPhase} >= {spawnStartPercentage}%)");
SetInternalState(InternalWaveState.SpawningInProgress);
hasSpawnedForThisWeatherCycle = true;

faunaManager.ExecuteSpawnWave(currentActiveWaveDef);

SetInternalState(InternalWaveState.WaveActive);
}

void ClearAllActiveAnimals() {
if(Debug.isDebugBuild) Debug.Log("[WaveManager] Clearing all active animals.");
AnimalController[] activeAnimals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
int count = 0;
foreach(AnimalController animal in activeAnimals) {
if(animal != null) { Destroy(animal.gameObject); count++; }
}
if(Debug.isDebugBuild) Debug.Log($"[WaveManager] Destroyed {count} animals.");
}

pub void ResetForNewRound() {
Debug.Log("[WaveManager] Resetting for new round.");
StopCurrentWaveSpawning();
if (deletePreviousWaveAnimals) {
ClearAllActiveAnimals();
}
currentActiveWaveDef = null;
activeWaveDefinitionIndex = -1;
hasSpawnedForThisWeatherCycle = false;
waveStartTick = 0;
waveEndTick = 0;
SetInternalState(InternalWaveState.Idle);
}

void Update() {
if (RunManager.Instance?.CurrentState == RunState.GrowthAndThreat) {
if (currentInternalState == InternalWaveState.WaitingForSpawnTime) {
Update_WaitingForSpawnTimeCheck();
}
}
UpdateLegacyTimeTrackerUI();
UpdateLegacyWaveStatusText();
}

void UpdateLegacyTimeTrackerUI() {
if (timeTrackerText == null || weatherManager == null) return;
WeatherManager.CyclePhase phase = weatherManager.CurrentPhase;
float total = weatherManager.CurrentTotalPhaseTime;
float remaining = weatherManager.CurrentPhaseTimer;
float progressPercent = (total > 0) ? (1f - (remaining / total)) * 100f : 0f;
string phaseName = phase.ToString().Replace("Transition", "");
timeTrackerText.text = $"{phaseName} [{progressPercent:F0}%]";
if (RunManager.Instance != null) {
if(RunManager.Instance.CurrentState == RunState.Planning) timeTrackerText.text += " (Planning)";
else if(RunManager.Instance.CurrentState == RunState.GrowthAndThreat) timeTrackerText.text += " (Growth & Threat)";
}
}

void UpdateLegacyWaveStatusText() {
if (waveStatusText == null) return;
if (RunManager.Instance == null) return;

if (RunManager.Instance.CurrentState == RunState.Planning) {
waveStatusText.text = $"Prepare for Round {RunManager.Instance.CurrentRoundNumber}";
}
else if (RunManager.Instance.CurrentState == RunState.GrowthAndThreat) {
if (currentActiveWaveDef != null) {
string waveNamePart = string.IsNullOrEmpty(currentActiveWaveDef.waveName) ? $"Wave {activeWaveDefinitionIndex + 1}" : currentActiveWaveDef.waveName;

if (TickManager.Instance != null) {
int ticksRemaining = Mathf.Max(0, waveEndTick - TickManager.Instance.CurrentTick);
waveStatusText.text = $"{waveNamePart} [{ticksRemaining} ticks left]";
} else {
waveStatusText.text = waveNamePart;
}
}
else if (currentInternalState == InternalWaveState.Idle) {
waveStatusText.text = "All waves for round complete.";
}
}
}

pub Camera GetMainCamera() { ret mainCamera; }
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Spawning\WaveDefinition.cs

﻿using UnityEngine;

pub enum WaveSpawnLocationType {
GlobalSpawnArea,
RandomNearPlayer,
Offscreen
}

pub cls WaveSpawnEntry {
pub string description = "Spawn Group";
pub AnimalDefinition animalDefinition;
pub int spawnCount = 1;
[Tooltip("Delay (in seconds) AFTER the designated wave spawn time (e.g. Day 50%) before *this entry* begins spawning.")] // Clarified Tooltip
pub float delayAfterSpawnTime = 0f; // Renamed from delayAfterWaveStart
pub float spawnInterval = 0.5f;
pub WaveSpawnLocationType spawnLocationType = WaveSpawnLocationType.GlobalSpawnArea;
pub float spawnRadius = 5f;
}

pub cls WaveDefinition : ScriptableObject {
pub string waveName = "New Wave";

pub List<WaveSpawnEntry> spawnEntries = new List<WaveSpawnEntry>();

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\UI\ThoughtBubbleController.cs

﻿using UnityEngine;
using TMPro;

pub cls ThoughtBubbleController : MonoBehaviour {
pub TMP_Text messageText;
pub float lifetime = 2f;

Transform followTarget;

pub void Initialize(string message, Transform target, float duration = 2f) {
if (messageText != null)
messageText.text = message;
followTarget = target;
lifetime = duration;
}

void Update() {
lifetime -= Time.deltaTime;
if (lifetime <= 0f)
Destroy(gameObject);

if (followTarget != null) {
transform.position = followTarget.position;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\UI\ThoughtTrigger.cs

﻿using UnityEngine;

pub enum ThoughtTrigger {
Hungry,
Eating,
HealthLow,
Fleeing,
Pooping,
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeDefinitionAutoAdder.cs

﻿using UnityEngine;
using UnityEditor;
using System.IO;

pub cls NodeDefinitionAutoAdder : AssetPostprocessor {
stat void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths) {
foreach (string assetPath in importedAssets) {
NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
if (nodeDef != null) {
string folderPath = Path.GetDirectoryName(assetPath);
string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
.Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
if (libraryFiles.Length > 0) {
NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
if (library != null && !library.definitions.Contains(nodeDef)) {
library.definitions.Add(nodeDef);
EditorUtility.SetDirty(library);
AssetDatabase.SaveAssets();
}
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeDefinitionCreator.cs

﻿using UnityEngine;
using UnityEditor;
using System.IO;

pub stat cls NodeDefinitionCreator {
c string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

pub stat void CreateNodeDefinition() {
string folder = GetSelectedPathOrFallback();

int nextNumber = GetNextNodeNumber(folder);

string newName = $"Node_{nextNumber:D3}_";
string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
AssetDatabase.CreateAsset(nodeDef, newPath);

AssetDatabase.SaveAssets();
AssetDatabase.Refresh();

Debug.Log($"Created NodeDefinition at: {newPath}");
}

stat bool ValidateCreateNodeDefinition() {
ret !Application.isPlaying;
}

stat string GetSelectedPathOrFallback() {
string path = "Assets";
foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets)) {
path = AssetDatabase.GetAssetPath(obj);
if (!string.IsNullOrEmpty(path)) {
if (File.Exists(path)) {
path = Path.GetDirectoryName(path);
}
break;
}
}
ret path;
}

stat int GetNextNodeNumber(string folderPath) {
int nextNumber = 1;
string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
foreach (var file in files) {
string fName = Path.GetFileNameWithoutExtension(file);
if (fName.StartsWith("Node_") && fName.Length >= 8) {
string numberPart = fName.Substring(5, 3);
if (int.TryParse(numberPart, out int num) && num >= nextNumber) {
nextNumber = num + 1;
}
}
}
ret nextNumber;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeDefinitionEditor.cs

﻿using UnityEditor;

pub cls NodeDefinitionEditor : Editor {
SerializedProperty displayName;
SerializedProperty description;
SerializedProperty thumbnail;
SerializedProperty thumbnailTintColor;
SerializedProperty backgroundColor;
SerializedProperty nodeViewPrefab;
SerializedProperty effects;

void OnEnable() {
displayName = serializedObject.FindProperty("displayName");
description = serializedObject.FindProperty("description");
thumbnail = serializedObject.FindProperty("thumbnail");
thumbnailTintColor = serializedObject.FindProperty("thumbnailTintColor");
backgroundColor = serializedObject.FindProperty("backgroundColor");
nodeViewPrefab = serializedObject.FindProperty("nodeViewPrefab");
effects = serializedObject.FindProperty("effects");
}

pub ovr void OnInspectorGUI() {
serializedObject.Update();

EditorGUILayout.LabelField("Display", EditorStyles.boldLabel);
EditorGUILayout.PropertyField(displayName);
EditorGUILayout.PropertyField(description);
EditorGUILayout.PropertyField(thumbnail);
EditorGUILayout.PropertyField(thumbnailTintColor);
EditorGUILayout.PropertyField(backgroundColor);

EditorGUILayout.Space();

EditorGUILayout.LabelField("Prefab & Effects", EditorStyles.boldLabel);
EditorGUILayout.PropertyField(nodeViewPrefab);

EditorGUILayout.PropertyField(effects, new GUIContent("Effects"), true, GUILayout.MinHeight(1300f));

serializedObject.ApplyModifiedProperties();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeDefinitionLibraryEditor.cs

﻿using UnityEngine;
using UnityEditor;
using System.IO;

pub cls NodeDefinitionLibraryEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

if (GUILayout.Button("UPDATE")) {
UpdateLibrary();
}
}

void UpdateLibrary() {
NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

string libraryPath = AssetDatabase.GetAssetPath(library);
string folderPath = Path.GetDirectoryName(libraryPath);

string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

List<NodeDefinition> defs = new List<NodeDefinition>();
foreach (string file in assetFiles) {
if (file == libraryPath)
continue;

NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
if (def != null)
defs.Add(def);
}

defs = defs.OrderBy(d => {
string name = d.name;
if (name.StartsWith("Node_") && name.Length >= 8) {
string numStr = name.Substring(5, 3);
if (int.TryParse(numStr, out int num))
ret num;
}
ret int.MaxValue; // if no number is found, sort last.
}).ToList();

library.definitions = defs;
EditorUtility.SetDirty(library);
AssetDatabase.SaveAssets();
Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeDefinitionPostprocessor.cs

﻿using UnityEngine;
using UnityEditor;
using System.IO;

pub cls NodeDefinitionPostprocessor : AssetPostprocessor {
stat void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths) {
foreach (string assetPath in importedAssets) {
NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
if (nodeDef != null) {
string fileName = Path.GetFileNameWithoutExtension(assetPath);
if (!fileName.StartsWith("Node_")) {
string folderPath = Path.GetDirectoryName(assetPath);
var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
int nextNumber = 1;
foreach (var file in files) {
string fName = Path.GetFileNameWithoutExtension(file);
string[] parts = fName.Split('_');
if (parts.Length >= 2 && int.TryParse(parts[1], out int num)) {
if (num >= nextNumber)
nextNumber = num + 1;
}
}
string newName = $"Node_{nextNumber:D3}_";
AssetDatabase.RenameAsset(assetPath, newName);
AssetDatabase.SaveAssets();
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeEffectDrawer.cs

﻿using UnityEngine;
using UnityEditor;

pub cls NodeEffectDrawer : PropertyDrawer {
pub ovr void OnGUI(Rect position, SerializedProperty property, GUIContent label) {
EditorGUI.BeginProperty(position, label, property);

var effectTypeProp = property.FindPropertyRelative("effectType");
var primaryValueProp = property.FindPropertyRelative("primaryValue");
var secondaryValueProp = property.FindPropertyRelative("secondaryValue");
var isPassiveProp = property.FindPropertyRelative("isPassive");
var scentDefRefProp = property.FindPropertyRelative("scentDefinitionReference");
var seedDataProp = property.FindPropertyRelative("seedData");

float yPos = position.y;
float lineHeight = EditorGUIUtility.singleLineHeight;
float spacing = EditorGUIUtility.standardVerticalSpacing;

EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight), effectTypeProp);
yPos += lineHeight + spacing;

EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight), isPassiveProp);
yPos += lineHeight + spacing;

NodeEffectType currentType = (NodeEffectType)effectTypeProp.enumValueIndex;

if (currentType == NodeEffectType.SeedSpawn) {
EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight),
primaryValueProp, new GUIContent("Enabled", "Set to 1 to make this a seed"));
yPos += lineHeight + spacing;

if (primaryValueProp.floatValue > 0) {
EditorGUI.indentLevel++;

EditorGUI.LabelField(new Rect(position.x, yPos, position.width, lineHeight), "Growth Properties", EditorStyles.boldLabel);
yPos += lineHeight + spacing;

var growthSpeedProp = seedDataProp.FindPropertyRelative("growthSpeed");
EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight), growthSpeedProp);
yPos += lineHeight + spacing;

var stemMinProp = seedDataProp.FindPropertyRelative("stemLengthMin");
var stemMaxProp = seedDataProp.FindPropertyRelative("stemLengthMax");
float halfWidth = (position.width - 10) / 2;
EditorGUI.PropertyField(new Rect(position.x, yPos, halfWidth, lineHeight), stemMinProp, new GUIContent("Stem Min"));
EditorGUI.PropertyField(new Rect(position.x + halfWidth + 10, yPos, halfWidth, lineHeight), stemMaxProp, new GUIContent("Stem Max"));
yPos += lineHeight + spacing;

var leafGapProp = seedDataProp.FindPropertyRelative("leafGap");
EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight), leafGapProp);
yPos += lineHeight + spacing;

var leafPatternProp = seedDataProp.FindPropertyRelative("leafPattern");
EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight), leafPatternProp);
yPos += lineHeight + spacing;

var stemRandomnessProp = seedDataProp.FindPropertyRelative("stemRandomness");
EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight), stemRandomnessProp);
yPos += lineHeight + spacing;

EditorGUI.LabelField(new Rect(position.x, yPos, position.width, lineHeight), "Energy Properties", EditorStyles.boldLabel);
yPos += lineHeight + spacing;

var energyStorageProp = seedDataProp.FindPropertyRelative("energyStorage");
EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight), energyStorageProp);
yPos += lineHeight + spacing;

EditorGUI.LabelField(new Rect(position.x, yPos, position.width, lineHeight), "Timing Properties", EditorStyles.boldLabel);
yPos += lineHeight + spacing;

var cooldownProp = seedDataProp.FindPropertyRelative("cooldown");
EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight), cooldownProp);
yPos += lineHeight + spacing;

var castDelayProp = seedDataProp.FindPropertyRelative("castDelay");
EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight), castDelayProp);

EditorGUI.indentLevel--;
}
}
else {
GUIContent primaryLabel = new GUIContent("Primary Value");
GUIContent secondaryLabel = new GUIContent("Secondary Value");
bool showSecondary = false;
bool showScentField = false;

switch (currentType) {
case NodeEffectType.EnergyStorage:
primaryLabel.text = "Max Energy Increase";
primaryLabel.tooltip = "Additional maximum energy capacity";
break;

case NodeEffectType.EnergyPerTick:
primaryLabel.text = "Energy Per Tick";
primaryLabel.tooltip = "Energy generated each tick (affected by sunlight and leaves)";
break;

case NodeEffectType.EnergyCost:
primaryLabel.text = "Energy Cost";
primaryLabel.tooltip = "Energy required to execute mature cycle";
break;

case NodeEffectType.StemLength:
primaryLabel.text = "Min Segments Add";
primaryLabel.tooltip = "Minimum stem segments to add";
secondaryLabel.text = "Max Segments Add";
secondaryLabel.tooltip = "Maximum stem segments to add";
showSecondary = true;
break;

case NodeEffectType.GrowthSpeed:
primaryLabel.text = "Ticks Per Stage";
primaryLabel.tooltip = "Number of ticks between each growth stage (lower = faster)";
break;

case NodeEffectType.LeafGap:
primaryLabel.text = "Segments Between Leaves";
primaryLabel.tooltip = "0 = leaves every segment, 1 = leaves every 2 segments, etc.";
break;

case NodeEffectType.LeafPattern:
primaryLabel.text = "Pattern Type";
primaryLabel.tooltip = "0=Symmetrical, 1=Offset, 2=Alternating, 3=Spiral, 4=Dense";
break;

case NodeEffectType.StemRandomness:
primaryLabel.text = "Wobble Chance (0-1)";
primaryLabel.tooltip = "Probability that stem will grow sideways";
break;

case NodeEffectType.Cooldown:
primaryLabel.text = "Cooldown Ticks";
primaryLabel.tooltip = "Ticks between mature cycle activations";
break;

case NodeEffectType.CastDelay:
primaryLabel.text = "Delay Ticks";
primaryLabel.tooltip = "Ticks to wait before starting growth";
break;

case NodeEffectType.PoopAbsorption:
primaryLabel.text = "Detection Radius";
primaryLabel.tooltip = "Radius in tiles to detect fertilizer";
secondaryLabel.text = "Energy Per Poop";
secondaryLabel.tooltip = "Energy gained when absorbing fertilizer";
showSecondary = true;
break;

case NodeEffectType.Damage:
primaryLabel.text = "Damage Multiplier Add";
primaryLabel.tooltip = "Adds to damage multiplier (1.0 = +100% damage)";
break;

case NodeEffectType.GrowBerry:
primaryLabel.text = "Enabled";
primaryLabel.tooltip = "Set to 1 to enable berry growth";
break;

case NodeEffectType.ScentModifier:
primaryLabel.text = "Radius Modifier";
primaryLabel.tooltip = "Adds/subtracts from scent radius";
secondaryLabel.text = "Strength Modifier";
secondaryLabel.tooltip = "Adds/subtracts from scent strength";
showSecondary = true;
showScentField = true;
break;
}

EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight), primaryValueProp, primaryLabel);
yPos += lineHeight + spacing;

if (showSecondary) {
EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight), secondaryValueProp, secondaryLabel);
yPos += lineHeight + spacing;
}

if (showScentField) {
EditorGUI.PropertyField(new Rect(position.x, yPos, position.width, lineHeight),
scentDefRefProp, new GUIContent("Scent Definition", "Which scent type to modify"));
}
}

EditorGUI.EndProperty();
}

pub ovr float GetPropertyHeight(SerializedProperty property, GUIContent label) {
float height = EditorGUIUtility.singleLineHeight * 2; // Type + Passive
height += EditorGUIUtility.standardVerticalSpacing * 2;

var effectTypeProp = property.FindPropertyRelative("effectType");
var primaryValueProp = property.FindPropertyRelative("primaryValue");
NodeEffectType currentType = (NodeEffectType)effectTypeProp.enumValueIndex;

if (currentType == NodeEffectType.SeedSpawn) {
height += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing; // Enabled field

if (primaryValueProp.floatValue > 0) {
height += (EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing) * 12;
}
}
else {
height += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing; // Primary value

switch (currentType) {
case NodeEffectType.StemLength:
case NodeEffectType.PoopAbsorption:
case NodeEffectType.ScentModifier:
height += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;
break;
}

if (currentType == NodeEffectType.ScentModifier) {
height += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;
}
}

ret height;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\RadiusPatternTester.cs

﻿using UnityEngine;
using WegoSystem;

#if UNITY_EDITOR
using UnityEditor;

pub cls RadiusPatternTesterEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

RadiusPatternTester tester = (RadiusPatternTester)target;

if (GUILayout.Button("Test Radius Pattern")) {
tester.TestRadiusPattern();
}

if (GUILayout.Button("Compare All Patterns")) {
tester.CompareAllPatterns();
}
}
}
#endif

pub cls RadiusPatternTester : MonoBehaviour {
pub int testRadius = 3;

pub void TestRadiusPattern() {
GridRadiusUtility.DebugPrintRadius(GridPosition.Zero, testRadius);
}

pub void CompareAllPatterns() {
Debug.Log("=== RADIUS PATTERN COMPARISON ===");

for (int r = 1; r <= 5; r++) {
Debug.Log($"\n--- Radius {r} ---");

var circleTiles = GridRadiusUtility.GetTilesInCircle(GridPosition.Zero, r);
Debug.Log($"Circle tiles: {circleTiles.Count}");

GridRadiusUtility.DebugPrintRadius(GridPosition.Zero, r);

int manhattanCount = 0;
int chebyshevCount = 0;

for (int x = -r; x <= r; x++) {
for (int y = -r; y <= r; y++) {
if (Mathf.Abs(x) + Mathf.Abs(y) <= r) manhattanCount++;
if (Mathf.Max(Mathf.Abs(x), Mathf.Abs(y)) <= r) chebyshevCount++;
}
}

Debug.Log($"Manhattan (diamond): {manhattanCount} tiles");
Debug.Log($"Chebyshev (square): {chebyshevCount} tiles");
Debug.Log($"Circle (ours): {circleTiles.Count} tiles");
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\TileDefinitionEditor.cs

﻿#if UNITY_EDITOR
using UnityEditor;

pub cls TileDefinitionEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

TileDefinition tileDefinition = (TileDefinition)target;

EditorGUILayout.Space();
if (GUILayout.Button("UPDATE COLOR IN SCENE", GUILayout.Height(30))) {
tileDefinition.UpdateColor();
}
}
}
#endif

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\TileInteractionManagerEditor.cs

﻿#if UNITY_EDITOR
using UnityEditor;

pub cls TileInteractionManagerEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

TileInteractionManager manager = (TileInteractionManager)target;

EditorGUILayout.Space();
EditorGUILayout.BeginHorizontal();

if (GUILayout.Button("UPDATE SORTING ORDER", GUILayout.Height(30))) {
manager.UpdateSortingOrder();
EditorUtility.SetDirty(manager);
}

if (GUILayout.Button("UPDATE ALL COLORS", GUILayout.Height(30))) {
manager.UpdateAllColors();
EditorUtility.SetDirty(manager);
}

EditorGUILayout.EndHorizontal();

EditorGUILayout.HelpBox("Order: First item in list gets highest sorting order value (" +
manager.baseSortingOrder + "). Each subsequent item is " +
(manager.baseSortingOrder - 1) + ", " +
(manager.baseSortingOrder - 2) + ", etc.", MessageType.Info);
}
}
#endif

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\LeafData.cs

﻿using UnityEngine;

pub cls LeafData {
pub Vector2Int GridCoord;
pub bool IsActive; // True if the leaf exists, false if it was eaten

pub LeafData(Vector2Int coord, bool isActive = true) {
GridCoord = coord;
IsActive = isActive;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeData.cs

﻿using System;

pub cls NodeData : ISerializationCallbackReceiver {
pub string nodeId;
pub string nodeDisplayName;
pub List<NodeEffectData> effects = new List<NodeEffectData>();
pub int orderIndex;

[HideInInspector] pub bool canBeDeleted = true;

[NonSerialized] bool _isContainedInSequence = false;
pub bool IsContainedInSequence => _isContainedInSequence;

[NonSerialized] NodeGraph _storedSequence;

pub NodeGraph storedSequence {
get {
if (_isContainedInSequence || !IsPotentialSeedContainer()) {
if (_storedSequence != null) _storedSequence = null;
}
ret _storedSequence;
}
set {
if (_isContainedInSequence || (!IsPotentialSeedContainer() && value != null)) {
_storedSequence = null;      // Disallow illegal assignments
}
else {
_storedSequence = value;
if (_storedSequence?.nodes != null) {
foreach (var node in _storedSequence.nodes.Where(n => n != null)) {
node.SetContainedInSequence(true);
node._storedSequence = null;
}
}
}
}
}

pub NodeData() {
nodeId             = Guid.NewGuid().ToString();
_storedSequence    = null;
_isContainedInSequence = false;
}

pub bool IsPotentialSeedContainer() =>
effects != null &&
effects.Any(e => e != null &&
e.effectType == NodeEffectType.SeedSpawn &&
e.isPassive);

pub bool IsSeed() => IsPotentialSeedContainer() && !_isContainedInSequence;

pub void SetContainedInSequence(bool isContained) {
_isContainedInSequence = isContained;
if (isContained) _storedSequence = null;
}

pub void EnsureSeedSequenceInitialized() {
if (IsPotentialSeedContainer() && !_isContainedInSequence && _storedSequence == null) {
_storedSequence = new NodeGraph { nodes = new List<NodeData>() };
}
else if (!IsPotentialSeedContainer() || _isContainedInSequence) {
_storedSequence = null;
}
}

pub void ClearStoredSequence() => _storedSequence = null;

pub void OnBeforeSerialize() {
if (_isContainedInSequence || !IsPotentialSeedContainer()) {
_storedSequence = null;
}
}

pub void OnAfterDeserialize() {
_isContainedInSequence = false;
if (!IsPotentialSeedContainer()) {
_storedSequence = null;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeDefinition.cs

﻿using System.Collections.Generic;
using System.Text;
using WegoSystem;

pub cls NodeDefinition : ScriptableObject, ITooltipDataProvider {
pub string displayName;
pub string description;
pub Sprite thumbnail;
pub Color thumbnailTintColor = Color.white;
pub Color backgroundColor = Color.gray;
pub GameObject nodeViewPrefab;
pub List<NodeEffectData> effects;

pub List<NodeEffectData> CloneEffects() {
var copy = new List<NodeEffectData>();
if (effects == null) {
ret copy;
}

foreach (var originalEffect in effects) {
if (originalEffect == null) {
Debug.LogWarning($"NodeDefinition '{this.name}' contains a null effect in its list.");
continue;
}

var newEffect = new NodeEffectData() {
effectType = originalEffect.effectType,
primaryValue = originalEffect.primaryValue,
secondaryValue = originalEffect.secondaryValue,
isPassive = originalEffect.isPassive,
scentDefinitionReference = originalEffect.scentDefinitionReference
};

if (originalEffect.effectType == NodeEffectType.SeedSpawn && originalEffect.seedData != null) {
newEffect.seedData = new SeedSpawnData {
growthSpeed = originalEffect.seedData.growthSpeed,
stemLengthMin = originalEffect.seedData.stemLengthMin,
stemLengthMax = originalEffect.seedData.stemLengthMax,
leafGap = originalEffect.seedData.leafGap,
leafPattern = originalEffect.seedData.leafPattern,
stemRandomness = originalEffect.seedData.stemRandomness,
energyStorage = originalEffect.seedData.energyStorage,
cooldown = originalEffect.seedData.cooldown,
castDelay = originalEffect.seedData.castDelay
};
}

copy.Add(newEffect);
}
ret copy;
}

pub string GetTooltipTitle() {
ret displayName ?? "Unknown Node";
}

pub string GetTooltipDescription() {
ret description ?? string.Empty;
}

pub string GetTooltipDetails(object source = null) {
var nodeData = source as NodeData;
if (nodeData == null) ret string.Empty;

var sb = new StringBuilder();

if (nodeData.effects != null && nodeData.effects.Any()) {
sb.Append("<b>Effects:</b>\n");
var passiveEffectColor = new Color(0.6f, 0.8f, 1f, 1f);
var activeEffectColor = new Color(1f, 0.8f, 0.6f, 1f);
c string effectPrefix = "• ";

foreach (var effect in nodeData.effects) {
if (effect == null) continue;
Color effectColor = effect.isPassive ? passiveEffectColor : activeEffectColor;
string hexColor = ColorUtility.ToHtmlStringRGB(effectColor);
sb.Append($"<color=#{hexColor}>{effectPrefix}{GetEffectDisplayName(effect.effectType)}: ");
sb.Append(GetEffectDescription(effect));
sb.Append("</color>\n");
}
}

if (nodeData.IsSeed()) {
if (sb.Length > 0 && sb[sb.Length - 1] != '\n') sb.Append("\n");
sb.Append("<b>Seed Sequence:</b> ");
if (nodeData.storedSequence?.nodes != null && nodeData.storedSequence.nodes.Any()) {
sb.Append($"{nodeData.storedSequence.nodes.Count} nodes");
}
else {
sb.Append("Empty");
}
}

ret sb.ToString().TrimEnd();
}

string GetEffectDisplayName(NodeEffectType type) {
switch (type) {
case NodeEffectType.EnergyStorage: ret "Energy Storage";
case NodeEffectType.EnergyPerTick: ret "Energy/Tick";
case NodeEffectType.EnergyCost: ret "Energy Cost";
case NodeEffectType.StemLength: ret "Stem Length";
case NodeEffectType.GrowthSpeed: ret "Growth Speed";
case NodeEffectType.LeafGap: ret "Leaf Gap";
case NodeEffectType.LeafPattern: ret "Leaf Pattern";
case NodeEffectType.StemRandomness: ret "Stem Wobble";
case NodeEffectType.Cooldown: ret "Cooldown";
case NodeEffectType.CastDelay: ret "Cast Delay";
case NodeEffectType.PoopAbsorption: ret "Poop Absorption";
case NodeEffectType.Damage: ret "Damage";
case NodeEffectType.GrowBerry: ret "Berry Growth";
case NodeEffectType.SeedSpawn: ret "Seed";
case NodeEffectType.ScentModifier: ret "Scent";
default: ret type.ToString();
}
}

string GetEffectDescription(NodeEffectData effect) {
switch (effect.effectType) {
case NodeEffectType.EnergyStorage:
ret $"+{effect.primaryValue:F0} max energy";

case NodeEffectType.EnergyPerTick:
ret $"+{effect.primaryValue:F2} energy/tick";

case NodeEffectType.EnergyCost:
ret $"{effect.primaryValue:F0} energy to activate";

case NodeEffectType.StemLength:
if (effect.secondaryValue > 0 && effect.secondaryValue != effect.primaryValue) {
ret $"+{effect.primaryValue:F0} to +{effect.secondaryValue:F0} stem segments";
} else {
ret $"+{effect.primaryValue:F0} stem segments";
}

case NodeEffectType.GrowthSpeed:
ret effect.primaryValue <= 1
? "Instant growth"
: $"{effect.primaryValue:F0} ticks/stage";

case NodeEffectType.LeafGap:
ret effect.primaryValue == 0
? "Leaves every segment"
: $"Leaves every {effect.primaryValue + 1:F0} segments";

case NodeEffectType.LeafPattern:
string patternName = GetLeafPatternName((int)effect.primaryValue);
ret $"Pattern: {patternName}";

case NodeEffectType.StemRandomness:
ret $"{effect.primaryValue * 100:F0}% chance to wobble";

case NodeEffectType.Cooldown:
ret $"{effect.primaryValue:F0} tick cooldown";

case NodeEffectType.CastDelay:
ret effect.primaryValue > 0
? $"{effect.primaryValue:F0} tick delay"
: "No delay";

case NodeEffectType.PoopAbsorption:
string result = "";
if (effect.primaryValue > 0) result += $"{effect.primaryValue:F0} tile radius";
if (effect.secondaryValue > 0) {
if (result.Length > 0) result += ", ";
result += $"+{effect.secondaryValue:F0} energy";
}
ret result;

case NodeEffectType.Damage:
ret $"+{effect.primaryValue * 100:F0}% damage";

case NodeEffectType.GrowBerry:
ret "Grows berries";

case NodeEffectType.SeedSpawn:
ret effect.isPassive ? "Contains seed" : "Active seed";

case NodeEffectType.ScentModifier:
string result = "";
if (effect.primaryValue != 0) result += $"Radius {(effect.primaryValue >= 0 ? "+" : "")}{effect.primaryValue:F0}";
if (effect.secondaryValue != 0) {
if (result.Length > 0) result += ", ";
result += $"Strength {(effect.secondaryValue >= 0 ? "+" : "")}{effect.secondaryValue:F0}";
}
if (effect.scentDefinitionReference != null) {
result += $" ({effect.scentDefinitionReference.displayName})";
}
ret result;

default:
string defaultResult = $"{effect.primaryValue:F1}";
if (effect.secondaryValue != 0) {
defaultResult += $" / {effect.secondaryValue:F1}";
}
ret defaultResult;
}
}

string GetLeafPatternName(int pattern) {
switch (pattern) {
case 0: ret "Symmetrical";
case 1: ret "Offset";
case 2: ret "Alternating";
case 3: ret "Spiral";
case 4: ret "Dense";
default: ret $"Pattern {pattern}";
}
}

pub string GetStatsAsString() {
if (effects == null || effects.Count == 0) ret "No effects";

var result = new System.Text.StringBuilder();

foreach (var effect in effects) {
result.AppendLine($"{GetEffectDisplayName(effect.effectType)}: {GetEffectDescription(effect)}");
}

ret result.ToString();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeDefinitionLibrary.cs

﻿using UnityEngine;
using System; // Needed for [Serializable]

[Serializable] // Make it visible and editable in the Inspector
pub struct InitialNodeConfig {
pub NodeDefinition nodeDefinition;

pub int cellIndex;

pub bool canMove;

pub bool canDelete;
}

pub cls NodeDefinitionLibrary : ScriptableObject {
pub List<NodeDefinition> definitions; // Your existing list

pub List<InitialNodeConfig> initialNodes; // <<< NEW LIST ADDED
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeEffectData.cs

﻿using System;

pub cls NodeEffectData {
pub NodeEffectType effectType;
pub float primaryValue;
pub float secondaryValue;
pub bool isPassive = false;
pub ScentDefinition scentDefinitionReference;

pub SeedSpawnData seedData;

pub int GetPrimaryValueAsInt() => Mathf.RoundToInt(primaryValue);
pub int GetSecondaryValueAsInt() => Mathf.RoundToInt(secondaryValue);

pub void ValidateForTicks() {
switch (effectType) {
case NodeEffectType.GrowthSpeed:
case NodeEffectType.Cooldown:
case NodeEffectType.CastDelay:
primaryValue = Mathf.Max(1, Mathf.RoundToInt(primaryValue));
break;

case NodeEffectType.PoopAbsorption:
primaryValue = Mathf.Max(0, Mathf.RoundToInt(primaryValue));
secondaryValue = Mathf.Max(0f, secondaryValue);
break;

case NodeEffectType.EnergyPerTick:
case NodeEffectType.EnergyStorage:
case NodeEffectType.EnergyCost:
primaryValue = Mathf.Max(0f, primaryValue);
break;

case NodeEffectType.SeedSpawn:
if (seedData != null) {
seedData.growthSpeed = Mathf.Max(1, seedData.growthSpeed);
seedData.stemLengthMin = Mathf.Max(1, seedData.stemLengthMin);
seedData.stemLengthMax = Mathf.Max(seedData.stemLengthMin, seedData.stemLengthMax);
seedData.leafGap = Mathf.Max(0, seedData.leafGap);
seedData.leafPattern = Mathf.Clamp(seedData.leafPattern, 0, 4);
seedData.stemRandomness = Mathf.Clamp01(seedData.stemRandomness);
seedData.energyStorage = Mathf.Max(1f, seedData.energyStorage);
seedData.cooldown = Mathf.Max(1, seedData.cooldown);
seedData.castDelay = Mathf.Max(0, seedData.castDelay);
}
break;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeEffectType.cs

﻿using System;

pub enum NodeEffectType {
EnergyStorage = 0,           // Max energy capacity
EnergyPerTick = 1,          // Energy generated per tick
EnergyCost = 2,             // Energy cost when executing mature cycle

StemLength = 3,             // Number of stem segments
GrowthSpeed = 4,            // Ticks between growth stages
LeafGap = 5,                // Stem segments between leaves
LeafPattern = 6,            // Pattern type (0-4)
StemRandomness = 7,         // Chance of random stem direction (0-1)

Cooldown = 8,               // Ticks between mature cycles
CastDelay = 9,              // Ticks delay before growth starts

PoopAbsorption = 10,        // Detection radius (primary) and energy bonus (secondary)

Damage = 11,                // Damage multiplier

GrowBerry = 12,             // Spawns berry
SeedSpawn = 13,             // Makes this a seed with comprehensive plant data

ScentModifier = 14,         // Modifies scent radius/strength
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeGraph.cs

﻿using System;

pub cls NodeGraph {
pub List<NodeData> nodes = new List<NodeData>();
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\SeedSpawnData.cs

﻿using System;

pub cls SeedSpawnData {
pub int growthSpeed = 5;

pub int stemLengthMin = 3;

pub int stemLengthMax = 5;

pub int leafGap = 1;

pub int leafPattern = 0;

pub float stemRandomness = 0.1f;

pub float energyStorage = 10f;

pub int cooldown = 20;

pub int castDelay = 0;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Execution\NodeExecutor.cs

﻿using UnityEngine;
using TMPro;

pub cls NodeExecutor : MonoBehaviour {
[SerializeField] GameObject plantPrefab;
[SerializeField] TMP_Text debugOutput;

pub stat List<NodeEffectData> CloneEffectsList(List<NodeEffectData> originalList) {
if (originalList == null) ret new List<NodeEffectData>();
List<NodeEffectData> newList = new List<NodeEffectData>(originalList.Count);
foreach (var originalEffect in originalList) {
if (originalEffect == null) continue;
NodeEffectData newEffect = new NodeEffectData {
effectType = originalEffect.effectType,
primaryValue = originalEffect.primaryValue,
secondaryValue = originalEffect.secondaryValue,
isPassive = originalEffect.isPassive,
scentDefinitionReference = originalEffect.scentDefinitionReference
};
newList.Add(newEffect);
}
ret newList;
}

pub stat NodeData CloneNodeData(NodeData original, bool preserveStoredSequence = false) {
if (original == null) ret null;

NodeData clone = new NodeData {
nodeId = System.Guid.NewGuid().ToString(),
nodeDisplayName = original.nodeDisplayName,
effects = CloneEffectsList(original.effects),
orderIndex = original.orderIndex,
canBeDeleted = original.canBeDeleted,
};

if (preserveStoredSequence && original.IsPotentialSeedContainer() && original.storedSequence != null) {
clone.EnsureSeedSequenceInitialized();
if (clone.storedSequence.nodes == null) {
clone.storedSequence.nodes = new List<NodeData>();
}

foreach (var nodeInOriginalSequence in original.storedSequence.nodes) {
if (nodeInOriginalSequence == null) continue;
NodeData innerClone = CloneNodeData(nodeInOriginalSequence, false); // Inner nodes never preserve sequence
innerClone.SetContainedInSequence(true);
clone.storedSequence.nodes.Add(innerClone);
}
}
else {
clone.EnsureSeedSequenceInitialized(); // Ensures a valid (but possibly empty) sequence object exists
}

ret clone;
}

pub GameObject SpawnPlantFromSeedInSlot(Vector3 plantingPosition, Transform parentTransform) {
if (NodeEditorGridController.Instance == null) { DebugLogError("Node Editor Grid Controller not found!"); ret null; }
if (plantPrefab == null) { DebugLogError("Plant prefab not assigned!"); ret null; }

NodeData seedNodeDataInSlot = NodeEditorGridController.Instance.GetCurrentSeedInSlot();

if (seedNodeDataInSlot == null) {
DebugLog("No seed in slot to plant.");
ret null;
}
if (!seedNodeDataInSlot.IsSeed()) {
DebugLogError($"Item '{seedNodeDataInSlot.nodeDisplayName}' in seed slot is not a valid seed container!");
ret null;
}

seedNodeDataInSlot.EnsureSeedSequenceInitialized();

NodeGraph sequenceFromEditor = NodeEditorGridController.Instance.GetCurrentGraphInEditorForSpawning();

DebugLog($"Attempting to plant seed '{seedNodeDataInSlot.nodeDisplayName}' with {sequenceFromEditor.nodes.Count} int nodes from editor...");

NodeGraph finalGraphForPlant = new NodeGraph { nodes = new List<NodeData>() };

NodeData clonedSeedNodeForPlant = CloneNodeData(seedNodeDataInSlot, false);
if (clonedSeedNodeForPlant == null) { DebugLogError("Failed to clone seed node for plant."); ret null; }

clonedSeedNodeForPlant.orderIndex = 0;
clonedSeedNodeForPlant.canBeDeleted = false;
finalGraphForPlant.nodes.Add(clonedSeedNodeForPlant);

int currentOrderIndex = 1;
foreach (NodeData nodeFromEditorSequence in sequenceFromEditor.nodes.OrderBy(n => n.orderIndex)) {
if (nodeFromEditorSequence == null) continue;

NodeData clonedSequenceNodeForPlant = CloneNodeData(nodeFromEditorSequence, false);
if (clonedSequenceNodeForPlant == null) continue;

clonedSequenceNodeForPlant.orderIndex = currentOrderIndex++;
clonedSequenceNodeForPlant.canBeDeleted = false;
finalGraphForPlant.nodes.Add(clonedSequenceNodeForPlant);
}

GameObject plantObj = Instantiate(plantPrefab, plantingPosition, Quaternion.identity, parentTransform);
PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();

if (growthComponent != null) {
growthComponent.InitializeAndGrow(finalGraphForPlant);
DebugLog($"Plant '{plantObj.name}' spawned and initialized with seed '{seedNodeDataInSlot.nodeDisplayName}'.");
ret plantObj;
}
else {
DebugLogError($"Prefab '{plantPrefab.name}' missing PlantGrowth component! Destroying spawned object.");
Destroy(plantObj);
ret null;
}
}

pub GameObject SpawnPlantFromInventorySeed(NodeData seedData, Vector3 spawnPos, Transform parent) {
if (seedData == null || !seedData.IsSeed()) {
DebugLogError("SpawnPlantFromInventorySeed called with invalid seed.");
ret null;
}
if (plantPrefab == null) {
DebugLogError("Plant prefab not assigned.");
ret null;
}

seedData.EnsureSeedSequenceInitialized();

NodeGraph graph = new NodeGraph { nodes = new List<NodeData>() };

NodeData seedClone = CloneNodeData(seedData, false);
seedClone.orderIndex = 0;
seedClone.canBeDeleted = false;
graph.nodes.Add(seedClone);

int order = 1;
if (seedData.storedSequence?.nodes != null) {
foreach (NodeData n in seedData.storedSequence.nodes.OrderBy(n => n.orderIndex)) {
NodeData clone = CloneNodeData(n, false);
if (clone == null) continue;
clone.orderIndex = order++;
clone.canBeDeleted = false;
graph.nodes.Add(clone);
}
}

GameObject plantGO = Instantiate(plantPrefab, spawnPos, Quaternion.identity, parent);
PlantGrowth growth = plantGO.GetComponent<PlantGrowth>();

if (growth == null) {
DebugLogError("Plant prefab missing PlantGrowth component.");
Destroy(plantGO);
ret null;
}

growth.InitializeAndGrow(graph);
ret plantGO;
}

void DebugLog(string msg) {
if (debugOutput != null) debugOutput.text += msg + "\n";
}

void DebugLogError(string msg) {
Debug.LogError($"[NodeExecutor] {msg}");
if (debugOutput != null) debugOutput.text += $"ERROR: {msg}\n";
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\OutputNodeEffect.cs

﻿using UnityEngine;

pub cls OutputNodeEffect : MonoBehaviour {
pub GameObject projectilePrefab;

pub Vector2 spawnOffset = Vector2.up;

PlantGrowth parentPlantGrowth;

void Awake() {
parentPlantGrowth = GetComponentInParent<PlantGrowth>();
if (parentPlantGrowth == null) {
Debug.LogError($"[{nameof(OutputNodeEffect)}] Could not find parent PlantGrowth component! Scent application will fail.", gameObject);
}
}

pub void Activate(float damageMultiplier, Dictionary<ScentDefinition, float> scentRadiusBonuses, // <<< UPDATED TYPE Dictionary<ScentDefinition, float> scentStrengthBonuses) // <<< UPDATED TYPE {
if (projectilePrefab == null) {
Debug.LogError($"[{nameof(OutputNodeEffect)}] Projectile Prefab not assigned!", gameObject);
return;
}

if (parentPlantGrowth == null) { // Check again in case Awake failed silently
Debug.LogError($"[{nameof(OutputNodeEffect)}] Cannot activate, parent PlantGrowth reference is missing. Scent application will fail.", gameObject);
}

Vector2 spawnPos = (Vector2)transform.position + spawnOffset;
GameObject projGO = Instantiate(projectilePrefab, spawnPos, transform.rotation); // Use plant's rotation or aim logic

if (parentPlantGrowth != null) // Check if reference exists before calling {

parentPlantGrowth.ApplyScentDataToObject(projGO, scentRadiusBonuses, scentStrengthBonuses);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantCell.cs

﻿using UnityEngine;

pub enum PlantCellType { Seed, Stem, Leaf, Flower, Fruit } // <<< ADDED ENUM DEFINITION

pub cls PlantCell : MonoBehaviour {
[HideInInspector] pub PlantGrowth ParentPlantGrowth;
[HideInInspector] pub Vector2Int GridCoord;
[HideInInspector] pub PlantCellType CellType; // Uses the enum defined above

void OnDestroy() {
if (ParentPlantGrowth != null) {
if (CellType == PlantCellType.Leaf) {
if (Debug.isDebugBuild)
Debug.Log($"[PlantCell OnDestroy] Leaf at {GridCoord} is being destroyed - notifying parent plant", gameObject);
}

ParentPlantGrowth.ReportCellDestroyed(GridCoord);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantCellManager.cs

﻿using UnityEngine;

pub cls PlantCellManager {
ro PlantGrowth plant;
ro GameObject seedCellPrefab;
ro GameObject stemCellPrefab;
ro GameObject leafCellPrefab;
ro GameObject berryCellPrefab;
ro float cellSpacing;

Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
List<GameObject> activeCellGameObjects = new List<GameObject>();
pub GameObject RootCellInstance { get; set; }
pub List<LeafData> LeafDataList { get; } = new List<LeafData>();

bool? offsetRightForPattern1 = null;

pub PlantCellManager(PlantGrowth plant, GameObject seedPrefab, GameObject stemPrefab, GameObject leafPrefab, GameObject berryPrefab, float spacing) {
this.plant = plant;
seedCellPrefab = seedPrefab;
stemCellPrefab = stemPrefab;
leafCellPrefab = leafPrefab;
berryCellPrefab = berryPrefab;
cellSpacing = spacing;
}

pub void ReportCellDestroyed(Vector2Int coord) {
if (cells.ContainsKey(coord)) {
PlantCellType cellType = cells[coord];

if (cellType == PlantCellType.Leaf) {
for (int i = 0; i < LeafDataList.Count; i++) {
if (LeafDataList[i].GridCoord == coord) {
LeafData updatedData = LeafDataList[i];
updatedData.IsActive = false;
LeafDataList[i] = updatedData;
break;
}
}
}

cells.Remove(coord);
activeCellGameObjects.RemoveAll(go => go == null || (go.GetComponent<PlantCell>()?.GridCoord == coord));

if (plant.IsOutlineEnabled() && plant.VisualManager.OutlineController != null) {
plant.VisualManager.OutlineController.OnPlantCellRemoved(coord);
}
}
}

pub void ClearAllVisuals() {
List<GameObject> cellsToClear = new List<GameObject>(activeCellGameObjects);
foreach (GameObject cellGO in cellsToClear) {
if (cellGO != null) {
Object.Destroy(cellGO);
}
}
activeCellGameObjects.Clear();
cells.Clear();
RootCellInstance = null;
}

pub GameObject SpawnCellVisual(PlantCellType cellType, Vector2Int coords, Dictionary<ScentDefinition, float> accumulatedScentRadiusBonus = null, Dictionary<ScentDefinition, float> accumulatedScentStrengthBonus = null) {
if (cells.ContainsKey(coords)) {
Debug.LogWarning($"[{plant.gameObject.name}] Trying to spawn {cellType} at occupied coord {coords}.");
ret null;
}

GameObject prefab = null;
switch (cellType) {
case PlantCellType.Seed: prefab = seedCellPrefab; break;
case PlantCellType.Stem: prefab = stemCellPrefab; break;
case PlantCellType.Leaf: prefab = leafCellPrefab; break;
case PlantCellType.Fruit: prefab = berryCellPrefab; break;
}

if (prefab == null) {
Debug.LogError($"[{plant.gameObject.name}] Prefab for PlantCellType.{cellType} is null!");
ret null;
}

Vector2 worldPos = (Vector2)plant.transform.position + ((Vector2)coords * cellSpacing);
GameObject instance = Object.Instantiate(prefab, worldPos, Quaternion.identity, plant.transform);
instance.name = $"{plant.gameObject.name}_{cellType}_{coords.x}_{coords.y}";

PlantCell cellComp = instance.GetComponent<PlantCell>() ?? instance.AddComponent<PlantCell>();
cellComp.ParentPlantGrowth = plant;
cellComp.GridCoord = coords;
cellComp.CellType = cellType;

cells[coords] = cellType;
activeCellGameObjects.Add(instance);

SortableEntity sorter = instance.GetComponent<SortableEntity>() ?? instance.AddComponent<SortableEntity>();
sorter.SetUseParentYCoordinate(cellType != PlantCellType.Seed);

if (cellType == PlantCellType.Fruit) {
plant.ApplyScentDataToObject(instance, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
}

plant.VisualManager.RegisterShadowForCell(instance, cellType.ToString());
if (plant.IsOutlineEnabled() && plant.VisualManager.OutlineController != null) {
plant.VisualManager.OutlineController.OnPlantCellAdded(coords, instance);
}

ret instance;
}

pub List<Vector2Int> CalculateLeafPositions(Vector2Int stemPos, int stageCounter, int leafPattern) {
List<Vector2Int> leafPositions = new List<Vector2Int>();
Vector2Int leftBase = stemPos + Vector2Int.left;
Vector2Int rightBase = stemPos + Vector2Int.right;

switch (leafPattern) {
case 0:
leafPositions.Add(leftBase);
leafPositions.Add(rightBase);
break;
case 1:
if (offsetRightForPattern1 == null) offsetRightForPattern1 = Random.value < 0.5f;
if (offsetRightForPattern1.Value) {
leafPositions.Add(leftBase);
leafPositions.Add(rightBase + Vector2Int.up);
} else {
leafPositions.Add(leftBase + Vector2Int.up);
leafPositions.Add(rightBase);
}
break;
case 2:
switch (stageCounter % 4) {
case 0:
case 2:
leafPositions.Add(leftBase);
leafPositions.Add(rightBase);
break;
case 1:
leafPositions.Add(leftBase + Vector2Int.up);
leafPositions.Add(rightBase);
break;
case 3:
leafPositions.Add(leftBase);
leafPositions.Add(rightBase + Vector2Int.up);
break;
}
break;
case 3:
int spiralDir = (stageCounter % 2 == 0) ? 1 : -1;
if (spiralDir > 0) {
leafPositions.Add(leftBase);
leafPositions.Add(rightBase + Vector2Int.up);
} else {
leafPositions.Add(leftBase + Vector2Int.up);
leafPositions.Add(rightBase);
}
break;
case 4:
leafPositions.Add(leftBase);
leafPositions.Add(leftBase + Vector2Int.up);
leafPositions.Add(rightBase);
leafPositions.Add(rightBase + Vector2Int.up);
break;
default:
leafPositions.Add(leftBase);
leafPositions.Add(rightBase);
break;
}
ret leafPositions;
}

pub bool TryRegrowLeaf() {
int missingLeafIndex = -1;
for (int i = 0; i < LeafDataList.Count; i++) {
if (!LeafDataList[i].IsActive) {
missingLeafIndex = i;
break;
}
}
if (missingLeafIndex == -1) ret false;

Vector2Int leafCoord = LeafDataList[missingLeafIndex].GridCoord;
if (cells.ContainsKey(leafCoord)) ret false;

GameObject newLeaf = SpawnCellVisual(PlantCellType.Leaf, leafCoord);
if (newLeaf != null) {
LeafDataList[missingLeafIndex] = new LeafData(leafCoord, true);
ret true;
}
ret false;
}

pub bool DoesCellExistAt(Vector2Int coord) => cells.ContainsKey(coord);

pub GameObject GetCellGameObjectAt(Vector2Int coord) {
ret activeCellGameObjects.FirstOrDefault(go => go != null && go.GetComponent<PlantCell>()?.GridCoord == coord);
}

pub Dictionary<Vector2Int, PlantCellType> GetCells() => cells;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantEnergySystem.cs

﻿// Assets\Scripts\PlantSystem\Growth\PlantEnergySystem.cs
using WegoSystem;

pub cls PlantEnergySystem {
ro PlantGrowth plant;

pub float CurrentEnergy { get; set; } = 0f;
pub float MaxEnergy { get; set; } = 10f;
pub float PhotosynthesisRate { get; set; } = 0.5f;

FireflyManager fireflyManagerInstance;

pub PlantEnergySystem(PlantGrowth plant) {
this.plant = plant;
fireflyManagerInstance = FireflyManager.Instance;
}

pub void AccumulateEnergy() {
if (PhotosynthesisRate <= 0 || MaxEnergy <= 0) return;

float sunlight = WeatherManager.Instance ? WeatherManager.Instance.sunIntensity : 1f;
int leafCount = plant.CellManager.GetCells().Values.Count(c => c == PlantCellType.Leaf);
float tileMultiplier = (PlantGrowthModifierManager.Instance != null) ?
PlantGrowthModifierManager.Instance.GetEnergyRechargeMultiplier(plant) : 1.0f;

float fireflyBonusRate = 0f;
if (fireflyManagerInstance != null) {
int nearbyFlyCount = fireflyManagerInstance.GetNearbyFireflyCount(plant.transform.position, fireflyManagerInstance.photosynthesisRadius);
fireflyBonusRate = Mathf.Min(nearbyFlyCount * fireflyManagerInstance.photosynthesisIntensityPerFly, fireflyManagerInstance.maxPhotosynthesisBonus);
}

float standardPhotosynthesis = PhotosynthesisRate * leafCount * sunlight;
float totalRate = (standardPhotosynthesis + fireflyBonusRate) * tileMultiplier;
float delta = totalRate * Time.deltaTime;
CurrentEnergy = Mathf.Clamp(CurrentEnergy + delta, 0f, MaxEnergy);
}

pub void AccumulateEnergyTick() {
if (PhotosynthesisRate <= 0 || MaxEnergy <= 0) return;

float sunlight = WeatherManager.Instance ? WeatherManager.Instance.sunIntensity : 1f;
int leafCount = plant.CellManager.GetCells().Values.Count(c => c == PlantCellType.Leaf);
float tileMultiplier = (PlantGrowthModifierManager.Instance != null) ?
PlantGrowthModifierManager.Instance.GetEnergyRechargeMultiplier(plant) : 1.0f;

float fireflyBonusRate = 0f;
if (fireflyManagerInstance != null) {
GridEntity plantGrid = plant.GetComponent<GridEntity>();
if (plantGrid != null) {
int radiusTiles = Mathf.CeilToInt(fireflyManagerInstance.photosynthesisRadius);

int nearbyFlyCount = 0;
var fireflies = Object.FindObjectsOfType<FireflyController>();

foreach (var firefly in fireflies) {
GridEntity fireflyGrid = firefly.GetComponent<GridEntity>();
if (fireflyGrid != null &&
GridRadiusUtility.IsWithinCircleRadius(fireflyGrid.Position, plantGrid.Position, radiusTiles)) {
nearbyFlyCount++;
}
}

fireflyBonusRate = Mathf.Min(
nearbyFlyCount * fireflyManagerInstance.photosynthesisIntensityPerFly,
fireflyManagerInstance.maxPhotosynthesisBonus
);
}
}

float ticksPerSecond = TickManager.Instance?.Config?.ticksPerRealSecond ?? 2f;
float standardPhotosynthesis = (PhotosynthesisRate * leafCount * sunlight) / ticksPerSecond;
float totalRate = (standardPhotosynthesis + (fireflyBonusRate / ticksPerSecond)) * tileMultiplier;

CurrentEnergy = Mathf.Clamp(CurrentEnergy + totalRate, 0f, MaxEnergy);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantGrowth.cs

﻿using UnityEngine;
using WegoSystem;

pub enum PlantState { Initializing, Growing, GrowthComplete, Mature_Idle, Mature_Executing }

pub cls PlantGrowth : MonoBehaviour, ITickUpdateable {
[SerializeField] bool useWegoSystem = true;

pub stat ro List<PlantGrowth> AllActivePlants = new List<PlantGrowth>();

pub PlantCellManager CellManager { get; set; }
pub PlantNodeExecutor NodeExecutor { get; set; }
pub PlantGrowthLogic GrowthLogic { get; set; }
pub PlantEnergySystem EnergySystem { get; set; }
pub PlantVisualManager VisualManager { get; set; }

pub NodeGraph NodeGraph { get; set; }
pub PlantState CurrentState { get; set; } = PlantState.Initializing;

[SerializeField] GameObject seedCellPrefab;
[SerializeField] GameObject stemCellPrefab;
[SerializeField] GameObject leafCellPrefab;
[SerializeField] GameObject berryCellPrefab;
[SerializeField] float cellSpacing = 0.08f;

[SerializeField] PlantShadowController shadowController;
[SerializeField] GameObject shadowPartPrefab;
[SerializeField] bool enableOutline = true;
[SerializeField] PlantOutlineController outlineController;
[SerializeField] GameObject outlinePartPrefab;

[SerializeField] bool allowPhotosynthesisDuringGrowth = false;

void Awake() {
InitializeComponents();
ValidateReferences();
AllActivePlants.Add(this);
}

void InitializeComponents() {
CellManager = new PlantCellManager(this, seedCellPrefab, stemCellPrefab, leafCellPrefab, berryCellPrefab, cellSpacing);
NodeExecutor = new PlantNodeExecutor(this);
GrowthLogic = new PlantGrowthLogic(this);
EnergySystem = new PlantEnergySystem(this);
VisualManager = new PlantVisualManager(this, shadowController, shadowPartPrefab, outlineController, outlinePartPrefab, enableOutline);
}

void ValidateReferences() {
bool setupValid = true;

if (shadowController == null) {
shadowController = GetComponentInChildren<PlantShadowController>(true);
if (shadowController == null) {
Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': PlantShadowController ref missing!", this);
setupValid = false;
}
}

if (shadowPartPrefab == null) {
Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Shadow Part Prefab missing!", this);
setupValid = false;
}

if (enableOutline) {
if (outlineController == null) {
outlineController = GetComponentInChildren<PlantOutlineController>(true);
if (outlineController == null) {
Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': PlantOutlineController ref missing but outline is enabled!", this);
setupValid = false;
}
}
if (outlinePartPrefab == null) {
Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Outline Part Prefab missing but outline is enabled!", this);
setupValid = false;
}
}

if (seedCellPrefab == null) {
Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Seed Cell Prefab missing!", this);
setupValid = false;
}

if (!setupValid) {
enabled = false;
return;
}

if (!enableOutline && outlineController != null) {
outlineController.gameObject.SetActive(false);
}
}

void Start() {
if (useWegoSystem && TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
VisualManager.UpdateUI();
}

void OnDestroy() {
AllActivePlants.Remove(this);
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
if (PlantGrowthModifierManager.Instance != null) {
PlantGrowthModifierManager.Instance.UnregisterPlant(this);
}
CellManager?.ClearAllVisuals();
}

void Update() {
if (useWegoSystem) {
VisualManager.UpdateWegoUI();
return;
}

switch (CurrentState) {
case PlantState.Growing:
if (allowPhotosynthesisDuringGrowth) EnergySystem.AccumulateEnergy();
VisualManager.UpdateRealtimeGrowthUI();
break;
case PlantState.GrowthComplete:
GrowthLogic.HandleGrowthComplete();
break;
case PlantState.Mature_Idle:
EnergySystem.AccumulateEnergy();
VisualManager.UpdateUI();
GrowthLogic.UpdateMaturityCycle();
break;
case PlantState.Mature_Executing:
EnergySystem.AccumulateEnergy();
VisualManager.UpdateUI();
break;
}
}

pub void OnTickUpdate(int currentTick) {
if (!useWegoSystem) return;
GrowthLogic.OnTickUpdate(currentTick);
VisualManager.UpdateUI();
}

pub void InitializeAndGrow(NodeGraph graph) {
if (graph == null || graph.nodes == null) {
Debug.LogError($"[{gameObject.name}] Null/empty NodeGraph provided.", gameObject);
Destroy(gameObject);
return;
}

GrowthLogic.StopGrowthCoroutine();
CellManager.ClearAllVisuals();
VisualManager.ResetDisplayState();

NodeGraph = graph;
CurrentState = PlantState.Initializing;
EnergySystem.CurrentEnergy = 0f;
CellManager.LeafDataList.Clear();

GrowthLogic.CalculateAndApplyStats();

GameObject spawnedSeed = CellManager.SpawnCellVisual(PlantCellType.Seed, Vector2Int.zero, null, null);
if (spawnedSeed != null) {
CellManager.RootCellInstance = spawnedSeed;
RegisterWithManagers();

if (GrowthLogic.TargetStemLength > 0) {
CurrentState = PlantState.Growing;
VisualManager.UpdateGrowthPercentageUI();
if (!useWegoSystem) {
GrowthLogic.StartRealtimeGrowth();
}
} else {
Debug.LogWarning($"[{gameObject.name}] Target stem length is {GrowthLogic.TargetStemLength}. Skipping visual growth phase.", gameObject);
GrowthLogic.CompleteGrowth();
}
} else {
Debug.LogError($"[{gameObject.name}] Failed to spawn initial seed! Aborting growth.", gameObject);
CurrentState = PlantState.Mature_Idle;
Destroy(gameObject, 0.1f);
}

VisualManager.UpdateUI();
}

void RegisterWithManagers() {
if (PlantGrowthModifierManager.Instance != null && TileInteractionManager.Instance != null) {
Vector3Int gridPos = TileInteractionManager.Instance.WorldToCell(transform.position);
TileDefinition currentTile = TileInteractionManager.Instance.FindWhichTileDefinitionAt(gridPos);
PlantGrowthModifierManager.Instance.RegisterPlantTile(this, currentTile);
}
}

pub void SetWegoSystem(bool enabled) {
bool wasEnabled = useWegoSystem;
useWegoSystem = enabled;

if (enabled && !wasEnabled && TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
if (CurrentState == PlantState.Growing) {
GrowthLogic.StopGrowthCoroutine();
}
} else if (!enabled && wasEnabled && TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
if (CurrentState == PlantState.Growing) {
GrowthLogic.StartRealtimeGrowth();
}
}
}

pub bool DoesCellExistAt(Vector2Int coord) => CellManager.DoesCellExistAt(coord);
pub float GetCellSpacing() => cellSpacing;
pub GameObject GetCellGameObjectAt(Vector2Int coord) => CellManager.GetCellGameObjectAt(coord);
pub bool IsOutlineEnabled() => enableOutline;
pub float GetPoopDetectionRadius() => NodeExecutor.PoopDetectionRadius;
pub void ReportCellDestroyed(Vector2Int coord) => CellManager.ReportCellDestroyed(coord);
pub void ApplyScentDataToObject(GameObject targetObject, Dictionary<ScentDefinition, float> scentRadiusBonuses, Dictionary<ScentDefinition, float> scentStrengthBonuses)
=> NodeExecutor.ApplyScentDataToObject(targetObject, scentRadiusBonuses, scentStrengthBonuses);
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantGrowthLogic.cs

﻿using System.Linq;
using WegoSystem;

pub cls PlantGrowthLogic {
ro PlantGrowth plant;

pub int TargetStemLength { get; set; }
pub int GrowthTicksPerStage { get; set; }
pub int LeafGap { get; set; }
pub int LeafPattern { get; set; }
pub float GrowthRandomness { get; set; }
pub int MaturityCycleTicks { get; set; }
pub int NodeCastDelayTicks { get; set; }

pub float EnergyPerTick { get; set; }
pub float EnergyCostPerCycle { get; set; }

float growthProgressTicks = 0f;
int maturityCycleTick = 0;
int currentStemStage = 0;

pub PlantGrowthLogic(PlantGrowth plant) {
this.plant = plant;
}

pub void CalculateAndApplyStats() {
if (plant.NodeGraph == null) {
Debug.LogError($"[{plant.gameObject.name}] CalculateAndApplyStats called with null NodeGraph!");
return;
}

float baseEnergyStorage = 10f;
float baseEnergyPerTick = 0.25f;
int baseStemMin = 3;
int baseStemMax = 5;
int baseGrowthTicksPerStage = 5;
int baseLeafGap = 1;
int baseLeafPattern = 0;
float baseGrowthRandomness = 0.1f;
int baseCooldownTicks = 20;
int baseCastDelayTicks = 0;

NodeData firstNode = plant.NodeGraph.nodes.FirstOrDefault();
bool hasComprehensiveSeed = false;

if (firstNode != null) {
var seedEffect = firstNode.effects?.FirstOrDefault(e => e != null && e.effectType == NodeEffectType.SeedSpawn);
if (seedEffect != null && seedEffect.seedData != null) {
hasComprehensiveSeed = true;
baseEnergyStorage = seedEffect.seedData.energyStorage;
baseGrowthTicksPerStage = seedEffect.seedData.growthSpeed;
baseStemMin = seedEffect.seedData.stemLengthMin;
baseStemMax = seedEffect.seedData.stemLengthMax;
baseLeafGap = seedEffect.seedData.leafGap;
baseLeafPattern = seedEffect.seedData.leafPattern;
baseGrowthRandomness = seedEffect.seedData.stemRandomness;
baseCooldownTicks = seedEffect.seedData.cooldown;
baseCastDelayTicks = seedEffect.seedData.castDelay;
}
}

float accumulatedEnergyStorage = 0f;
float accumulatedEnergyPerTick = 0f;
int stemLengthMinModifier = 0;
int stemLengthMaxModifier = 0;
int growthTicksModifier = 0;
int leafGapModifier = 0;
int currentLeafPattern = baseLeafPattern;
float growthRandomnessModifier = 0f;
int cooldownTicksModifier = 0;
int castDelayTicksModifier = 0;
bool seedFound = false;

foreach (NodeData node in plant.NodeGraph.nodes.OrderBy(n => n.orderIndex)) {
if (node?.effects == null) continue;

foreach (var effect in node.effects) {
if (effect == null) continue;

effect.ValidateForTicks();

if (effect.effectType == NodeEffectType.SeedSpawn) {
seedFound = true;
if (hasComprehensiveSeed && node == firstNode) continue;
}

if (!effect.isPassive) continue;

switch (effect.effectType) {
case NodeEffectType.EnergyStorage:
accumulatedEnergyStorage += effect.primaryValue;
break;

case NodeEffectType.EnergyPerTick:
accumulatedEnergyPerTick += effect.primaryValue;
break;

case NodeEffectType.StemLength:
stemLengthMinModifier += effect.GetPrimaryValueAsInt();
stemLengthMaxModifier += effect.GetSecondaryValueAsInt();
break;

case NodeEffectType.GrowthSpeed:
growthTicksModifier += effect.GetPrimaryValueAsInt();
break;

case NodeEffectType.LeafGap:
leafGapModifier += effect.GetPrimaryValueAsInt();
break;

case NodeEffectType.LeafPattern:
currentLeafPattern = Mathf.Clamp(effect.GetPrimaryValueAsInt(), 0, 4);
break;

case NodeEffectType.StemRandomness:
growthRandomnessModifier += effect.primaryValue;
break;

case NodeEffectType.Cooldown:
cooldownTicksModifier += effect.GetPrimaryValueAsInt();
break;

case NodeEffectType.CastDelay:
castDelayTicksModifier += effect.GetPrimaryValueAsInt();
break;
}
}
}

plant.EnergySystem.MaxEnergy = Mathf.Max(1f, baseEnergyStorage + accumulatedEnergyStorage);
EnergyPerTick = Mathf.Max(0f, baseEnergyPerTick + accumulatedEnergyPerTick);
plant.EnergySystem.PhotosynthesisRate = EnergyPerTick;

int finalStemMin = Mathf.Max(1, baseStemMin + stemLengthMinModifier);
int finalStemMax = Mathf.Max(finalStemMin, baseStemMax + stemLengthMaxModifier);
TargetStemLength = seedFound ? Random.Range(finalStemMin, finalStemMax + 1) : 0;

GrowthTicksPerStage = Mathf.Max(1, baseGrowthTicksPerStage + growthTicksModifier);
LeafGap = Mathf.Max(0, baseLeafGap + leafGapModifier);
LeafPattern = currentLeafPattern;
GrowthRandomness = Mathf.Clamp01(baseGrowthRandomness + growthRandomnessModifier);
MaturityCycleTicks = Mathf.Max(1, baseCooldownTicks + cooldownTicksModifier);
NodeCastDelayTicks = Mathf.Max(0, baseCastDelayTicks + castDelayTicksModifier);

plant.NodeExecutor.ProcessPassiveEffects(plant.NodeGraph);

if (!seedFound) {
Debug.LogWarning($"[{plant.gameObject.name}] NodeGraph lacks a SeedSpawn effect. Growth aborted.", plant.gameObject);
}

Debug.Log($"[{plant.gameObject.name}] Growth stats: TargetStem={TargetStemLength}, GrowthTicks={GrowthTicksPerStage}, Cooldown={MaturityCycleTicks}");
}

pub void OnTickUpdate(int currentTick) {
switch (plant.CurrentState) {
case PlantState.Growing:
growthProgressTicks += 1f;

if (growthProgressTicks >= GrowthTicksPerStage) {
growthProgressTicks = 0f;

if (currentStemStage < TargetStemLength) {
GrowNextStemStage();
} else {
CompleteGrowth();
}
}
break;

case PlantState.Mature_Idle:
plant.EnergySystem.AccumulateEnergyTick();
maturityCycleTick++;

if (maturityCycleTick >= MaturityCycleTicks && plant.EnergySystem.CurrentEnergy >= 1f) {
plant.CurrentState = PlantState.Mature_Executing;
plant.NodeExecutor.ExecuteMatureCycleTick();
maturityCycleTick = 0;
}
break;

case PlantState.Mature_Executing:
plant.EnergySystem.AccumulateEnergyTick();
plant.CurrentState = PlantState.Mature_Idle;
break;
}
}

void GrowNextStemStage() {
if (currentStemStage >= TargetStemLength) return;

currentStemStage++;
Vector2Int stemPos = Vector2Int.up * currentStemStage;

if (Random.value < GrowthRandomness) {
stemPos += (Random.value < 0.5f) ? Vector2Int.left : Vector2Int.right;
}

GameObject stemCell = plant.CellManager.SpawnCellVisual(PlantCellType.Stem, stemPos, null, null);
if (stemCell == null) {
Debug.LogError($"[{plant.gameObject.name}] Failed to spawn stem at stage {currentStemStage}");
return;
}

if (LeafGap >= 0 && (currentStemStage % (LeafGap + 1)) == 0) {
var leafPositions = plant.CellManager.CalculateLeafPositions(stemPos, currentStemStage, LeafPattern);
foreach (Vector2Int leafPos in leafPositions) {
GameObject leafCell = plant.CellManager.SpawnCellVisual(PlantCellType.Leaf, leafPos, null, null);
if (leafCell != null) {
plant.CellManager.LeafDataList.Add(new LeafData(leafPos, true));
}
}
}
}

pub void CompleteGrowth() {
if (plant.CurrentState == PlantState.GrowthComplete) return;

plant.CurrentState = PlantState.Mature_Idle;
maturityCycleTick = 0;

if (Debug.isDebugBuild) {
Debug.Log($"[{plant.gameObject.name}] Growth completed! Transitioning to mature state.");
}
}

pub float GetGrowthProgressNormalized() {
if (GrowthTicksPerStage <= 0) ret 1f;
ret growthProgressTicks / GrowthTicksPerStage;
}

pub int GetCurrentStemStage() => currentStemStage;
pub void HandleGrowthComplete() => CompleteGrowth();
pub void UpdateMaturityCycle() { }
pub void StopGrowthCoroutine() { }
pub void StartRealtimeGrowth() { }
pub int GetStepsCompleted() => currentStemStage;
pub float GetGrowthProgress() => TargetStemLength > 0 ? (float)currentStemStage / TargetStemLength : 0f;
pub int GetTotalPlannedSteps() => TargetStemLength;
pub float GetActualGrowthProgress() => GrowthTicksPerStage > 0 ? growthProgressTicks / GrowthTicksPerStage : 0f;
pub int GetCurrentStemCount() => currentStemStage;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantNodeExecutor.cs

﻿using System.Collections.Generic;
using WegoSystem;

pub cls PlantNodeExecutor {
ro PlantGrowth plant;

pub float PoopDetectionRadius { get; set; }
pub float PoopEnergyBonus { get; set; }

pub PlantNodeExecutor(PlantGrowth plant) {
this.plant = plant;
}

pub void ProcessPassiveEffects(NodeGraph nodeGraph) {
PoopDetectionRadius = 0f;
PoopEnergyBonus = 0f;

foreach (NodeData node in nodeGraph.nodes.OrderBy(n => n.orderIndex)) {
if (node?.effects == null) continue;

foreach (var effect in node.effects) {
if (effect == null || !effect.isPassive) continue;

switch (effect.effectType) {
case NodeEffectType.PoopAbsorption:
PoopDetectionRadius = Mathf.Max(0f, effect.primaryValue);
PoopEnergyBonus = Mathf.Max(0f, effect.secondaryValue);
break;
}
}
}
}

pub void ExecuteMatureCycleTick() {
if (plant.NodeGraph?.nodes == null || plant.NodeGraph.nodes.Count == 0) {
Debug.LogError($"[{plant.gameObject.name}] NodeGraph missing or empty!");
return;
}

float damageMultiplier = 1.0f;
var accumulatedScentRadiusBonus = new Dictionary<ScentDefinition, float>();
var accumulatedScentStrengthBonus = new Dictionary<ScentDefinition, float>();
float totalEnergyCostForCycle = 0f;

foreach (var node in plant.NodeGraph.nodes.OrderBy(n => n.orderIndex)) {
if (node?.effects == null) continue;

foreach (var effect in node.effects) {
if (effect == null || effect.isPassive) continue;

switch (effect.effectType) {
case NodeEffectType.EnergyCost:
totalEnergyCostForCycle += Mathf.Max(0f, effect.primaryValue);
break;

case NodeEffectType.Damage:
damageMultiplier = Mathf.Max(0.1f, damageMultiplier + effect.primaryValue);
break;

case NodeEffectType.ScentModifier:
if (effect.scentDefinitionReference != null) {
ScentDefinition key = effect.scentDefinitionReference;

if (!accumulatedScentRadiusBonus.ContainsKey(key))
accumulatedScentRadiusBonus[key] = 0f;
accumulatedScentRadiusBonus[key] += effect.primaryValue;

if (!accumulatedScentStrengthBonus.ContainsKey(key))
accumulatedScentStrengthBonus[key] = 0f;
accumulatedScentStrengthBonus[key] += effect.secondaryValue;
}
break;
}
}
}

if (PoopDetectionRadius > 0f) {
CheckForPoopAndAbsorb();
}

if (plant.EnergySystem.CurrentEnergy < totalEnergyCostForCycle) {
if (Debug.isDebugBuild) {
Debug.Log($"[{plant.gameObject.name}] Not enough energy ({plant.EnergySystem.CurrentEnergy}/{totalEnergyCostForCycle}) for mature cycle.");
}
return;
}

plant.EnergySystem.CurrentEnergy = Mathf.Max(0f, plant.EnergySystem.CurrentEnergy - totalEnergyCostForCycle);

foreach (var node in plant.NodeGraph.nodes.OrderBy(n => n.orderIndex)) {
if (node?.effects == null) continue;

foreach (var effect in node.effects) {
if (effect == null || effect.isPassive ||
effect.effectType == NodeEffectType.EnergyCost ||
effect.effectType == NodeEffectType.Damage ||
effect.effectType == NodeEffectType.ScentModifier) continue;

switch (effect.effectType) {
case NodeEffectType.GrowBerry:
TrySpawnBerry(accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
break;
}
}
}
}

void CheckForPoopAndAbsorb() {
bool hasMissingLeaves = plant.CellManager.LeafDataList.Any(leaf => !leaf.IsActive);
bool canAddEnergy = PoopEnergyBonus > 0f;
if (!hasMissingLeaves && !canAddEnergy) return;

int discreteRadius = Mathf.RoundToInt(PoopDetectionRadius);
if (discreteRadius <= 0) return;

GridEntity plantGrid = plant.GetComponent<GridEntity>();
if (plantGrid == null) return;

var tilesInRange = GridRadiusUtility.GetTilesInCircle(plantGrid.Position, discreteRadius);

foreach (var tilePos in tilesInRange) {
Vector3 worldPos = GridPositionManager.Instance.GridToWorld(tilePos);
Collider2D[] colliders = Physics2D.OverlapPointAll(worldPos);

foreach (Collider2D collider in colliders) {
PoopController poop = collider.GetComponent<PoopController>();
if (poop != null) {
bool absorbed = false;

if (hasMissingLeaves) {
absorbed = plant.CellManager.TryRegrowLeaf();
}

if ((!absorbed || !hasMissingLeaves) && canAddEnergy) {
plant.EnergySystem.CurrentEnergy = Mathf.Min(
plant.EnergySystem.MaxEnergy,
plant.EnergySystem.CurrentEnergy + PoopEnergyBonus
);
absorbed = true;
}

if (absorbed) {
Object.Destroy(poop.gameObject);
return;
}
}
}
}
}

void TrySpawnBerry(Dictionary<ScentDefinition, float> scentRadiiBonus, Dictionary<ScentDefinition, float> scentStrengthsBonus) {
var berryCellPrefab = plant.CellManager.GetType()
.GetField("berryCellPrefab", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
.GetValue(plant.CellManager) as GameObject;

if (berryCellPrefab == null) {
Debug.LogWarning($"[{plant.gameObject.name}] Berry Prefab not assigned. Cannot spawn berry.", plant.gameObject);
return;
}

var cells = plant.CellManager.GetCells();
var potentialCoords = cells
.Where(cellKvp => cellKvp.Value == PlantCellType.Stem || cellKvp.Value == PlantCellType.Seed)
.SelectMany(cellKvp => {
Vector2Int[] berryOffsets = { Vector2Int.up, Vector2Int.left, Vector2Int.right };
ret berryOffsets.Select(offset => cellKvp.Key + offset);
})
.Where(coord => !cells.ContainsKey(coord))
.Distinct()
.ToList();

if (potentialCoords.Count > 0) {
Vector2Int chosenCoord = potentialCoords[Random.Range(0, potentialCoords.Count)];
GameObject berryGO = plant.CellManager.SpawnCellVisual(
PlantCellType.Fruit,
chosenCoord,
scentRadiiBonus,
scentStrengthsBonus
);

if (berryGO == null) {
Debug.LogError($"[{plant.gameObject.name}] Failed to spawn berry visual at {chosenCoord}");
}
} else {
if (Debug.isDebugBuild) {
Debug.Log($"[{plant.gameObject.name}] No valid empty adjacent locations found to spawn a berry.");
}
}
}

pub void ApplyScentDataToObject(GameObject targetObject, Dictionary<ScentDefinition, float> scentRadiusBonuses, Dictionary<ScentDefinition, float> scentStrengthBonuses) {
if (targetObject == null || EcosystemManager.Instance?.scentLibrary == null) return;

ScentDefinition strongestScentDef = null;
float maxStrengthBonus = -1f;

if (scentStrengthBonuses != null && scentStrengthBonuses.Count > 0) {
foreach (var kvp in scentStrengthBonuses) {
if (kvp.Key != null && kvp.Value > maxStrengthBonus) {
maxStrengthBonus = kvp.Value;
strongestScentDef = kvp.Key;
}
}
}

if (strongestScentDef != null) {
ScentSource scentSource = targetObject.GetComponent<ScentSource>() ?? targetObject.AddComponent<ScentSource>();
scentSource.definition = strongestScentDef;

scentRadiusBonuses.TryGetValue(strongestScentDef, out float radiusBonus);
scentSource.radiusModifier = radiusBonus;
scentSource.strengthModifier = maxStrengthBonus;

if (strongestScentDef.particleEffectPrefab != null) {
if (!targetObject.transform.GetComponentInChildren<ParticleSystem>()) {
Object.Instantiate(strongestScentDef.particleEffectPrefab, targetObject.transform);
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantVisualManager.cs

﻿using UnityEngine;
using TMPro;

pub cls PlantVisualManager {
ro PlantGrowth plant;
ro PlantShadowController shadowController;
ro GameObject shadowPartPrefab;
ro bool enableOutline;

pub PlantOutlineController OutlineController { get; set; }
ro GameObject outlinePartPrefab;

TMP_Text energyText;
pub bool ShowGrowthPercentage { get; set; } = true;
pub bool ContinuousIncrement { get; set; } = false;

[SerializeField] int percentageIncrement = 5;
int displayedGrowthPercentage = -1;

pub PlantVisualManager(PlantGrowth plant, PlantShadowController shadowController, GameObject shadowPartPrefab, PlantOutlineController outlineController, GameObject outlinePartPrefab, bool enableOutline) {
this.plant = plant;
this.shadowController = shadowController;
this.shadowPartPrefab = shadowPartPrefab;
this.OutlineController = outlineController;
this.outlinePartPrefab = outlinePartPrefab;
this.enableOutline = enableOutline;

EnsureUIReferences();
}

void EnsureUIReferences() {
if (energyText) return;

energyText = plant.GetComponentInChildren<TMP_Text>(true);
if (!energyText) {
Debug.LogWarning($"[{plant.gameObject.name}] Energy Text (TMP_Text) UI reference not assigned and not found in children.", plant.gameObject);
}

var plantType = plant.GetType();
var showGrowthField = plantType.GetField("showGrowthPercentage", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
if (showGrowthField != null) ShowGrowthPercentage = (bool)showGrowthField.GetValue(plant);

var percentIncrementField = plantType.GetField("percentageIncrement", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
if (percentIncrementField != null) percentageIncrement = (int)percentIncrementField.GetValue(plant);

var continuousField = plantType.GetField("continuousIncrement", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
if (continuousField != null) ContinuousIncrement = (bool)continuousField.GetValue(plant);

var energyTextField = plantType.GetField("energyText", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
if (energyTextField != null) energyText = (TMP_Text)energyTextField.GetValue(plant);
}

pub void RegisterShadowForCell(GameObject cellInstance, string cellTypeName) {
if (shadowController == null || shadowPartPrefab == null || cellInstance == null) return;
SpriteRenderer partRenderer = cellInstance.GetComponentInChildren<SpriteRenderer>();
if (partRenderer != null) {
shadowController.RegisterPlantPart(partRenderer, shadowPartPrefab);
} else {
Debug.LogWarning($"Plant '{plant.gameObject.name}': {cellTypeName} missing SpriteRenderer. No shadow.", cellInstance);
}
}

pub void UpdateUI() {
if (energyText == null) return;
if (ShowGrowthPercentage && (plant.CurrentState == PlantState.Growing ||
(plant.CurrentState == PlantState.GrowthComplete && plant.GrowthLogic.GetStepsCompleted() > 0))) {
} else {
energyText.text = $"{Mathf.FloorToInt(plant.EnergySystem.CurrentEnergy)}/{Mathf.FloorToInt(plant.EnergySystem.MaxEnergy)}";
}
}

pub void UpdateWegoUI() {
if (ShowGrowthPercentage && plant.CurrentState == PlantState.Growing) {
UpdateGrowthPercentageUI();
}
}

pub void UpdateRealtimeGrowthUI() {
if (ShowGrowthPercentage && ContinuousIncrement) {
UpdateGrowthPercentageUI();
}
}

pub void UpdateGrowthPercentageUI(bool forceComplete = false) {
if (!ShowGrowthPercentage || energyText == null) return;

float rawPercentageFloat;
var logic = plant.GrowthLogic;

if (forceComplete || plant.CurrentState == PlantState.GrowthComplete) {
rawPercentageFloat = 100f;
} else if (plant.GetType().GetField("useWegoSystem", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance).GetValue(plant) is bool useWego && useWego) {
if (logic.TargetStemLength <= 0) {
rawPercentageFloat = 100f;
} else {
float partialStepProgress = logic.GetGrowthProgress() * (100f / logic.TargetStemLength);
rawPercentageFloat = ((float)logic.GetCurrentStemStage() / logic.TargetStemLength) * 100f + partialStepProgress;
}
} else if (ContinuousIncrement) {
if (logic.GetTotalPlannedSteps() > 0) {
rawPercentageFloat = ((float)logic.GetStepsCompleted() / logic.GetTotalPlannedSteps()) * 100f;
if (logic.GetActualGrowthProgress() > 0f && logic.GetStepsCompleted() < logic.GetTotalPlannedSteps()) {
float stepSize = 100f / logic.GetTotalPlannedSteps();
float partialStepProgress = logic.GetActualGrowthProgress() * stepSize;
rawPercentageFloat = (logic.GetStepsCompleted() * stepSize) + partialStepProgress;
}
} else {
rawPercentageFloat = (plant.CurrentState == PlantState.Growing) ? 0f : 100f;
}
} else {
if (logic.TargetStemLength <= 0) {
rawPercentageFloat = 100f;
} else {
rawPercentageFloat = Mathf.Clamp(((float)logic.GetCurrentStemCount() / logic.TargetStemLength) * 100f, 0f, 100f);
}
}

rawPercentageFloat = Mathf.Clamp(rawPercentageFloat, 0f, 100f);
int targetDisplayValue;
if (percentageIncrement <= 1) {
targetDisplayValue = Mathf.FloorToInt(rawPercentageFloat);
} else {
targetDisplayValue = Mathf.RoundToInt(rawPercentageFloat / percentageIncrement) * percentageIncrement;
}
targetDisplayValue = Mathf.Min(targetDisplayValue, 100);

if (targetDisplayValue == 100 && plant.CurrentState == PlantState.Growing && !forceComplete) {
targetDisplayValue = 99;
}

if (targetDisplayValue != displayedGrowthPercentage) {
displayedGrowthPercentage = targetDisplayValue;
energyText.text = $"{displayedGrowthPercentage}%";
}
}

pub void ResetDisplayState() {
displayedGrowthPercentage = -1;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryBarController.cs

﻿using UnityEngine;

pub cls InventoryBarController : MonoBehaviour {
pub stat InventoryBarController Instance { get; set; }

[SerializeField] int slotsPerRow = 10;
[SerializeField] Vector2 cellSize = new Vector2(64f, 64f);
[SerializeField] float cellMargin = 10f;

[SerializeField] Transform cellContainer;
[SerializeField] Button upArrowButton;
[SerializeField] Button downArrowButton;
[SerializeField] GameObject selectionHighlight;

[SerializeField] Sprite emptyCellSprite;
[SerializeField] Color emptyCellColor = Color.white;

[SerializeField] InventoryGridController inventoryGridController;

ro List<NodeCell> barCells = new List<NodeCell>();
int currentRow = 0;
int selectedSlot = 0;
int totalRows = 0;

pub InventoryBarItem SelectedItem { get; set; }
pub event System.Action<InventoryBarItem> OnSelectionChanged;

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;
selectedSlot = 0;
}

void Start() {
if (upArrowButton != null) upArrowButton.onClick.AddListener(() => ChangeRow(-1));
if (downArrowButton != null) downArrowButton.onClick.AddListener(() => ChangeRow(1));

SetupBarCells();
gameObject.SetActive(false); // Start hidden
}

void OnDestroy() {
if (upArrowButton != null) upArrowButton.onClick.RemoveAllListeners();
if (downArrowButton != null) downArrowButton.onClick.RemoveAllListeners();
}

void Update() {
if (!gameObject.activeInHierarchy) return;
HandleNumberKeyInput();
HandleArrowKeyInput();
}

pub void ShowBar() {
if (inventoryGridController == null) return;
if (selectedSlot < 0 && slotsPerRow > 0) selectedSlot = 0;
RefreshFromInventory();
gameObject.SetActive(true);
UpdateBarDisplay();
UpdateSelection();
}

pub void HideBar() {
gameObject.SetActive(false);
if (selectionHighlight != null) selectionHighlight.SetActive(false);
UniversalTooltipManager.Instance?.HideTooltip();
}

void SetupBarCells() {
foreach (Transform child in cellContainer) Destroy(child.gameObject);
barCells.Clear();

GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
gridLayout.cellSize = cellSize;
gridLayout.spacing = new Vector2(cellMargin, cellMargin);
gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
gridLayout.constraintCount = slotsPerRow;

for (int i = 0; i < slotsPerRow; i++) {
GameObject cellGO = new GameObject($"BarCell_{i}", typeof(RectTransform));
cellGO.transform.SetParent(cellContainer, false);
Image cellImage = cellGO.AddComponent<Image>();
cellImage.sprite = emptyCellSprite;
cellImage.color = emptyCellColor;
NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
cellLogic.Init(i, inventoryGridController, cellImage);
barCells.Add(cellLogic);
}
}

void RefreshFromInventory() {
if (inventoryGridController == null) return;
totalRows = Mathf.Max(1, Mathf.CeilToInt((float)inventoryGridController.TotalSlots / inventoryGridController.inventoryColumns));
currentRow = Mathf.Clamp(currentRow, 0, totalRows - 1);
}

void UpdateBarDisplay() {
if (inventoryGridController == null || barCells == null) return;
foreach (var cell in barCells) { cell.RemoveNode(); }

int startIndexInMainInventory = currentRow * inventoryGridController.inventoryColumns;

for (int i = 0; i < slotsPerRow; i++) {
if (i >= inventoryGridController.inventoryColumns) break;
int inventoryIndexToDisplay = startIndexInMainInventory + i;
if (inventoryIndexToDisplay >= inventoryGridController.TotalSlots) continue;

NodeCell inventoryCell = inventoryGridController.GetInventoryCellAtIndex(inventoryIndexToDisplay);
if (inventoryCell != null && inventoryCell.HasItem()) {
CopyInventoryItemToBarCell(inventoryCell, barCells[i]);
}
}

if (upArrowButton != null) upArrowButton.interactable = currentRow > 0;
if (downArrowButton != null) downArrowButton.interactable = currentRow < totalRows - 1;
}

void CopyInventoryItemToBarCell(NodeCell inventoryCell, NodeCell barCell) {
NodeData nodeData = inventoryCell.GetNodeData();
ToolDefinition toolDef = inventoryCell.GetToolDefinition();
NodeDefinition nodeDef = inventoryCell.GetNodeDefinition();

GameObject display = new GameObject("DisplayItem", typeof(RectTransform), typeof(Image));
display.transform.SetParent(barCell.transform, false);
Image displayImage = display.GetComponent<Image>();
displayImage.raycastTarget = false;

if (toolDef != null) {
displayImage.sprite = toolDef.icon;
displayImage.color = toolDef.iconTint;
}
else if (nodeDef != null) {
displayImage.sprite = nodeDef.thumbnail;
displayImage.color = nodeDef.thumbnailTintColor;
}

display.transform.localScale = Vector3.one * InventoryGridController.Instance.NodeGlobalImageScale;
display.GetComponent<RectTransform>().sizeDelta = cellSize * 0.8f;

barCell.AssignDisplayOnly(display, nodeData, toolDef);
}

void CreateToolCopyInBarCell(ToolDefinition toolDef, NodeData toolWrapperNodeData, NodeCell barCell) {
GameObject toolDisplay = new GameObject($"ToolDisplay_{toolDef.displayName}", typeof(RectTransform), typeof(Image));
toolDisplay.transform.SetParent(barCell.transform, false);

Image toolImage = toolDisplay.GetComponent<Image>();
toolImage.sprite = toolDef.icon;
toolImage.color = toolDef.iconTint;
toolImage.raycastTarget = false;

float globalScale = 1f;
if (InventoryGridController.Instance != null) {
globalScale = InventoryGridController.Instance.NodeGlobalImageScale;
}
toolDisplay.transform.localScale = new Vector3(globalScale, globalScale, 1f);

RectTransform toolRect = toolDisplay.GetComponent<RectTransform>();
toolRect.anchoredPosition = Vector2.zero;
toolRect.sizeDelta = cellSize * 0.8f;

barCell.AssignDisplayOnly(toolDisplay, toolWrapperNodeData, toolDef);
}

void CreateNodeCopyInBarCell(NodeDefinition nodeDef, NodeData originalNodeData, NodeCell barCell) {
GameObject nodeDisplay = new GameObject($"NodeDisplay_{nodeDef.displayName}", typeof(RectTransform), typeof(Image));
nodeDisplay.transform.SetParent(barCell.transform, false);

Image nodeImage = nodeDisplay.GetComponent<Image>();
nodeImage.sprite = nodeDef.thumbnail;
nodeImage.color = nodeDef.thumbnailTintColor;
nodeImage.raycastTarget = false;

float globalScale = 1f;
if (InventoryGridController.Instance != null) {
globalScale = InventoryGridController.Instance.NodeGlobalImageScale;
}
nodeDisplay.transform.localScale = new Vector3(globalScale, globalScale, 1f);

RectTransform nodeRect = nodeDisplay.GetComponent<RectTransform>();
nodeRect.anchoredPosition = Vector2.zero;
nodeRect.sizeDelta = cellSize * 0.8f;

barCell.AssignDisplayOnly(nodeDisplay, originalNodeData, null);
}

void HandleNumberKeyInput() {
for (int i = 1; i <= 9; i++) {
KeyCode key = (KeyCode)((int)KeyCode.Alpha1 + (i - 1));
if (Input.GetKeyDown(key)) {
int targetSlotIndexInBar = i - 1; // 1-9 maps to slots 0-8
if (targetSlotIndexInBar < slotsPerRow) {
SelectSlot(targetSlotIndexInBar);
}
return;
}
}

if (Input.GetKeyDown(KeyCode.Alpha0)) {
int targetSlotIndexInBar = 9; // 0 maps to slot 9
if (targetSlotIndexInBar < slotsPerRow) {
SelectSlot(targetSlotIndexInBar);
}
}
}

void HandleArrowKeyInput() {
if (Input.GetKeyDown(KeyCode.UpArrow)) {
ChangeRow(-1);
}
else if (Input.GetKeyDown(KeyCode.DownArrow)) {
ChangeRow(1);
}
}

void ChangeRow(int direction) {
int newRow = currentRow + direction;
if (newRow >= 0 && newRow < totalRows) {
currentRow = newRow;
UpdateBarDisplay();
UpdateSelection();
}
}

void SelectSlot(int slotIndexInBar) {
if (this.selectedSlot == slotIndexInBar && this.SelectedItem != null) {
this.selectedSlot = -1; // Mark as deselected
}
else {
this.selectedSlot = Mathf.Clamp(slotIndexInBar, 0, slotsPerRow - 1);
}
UpdateSelection();
}

void UpdateSelection() {
SelectedItem = null; // Reset

if (selectedSlot == -1) // Explicitly deselected {
}
else if (selectedSlot >= 0 && selectedSlot < barCells.Count && inventoryGridController != null) {
int mainInventoryColumns = inventoryGridController.inventoryColumns;
if (mainInventoryColumns > 0) {
int inventoryIndex = currentRow * mainInventoryColumns + selectedSlot;
if (inventoryIndex >= 0 && inventoryIndex < inventoryGridController.TotalSlots) {
InventoryBarItem itemFromMainInventory = inventoryGridController.GetItemAtIndex(inventoryIndex);
if (itemFromMainInventory != null && itemFromMainInventory.IsValid()) {
SelectedItem = itemFromMainInventory;
}
}
}
}

if (selectionHighlight != null) {
if (SelectedItem != null && SelectedItem.IsValid() && selectedSlot >= 0 && selectedSlot < barCells.Count) {
if (gameObject.activeInHierarchy) {
NodeCell targetBarCellForHighlight = barCells[selectedSlot];
RectTransform cellRect = targetBarCellForHighlight.GetComponent<RectTransform>();

if (cellRect != null) {
selectionHighlight.SetActive(true);
selectionHighlight.transform.SetParent(cellRect.transform, false);
RectTransform highlightRect = selectionHighlight.GetComponent<RectTransform>();
if (highlightRect != null) {
highlightRect.anchoredPosition = Vector2.zero;
highlightRect.sizeDelta = cellRect.sizeDelta;
}
}
else { selectionHighlight.SetActive(false); }
}
else { selectionHighlight.SetActive(false); }
}
else // No valid item selected or slot is -1 {
selectionHighlight.SetActive(false);
}
}

if (gameObject.activeInHierarchy && SelectedItem != null && SelectedItem.IsValid() && UniversalTooltipManager.Instance != null && selectedSlot >= 0 && selectedSlot < barCells.Count) {
ITooltipDataProvider provider = (SelectedItem.Type == InventoryBarItem.ItemType.Node)
? (ITooltipDataProvider)SelectedItem.NodeDefinition
: SelectedItem.ToolDefinition;

object sourceData = (SelectedItem.Type == InventoryBarItem.ItemType.Node)
? SelectedItem.NodeData
: null;

UniversalTooltipManager.Instance.ShowTooltip(provider, barCells[selectedSlot].transform, sourceData);
}
else if (UniversalTooltipManager.Instance != null) {
UniversalTooltipManager.Instance.HideTooltip();
}

OnSelectionChanged?.Invoke(SelectedItem);
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryBarItem.cs

﻿using UnityEngine;

pub cls InventoryBarItem {
pub enum ItemType { Node, Tool }

[SerializeField] ItemType itemType;
[SerializeField] NodeData nodeData;
[SerializeField] NodeDefinition nodeDefinition;
[SerializeField] ToolDefinition toolDefinition;
[SerializeField] GameObject viewGameObject;

pub ItemType Type => itemType;
pub NodeData NodeData => nodeData;
pub NodeDefinition NodeDefinition => nodeDefinition;
pub ToolDefinition ToolDefinition => toolDefinition;
pub GameObject ViewGameObject => viewGameObject;

pub stat InventoryBarItem FromNode(NodeData data, NodeDefinition def, GameObject viewObj = null) {
ret new InventoryBarItem {
itemType = ItemType.Node,
nodeData = data,
nodeDefinition = def,
toolDefinition = null,
viewGameObject = viewObj
};
}

pub stat InventoryBarItem FromTool(ToolDefinition tool, GameObject viewObj = null) {
ret new InventoryBarItem {
itemType = ItemType.Tool,
nodeData = null,
nodeDefinition = null,
toolDefinition = tool,
viewGameObject = viewObj
};
}

pub string GetDisplayName() {
ret itemType == ItemType.Node ?
(nodeDefinition?.displayName ?? nodeData?.nodeDisplayName ?? "Unknown Node") :
(toolDefinition?.displayName ?? "Unknown Tool");
}

pub Sprite GetIcon() {
ret itemType == ItemType.Node ? nodeDefinition?.thumbnail : toolDefinition?.icon;
}

pub Color GetIconTint() {
ret itemType == ItemType.Node ?
(nodeDefinition?.thumbnailTintColor ?? Color.white) :
(toolDefinition?.iconTint ?? Color.white);
}

pub bool IsValid() {
ret itemType == ItemType.Node ?
(nodeData != null && nodeDefinition != null) :
(toolDefinition != null);
}

pub bool IsSeed() {
ret itemType == ItemType.Node && nodeData != null && nodeData.IsSeed();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryGridController.cs

﻿using System.Collections.Generic;
using UnityEngine.EventSystems;

pub cls InventoryGridController : MonoBehaviour {
pub stat InventoryGridController Instance { get; set; }

[SerializeField][Min(1)] pub int inventoryRows = 2;
[SerializeField][Min(1)] pub int inventoryColumns = 8;
[SerializeField] Vector2 cellSize = new Vector2(64f, 64f);
[SerializeField] float cellMargin = 10f;

[SerializeField] Sprite emptyCellSprite;
[SerializeField] Color emptyCellColor = Color.white;
[SerializeField] GameObject inventoryItemPrefab;
[SerializeField] float nodeGlobalImageScale = 1f;
[SerializeField] float nodeImageRaycastPadding = 0f;

[SerializeField] ToolDefinition[] availableTools;

[SerializeField] Transform cellContainer;
[SerializeField] Canvas _rootCanvas;

[SerializeField] bool logInventoryChanges = true;

ro List<NodeCell> inventoryCells = new List<NodeCell>();

pub GameObject InventoryItemPrefab => inventoryItemPrefab;
pub Color EmptyCellColor => emptyCellColor;
pub float NodeGlobalImageScale => nodeGlobalImageScale;
pub float NodeImageRaycastPadding => nodeImageRaycastPadding;
pub int TotalSlots => inventoryRows * inventoryColumns;
pub int ActualCellCount => inventoryCells?.Count ?? 0;

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;

if (cellContainer == null) Debug.LogError("[InventoryGridController] Cell Container not assigned!", gameObject);
if (inventoryItemPrefab == null) Debug.LogError("[InventoryGridController] Inventory Item Prefab not assigned!", gameObject);
if (_rootCanvas == null) Debug.LogError("[InventoryGridController] Root Canvas not assigned!", gameObject);
}

void Start() {
if (cellContainer != null) {
CreateInventoryCells();
PopulateInitialGenesFromLibrary();
}
}

void CreateInventoryCells() {
foreach (Transform child in cellContainer) Destroy(child.gameObject);
inventoryCells.Clear();

GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
if (gridLayout == null) {
Debug.LogError("[InventoryGridController] Cell Container MUST have a GridLayoutGroup.", cellContainer.gameObject);
return;
}

gridLayout.cellSize = cellSize;
gridLayout.spacing = new Vector2(cellMargin, cellMargin);
gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
gridLayout.constraintCount = inventoryColumns;

int totalCells = inventoryRows * inventoryColumns;
for (int i = 0; i < totalCells; i++) {
GameObject cellGO = new GameObject($"InventoryCell_{i}", typeof(RectTransform));
cellGO.transform.SetParent(cellContainer, false);
Image cellImage = cellGO.AddComponent<Image>();
cellImage.sprite = emptyCellSprite;
cellImage.color = emptyCellColor;
cellImage.raycastTarget = true;
NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
cellLogic.Init(i, this, cellImage);
inventoryCells.Add(cellLogic);
}
}

void PopulateInitialGenesFromLibrary() {
if (NodeEditorGridController.Instance?.DefinitionLibrary == null) {
Debug.LogWarning("[InventoryGridController] Cannot populate: NodeEditorGridController or DefinitionLibrary not ready.");
return;
}

if (availableTools != null) {
foreach (var tool in availableTools) {
if (tool != null && tool.autoAddToInventory) {
AddToolToInventory(tool);
}
}
}

NodeDefinitionLibrary lib = NodeEditorGridController.Instance.DefinitionLibrary;
if (lib.definitions != null) {
int remainingSlots = TotalSlots - GetUsedSlotCount();
var definitionsToAdd = lib.definitions.Where(d => d != null).Take(remainingSlots).ToList();
foreach (var def in definitionsToAdd) {
AddGeneToInventoryFromDefinition(def, null);
}
}
}

bool AddToolToInventory(ToolDefinition tool) {
NodeCell emptyCell = inventoryCells.FirstOrDefault(cell => !cell.HasItem());
if (emptyCell == null) ret false;

NodeData toolNodeData = new NodeData {
nodeId = tool.name + "_tool_" + System.Guid.NewGuid().ToString(),
nodeDisplayName = tool.displayName,
effects = new List<NodeEffectData>(),
orderIndex = -1,
canBeDeleted = false,
storedSequence = null
};

GameObject itemViewGO = Instantiate(inventoryItemPrefab, emptyCell.transform);
ItemView itemView = itemViewGO.GetComponent<ItemView>();

if (itemView != null) {
itemView.Initialize(toolNodeData, tool);

NodeDraggable draggable = itemViewGO.GetComponent<NodeDraggable>() ?? itemViewGO.AddComponent<NodeDraggable>();
draggable.Initialize(this, emptyCell);
emptyCell.AssignItemView(itemView, toolNodeData, tool);
if (logInventoryChanges) Debug.Log($"[Inventory] Added tool '{tool.displayName}' to cell {emptyCell.CellIndex}.");
ret true;
}

Destroy(itemViewGO);
ret false;
}

pub bool AddGeneToInventoryFromDefinition(NodeDefinition geneDef, NodeCell targetCellHint) {
if (geneDef == null) ret false;

NodeCell cellToUse = (targetCellHint != null && targetCellHint.IsInventoryCell && !targetCellHint.HasItem())
? targetCellHint
: inventoryCells.FirstOrDefault(cell => !cell.HasItem());

if (cellToUse != null) {
NodeData inventoryNodeData = new NodeData {
nodeId = geneDef.name + "_inventory_" + System.Guid.NewGuid().ToString(),
nodeDisplayName = geneDef.displayName,
effects = geneDef.CloneEffects(),
orderIndex = -1,
canBeDeleted = false,
};

bool isSeed = inventoryNodeData.effects != null &&
inventoryNodeData.effects.Any(e => e != null && e.effectType == NodeEffectType.SeedSpawn);

if (isSeed) {
inventoryNodeData.EnsureSeedSequenceInitialized();
}

GameObject itemViewGO = Instantiate(inventoryItemPrefab, cellToUse.transform);
ItemView view = itemViewGO.GetComponent<ItemView>();
if (view == null) { Destroy(itemViewGO); ret false; }

view.Initialize(inventoryNodeData, geneDef, null);
NodeDraggable draggable = view.GetComponent<NodeDraggable>() ?? view.gameObject.AddComponent<NodeDraggable>();
draggable.Initialize(this, cellToUse);
cellToUse.AssignItemView(view, inventoryNodeData, null);
if (logInventoryChanges) Debug.Log($"[Inventory] Added gene '{geneDef.displayName}' (seed: {isSeed}) to cell {cellToUse.CellIndex}.");
ret true;
}
ret false;
}

pub void ReturnGeneToInventory(ItemView itemViewToReturn, NodeData geneDataToReturn) {
if (itemViewToReturn == null || geneDataToReturn == null) {
if (itemViewToReturn != null) Destroy(itemViewToReturn.gameObject);
return;
}

NodeCell emptyCell = inventoryCells.FirstOrDefault(cell => !cell.HasItem());
if (emptyCell == null) {
if (logInventoryChanges) Debug.LogWarning($"[Inventory] No empty cell to ret '{geneDataToReturn.nodeDisplayName}' to. Item destroyed.");
Destroy(itemViewToReturn.gameObject);
return;
}

geneDataToReturn.orderIndex = -1;
geneDataToReturn.canBeDeleted = false;

if (geneDataToReturn.IsSeed()) {
geneDataToReturn.EnsureSeedSequenceInitialized();
}

emptyCell.AssignItemView(itemViewToReturn, geneDataToReturn, null);

NodeDraggable draggable = itemViewToReturn.GetComponent<NodeDraggable>();
if (draggable == null) draggable = itemViewToReturn.gameObject.AddComponent<NodeDraggable>();
draggable.Initialize(this, emptyCell);
draggable.SnapToCell(emptyCell);
if (logInventoryChanges) Debug.Log($"[Inventory] Returned gene '{geneDataToReturn.nodeDisplayName}' to cell {emptyCell.CellIndex}.");
}

pub void HandleDropOnInventoryCell(NodeDraggable draggedDraggable, NodeCell originalCell, NodeCell targetInventoryCell) {
if (draggedDraggable == null || originalCell == null || targetInventoryCell == null || !targetInventoryCell.IsInventoryCell) {
draggedDraggable?.ResetPosition();
return;
}

ItemView draggedItemView = draggedDraggable.GetComponent<ItemView>();
if (draggedItemView == null) {
draggedDraggable.ResetPosition();
return;
}

NodeData draggedData = draggedItemView.GetNodeData();
NodeDefinition draggedNodeDef = draggedItemView.GetNodeDefinition();
ToolDefinition draggedToolDef = draggedItemView.GetToolDefinition();

if (originalCell.IsInventoryCell) {
if (targetInventoryCell == originalCell) { draggedDraggable.ResetPosition(); return; }

if (targetInventoryCell.HasItem()) {
ItemView viewInTargetCell = targetInventoryCell.GetItemView();
NodeData dataInTargetCell = targetInventoryCell.GetNodeData();
ToolDefinition toolInTargetCell = targetInventoryCell.GetToolDefinition();

if (logInventoryChanges) Debug.Log($"[Inventory] Swapped item '{draggedData.nodeDisplayName}' from cell {originalCell.CellIndex} with item '{dataInTargetCell.nodeDisplayName}' from cell {targetInventoryCell.CellIndex}.");

originalCell.ClearNodeReference();
originalCell.AssignItemView(viewInTargetCell, dataInTargetCell, toolInTargetCell);
viewInTargetCell.GetComponent<NodeDraggable>()?.SnapToCell(originalCell);
targetInventoryCell.ClearNodeReference();
}
else {
if (logInventoryChanges) Debug.Log($"[Inventory] Moved item '{draggedData.nodeDisplayName}' from cell {originalCell.CellIndex} to empty cell {targetInventoryCell.CellIndex}.");
originalCell.ClearNodeReference();
}

targetInventoryCell.AssignItemView(draggedItemView, draggedData, draggedToolDef);
draggedDraggable.SnapToCell(targetInventoryCell);
}
else {
NodeCell actualTargetInvCell = targetInventoryCell.HasItem()
? inventoryCells.FirstOrDefault(c => !c.HasItem())
: targetInventoryCell;

if (actualTargetInvCell == null) { draggedDraggable.ResetPosition(); return; }

if (originalCell.IsSeedSlot) {
if (logInventoryChanges) Debug.Log($"[Inventory] Moved seed '{draggedData.nodeDisplayName}' from Seed Slot to inventory cell {actualTargetInvCell.CellIndex}.");
NodeEditorGridController.Instance.UnloadSeedFromSlot();
originalCell.ClearNodeReference();
actualTargetInvCell.AssignItemView(draggedItemView, draggedData, null);
draggedDraggable.SnapToCell(actualTargetInvCell);
}
else {
if (logInventoryChanges) Debug.Log($"[Inventory] Returned node '{draggedNodeDef.displayName}' from sequence to inventory cell {actualTargetInvCell.CellIndex}.");
NodeEditorGridController.Instance?.GetCellAtIndex(originalCell.CellIndex)?.RemoveNode();
NodeEditorGridController.Instance?.RefreshGraphAndUpdateSeed();
AddGeneToInventoryFromDefinition(draggedNodeDef, actualTargetInvCell);
Destroy(draggedDraggable.gameObject);
}
}
}

pub int GetUsedSlotCount() => inventoryCells.Count(cell => cell.HasItem());

pub void RemoveGeneFromInventory(NodeCell inventoryCell) {
if (inventoryCell != null && inventoryCell.HasItem() && inventoryCell.IsInventoryCell) {
if (logInventoryChanges) Debug.Log($"[Inventory] Removing item '{inventoryCell.GetNodeData()?.nodeDisplayName ?? "Unknown"}' from cell {inventoryCell.CellIndex}.");
inventoryCell.ClearNodeReference();
}
}

pub NodeCell GetInventoryCellAtIndex(int index) => (index >= 0 && index < inventoryCells.Count) ? inventoryCells[index] : null;

pub NodeCell FindInventoryCellAtScreenPosition(Vector2 screenPosition) {
if (_rootCanvas == null) ret null;
foreach (NodeCell cell in inventoryCells) {
if (RectTransformUtility.RectangleContainsScreenPoint(cell.GetComponent<RectTransform>(), screenPosition, _rootCanvas.worldCamera)) {
ret cell;
}
}
ret null;
}

pub InventoryBarItem GetItemAtIndex(int index) {
if (index < 0 || index >= inventoryCells.Count) ret null;

var cell = inventoryCells[index];
if (cell.HasItem()) {
var itemView = cell.GetItemView();
var toolDef = cell.GetToolDefinition();
var nodeDef = cell.GetNodeDefinition();
var nodeData = cell.GetNodeData();

if (toolDef != null) {
ret InventoryBarItem.FromTool(toolDef, itemView?.gameObject);
}
if (nodeDef != null && nodeData != null) {
ret InventoryBarItem.FromNode(nodeData, nodeDef, itemView?.gameObject);
}
}
ret null;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\ItemView.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;

pub cls ItemView : MonoBehaviour, IPointerDownHandler {
[SerializeField] Image thumbnailImage;
[SerializeField] Image backgroundImage;

NodeData _nodeData;
NodeDefinition _nodeDefinition;
ToolDefinition _toolDefinition;

NodeEditorGridController _sequenceGridControllerRef;
NodeCell _parentCell;
Color _originalBackgroundColor;
TooltipTrigger _tooltipTrigger;
DisplayType _displayType;

pub enum DisplayType { None, Node, Tool }

pub void Initialize(NodeData data, NodeDefinition definition, NodeEditorGridController sequenceController) {
_displayType = DisplayType.Node;
_nodeData = data;
_nodeDefinition = definition;
_sequenceGridControllerRef = sequenceController;

if (_nodeData == null || _nodeDefinition == null) {
Debug.LogError($"[ItemView Initialize Node] NodeData or NodeDefinition is null for {gameObject.name}. Disabling.", gameObject);
gameObject.SetActive(false);
return;
}

if (!_nodeData.IsSeed()) {
_nodeData.ClearStoredSequence();
}

SetupVisuals();
}

pub void Initialize(NodeData data, ToolDefinition toolDef) {
_displayType = DisplayType.Tool;
_nodeData = data; // This is the wrapper NodeData for the tool
_toolDefinition = toolDef;

if (_toolDefinition == null) {
Debug.LogError($"[ItemView Initialize Tool] ToolDefinition is null for {gameObject.name}. Disabling.", gameObject);
gameObject.SetActive(false);
return;
}

SetupVisuals();
}

void SetupVisuals() {
UpdateParentCellReference();
_tooltipTrigger = GetComponent<TooltipTrigger>() ?? gameObject.AddComponent<TooltipTrigger>();

float globalScaleFactor = 1f;
float raycastPaddingValue = 0f;
if (InventoryGridController.Instance != null) {
globalScaleFactor = InventoryGridController.Instance.NodeGlobalImageScale;
raycastPaddingValue = InventoryGridController.Instance.NodeImageRaycastPadding;
}

Vector4 raycastPaddingVector = new Vector4(raycastPaddingValue, raycastPaddingValue, raycastPaddingValue, raycastPaddingValue);

if (thumbnailImage != null) {
thumbnailImage.sprite = (_displayType == DisplayType.Node) ? _nodeDefinition.thumbnail : _toolDefinition.icon;
thumbnailImage.color = (_displayType == DisplayType.Node) ? _nodeDefinition.thumbnailTintColor : _toolDefinition.iconTint;
thumbnailImage.rectTransform.localScale = new Vector3(globalScaleFactor, globalScaleFactor, 1f);
thumbnailImage.enabled = (thumbnailImage.sprite != null);
thumbnailImage.raycastTarget = true;
thumbnailImage.raycastPadding = raycastPaddingVector;
}

if (backgroundImage != null) {
_originalBackgroundColor = (_displayType == DisplayType.Node) ? _nodeDefinition.backgroundColor : new Color(0.5f, 0.5f, 0.5f, 1f);
backgroundImage.color = _originalBackgroundColor;
backgroundImage.enabled = true;
backgroundImage.raycastTarget = true;
backgroundImage.raycastPadding = raycastPaddingVector;
}
}

pub NodeData GetNodeData() => _nodeData;
pub NodeDefinition GetNodeDefinition() => _nodeDefinition;
pub ToolDefinition GetToolDefinition() => _toolDefinition;
pub NodeCell GetParentCell() => _parentCell;
pub DisplayType GetDisplayType() => _displayType;

pub void UpdateParentCellReference() {
_parentCell = GetComponentInParent<NodeCell>();
}

pub void Highlight() {
if (backgroundImage != null && _sequenceGridControllerRef != null && _parentCell != null && !_parentCell.IsInventoryCell && _displayType == DisplayType.Node) {
backgroundImage.color = _sequenceGridControllerRef.SelectedNodeBackgroundColor;
}
}

pub void Unhighlight() {
if (backgroundImage != null) {
backgroundImage.color = _originalBackgroundColor;
}
}

pub void OnPointerDown(PointerEventData eventData) {
if (_parentCell == null) UpdateParentCellReference();

if (_parentCell != null && eventData.button == PointerEventData.InputButton.Left) {
if (!_parentCell.IsInventoryCell && !_parentCell.IsSeedSlot && _displayType == DisplayType.Node) {
NodeCell.SelectCell(_parentCell);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\NodeCell.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;

pub cls NodeCell : MonoBehaviour, IPointerClickHandler, IDropHandler {
pub stat NodeCell CurrentlySelectedCell { get; set; }

pub int CellIndex { get; set; }
pub bool IsInventoryCell { get; set; }
pub bool IsSeedSlot { get; set; }

NodeEditorGridController _sequenceController;
InventoryGridController _inventoryController;

ItemView _itemView;
NodeData _nodeData;
NodeDefinition _nodeDefinition;
ToolDefinition _toolDefinition;

Image _backgroundImage;
GameObject _displayObject; // For inventory bar display-only items

pub void Init(int index, NodeEditorGridController sequenceController, InventoryGridController inventoryController, Image bgImage) {
CellIndex = index;
_sequenceController = sequenceController;
_inventoryController = inventoryController;
_backgroundImage = bgImage;
IsInventoryCell = (_inventoryController != null);
IsSeedSlot = false;

if (_backgroundImage != null) {
Color emptyColor = Color.gray;
if (IsInventoryCell && _inventoryController != null) emptyColor = _inventoryController.EmptyCellColor;
else if (!IsInventoryCell && _sequenceController != null) emptyColor = _sequenceController.EmptyCellColor;
_backgroundImage.color = emptyColor;
}
}
pub void Init(int index, NodeEditorGridController sequenceController, Image bgImage) => Init(index, sequenceController, null, bgImage);
pub void Init(int index, InventoryGridController inventoryController, Image bgImage) => Init(index, null, inventoryController, bgImage);
pub void InitAsSeedSlot(NodeEditorGridController sequenceController, Image bgImage) {
CellIndex = -1;
_sequenceController = sequenceController;
_inventoryController = null;
_backgroundImage = bgImage;
IsInventoryCell = false;
IsSeedSlot = true;
if (_backgroundImage != null) {
_backgroundImage.color = _sequenceController != null ? _sequenceController.EmptyCellColor : Color.magenta;
}
}

pub bool HasItem() => _itemView != null || _displayObject != null;
pub NodeData GetNodeData() => _nodeData;
pub NodeDefinition GetNodeDefinition() => _nodeDefinition;
pub ToolDefinition GetToolDefinition() => _toolDefinition;
pub ItemView GetItemView() => _itemView;

pub void AssignItemView(ItemView view, NodeData data, ToolDefinition toolDef) {
RemoveNode();

_itemView = view;
_nodeData = data;
_toolDefinition = toolDef;
_nodeDefinition = view?.GetNodeDefinition();

if (_itemView != null) {
_itemView.transform.SetParent(transform, false);
_itemView.GetComponent<RectTransform>().anchoredPosition = Vector2.zero;

if (_nodeData != null && !IsInventoryCell && !IsSeedSlot && _sequenceController != null) {
_nodeData.orderIndex = this.CellIndex;
}

if (_backgroundImage != null) _backgroundImage.raycastTarget = false;
}
}

pub void AssignNode(NodeDefinition def) {
if (def == null || IsInventoryCell || IsSeedSlot || _sequenceController == null) return;
if (def.effects.Any(e => e != null && e.effectType == NodeEffectType.SeedSpawn)) return;

RemoveNode();

_nodeData = new NodeData {
nodeId = System.Guid.NewGuid().ToString(),
nodeDisplayName = def.displayName,
effects = def.CloneEffects(),
orderIndex = this.CellIndex,
canBeDeleted = true
};
_nodeData.ClearStoredSequence();
_nodeDefinition = def;
_toolDefinition = null;

GameObject prefabToInstantiate = _sequenceController.InventoryItemPrefab;
if (prefabToInstantiate == null) {
Debug.LogError($"[NodeCell {CellIndex}] Sequence controller is missing its InventoryItemPrefab!", gameObject);
return;
}

GameObject itemViewGO = Instantiate(prefabToInstantiate, transform);
_itemView = itemViewGO.GetComponent<ItemView>();

if (_itemView == null) { Destroy(itemViewGO); return; }

_itemView.Initialize(_nodeData, def, _sequenceController);

NodeDraggable draggable = _itemView.GetComponent<NodeDraggable>() ?? _itemView.gameObject.AddComponent<NodeDraggable>();
draggable.Initialize(_sequenceController, this);

if (_backgroundImage != null) _backgroundImage.raycastTarget = false;
}

pub void RemoveNode() {
if (CurrentlySelectedCell == this) NodeCell.ClearSelection();
if (_itemView != null) Destroy(_itemView.gameObject);
if (_displayObject != null) Destroy(_displayObject);

_itemView = null;
_nodeData = null;
_nodeDefinition = null;
_toolDefinition = null;
_displayObject = null;

if (_backgroundImage != null) _backgroundImage.raycastTarget = true;
}

pub void ClearNodeReference() {
_itemView = null;
_nodeData = null;
_nodeDefinition = null;
_toolDefinition = null;
if (_backgroundImage != null) _backgroundImage.raycastTarget = true;
}

pub stat void SelectCell(NodeCell cellToSelect) {
if (cellToSelect == null || !cellToSelect.HasItem() || cellToSelect.IsInventoryCell || cellToSelect.IsSeedSlot) {
ClearSelection();
return;
}
if (CurrentlySelectedCell == cellToSelect) return;

ClearSelection();
CurrentlySelectedCell = cellToSelect;
CurrentlySelectedCell?.GetItemView()?.Highlight();
}

pub stat void ClearSelection() {
CurrentlySelectedCell?.GetItemView()?.Unhighlight();
CurrentlySelectedCell = null;
}

pub void OnPointerClick(PointerEventData eventData) {
if (eventData.button == PointerEventData.InputButton.Right) {
if (!HasItem() && !IsInventoryCell && !IsSeedSlot && _sequenceController != null) {
ClearSelection();
_sequenceController.OnEmptyCellRightClicked(this, eventData);
}
}
else if (eventData.button == PointerEventData.InputButton.Left) {
if (HasItem() && !IsInventoryCell && !IsSeedSlot) SelectCell(this);
else if (!HasItem()) ClearSelection();
}
}

pub void OnDrop(PointerEventData eventData) {
GameObject draggedObject = eventData.pointerDrag;
if (draggedObject == null) return;

NodeDraggable draggedDraggable = draggedObject.GetComponent<NodeDraggable>();
if (draggedDraggable == null) return;

NodeCell originalCell = draggedDraggable.OriginalCell;
if (originalCell == null || draggedDraggable.GetComponent<ItemView>() == null) {
draggedDraggable.ResetPosition();
return;
}

if (this.IsSeedSlot && _sequenceController != null)
_sequenceController.HandleDropOnSeedSlot(draggedDraggable, originalCell, this);
else if (!this.IsInventoryCell && _sequenceController != null)
_sequenceController.HandleDropOnSequenceCell(draggedDraggable, originalCell, this);
else if (this.IsInventoryCell && _inventoryController != null)
_inventoryController.HandleDropOnInventoryCell(draggedDraggable, originalCell, this);
else
draggedDraggable.ResetPosition();
}

pub void AssignDisplayOnly(GameObject displayObject, NodeData data, ToolDefinition toolDef) {
RemoveNode();
_nodeData = data;
_toolDefinition = toolDef;
_displayObject = displayObject;

if (_displayObject != null) {
_displayObject.transform.SetParent(transform, false);
_displayObject.GetComponent<RectTransform>().anchoredPosition = Vector2.zero;
if (_backgroundImage != null) _backgroundImage.raycastTarget = false;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\NodeDraggable.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;

[RequireComponent(typeof(ItemView))] // Ensures an ItemView is always present
pub cls NodeDraggable : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler {
RectTransform _rectTransform;
CanvasGroup _canvasGroup;
Vector2 _originalAnchoredPosition;
Transform _originalParent;
NodeCell _originalCell;
NodeEditorGridController _gridController;
InventoryGridController _inventoryController;
Canvas _rootCanvas;
ItemView _itemView; // Reference to the unified view

pub NodeCell OriginalCell => _originalCell;

void Awake() {
_rectTransform = GetComponent<RectTransform>();
_canvasGroup = GetComponent<CanvasGroup>() ?? gameObject.AddComponent<CanvasGroup>();
_itemView = GetComponent<ItemView>(); // Get the unified ItemView component
}

pub void Initialize(NodeEditorGridController gridCtrl, NodeCell startingCell) => Initialize(gridCtrl, null, startingCell);
pub void Initialize(InventoryGridController invCtrl, NodeCell startingCell) => Initialize(null, invCtrl, startingCell);

void Initialize(NodeEditorGridController gridCtrl, InventoryGridController invCtrl, NodeCell startingCell) {
_gridController = gridCtrl;
_inventoryController = invCtrl;
_originalCell = startingCell;

_rootCanvas = GetComponentInParent<Canvas>()?.rootCanvas ?? FindFirstObjectByType<Canvas>();
if (_rootCanvas == null) Debug.LogError("[NodeDraggable] Could not find root Canvas!", gameObject);
}

pub void OnBeginDrag(PointerEventData eventData) {
if (eventData.button != PointerEventData.InputButton.Left) return;
if (_originalCell == null || _itemView == null) return;

NodeData data = _itemView.GetNodeData();
if (data == null) return;

bool isInSequenceEditorCell = _gridController != null && !_originalCell.IsInventoryCell && !_originalCell.IsSeedSlot;
if (isInSequenceEditorCell && !data.canBeDeleted) {
eventData.pointerDrag = null; // Prevent drag from starting
return;
}

if (_rootCanvas == null) return;

_originalParent = transform.parent;
_originalAnchoredPosition = _rectTransform.anchoredPosition;

_canvasGroup.alpha = 0.6f;
_canvasGroup.blocksRaycasts = false;

transform.SetParent(_rootCanvas.transform, true);
transform.SetAsLastSibling();

Vector2 mouseLocalPosInCanvas;
RectTransformUtility.ScreenPointToLocalPointInRectangle(_rootCanvas.transform as RectTransform, eventData.position, _rootCanvas.worldCamera, out mouseLocalPosInCanvas);
_rectTransform.localPosition = mouseLocalPosInCanvas;
}

pub void OnDrag(PointerEventData eventData) {
if (eventData.button != PointerEventData.InputButton.Left || _canvasGroup.blocksRaycasts) return;
if (_rootCanvas == null || _rectTransform == null) return;

Vector2 mouseLocalPosInCanvas;
if (RectTransformUtility.ScreenPointToLocalPointInRectangle(_rootCanvas.transform as RectTransform, eventData.position, _rootCanvas.worldCamera, out mouseLocalPosInCanvas)) {
_rectTransform.localPosition = mouseLocalPosInCanvas;
}
}

pub void OnEndDrag(PointerEventData eventData) {
_canvasGroup.alpha = 1f;
_canvasGroup.blocksRaycasts = true;

if (eventData.button != PointerEventData.InputButton.Left) {
if (transform.parent == _rootCanvas.transform) ResetPosition();
return;
}

if (eventData.pointerEnter == null || eventData.pointerEnter.GetComponent<IDropHandler>() == null) {
ResetPosition();
}
}

pub void ResetPosition() {
if (_originalParent == null || _originalCell == null) {
Destroy(gameObject);
return;
}

transform.SetParent(_originalParent, false);
_rectTransform.anchoredPosition = _originalAnchoredPosition;
}

pub void SnapToCell(NodeCell targetCell) {
if (targetCell == null) {
ResetPosition();
return;
}

transform.SetParent(targetCell.transform, false);
_rectTransform.anchoredPosition = Vector2.zero;

_originalParent = targetCell.transform;
_originalCell = targetCell;
_originalAnchoredPosition = Vector2.zero;

_itemView?.UpdateParentCellReference();

if (targetCell.IsInventoryCell) {
_inventoryController = InventoryGridController.Instance;
_gridController = null;
}
else // Sequence or Seed Slot {
_inventoryController = null;
_gridController = NodeEditorGridController.Instance;
}
}

void OnDisable() {
if (_canvasGroup != null && !_canvasGroup.blocksRaycasts) {
_canvasGroup.alpha = 1f;
_canvasGroup.blocksRaycasts = true;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\NodeEditorGridController.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;
using TMPro;

pub cls NodeEditorGridController : MonoBehaviour {
pub stat NodeEditorGridController Instance { get; set; }

[SerializeField][Min(1)] int emptyCellsCount = 8;
[SerializeField] Vector2 cellSize = new Vector2(64f, 64f);
[SerializeField] float cellMargin = 10f;

[SerializeField] Sprite emptyCellSprite;
[SerializeField] Color emptyCellColor = Color.white;
[SerializeField] Vector3 emptyCellScale = Vector3.one;
[SerializeField] GameObject inventoryItemPrefab;
[SerializeField] Color selectedNodeBackgroundColor = new Color(0.9f, 0.9f, 0.7f, 1f);

[SerializeField] NodeDefinitionLibrary definitionLibrary;
[SerializeField] TMP_Dropdown nodeDropdown;
[SerializeField] pub GameObject gridUIParent;
[SerializeField] Transform cellContainer;
[SerializeField] Transform seedSlotContainer;

ro List<NodeCell> nodeCells = new List<NodeCell>();
NodeCell _actualSeedSlotCell;
Canvas _rootCanvas;
ro NodeGraph _currentlyEditedSequence = new NodeGraph();

pub GameObject InventoryItemPrefab => inventoryItemPrefab;
pub NodeDefinitionLibrary DefinitionLibrary => definitionLibrary;
pub Color SelectedNodeBackgroundColor => selectedNodeBackgroundColor;
pub Color EmptyCellColor => emptyCellColor;
pub NodeData GetCurrentSeedInSlot() => _actualSeedSlotCell?.GetNodeData();
pub NodeCell SeedSlotCell => _actualSeedSlotCell;

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;

_rootCanvas = GetComponentInParent<Canvas>()?.rootCanvas ?? FindFirstObjectByType<Canvas>();
if (_rootCanvas == null) Debug.LogError("[NodeEditorGridController] Root Canvas not found!", gameObject);
if (inventoryItemPrefab == null) Debug.LogError("[NodeEditorGridController] Inventory Item Prefab is not assigned!", gameObject);
}

void OnDestroy() {
if (Instance == this) Instance = null;
}

void Start() {
if (nodeDropdown != null) nodeDropdown.gameObject.SetActive(false);
if (seedSlotContainer != null) CreateSeedSlot();
if (cellContainer != null && definitionLibrary != null) {
CreateSequenceCells();
HideNodeEditorPanel();
}
}

pub NodeGraph GetCurrentGraphInEditorForSpawning() {
NodeGraph clone = new NodeGraph { nodes = new List<NodeData>() };
if (_currentlyEditedSequence?.nodes != null) {
foreach (var nodeData in _currentlyEditedSequence.nodes) {
if (nodeData == null) continue;
NodeData clonedNode = new NodeData {
nodeId = nodeData.nodeId,
nodeDisplayName = nodeData.nodeDisplayName,
effects = NodeExecutor.CloneEffectsList(nodeData.effects),
orderIndex = nodeData.orderIndex,
canBeDeleted = nodeData.canBeDeleted,
storedSequence = null // Nodes *within* a sequence for spawning DO NOT have their own stored sequences
};
clone.nodes.Add(clonedNode);
}
}
ret clone;
}

void CreateSeedSlot() {
foreach (Transform child in seedSlotContainer) Destroy(child.gameObject);

GameObject seedCellGO = new GameObject("SeedSlot_Cell", typeof(RectTransform));
seedCellGO.transform.SetParent(seedSlotContainer, false);
seedCellGO.GetComponent<RectTransform>().sizeDelta = cellSize;
Image cellImage = seedCellGO.AddComponent<Image>();
cellImage.sprite = emptyCellSprite;
cellImage.color = emptyCellColor;
NodeCell cellLogic = seedCellGO.AddComponent<NodeCell>();
cellLogic.InitAsSeedSlot(this, cellImage);
_actualSeedSlotCell = cellLogic;
}

void CreateSequenceCells() {
foreach (Transform child in cellContainer) Destroy(child.gameObject);
nodeCells.Clear();
NodeCell.ClearSelection();

GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
gridLayout.cellSize = cellSize;
gridLayout.spacing = new Vector2(cellMargin, cellMargin);

for (int i = 0; i < emptyCellsCount; i++) {
GameObject cellGO = new GameObject($"SequenceCell_{i}", typeof(RectTransform));
cellGO.transform.SetParent(cellContainer, false);
Image cellImage = cellGO.AddComponent<Image>();
cellImage.sprite = emptyCellSprite;
cellImage.color = emptyCellColor;
NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
cellLogic.Init(i, this, cellImage);
nodeCells.Add(cellLogic);
}
}

void Update() {
if (gridUIParent != null && gridUIParent.activeInHierarchy) {
if (Input.GetKeyDown(KeyCode.Delete) && NodeCell.CurrentlySelectedCell != null) {
NodeCell selected = NodeCell.CurrentlySelectedCell;
NodeData data = selected.GetNodeData();
if (data != null && data.canBeDeleted) {
selected.RemoveNode();
RefreshGraphAndUpdateSeed();
}
}
if (Input.GetKeyDown(KeyCode.Escape)) {
if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) HideDropdown();
else if (NodeCell.CurrentlySelectedCell != null) NodeCell.ClearSelection();
}
}
}

pub void LoadSequenceFromSeed(NodeData seedData) {
if (_actualSeedSlotCell == null || seedData == null || !seedData.IsSeed()) {
HideNodeEditorPanel();
_currentlyEditedSequence.nodes.Clear();
return;
}

seedData.EnsureSeedSequenceInitialized();
ClearSequenceEditorCells();
_currentlyEditedSequence.nodes.Clear();

if (seedData.storedSequence?.nodes != null) {
foreach (NodeData nodeDataInSeedSequence in seedData.storedSequence.nodes.OrderBy(n => n.orderIndex)) {
if (nodeDataInSeedSequence == null || nodeDataInSeedSequence.orderIndex >= nodeCells.Count) continue;

NodeCell targetCell = nodeCells[nodeDataInSeedSequence.orderIndex];
NodeDefinition def = definitionLibrary.definitions.FirstOrDefault(d => d.displayName == nodeDataInSeedSequence.nodeDisplayName);

if (def != null) {
targetCell.AssignNode(def); // AssignNode creates a new view
_currentlyEditedSequence.nodes.Add(targetCell.GetNodeData());
}
}
}
ShowNodeEditorPanel();
}

pub void UnloadSeedFromSlot() {
ClearSequenceEditorCells();
HideNodeEditorPanel();
_currentlyEditedSequence.nodes.Clear();
}

pub void OnEmptyCellRightClicked(NodeCell cell, PointerEventData eventData) {
if (cell.IsInventoryCell || cell == _actualSeedSlotCell || nodeDropdown == null) return;
StopCoroutine(nameof(ShowDropdownCoroutine));
StartCoroutine(ShowDropdownCoroutine(cell, eventData));
}

IEnumerator ShowDropdownCoroutine(NodeCell cell, PointerEventData eventData) {
var sortedDefinitions = definitionLibrary.definitions
.Where(def => def != null && !def.effects.Any(e => e.effectType == NodeEffectType.SeedSpawn))
.OrderBy(def => def.displayName)
.ToList();

List<TMP_Dropdown.OptionData> options = new List<TMP_Dropdown.OptionData> { new TMP_Dropdown.OptionData("Select Node...") };
options.AddRange(sortedDefinitions.Select(def => new TMP_Dropdown.OptionData { text = def.displayName, image = def.thumbnail }));

nodeDropdown.ClearOptions();
nodeDropdown.AddOptions(options);
nodeDropdown.onValueChanged.RemoveAllListeners();
nodeDropdown.onValueChanged.AddListener((index) => OnDropdownValueChanged(index, cell, sortedDefinitions));

RectTransformUtility.ScreenPointToLocalPointInRectangle(nodeDropdown.transform.parent as RectTransform, eventData.position, _rootCanvas.worldCamera, out Vector2 localPos);
(nodeDropdown.transform as RectTransform).localPosition = localPos;
nodeDropdown.gameObject.SetActive(true);
yield ret null;
nodeDropdown.Show();
nodeDropdown.value = 0;
nodeDropdown.RefreshShownValue();
}

void OnDropdownValueChanged(int selectedIndex, NodeCell targetCell, List<NodeDefinition> sortedDefinitions) {
HideDropdown();
if (selectedIndex > 0 && (selectedIndex - 1) < sortedDefinitions.Count) {
NodeDefinition selectedDef = sortedDefinitions[selectedIndex - 1];
targetCell.AssignNode(selectedDef);
NodeCell.SelectCell(targetCell);
RefreshGraphAndUpdateSeed();
}
}

pub void RefreshGraphAndUpdateSeed() {
if (_actualSeedSlotCell == null) return;

_currentlyEditedSequence.nodes.Clear();
foreach (var cell in nodeCells.OrderBy(c => c.CellIndex)) {
if (cell.HasItem()) {
NodeData dataFromCell = cell.GetNodeData();
dataFromCell.orderIndex = cell.CellIndex;
dataFromCell.ClearStoredSequence();
_currentlyEditedSequence.nodes.Add(dataFromCell);
}
}

NodeData currentSeedInSlot = GetCurrentSeedInSlot();
if (currentSeedInSlot != null && currentSeedInSlot.IsSeed()) {
currentSeedInSlot.EnsureSeedSequenceInitialized();
currentSeedInSlot.storedSequence.nodes.Clear();
foreach (NodeData uiNodeData in _currentlyEditedSequence.nodes) {
currentSeedInSlot.storedSequence.nodes.Add(new NodeData {
nodeId = uiNodeData.nodeId,
nodeDisplayName = uiNodeData.nodeDisplayName,
effects = NodeExecutor.CloneEffectsList(uiNodeData.effects),
orderIndex = uiNodeData.orderIndex,
canBeDeleted = uiNodeData.canBeDeleted,
storedSequence = null
});
}
}
}

pub void HandleDropOnSeedSlot(NodeDraggable draggedDraggable, NodeCell originalCell, NodeCell targetSeedSlotCell) {
if (_actualSeedSlotCell == null || targetSeedSlotCell != _actualSeedSlotCell) {
draggedDraggable.ResetPosition(); return;
}

ItemView draggedView = draggedDraggable.GetComponent<ItemView>();
NodeData draggedData = draggedView?.GetNodeData();

if (draggedView == null || draggedData == null || !draggedData.IsSeed()) {
draggedDraggable.ResetPosition(); return;
}

ItemView existingSeedViewInSlot = _actualSeedSlotCell.GetItemView();
if (existingSeedViewInSlot != null) {
RefreshGraphAndUpdateSeed();
NodeData existingSeedInSlotData = _actualSeedSlotCell.GetNodeData();
_actualSeedSlotCell.ClearNodeReference();
InventoryGridController.Instance.ReturnGeneToInventory(existingSeedViewInSlot, existingSeedInSlotData);
}

if (originalCell.IsInventoryCell) {
InventoryGridController.Instance.RemoveGeneFromInventory(originalCell);
}
else {
originalCell.RemoveNode();
}

draggedData.EnsureSeedSequenceInitialized();
_actualSeedSlotCell.AssignItemView(draggedView, draggedData, null);
draggedDraggable.SnapToCell(_actualSeedSlotCell);
LoadSequenceFromSeed(draggedData);
}

pub void HandleDropOnSequenceCell(NodeDraggable draggedDraggable, NodeCell originalCell, NodeCell targetSequenceCell) {
if (draggedDraggable == null || originalCell == null || targetSequenceCell == null || targetSequenceCell.IsInventoryCell || targetSequenceCell.IsSeedSlot) {
draggedDraggable?.ResetPosition(); return;
}

ItemView draggedView = draggedDraggable.GetComponent<ItemView>();
if (draggedView == null) { draggedDraggable.ResetPosition(); return; }

NodeDefinition draggedNodeDef = draggedView.GetNodeDefinition();
NodeData draggedData = draggedView.GetNodeData();

if (draggedNodeDef != null && draggedNodeDef.effects.Any(e => e.effectType == NodeEffectType.SeedSpawn)) {
draggedDraggable.ResetPosition(); return;
}

if (originalCell.IsInventoryCell) {
InventoryGridController.Instance?.RemoveGeneFromInventory(originalCell);
ItemView existingViewInTargetSeq = targetSequenceCell.GetItemView();
if (existingViewInTargetSeq != null) {
InventoryGridController.Instance.ReturnGeneToInventory(existingViewInTargetSeq, targetSequenceCell.GetNodeData());
targetSequenceCell.ClearNodeReference();
}
targetSequenceCell.AssignNode(draggedNodeDef);
NodeCell.SelectCell(targetSequenceCell);
Destroy(draggedDraggable.gameObject);
}
else if (!originalCell.IsSeedSlot) {
ItemView existingViewInTarget = targetSequenceCell.GetItemView();
NodeData existingDataInTarget = targetSequenceCell.GetNodeData();

originalCell.ClearNodeReference();

if (existingViewInTarget != null) {
originalCell.AssignItemView(existingViewInTarget, existingDataInTarget, null);
existingViewInTarget.GetComponent<NodeDraggable>()?.SnapToCell(originalCell);
}
targetSequenceCell.AssignItemView(draggedView, draggedData, null);
draggedDraggable.SnapToCell(targetSequenceCell);
NodeCell.SelectCell(targetSequenceCell);
}
else {
draggedDraggable.ResetPosition();
}

RefreshGraphAndUpdateSeed();
}

void HideNodeEditorPanel() { if (gridUIParent != null) gridUIParent.SetActive(false); }
void ShowNodeEditorPanel() { if (gridUIParent != null) gridUIParent.SetActive(true); }
void ClearSequenceEditorCells() { foreach (NodeCell cell in nodeCells) { cell.RemoveNode(); } }
pub void HideDropdown() { if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) { nodeDropdown.Hide(); nodeDropdown.gameObject.SetActive(false); } }
pub NodeCell GetCellAtIndex(int index) => (index >= 0 && index < nodeCells.Count) ? nodeCells[index] : null;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\OutlinePartController.cs

﻿using UnityEngine;

pub cls OutlinePartController : MonoBehaviour {
SpriteRenderer outlineRenderer;
Transform cachedTransform;

SpriteRenderer sourcePlantPartRenderer; // The plant part this outline mimics

pub Vector2Int gridCoord; // The coordinate *this outline* lives at

void Awake() {
outlineRenderer = GetComponent<SpriteRenderer>();
cachedTransform = transform;

if (outlineRenderer != null) {
outlineRenderer.drawMode = SpriteDrawMode.Simple;
outlineRenderer.enabled = false;
}
else {
Debug.LogError($"[{gameObject.name}] OutlinePartController is missing SpriteRenderer component!", this);
}
}

pub void Initialize(SpriteRenderer sourceRenderer, Vector2Int myCoord, PlantOutlineController controller) {
if (sourceRenderer == null || controller == null) {
Debug.LogError($"[{gameObject.name}] Initialization failed! Source renderer or controller is null!", this);
Destroy(gameObject);
return;
}

sourcePlantPartRenderer = sourceRenderer; // Store initial source
gridCoord = myCoord;

if (outlineRenderer == null) {
outlineRenderer = GetComponent<SpriteRenderer>();
if (outlineRenderer == null) {
Debug.LogError($"[{gameObject.name}] Initialize: Cannot find SpriteRenderer component!", this);
Destroy(gameObject);
return;
}
}

outlineRenderer.sortingLayerID = controller.OutlineSortingLayer;
outlineRenderer.sortingOrder = controller.OutlineSortingOrder;
outlineRenderer.color = controller.OutlineColor;

cachedTransform.SetParent(controller.transform, true); // Parent to controller's transform

float spacing = controller.GetComponentInParent<PlantGrowth>()?.GetCellSpacing() ?? 0.08f; // Get spacing
cachedTransform.localPosition = (Vector2)myCoord * spacing;

outlineRenderer.enabled = IsSourceRendererValid() &&
sourcePlantPartRenderer.enabled &&
sourcePlantPartRenderer.sprite != null;

SyncSpriteAndTransform(); // Initial sync
}

void LateUpdate() {
if (outlineRenderer == null || !outlineRenderer.enabled) return;

if (!IsSourceRendererValid()) {
SetVisibility(false);
return;
}

if (!sourcePlantPartRenderer.enabled || sourcePlantPartRenderer.sprite == null) {
SetVisibility(false);
return;
}

SyncSpriteAndTransform();
}

pub bool IsSourceRendererValid() {
if (sourcePlantPartRenderer == null)
ret false;

if (!sourcePlantPartRenderer.gameObject.activeInHierarchy)
ret false;

ret true;
}

pub void UpdateSourceRenderer(SpriteRenderer newSource) {
if (newSource != null) {
sourcePlantPartRenderer = newSource;

SetVisibility(
outlineRenderer != null &&
sourcePlantPartRenderer.enabled &&
sourcePlantPartRenderer.sprite != null
);

SyncSpriteAndTransform();
}
else {
Debug.LogWarning($"Attempted to update source renderer for outline at {gridCoord} with null.", gameObject);
SetVisibility(false);
}
}

pub void SyncSpriteAndTransform() {
if (!IsSourceRendererValid() || outlineRenderer == null)
return;

if (outlineRenderer.sprite != sourcePlantPartRenderer.sprite) {
outlineRenderer.sprite = sourcePlantPartRenderer.sprite;
}

cachedTransform.localScale = sourcePlantPartRenderer.transform.localScale;
outlineRenderer.flipX = sourcePlantPartRenderer.flipX;
outlineRenderer.flipY = sourcePlantPartRenderer.flipY;
}

pub void SetVisibility(bool isVisible) {
if (outlineRenderer != null && outlineRenderer.enabled != isVisible) {
outlineRenderer.enabled = isVisible;
}
}

pub void DestroyOutlinePart() {
if (this != null && gameObject != null) {
if (Application.isPlaying) {
Destroy(gameObject);
}
else {
DestroyImmediate(gameObject);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\PlantOutlineController.cs

﻿using UnityEngine;

pub cls PlantOutlineController : MonoBehaviour {
[SerializeField] Color outlineColor = Color.black;
[SerializeField] bool excludeOuterCorners = false;
[SerializeField] bool excludeBaseCell = true;
[SerializeField] GameObject outlinePartPrefab;

[SerializeField] string outlineSortingLayerName = "Default";
[SerializeField] int outlineSortingOrder = -1;

[SerializeField] bool debugLogging = false;

pub Color OutlineColor => outlineColor;
pub int OutlineSortingLayer => outlineSortingLayerID;
pub int OutlineSortingOrder => outlineSortingOrder;

int outlineSortingLayerID;
PlantGrowth parentPlantGrowth;
Dictionary<Vector2Int, OutlinePartController> outlinePartMap = new Dictionary<Vector2Int, OutlinePartController>();
HashSet<Vector2Int> plantCellCoords = new HashSet<Vector2Int>();

stat ro Vector2Int[] neighborOffsets = new Vector2Int[] {
new Vector2Int(-1, -1), // Down-Left
new Vector2Int(0, -1),  // Down
new Vector2Int(1, -1),  // Down-Right
new Vector2Int(-1, 0),  // Left
new Vector2Int(1, 0),   // Right
new Vector2Int(-1, 1),  // Up-Left
new Vector2Int(0, 1),   // Up
new Vector2Int(1, 1),   // Up-Right
};

stat ro Vector2Int[] cardinalOffsets = new Vector2Int[] {
new Vector2Int(0, -1),  // Down
new Vector2Int(-1, 0),  // Left
new Vector2Int(1, 0),   // Right
new Vector2Int(0, 1),   // Up
};

void Awake() {
parentPlantGrowth = GetComponentInParent<PlantGrowth>();
if (parentPlantGrowth == null) {
Debug.LogError($"[{gameObject.name} Awake] Missing PlantGrowth parent!", gameObject);
enabled = false;
return;
}

if (outlinePartPrefab == null) {
Debug.LogError($"[{gameObject.name} Awake] Outline Part Prefab not assigned!", gameObject);
enabled = false;
return;
}

outlineSortingLayerID = SortingLayer.NameToID(outlineSortingLayerName);
if (outlineSortingLayerID == 0 && outlineSortingLayerName != "Default") {
Debug.LogWarning($"[{gameObject.name} Awake] Sorting Layer '{outlineSortingLayerName}' not found, using 'Default'.");
outlineSortingLayerID = SortingLayer.NameToID("Default");
}

transform.localPosition = Vector3.zero;
transform.localRotation = Quaternion.identity;
transform.localScale = Vector3.one;

if (debugLogging)
Debug.Log($"[{gameObject.name} Awake] Initialized outline controller for {parentPlantGrowth.gameObject.name}");
}

pub void OnPlantCellAdded(Vector2Int plantCoord, GameObject plantCellGO) {
if (plantCellGO == null) {
if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] OnPlantCellAdded: Null GameObject at {plantCoord}");
return;
}

plantCellCoords.Add(plantCoord);

RemoveOutlinePartIfExists(plantCoord);

SpriteRenderer plantRenderer = plantCellGO.GetComponentInChildren<SpriteRenderer>();
if (plantRenderer == null) {
Debug.LogWarning($"Plant cell added at {plantCoord} missing SpriteRenderer.", plantCellGO);
return;
}

foreach (Vector2Int offset in neighborOffsets) {
Vector2Int neighborCoord = plantCoord + offset;

if (!plantCellCoords.Contains(neighborCoord) &&
!outlinePartMap.ContainsKey(neighborCoord)) {
if (ShouldExcludeOutlineAt(neighborCoord))
continue;

CreateOutlinePart(neighborCoord, plantRenderer);
}
}

if (debugLogging)
Debug.Log($"[{gameObject.name}] Added cell at {plantCoord}, now tracking {plantCellCoords.Count} cells and {outlinePartMap.Count} outline parts");
}

pub void OnPlantCellRemoved(Vector2Int plantCoord) {
if (!plantCellCoords.Contains(plantCoord)) {
if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] OnPlantCellRemoved: Coordinate {plantCoord} not found in plant cells!");
return;
}

plantCellCoords.Remove(plantCoord);

if (debugLogging)
Debug.Log($"[{gameObject.name}] Removed cell at {plantCoord}, now have {plantCellCoords.Count} cells");

if (!outlinePartMap.ContainsKey(plantCoord)) {
if (HasPlantNeighbor(plantCoord)) {
SpriteRenderer sourceRenderer = FindValidNeighborRenderer(plantCoord);
if (sourceRenderer != null && !ShouldExcludeOutlineAt(plantCoord)) {
CreateOutlinePart(plantCoord, sourceRenderer);
if (debugLogging)
Debug.Log($"[{gameObject.name}] Created new outline at removed cell position {plantCoord}");
}
}
}

foreach (Vector2Int offset in neighborOffsets) {
Vector2Int neighborCoord = plantCoord + offset;

if (outlinePartMap.TryGetValue(neighborCoord, out OutlinePartController outlinePart)) {
if (outlinePart == null) {
outlinePartMap.Remove(neighborCoord);
if (debugLogging)
Debug.Log($"[{gameObject.name}] Removed null outline at {neighborCoord} from dictionary");
continue;
}

bool neighborStillHasPlantNeighbor = HasPlantNeighbor(neighborCoord);

if (!neighborStillHasPlantNeighbor) {
RemoveOutlinePartIfExists(neighborCoord);
if (debugLogging)
Debug.Log($"[{gameObject.name}] Removed orphaned outline at {neighborCoord}");
}
else if (!outlinePart.IsSourceRendererValid()) {
SpriteRenderer newSource = FindValidNeighborRenderer(neighborCoord);
if (newSource != null) {
outlinePart.UpdateSourceRenderer(newSource);
outlinePart.SyncSpriteAndTransform();
if (debugLogging)
Debug.Log($"[{gameObject.name}] Updated source for outline at {neighborCoord}");
}
else {
if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] Outline at {neighborCoord} lost source but HasPlantNeighbor=true. Removing.");
RemoveOutlinePartIfExists(neighborCoord);
}
}
}
else if (!plantCellCoords.Contains(neighborCoord) && HasPlantNeighbor(neighborCoord)) {
if (!ShouldExcludeOutlineAt(neighborCoord)) {
SpriteRenderer sourceRenderer = FindValidNeighborRenderer(neighborCoord);
if (sourceRenderer != null) {
CreateOutlinePart(neighborCoord, sourceRenderer);
if (debugLogging)
Debug.Log($"[{gameObject.name}] Created new outline at neighbor {neighborCoord} after cell removal");
}
}
}
}
}

void CreateOutlinePart(Vector2Int coord, SpriteRenderer sourceRenderer) {
if (outlinePartPrefab == null) {
Debug.LogError($"[{gameObject.name}] CreateOutlinePart: outlinePartPrefab is null!");
return;
}

if (sourceRenderer == null) {
Debug.LogWarning($"[{gameObject.name}] CreateOutlinePart: sourceRenderer is null for coord {coord}");
return;
}

if (outlinePartMap.ContainsKey(coord)) {
if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] CreateOutlinePart: Outline already exists at {coord}");
return;
}

GameObject outlineInstance = Instantiate(outlinePartPrefab, transform);
if (outlineInstance == null) {
Debug.LogError($"[{gameObject.name}] CreateOutlinePart: Failed to instantiate outline prefab!");
return;
}

float spacing = parentPlantGrowth.GetCellSpacing();
outlineInstance.transform.localPosition = (Vector2)coord * spacing;

OutlinePartController outlineController = outlineInstance.GetComponent<OutlinePartController>();
if (outlineController != null) {
outlineController.Initialize(sourceRenderer, coord, this);
outlineController.SetVisibility(true);
outlinePartMap.Add(coord, outlineController);

if (debugLogging)
Debug.Log($"[{gameObject.name}] Created outline part at {coord} using source {sourceRenderer.gameObject.name}");
}
else {
Debug.LogError($"[{gameObject.name}] Outline Part Prefab missing OutlinePartController script!", outlinePartPrefab);
Destroy(outlineInstance);
}
}

void RemoveOutlinePartIfExists(Vector2Int coord) {
if (outlinePartMap.TryGetValue(coord, out OutlinePartController outlinePart)) {
if (outlinePart != null) {
outlinePart.DestroyOutlinePart();
if (debugLogging)
Debug.Log($"[{gameObject.name}] Destroyed outline part at {coord}");
}
outlinePartMap.Remove(coord);
}
}

bool HasPlantNeighbor(Vector2Int coord) {
foreach (Vector2Int offset in neighborOffsets) {
if (plantCellCoords.Contains(coord + offset)) {
ret true;
}
}
ret false;
}

SpriteRenderer FindValidNeighborRenderer(Vector2Int coord) {
foreach (Vector2Int offset in neighborOffsets) {
Vector2Int neighborCoord = coord + offset;

if (plantCellCoords.Contains(neighborCoord)) {
GameObject plantGO = parentPlantGrowth.GetCellGameObjectAt(neighborCoord);
if (plantGO != null) {
SpriteRenderer renderer = plantGO.GetComponentInChildren<SpriteRenderer>();
if (renderer != null) {
if (debugLogging)
Debug.Log($"[{gameObject.name}] Found valid renderer at {neighborCoord} for outline at {coord}");
ret renderer;
}
}
}
}

if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] Could not find any valid neighbor renderer for {coord}");
ret null;
}

bool ShouldExcludeOutlineAt(Vector2Int coord) {
if (excludeBaseCell && coord == Vector2Int.down && plantCellCoords.Contains(Vector2Int.zero)) {
ret true;
}

if (excludeOuterCorners && IsOuterCornerCandidate(coord)) {
ret true;
}

ret false;
}

bool IsOuterCornerCandidate(Vector2Int coord) {
if (plantCellCoords.Contains(coord))
ret false;

int plantNeighborCount = 0;
foreach (Vector2Int offset in neighborOffsets) {
if (plantCellCoords.Contains(coord + offset)) {
plantNeighborCount++;
}
}

ret plantNeighborCount == 3;
}

void OnDestroy() {
foreach (var kvp in outlinePartMap) {
if (kvp.Value != null) {
kvp.Value.DestroyOutlinePart();
}
}
outlinePartMap.Clear();
plantCellCoords.Clear();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\PlantShadowController.cs

﻿using UnityEngine;

pub cls PlantShadowController : MonoBehaviour {
[SerializeField] Color shadowColor = new Color(0f, 0f, 0f, 0.5f);
float squashFactor = 0.6f;
float shadowAngleDegrees = 270f; // Default to directly downwards
bool flipShadow = false;

[SerializeField] bool enableDistanceFade = true;
[SerializeField] float fadeStartDistance = 1.5f;
[SerializeField] float fadeEndDistance = 3.0f;
[SerializeField] [Range(0f, 1f)] float minFadeAlpha = 0.0f;

string shadowSortingLayerName = "Default";
int shadowSortingOrder = -1;

int shadowSortingLayerID;

pub Color ShadowColor => shadowColor;
pub int ShadowSortingLayer => shadowSortingLayerID;
pub int ShadowSortingOrder => shadowSortingOrder;

pub bool EnableDistanceFade => enableDistanceFade;
pub float FadeStartDistance => fadeStartDistance;
pub float FadeEndDistance => fadeEndDistance;
pub float MinFadeAlpha => minFadeAlpha;

Vector3 baseLocalScale;
Quaternion baseLocalRotation;
Vector3 baseLocalPosition;

Dictionary<SpriteRenderer, ShadowPartController> shadowPartMap = new Dictionary<SpriteRenderer, ShadowPartController>();

void Awake() {
shadowSortingLayerID = SortingLayer.NameToID(shadowSortingLayerName);
if (shadowSortingLayerID == 0 && shadowSortingLayerName != "Default") {
Debug.LogWarning($"Sorting Layer '{shadowSortingLayerName}' not found. Shadow will use 'Default'.", this);
shadowSortingLayerID = SortingLayer.NameToID("Default");
}

baseLocalScale = transform.localScale;
baseLocalRotation = transform.localRotation;
baseLocalPosition = transform.localPosition;
if (baseLocalPosition != Vector3.zero) {
Debug.LogWarning($"'{gameObject.name}' initial localPosition is not zero ({baseLocalPosition}). Shadow origin might be slightly offset from plant root.", gameObject);
}
}

void LateUpdate() {
transform.localPosition = baseLocalPosition; // Should typically be Vector3.zero

Quaternion angleRotation = Quaternion.Euler(0, 0, shadowAngleDegrees);
transform.localRotation = baseLocalRotation * angleRotation;

Vector3 finalScale = baseLocalScale; // Start with original scale
finalScale.y *= squashFactor;

if (flipShadow) {
finalScale.x *= -1f;
}
transform.localScale = finalScale;

}

pub void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject shadowPartPrefab) {
if (plantPartRenderer == null || shadowPartPrefab == null) return;
if (shadowPartMap.ContainsKey(plantPartRenderer)) return;
GameObject shadowInstance = Instantiate(shadowPartPrefab, transform);
ShadowPartController shadowController = shadowInstance.GetComponent<ShadowPartController>();
if (shadowController != null) { shadowController.Initialize(plantPartRenderer, this); shadowPartMap.Add(plantPartRenderer, shadowController); }
else { Debug.LogError($"Shadow Part Prefab '{shadowPartPrefab.name}' missing ShadowPartController.", shadowPartPrefab); Destroy(shadowInstance); }
}

pub void UnregisterPlantPart(SpriteRenderer plantPartRenderer) {
if (plantPartRenderer != null && shadowPartMap.TryGetValue(plantPartRenderer, out ShadowPartController shadowController)) {
if (shadowController != null) { shadowController.OnPlantPartDestroyed(); }
shadowPartMap.Remove(plantPartRenderer);
}
}

void OnDestroy() {
shadowPartMap.Clear(); // Prevent memory leaks
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\ShadowPartController.cs

﻿using UnityEngine;

pub cls ShadowPartController : MonoBehaviour {
SpriteRenderer shadowRenderer;
Transform cachedTransform;

SpriteRenderer plantPartRenderer;
Transform plantPartTransform;
Transform shadowRootTransform;
PlantShadowController mainShadowController;

void Awake() {
shadowRenderer = GetComponent<SpriteRenderer>();
cachedTransform = transform;

shadowRenderer.drawMode = SpriteDrawMode.Simple;
shadowRenderer.enabled = false;
}

pub void Initialize(SpriteRenderer targetPlantPartRenderer, PlantShadowController controller) {
if (targetPlantPartRenderer == null || controller == null) {
Destroy(gameObject);
return;
}

plantPartRenderer = targetPlantPartRenderer;
plantPartTransform = targetPlantPartRenderer.transform;
mainShadowController = controller;
shadowRootTransform = controller.transform;

shadowRenderer.sortingLayerID = mainShadowController.ShadowSortingLayer;
shadowRenderer.sortingOrder = mainShadowController.ShadowSortingOrder;

cachedTransform.SetParent(shadowRootTransform, true); // Parent first

shadowRenderer.enabled = plantPartRenderer.enabled && plantPartRenderer.sprite != null;
UpdateColorAndFade();
}

void LateUpdate() {
if (plantPartRenderer == null || !plantPartRenderer.enabled || plantPartRenderer.sprite == null || shadowRenderer == null || mainShadowController == null) {
if (shadowRenderer != null)
shadowRenderer.enabled = false;
return;
}

shadowRenderer.enabled = true;
shadowRenderer.sprite = plantPartRenderer.sprite;

Vector3 plantPartPosRelativeToPlantRoot = plantPartTransform.parent.InverseTransformPoint(plantPartTransform.position);
cachedTransform.localPosition = plantPartPosRelativeToPlantRoot;
cachedTransform.localRotation = plantPartTransform.localRotation;
cachedTransform.localScale = plantPartTransform.localScale;

shadowRenderer.flipX = plantPartRenderer.flipX;
shadowRenderer.flipY = plantPartRenderer.flipY;

UpdateColorAndFade();
}

void UpdateColorAndFade() {
if (mainShadowController == null || shadowRenderer == null) return;

Color baseShadowColor = mainShadowController.ShadowColor;
float finalAlpha = baseShadowColor.a; // Start with the controller's base alpha

if (mainShadowController.EnableDistanceFade) {
float distance = Vector3.Distance(cachedTransform.position, shadowRootTransform.position); // Distance from shadow part to shadow root

float fadeStart = mainShadowController.FadeStartDistance;
float fadeEnd = mainShadowController.FadeEndDistance;
float minAlpha = mainShadowController.MinFadeAlpha;

if (distance >= fadeEnd) {
finalAlpha *= minAlpha; // Apply min alpha
}
else if (distance > fadeStart) {
float t = Mathf.InverseLerp(fadeStart, fadeEnd, distance);
float distanceAlphaMultiplier = Mathf.Lerp(1f, minAlpha, t);
finalAlpha *= distanceAlphaMultiplier; // Modulate base alpha
}
}

shadowRenderer.color = new Color(baseShadowColor.r, baseShadowColor.g, baseShadowColor.b, finalAlpha);
}

pub void OnPlantPartDestroyed() {
if (this != null && gameObject != null) {
if (Application.isPlaying) {
Destroy(gameObject);
}
else {
DestroyImmediate(gameObject);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridDebugVisualizer.cs

﻿using UnityEngine;
using WegoSystem;

pub cls GridDebugVisualizer : MonoBehaviour {
pub stat GridDebugVisualizer Instance { get; set; }

[SerializeField] bool showRadiusVisualizations = true;
[SerializeField] float tileVisualizationAlpha = 0.3f;
[SerializeField] GameObject tilePrefab; // Simple square sprite

[SerializeField] Color animalSearchRadiusColor = new Color(1f, 0.5f, 0f, 0.3f);
[SerializeField] Color plantPoopRadiusColor = new Color(0.6f, 0.4f, 0.2f, 0.3f);
[SerializeField] Color scentRadiusColor = new Color(1f, 1f, 0f, 0.3f);
[SerializeField] Color fireflyPhotosynthesisColor = new Color(0f, 1f, 0.5f, 0.3f);
[SerializeField] Color toolUseRadiusColor = new Color(0f, 0.5f, 1f, 0.3f);

Dictionary<object, List<GameObject>> visualizedRadii = new Dictionary<object, List<GameObject>>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void OnDestroy() {
ClearAllVisualizations();
if (Instance == this) Instance = null;
}

pub void VisualizeRadius(object source, GridPosition center, int radius, Color color, float duration = 0f) {
if (!showRadiusVisualizations || tilePrefab == null) return;

ClearVisualization(source);

var tiles = GridRadiusUtility.GetTilesInCircle(center, radius);
var tileObjects = new List<GameObject>();

foreach (var tile in tiles) {
Vector3 worldPos = GridPositionManager.Instance.GridToWorld(tile);
GameObject tileVis = Instantiate(tilePrefab, worldPos, Quaternion.identity, transform);

SpriteRenderer sr = tileVis.GetComponent<SpriteRenderer>();
if (sr != null) {
Color finalColor = color;
finalColor.a = tileVisualizationAlpha;
sr.color = finalColor;
sr.sortingOrder = -100; // Behind everything
}

tileObjects.Add(tileVis);

if (duration > 0) {
Destroy(tileVis, duration);
}
}

if (duration <= 0) {
visualizedRadii[source] = tileObjects;
}
}

pub void ClearVisualization(object source) {
if (visualizedRadii.TryGetValue(source, out var tiles)) {
foreach (var tile in tiles) {
if (tile != null) Destroy(tile);
}
visualizedRadii.Remove(source);
}
}

pub void ClearAllVisualizations() {
foreach (var kvp in visualizedRadii) {
foreach (var tile in kvp.Value) {
if (tile != null) Destroy(tile);
}
}
visualizedRadii.Clear();
}

pub void VisualizeAnimalSearchRadius(AnimalController animal, GridPosition center, int radius) {
VisualizeRadius(animal, center, radius, animalSearchRadiusColor);
}

pub void VisualizePlantPoopRadius(PlantGrowth plant, GridPosition center, int radius) {
VisualizeRadius(plant, center, radius, plantPoopRadiusColor);
}

pub void VisualizeScentRadius(ScentSource scent, GridPosition center, int radius) {
VisualizeRadius(scent, center, radius, scentRadiusColor);
}

pub void VisualizeToolUseRadius(GridPosition center, int radius, float duration = 1f) {
VisualizeRadius("tool_use", center, radius, toolUseRadiusColor, duration);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridSnapStartup.cs

﻿// Assets\Scripts\Core\GridSnapStartup.cs

using WegoSystem;

pub cls GridSnapStartup : MonoBehaviour {
[SerializeField] bool snapAllAnimals = true;
[SerializeField] bool snapAllPlants = true;
[SerializeField] bool snapPlayer = true;
[SerializeField] bool debugLog = true;

void Awake() {
if (GridPositionManager.Instance == null) {
Debug.LogError("[GridSnapStartup] GridPositionManager not found! Cannot snap entities.");
return;
}
}

void Start() {
PerformGridSnapping();
}

void PerformGridSnapping() {
int snappedCount = 0;

if (snapPlayer) {
GardenerController[] gardeners = FindObjectsByType<GardenerController>(FindObjectsSortMode.None);
foreach (var gardener in gardeners) {
GridPositionManager.Instance.SnapEntityToGrid(gardener.gameObject);
snappedCount++;
}
}

if (snapAllAnimals) {
AnimalController[] animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
foreach (var animal in animals) {
GridPositionManager.Instance.SnapEntityToGrid(animal.gameObject);
snappedCount++;
}
}

if (snapAllPlants) {
PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
foreach (var plant in plants) {
GridPositionManager.Instance.SnapEntityToGrid(plant.gameObject);
snappedCount++;
}
}

if (debugLog) {
Debug.Log($"[GridSnapStartup] Snapped {snappedCount} entities to grid on startup");
}
}

void SnapAllEntitiesNow() {
if (GridPositionManager.Instance == null) {
Debug.LogError("GridPositionManager not found in scene!");
return;
}

PerformGridSnapping();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickDebugMonitor.cs

﻿using UnityEngine;
using TMPro;
using WegoSystem;

pub cls TickDebugMonitor : MonoBehaviour {
[SerializeField] GameObject monitorPanel;
[SerializeField] TextMeshProUGUI tickCounterText;
[SerializeField] TextMeshProUGUI tickRateText;
[SerializeField] TextMeshProUGUI dayProgressText;
[SerializeField] TextMeshProUGUI phaseText;

[SerializeField] TextMeshProUGUI animalCountText;
[SerializeField] TextMeshProUGUI plantCountText;
[SerializeField] TextMeshProUGUI fireflyCountText;

[SerializeField] TextMeshProUGUI tickDurationText;
[SerializeField] Slider tickDurationBar;
[SerializeField] float maxTickDuration = 50f; // milliseconds

[SerializeField] Transform effectListContainer;
[SerializeField] GameObject effectEntryPrefab;

[SerializeField] KeyCode toggleKey = KeyCode.F3;
[SerializeField] bool showOnStart = false;

float lastTickStartTime;
float lastTickDuration;
Queue<float> tickDurationHistory = new Queue<float>();
c int HISTORY_SIZE = 60;

Dictionary<string, TickEffectEntry> activeEffects = new Dictionary<string, TickEffectEntry>();
List<GameObject> effectUIEntries = new List<GameObject>();

cls TickEffectEntry {
pub string name;
pub string source;
pub int remainingTicks;
pub Color color;
}

void Start() {
monitorPanel.SetActive(showOnStart);

if (TickManager.Instance != null) {
TickManager.Instance.OnTickStarted += OnTickStarted;
TickManager.Instance.OnTickCompleted += OnTickCompleted;
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.OnTickStarted -= OnTickStarted;
TickManager.Instance.OnTickCompleted -= OnTickCompleted;
}
}

void Update() {
if (Input.GetKeyDown(toggleKey)) {
monitorPanel.SetActive(!monitorPanel.activeSelf);
}

if (monitorPanel.activeSelf) {
UpdateDisplay();
}
}

void OnTickStarted(int tick) {
lastTickStartTime = Time.realtimeSinceStartup;
}

void OnTickCompleted(int tick) {
lastTickDuration = (Time.realtimeSinceStartup - lastTickStartTime) * 1000f; // Convert to ms

tickDurationHistory.Enqueue(lastTickDuration);
if (tickDurationHistory.Count > HISTORY_SIZE) {
tickDurationHistory.Dequeue();
}
}

void UpdateDisplay() {
if (TickManager.Instance == null) return;

tickCounterText.text = $"Tick: {TickManager.Instance.CurrentTick}";
tickRateText.text = $"Rate: {TickManager.Instance.Config.ticksPerRealSecond:F1} ticks/sec";

if (TickManager.Instance.Config != null) {
int dayProgress = TickManager.Instance.Config.GetDayProgress(TickManager.Instance.CurrentTick);
float dayPercent = TickManager.Instance.Config.GetDayProgressNormalized(TickManager.Instance.CurrentTick) * 100f;
dayProgressText.text = $"Day: {dayProgress}/{TickManager.Instance.Config.ticksPerDay} ({dayPercent:F0}%)";
}

if (TurnPhaseManager.Instance != null) {
phaseText.text = $"Phase: {TurnPhaseManager.Instance.CurrentPhase} (Tick {TurnPhaseManager.Instance.CurrentPhaseTicks})";
}

animalCountText.text = $"Animals: {CountEntities<AnimalController>()}";
plantCountText.text = $"Plants: {PlantGrowth.AllActivePlants.Count}";
fireflyCountText.text = $"Fireflies: {CountEntities<FireflyController>()}";

float avgTickDuration = tickDurationHistory.Count > 0 ? tickDurationHistory.Average() : 0f;
tickDurationText.text = $"Tick Time: {avgTickDuration:F1}ms (Last: {lastTickDuration:F1}ms)";
tickDurationBar.value = avgTickDuration / maxTickDuration;

if (avgTickDuration < maxTickDuration * 0.5f) {
tickDurationBar.fillRect.GetComponent<Image>().color = Color.green;
} else if (avgTickDuration < maxTickDuration * 0.8f) {
tickDurationBar.fillRect.GetComponent<Image>().color = Color.yellow;
} else {
tickDurationBar.fillRect.GetComponent<Image>().color = Color.red;
}

UpdateActiveEffects();
}

int CountEntities<T>() where T : Component {
ret FindObjectsByType<T>(FindObjectsSortMode.None).Length;
}

void UpdateActiveEffects() {
activeEffects.Clear();

var animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
foreach (var animal in animals) {
if (animal.CurrentHealth < animal.definition.maxHealth * 0.3f) {
AddEffect($"{animal.SpeciesName}_low_health", "Low Health", animal.SpeciesName, -1, Color.red);
}
}

foreach (var plant in PlantGrowth.AllActivePlants) {
if (plant.CurrentState == PlantState.Growing) {
var logic = plant.GrowthLogic;
int remainingTicks = logic.GrowthTicksPerStage - Mathf.FloorToInt(logic.GetGrowthProgressNormalized() * logic.GrowthTicksPerStage);
AddEffect($"plant_growing_{plant.GetInstanceID()}", "Growing", plant.name, remainingTicks, Color.green);
}
}

RefreshEffectUI();
}

void AddEffect(string id, string name, string source, int remainingTicks, Color color) {
activeEffects[id] = new TickEffectEntry {
name = name,
source = source,
remainingTicks = remainingTicks,
color = color
};
}

void RefreshEffectUI() {
foreach (var entry in effectUIEntries) {
Destroy(entry);
}
effectUIEntries.Clear();

foreach (var effect in activeEffects.Values.OrderBy(e => e.source)) {
GameObject entry = Instantiate(effectEntryPrefab, effectListContainer);
effectUIEntries.Add(entry);

TextMeshProUGUI text = entry.GetComponentInChildren<TextMeshProUGUI>();
if (text != null) {
string tickText = effect.remainingTicks >= 0 ? $"{effect.remainingTicks}t" : "∞";
text.text = $"{effect.source}: {effect.name} [{tickText}]";
text.color = effect.color;
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TurnPhaseManager.cs

﻿using System;
using WegoSystem;

pub enum TurnPhase {
Planning,
Execution
}

pub cls TurnPhaseManager : MonoBehaviour, ITickUpdateable {
pub stat TurnPhaseManager Instance { get; set; }

[SerializeField] TurnPhase currentPhase = TurnPhase.Planning;
[SerializeField] int currentPhaseTicks = 0;
[SerializeField] bool debugMode = false;

pub TurnPhase CurrentPhase => currentPhase;
pub int CurrentPhaseTicks => currentPhaseTicks;
pub bool IsInPlanningPhase => currentPhase == TurnPhase.Planning;
pub bool IsInExecutionPhase => currentPhase == TurnPhase.Execution;

pub event Action<TurnPhase, TurnPhase> OnPhaseChanged;
pub event Action OnPlanningPhaseStarted;
pub event Action OnExecutionPhaseStarted;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
else {
Debug.LogError("[TurnPhaseManager] TickManager not found!");
}

TransitionToPhase(TurnPhase.Planning);
}

void OnDestroy() {
if (Instance == this) {
Instance = null;
}

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
currentPhaseTicks++;
}

bool HasActionsToProcess() {
var gardeners = FindObjectsByType<GardenerController>(FindObjectsSortMode.None);
foreach (var gardener in gardeners) {
}

var animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
foreach (var animal in animals) {
if (currentPhaseTicks % animal.thinkingTickInterval == 0) ret true;
}

var plants = PlantGrowth.AllActivePlants;
if (plants.Count > 0) ret true; // Plants always need processing

ret false;
}

pub void EndPlanningPhase() {
if (currentPhase == TurnPhase.Planning) {
TransitionToPhase(TurnPhase.Execution);
}
else {
Debug.LogWarning($"[TurnPhaseManager] Cannot end planning phase - current phase is {currentPhase}");
}
}

pub void TransitionToPhase(TurnPhase newPhase) {
if (currentPhase == newPhase) return;

TurnPhase oldPhase = currentPhase;
currentPhase = newPhase;
currentPhaseTicks = 0;

switch (newPhase) {
case TurnPhase.Planning:
OnPlanningPhaseStarted?.Invoke();
break;

case TurnPhase.Execution:
OnExecutionPhaseStarted?.Invoke();
break;
}

OnPhaseChanged?.Invoke(oldPhase, newPhase);

if (debugMode) {
Debug.Log($"[TurnPhaseManager] Phase transition: {oldPhase} -> {newPhase}");
}
}

pub void ForcePhase(TurnPhase phase) {
if (Application.isEditor || Debug.isDebugBuild) {
TransitionToPhase(phase);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Tooltips\TooltipTrigger.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;

pub cls TooltipTrigger : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler {
ItemView _itemView;
NodeCell _nodeCell;
bool _isShowingTooltip = false;

void Awake() {
_itemView = GetComponent<ItemView>();
_nodeCell = GetComponentInParent<NodeCell>();
}

pub void OnPointerEnter(PointerEventData eventData) {
if (UniversalTooltipManager.Instance == null || _isShowingTooltip) return;

ShowTooltip();
}

pub void OnPointerExit(PointerEventData eventData) {
if (UniversalTooltipManager.Instance == null || !_isShowingTooltip) return;

HideTooltip();
}

void ShowTooltip() {
ITooltipDataProvider provider = null;
object sourceData = null; // For passing NodeData to a NodeDefinition provider

if (_itemView != null) {
if (_itemView.GetToolDefinition() != null) {
provider = _itemView.GetToolDefinition();
}
else if (_itemView.GetNodeDefinition() != null) {
provider = _itemView.GetNodeDefinition();
sourceData = _itemView.GetNodeData();
}
}
else if (_nodeCell != null) {
if (_nodeCell.GetToolDefinition() != null) {
provider = _nodeCell.GetToolDefinition();
}
else if (_nodeCell.GetNodeDefinition() != null) {
provider = _nodeCell.GetNodeDefinition();
sourceData = _nodeCell.GetNodeData();
}
}

if (provider != null) {
UniversalTooltipManager.Instance.ShowTooltip(provider, transform, sourceData);
_isShowingTooltip = true;
}
}

void HideTooltip() {
UniversalTooltipManager.Instance?.HideTooltip();
_isShowingTooltip = false;
}

void OnDisable() {
if (_isShowingTooltip) {
HideTooltip();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Tooltips\UniversalTooltipManager.cs

﻿using UnityEngine;
using TMPro;

pub ifc ITooltipDataProvider {
string GetTooltipTitle();
string GetTooltipDescription();
string GetTooltipDetails(object source = null);
}

pub cls UniversalTooltipManager : MonoBehaviour {
pub stat UniversalTooltipManager Instance { get; set; }

[SerializeField] GameObject tooltipPanel;
[SerializeField] TextMeshProUGUI titleText;
[SerializeField] TextMeshProUGUI descriptionText;
[SerializeField] TextMeshProUGUI detailsText;
[SerializeField] Image backgroundImage;
[SerializeField] CanvasGroup canvasGroup;
[SerializeField] VerticalLayoutGroup layoutGroup;

[SerializeField] float fadeDuration = 0.15f;
[SerializeField] bool moveTooltipWithMouse = true;
[SerializeField] Vector2 mouseFollowOffset = new Vector2(15f, -15f);

[SerializeField] Color backgroundColor = new Color(0.1f, 0.1f, 0.1f, 0.95f);
[SerializeField] Color titleColor = Color.white;
[SerializeField] Color descriptionColor = new Color(0.8f, 0.8f, 0.8f, 1f);
[SerializeField] Color detailsColor = new Color(0.7f, 0.7f, 0.7f, 1f);
[SerializeField] int titleFontSize = 18;
[SerializeField] int descriptionFontSize = 14;
[SerializeField] int detailsFontSize = 12;

Coroutine _fadeCoroutine;
object _currentTarget;
bool _isVisible = false;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (!ValidateReferences()) {
enabled = false;
return;
}

SetupTooltipPanel();
if (tooltipPanel != null) tooltipPanel.SetActive(false);
if (canvasGroup != null) canvasGroup.alpha = 0f;
_isVisible = false;
}

void Update() {
if (_isVisible && IsTargetNullOrDestroyed(_currentTarget)) {
HideTooltip();
}
}

pub void ShowTooltip(ITooltipDataProvider provider, Transform anchor = null, object source = null) {
if (provider == null) return;

if (_isVisible && ReferenceEquals(_currentTarget, provider)) return;

_currentTarget = provider;

string title = provider.GetTooltipTitle();
string description = provider.GetTooltipDescription();
string details = provider.GetTooltipDetails(source);

ShowTooltipInternal(title, description, details, anchor);
}

pub void HideTooltip() {
_currentTarget = null;
if (tooltipPanel == null || canvasGroup == null) return;

if (_fadeCoroutine != null) {
StopCoroutine(_fadeCoroutine);
}

if (fadeDuration > 0f && gameObject.activeInHierarchy) {
_fadeCoroutine = StartCoroutine(FadeTooltip(false));
}
else {
canvasGroup.alpha = 0f;
if (tooltipPanel != null) tooltipPanel.SetActive(false);
_isVisible = false;
}
}

void ShowTooltipInternal(string title, string description, string details, Transform itemAnchor) {
if (tooltipPanel == null || canvasGroup == null) return;

if (_fadeCoroutine != null) {
StopCoroutine(_fadeCoroutine);
}

if (titleText != null) {
titleText.text = title;
titleText.gameObject.SetActive(!string.IsNullOrEmpty(title));
}
if (descriptionText != null) {
descriptionText.text = description;
descriptionText.gameObject.SetActive(!string.IsNullOrEmpty(description));
}
if (detailsText != null) {
detailsText.text = details;
detailsText.gameObject.SetActive(!string.IsNullOrEmpty(details));
}

tooltipPanel.SetActive(true);
if (layoutGroup != null) {
LayoutRebuilder.ForceRebuildLayoutImmediate(layoutGroup.GetComponent<RectTransform>());
}

if (moveTooltipWithMouse) {
PositionTooltipWithMouse();
}

if (fadeDuration > 0f) {
_fadeCoroutine = StartCoroutine(FadeTooltip(true));
}
else {
canvasGroup.alpha = 1f;
_isVisible = true;
}
}

void PositionTooltipWithMouse() {
var tooltipRect = tooltipPanel.GetComponent<RectTransform>();
var rootCanvas = tooltipPanel.GetComponentInParent<Canvas>()?.rootCanvas;

if (tooltipRect == null || rootCanvas == null || !Input.mousePresent) return;

Vector2 targetScreenPos = Input.mousePosition;
targetScreenPos += mouseFollowOffset; // Apply user offset

var panelRect = tooltipRect.rect;
targetScreenPos.x = Mathf.Clamp(targetScreenPos.x, 0, Screen.width - panelRect.width);
targetScreenPos.y = Mathf.Clamp(targetScreenPos.y, 0, Screen.height - panelRect.height);

var parentRect = tooltipRect.parent as RectTransform;
if (parentRect == null) return;

Camera renderCamera = (rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay) ? null : rootCanvas.worldCamera;
if (RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRect, targetScreenPos, renderCamera, out var localPos)) {
tooltipRect.localPosition = localPos;
}
}

IEnumerator FadeTooltip(bool fadeIn) {
if (canvasGroup == null) yield break;

float elapsed = 0f;
float startAlpha = canvasGroup.alpha;
float targetAlpha = fadeIn ? 1f : 0f;

if (fadeIn) _isVisible = true;

if (fadeIn && tooltipPanel != null && !tooltipPanel.activeSelf)
tooltipPanel.SetActive(true);

while (elapsed < fadeDuration) {
elapsed += Time.unscaledDeltaTime;
float t = (fadeDuration > 0) ? elapsed / fadeDuration : 1f;
canvasGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, t);
yield ret null;
}

canvasGroup.alpha = targetAlpha;

if (!fadeIn) {
if (tooltipPanel != null) tooltipPanel.SetActive(false);
_isVisible = false;
}
}

bool IsTargetNullOrDestroyed(object target) {
if (target is UnityEngine.Object unityObject) {
ret unityObject == null;
}
ret System.Object.ReferenceEquals(target, null);
}

void SetupTooltipPanel() {
if (canvasGroup != null) {
canvasGroup.alpha = 0f;
canvasGroup.interactable = false;
canvasGroup.blocksRaycasts = false;
}
if (backgroundImage != null) backgroundImage.color = backgroundColor;
ApplyTextStyles();
}

void ApplyTextStyles() {
if (titleText != null) { titleText.color = titleColor; titleText.fontSize = titleFontSize; titleText.fontStyle = FontStyles.Bold; }
if (descriptionText != null) { descriptionText.color = descriptionColor; descriptionText.fontSize = descriptionFontSize; }
if (detailsText != null) { detailsText.color = detailsColor; detailsText.fontSize = detailsFontSize; }
}

bool ValidateReferences() {
if (tooltipPanel == null) { Debug.LogError("[UniversalTooltipManager] Tooltip Panel not assigned!"); ret false; }

if (canvasGroup == null) canvasGroup = tooltipPanel.GetComponent<CanvasGroup>() ?? tooltipPanel.AddComponent<CanvasGroup>();
if (layoutGroup == null) layoutGroup = tooltipPanel.GetComponent<VerticalLayoutGroup>();
if (backgroundImage == null) backgroundImage = tooltipPanel.GetComponent<Image>();
if (titleText == null) titleText = FindTextComponent("Title");
if (descriptionText == null) descriptionText = FindTextComponent("Description");
if (detailsText == null) detailsText = FindTextComponent("Details");

if (titleText == null) { Debug.LogError("[UniversalTooltipManager] Missing required title text component!"); ret false; }

ret true;
}

TextMeshProUGUI FindTextComponent(string nameContains) {
if (tooltipPanel == null) ret null;
foreach (var text in tooltipPanel.GetComponentsInChildren<TextMeshProUGUI>(true)) {
if (text.name.ToLower().Contains(nameContains.ToLower()))
ret text;
}
ret null;
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Utilities\ColorExtensions.cs

﻿using UnityEngine;

pub stat cls ColorExtensions {
pub stat Color WithAlpha(this Color c, float alpha) {
ret new Color(c.r, c.g, c.b, alpha);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Utilities\PrefabOrigin.cs

﻿// Assets/Scripts/Utility/PrefabOrigin.cs

pub cls PrefabOrigin : MonoBehaviour {
pub Transform originTransform;

void Awake() {
if (originTransform == null) {
Debug.LogError($"[PrefabOrigin] The 'Origin Transform' is not assigned on '{gameObject.name}'. The script cannot function.", this);
Destroy(this); // Destroy self if not configured
return;
}

if (!originTransform.IsChildOf(transform)) {
Debug.LogError($"[PrefabOrigin] The assigned 'Origin Transform' ('{originTransform.name}') is not a child of '{gameObject.name}'. The script cannot function.", this);
Destroy(this); // Destroy self if configuration is invalid
return;
}

Vector3 worldOffset = transform.TransformVector(originTransform.localPosition);

transform.position -= worldOffset;

Destroy(this);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\NightColorPostProcess.cs

﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

pub cls NightColorPostProcess : MonoBehaviour {
pub WeatherManager weatherManager;

pub Volume globalVolume;

pub Color dayColorFilter = Color.white;
pub Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);

pub float dayPostExposure = 0f;
pub float nightPostExposure = -0.5f;

pub float daySaturation = 0f;
pub float nightSaturation = -50f;

pub float dayFilmGrainIntensity = 0.1f;
pub float nightFilmGrainIntensity = 0.5f;

pub float dayVignetteIntensity = 0.2f;
pub float nightVignetteIntensity = 0.5f;

pub float dayVignetteSmoothness = 0.2f;
pub float nightVignetteSmoothness = 0.3f;

[SerializeField] float transitionSmoothingSpeed = 5f;

ColorAdjustments colorAdjustments;
FilmGrain filmGrain;
Vignette vignette;

float smoothedSunIntensity;

void Start() {
if (!weatherManager) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] WeatherManager not assigned!", this);
enabled = false; // Disable script if core references are missing
return;
}
if (!globalVolume) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume not assigned!", this);
enabled = false;
return;
}
if (globalVolume.profile == null) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume has no profile assigned!", this);
enabled = false;
return;
}

if (!globalVolume.profile.TryGet<ColorAdjustments>(out colorAdjustments)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] ColorAdjustments ovr not found in Volume profile.", this);
}
if (!globalVolume.profile.TryGet<FilmGrain>(out filmGrain)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] FilmGrain ovr not found in Volume profile.", this);
}
if (!globalVolume.profile.TryGet<Vignette>(out vignette)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] Vignette ovr not found in Volume profile.", this);
}

smoothedSunIntensity = weatherManager.sunIntensity;
}

void Update() {
if (colorAdjustments == null && filmGrain == null && vignette == null)
return; // Nothing to update if no overrides were found

if (weatherManager != null) {
smoothedSunIntensity = Mathf.Lerp(smoothedSunIntensity, weatherManager.sunIntensity, transitionSmoothingSpeed * Time.deltaTime);
}

float sun = Mathf.Clamp01(smoothedSunIntensity); // Use the smoothed value
float t = 1f - sun;  // t=0 at day, t=1 at night

if (colorAdjustments != null) {
colorAdjustments.colorFilter.value = Color.Lerp(dayColorFilter, nightColorFilter, t);
colorAdjustments.postExposure.value = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
colorAdjustments.saturation.value = Mathf.Lerp(daySaturation, nightSaturation, t);
}

if (filmGrain != null) {
filmGrain.intensity.value = Mathf.Lerp(dayFilmGrainIntensity, nightFilmGrainIntensity, t);
}

if (vignette != null) {
vignette.intensity.value = Mathf.Lerp(dayVignetteIntensity, nightVignetteIntensity, t);
vignette.smoothness.value = Mathf.Lerp(dayVignetteSmoothness, nightVignetteSmoothness, t);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\RuntimeCircleDrawer.cs

﻿using UnityEngine;

pub cls RuntimeCircleDrawer : MonoBehaviour {
pub int segments = 30; // Number of line segments to approximate the circle
pub float radius = 1.0f;
pub float lineWidth = 0.02f;
pub Color color = Color.yellow;
pub Material lineMaterial; // Assign the same material used for firefly lines, or a specific one

LineRenderer lineRenderer;
bool needsRedraw = true; // Flag to force redraw on first UpdateCircle call or when params change
float currentRadius = -1f; // Store current values to detect changes
Color currentColor = Color.clear;

void Awake() {
lineRenderer = GetComponent<LineRenderer>();
if (lineRenderer == null) { // Should not happen with RequireComponent
Debug.LogError($"[{gameObject.name}] RuntimeCircleDrawer: Missing required LineRenderer component!");
enabled = false; // Disable script if component missing
return;
}
ConfigureLineRendererDefaults();
lineRenderer.enabled = false; // Start hidden
}

void ConfigureLineRendererDefaults() {
lineRenderer.useWorldSpace = false; // Draw relative to this object's transform
lineRenderer.loop = true; // Connect the last point to the first
lineRenderer.startWidth = lineWidth;
lineRenderer.endWidth = lineWidth;

if (lineMaterial != null && lineRenderer.material == null) {
lineRenderer.material = lineMaterial;
}

SpriteRenderer parentSprite = GetComponentInParent<SpriteRenderer>();
if (parentSprite != null) {
lineRenderer.sortingLayerName = parentSprite.sortingLayerName;
lineRenderer.sortingOrder = parentSprite.sortingOrder + 1; // Draw slightly in front
} else {
lineRenderer.sortingLayerName = "Default";
lineRenderer.sortingOrder = 1;
}
}

pub void UpdateCircle(float newRadius, Color newColor) {
bool radiusChanged = !Mathf.Approximately(currentRadius, newRadius);
bool colorChanged = currentColor != newColor;

if (!needsRedraw && !radiusChanged && !colorChanged) {
if (!lineRenderer.enabled) lineRenderer.enabled = true;
return; // No change needed
}

currentRadius = newRadius;
radius = newRadius; // Update pub field for potential inspector viewing
currentColor = newColor;
color = newColor; // Update pub field

lineRenderer.startColor = currentColor;
lineRenderer.endColor = currentColor;

if (colorChanged && Debug.isDebugBuild) {
Debug.Log($"[RuntimeCircleDrawer] Updated color to: {newColor}", gameObject);
}

DrawCircle(); // Recalculate points
lineRenderer.enabled = true; // Ensure it's visible
needsRedraw = false; // Mark as drawn
}

pub void HideCircle() {
if (lineRenderer != null && lineRenderer.enabled) {
lineRenderer.enabled = false;
needsRedraw = true; // Needs redraw next time it's shown
}
}

void DrawCircle() {
if (lineRenderer == null || segments <= 2 || radius <= 0f) {
lineRenderer.positionCount = 0; // Clear points if invalid params
return;
};

if (lineRenderer.positionCount != segments + 1) {
lineRenderer.positionCount = segments + 1;
}

float angleStep = 360f / segments;
Vector3[] points = new Vector3[segments + 1];

for (int i = 0; i <= segments; i++) {
float currentAngle = Mathf.Deg2Rad * (i * angleStep);
float x = Mathf.Cos(currentAngle) * radius;
float y = Mathf.Sin(currentAngle) * radius;
points[i] = new Vector3(x, y, 0); // Z is 0 for local space relative to transform
}

lineRenderer.SetPositions(points);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\WaterReflection.cs

﻿using UnityEngine;
using UnityEngine.Tilemaps;
#if UNITY_EDITOR
using UnityEditor;
#endif

pub cls WaterReflection : MonoBehaviour {
pub cls OverrideSettings {
pub bool reflectionOpacity = false;
pub bool reflectionTint = false;
pub bool gradientFadeBaseMaterial = false;
pub bool sortingOrderOffset = false;
pub bool useWaterMasking = false;
pub bool waterTilemapTag = false;
pub bool showDebugInfo = false;
}
[SerializeField] OverrideSettings overrides;

[SerializeField] bool useParentAsReference = false; // This remains a local setting

[SerializeField] float yOffset = -1f; // This remains a local setting

[SerializeField] [Range(0f, 1f)] float localReflectionOpacity = 0.5f;

[SerializeField] Color localReflectionTint = Color.white;

[SerializeField] bool enableDistanceFade = true; // This remains local as it depends on material
[SerializeField] float fadeStartDistance = 0.0f; // Local
[SerializeField] float fadeEndDistance = 1.0f; // Local
[SerializeField] [Range(0f, 1f)] float minFadeAlpha = 0.0f; // Local
[SerializeField] Material localGradientFadeBaseMaterial;

[SerializeField] int localSortingOrderOffset = -1;

[SerializeField] bool localUseWaterMasking = true;
[SerializeField] string localWaterTilemapTag = "Water";

[SerializeField] bool localShowDebugInfo = false;

SpriteRenderer originalRenderer;
Animator originalAnimator;
GameObject reflectionObject;
SpriteRenderer reflectionRenderer;
Animator reflectionAnimator;
Material reflectionMaterialInstance; // Instanced material for this reflection

float _actualReflectionOpacity;
Color _actualReflectionTint;
Material _actualGradientFadeBaseMaterial;
int _actualSortingOrderOffset;
bool _actualUseWaterMasking;
string _actualWaterTilemapTag;
bool _actualShowDebugInfo;

Sprite lastSprite;
Color lastOriginalColor;
bool lastFlipX, lastFlipY;
bool lastEnabled;
Vector3 lastScale;
Vector3 lastPosition;
float lastParentY;

void Awake() {
_actualReflectionOpacity = localReflectionOpacity;
_actualReflectionTint = localReflectionTint;
_actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
_actualSortingOrderOffset = localSortingOrderOffset;
_actualUseWaterMasking = localUseWaterMasking;
_actualWaterTilemapTag = localWaterTilemapTag;
_actualShowDebugInfo = localShowDebugInfo;

originalRenderer = GetComponent<SpriteRenderer>();
originalAnimator = GetComponent<Animator>();

if (originalRenderer == null) {
if (_actualShowDebugInfo) Debug.LogError($"[WaterReflection] No SpriteRenderer found on {gameObject.name}! Component disabled.", this);
enabled = false;
return;
}

if (useParentAsReference && transform.parent == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] 'Use Parent As Reference' is true on {gameObject.name}, but it has no parent. Will use self as reference.", this);
useParentAsReference = false;
}

if (Application.isPlaying) {
if (enableDistanceFade && _actualGradientFadeBaseMaterial == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection Awake] '{gameObject.name}': 'Enable Distance Fade' is true, but no 'Gradient Fade Base Material' (local or global) is assigned/found. Distance fade will not use the custom shader.", this);
}
}

CreateReflectionObject();

if (_actualUseWaterMasking) {
SetupWaterMaskingInteraction();
}
}

void ResolveSettings() {
if (WaterReflectionManager.Instance != null) {
_actualReflectionOpacity = overrides.reflectionOpacity ? localReflectionOpacity : WaterReflectionManager.Instance.defaultReflectionOpacity;
_actualReflectionTint = overrides.reflectionTint ? localReflectionTint : WaterReflectionManager.Instance.defaultReflectionTint;
_actualGradientFadeBaseMaterial = overrides.gradientFadeBaseMaterial ? localGradientFadeBaseMaterial : WaterReflectionManager.Instance.defaultGradientFadeMaterial;
_actualSortingOrderOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : WaterReflectionManager.Instance.defaultSortingOrderOffset;
_actualUseWaterMasking = overrides.useWaterMasking ? localUseWaterMasking : WaterReflectionManager.Instance.defaultUseWaterMasking;
_actualWaterTilemapTag = overrides.waterTilemapTag && !string.IsNullOrEmpty(localWaterTilemapTag) ? localWaterTilemapTag : WaterReflectionManager.Instance.defaultWaterTilemapTag;
_actualShowDebugInfo = overrides.showDebugInfo ? localShowDebugInfo : WaterReflectionManager.Instance.globalShowDebugInfo;
}
else // Fallback if no manager in scene {
_actualReflectionOpacity = localReflectionOpacity;
_actualReflectionTint = localReflectionTint;
_actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
_actualSortingOrderOffset = localSortingOrderOffset;
_actualUseWaterMasking = localUseWaterMasking;
_actualWaterTilemapTag = localWaterTilemapTag;
_actualShowDebugInfo = localShowDebugInfo;
if (Application.isPlaying) Debug.LogWarning("[WaterReflection] WaterReflectionManager not found in scene. Using local settings for all reflections.", this);
}
}

void Start() {
ResolveSettings(); // Now resolve settings after all Awake() calls are completed
UpdateReflectionVisuals();
UpdateReflectionTransform();
CacheCurrentState();
}

void LateUpdate() {
if (originalRenderer == null || reflectionObject == null) {
if (reflectionObject != null) reflectionObject.SetActive(false);
return;
}
UpdateReflectionTransform();
if (HasVisualStateChanged()) {
UpdateReflectionVisuals();
CacheCurrentState();
}
}

void CreateReflectionObject() {
reflectionObject = new GameObject($"{gameObject.name}_Reflection");
reflectionObject.transform.SetParent(transform.parent, false);
reflectionObject.transform.SetSiblingIndex(transform.GetSiblingIndex() + 1);

reflectionRenderer = reflectionObject.AddComponent<SpriteRenderer>();
reflectionRenderer.sortingLayerName = originalRenderer.sortingLayerName;
reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + _actualSortingOrderOffset; // Use resolved
reflectionRenderer.drawMode = originalRenderer.drawMode;

if (enableDistanceFade && _actualGradientFadeBaseMaterial != null) // Use resolved {
reflectionMaterialInstance = new Material(_actualGradientFadeBaseMaterial);
reflectionRenderer.material = reflectionMaterialInstance;
if (_actualShowDebugInfo && Application.isPlaying) Debug.Log($"[{gameObject.name}] Instantiated gradient material for reflection using '{_actualGradientFadeBaseMaterial.name}'.", this);
}
else {
reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
if (enableDistanceFade && _actualGradientFadeBaseMaterial == null && _actualShowDebugInfo && Application.isPlaying) {
Debug.Log($"[{gameObject.name}] Using sharedMaterial for reflection as no gradientFadeBaseMaterial (local or global) was resolved during CreateReflectionObject.", this);
}
}

if (originalAnimator != null) {
reflectionAnimator = reflectionObject.AddComponent<Animator>();
reflectionAnimator.runtimeAnimatorController = originalAnimator.runtimeAnimatorController;
}
SortableEntity originalSortable = GetComponent<SortableEntity>();
if (originalSortable != null) {
reflectionObject.AddComponent<SortableEntity>();
}
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Created reflection for {gameObject.name}", this);
}

void UpdateReflectionTransform() {
if (reflectionObject == null || originalRenderer == null) return;
Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
Vector3 originalWorldPos = transform.position;
Vector3 reflectionWorldPos = originalWorldPos;
float referenceYForOffset = referenceTransform.position.y;
reflectionWorldPos.y = referenceYForOffset + yOffset - (originalWorldPos.y - referenceYForOffset);
reflectionObject.transform.position = reflectionWorldPos;
reflectionObject.transform.rotation = transform.rotation;
reflectionObject.transform.localScale = transform.localScale;
Vector3 currentLocalScale = reflectionObject.transform.localScale;
currentLocalScale.y *= -1;
reflectionObject.transform.localScale = currentLocalScale;
}

void UpdateReflectionVisuals() {
if (reflectionRenderer == null || originalRenderer == null) return;

reflectionRenderer.sprite = originalRenderer.sprite;
reflectionRenderer.flipX = originalRenderer.flipX;
reflectionRenderer.flipY = originalRenderer.flipY;

Color baseOriginalSpriteColor = originalRenderer.color;
Color finalReflectionTintedColor = baseOriginalSpriteColor * _actualReflectionTint; // Use resolved
float finalCombinedAlpha = baseOriginalSpriteColor.a * _actualReflectionOpacity; // Use resolved
reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);

if (enableDistanceFade && reflectionMaterialInstance != null) {
Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
float waterSurfaceY = referenceTransform.position.y;
reflectionMaterialInstance.SetFloat("_FadeStart", fadeStartDistance);
reflectionMaterialInstance.SetFloat("_FadeEnd", fadeEndDistance);
reflectionMaterialInstance.SetFloat("_MinAlpha", minFadeAlpha);
reflectionMaterialInstance.SetFloat("_OriginalY", waterSurfaceY);
Color materialBaseColor = _actualReflectionTint; // Use resolved
materialBaseColor.a = _actualReflectionOpacity * baseOriginalSpriteColor.a; // Use resolved
reflectionMaterialInstance.SetColor("_Color", materialBaseColor);
}
else if (!enableDistanceFade && reflectionMaterialInstance != null) {
reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
Destroy(reflectionMaterialInstance);
reflectionMaterialInstance = null;
}

reflectionRenderer.enabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;

if (reflectionAnimator != null && originalAnimator != null) {
reflectionAnimator.enabled = originalAnimator.enabled;
if (originalAnimator.runtimeAnimatorController != null && originalAnimator.parameterCount > 0) {
foreach (AnimatorControllerParameter param in originalAnimator.parameters) {
try {
switch (param.type) {
case AnimatorControllerParameterType.Bool:
reflectionAnimator.SetBool(param.name, originalAnimator.GetBool(param.name));
break;
case AnimatorControllerParameterType.Float:
reflectionAnimator.SetFloat(param.name, originalAnimator.GetFloat(param.name));
break;
case AnimatorControllerParameterType.Int:
reflectionAnimator.SetInteger(param.name, originalAnimator.GetInteger(param.name));
break;
}
} catch (System.Exception e) {
if(_actualShowDebugInfo) Debug.LogWarning($"Failed to sync animator param '{param.name}': {e.Message}", reflectionAnimator);
}
}
}
}
}

bool HasVisualStateChanged() {
if (originalRenderer == null) ret false;
bool parentYChanged = false;
if (useParentAsReference && transform.parent != null) {
parentYChanged = !Mathf.Approximately(lastParentY, transform.parent.position.y);
}
ret lastSprite != originalRenderer.sprite ||
!ColorsApproximatelyEqual(lastOriginalColor, originalRenderer.color) ||
lastFlipX != originalRenderer.flipX ||
lastFlipY != originalRenderer.flipY ||
lastEnabled != (originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy) ||
lastScale != transform.localScale ||
lastPosition != transform.position ||
parentYChanged;
}

void CacheCurrentState() {
if (originalRenderer == null) return;
lastSprite = originalRenderer.sprite;
lastOriginalColor = originalRenderer.color;
lastFlipX = originalRenderer.flipX;
lastFlipY = originalRenderer.flipY;
lastEnabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;
lastScale = transform.localScale;
lastPosition = transform.position;
if (useParentAsReference && transform.parent != null) {
lastParentY = transform.parent.position.y;
}
}

bool ColorsApproximatelyEqual(Color c1, Color c2, float tolerance = 0.001f) {
ret Mathf.Abs(c1.r - c2.r) < tolerance &&
Mathf.Abs(c1.g - c2.g) < tolerance &&
Mathf.Abs(c1.b - c2.b) < tolerance &&
Mathf.Abs(c1.a - c2.a) < tolerance;
}

void SetupWaterMaskingInteraction() {
if (!_actualUseWaterMasking || reflectionRenderer == null) return; // Use resolved
GameObject waterTilemapGO = FindWaterTilemapByTag(); // FindWaterTilemapByTag will use resolved tag
if (waterTilemapGO == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Water tilemap for masking not found on {gameObject.name} using tag '{_actualWaterTilemapTag}'. Masking disabled.", this);
return;
}
SpriteMask maskComponent = waterTilemapGO.GetComponent<SpriteMask>();
if (maskComponent == null) {
maskComponent = waterTilemapGO.AddComponent<SpriteMask>();
maskComponent.sprite = null;
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Added SpriteMask to water tilemap '{waterTilemapGO.name}' for object '{gameObject.name}'.", waterTilemapGO);
}
reflectionRenderer.maskInteraction = SpriteMaskInteraction.VisibleInsideMask;
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Reflection of '{gameObject.name}' will be masked by '{waterTilemapGO.name}'.", this);
}

GameObject FindWaterTilemapByTag() {
if (string.IsNullOrEmpty(_actualWaterTilemapTag)) ret FindWaterTilemapFallback();
GameObject taggedWater = GameObject.FindGameObjectWithTag(_actualWaterTilemapTag);
if (taggedWater != null && taggedWater.GetComponent<Tilemap>() != null) {
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Found water tilemap by tag '{_actualWaterTilemapTag}': {taggedWater.name} for {gameObject.name}", this);
ret taggedWater;
}
if (taggedWater != null && taggedWater.GetComponent<Tilemap>() == null && _actualShowDebugInfo) {
Debug.LogWarning($"[WaterReflection] GameObject '{taggedWater.name}' (tag '{_actualWaterTilemapTag}') has no Tilemap component!", this);
}
ret FindWaterTilemapFallback();
}

GameObject FindWaterTilemapFallback() {
if (TileInteractionManager.Instance != null) {
var mappings = TileInteractionManager.Instance.tileDefinitionMappings;
if (mappings != null) {
foreach (var mapping in mappings) {
if (mapping?.tileDef != null && mapping.tilemapModule != null && mapping.tileDef.isWaterTile) {
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null && renderTilemapTransform.GetComponent<Tilemap>() != null) {
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Auto-detected water tilemap via TIM: {renderTilemapTransform.name} for {gameObject.name}", this);
ret renderTilemapTransform.gameObject;
}
}
}
}
}
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Could not auto-detect water tilemap via TileInteractionManager for {gameObject.name}.", this);
ret null;
}

void OnDestroy() {
if (reflectionObject != null) {
if (Application.isPlaying) Destroy(reflectionObject);
else DestroyImmediate(reflectionObject);
}
if (reflectionMaterialInstance != null) {
if (Application.isPlaying) Destroy(reflectionMaterialInstance);
else DestroyImmediate(reflectionMaterialInstance);
}
}

void OnValidate() {
#if UNITY_EDITOR
EditorApplication.delayCall -= EditorUpdatePreview; // Remove previous requests to avoid stacking
EditorApplication.delayCall += EditorUpdatePreview; // Add a new request
#endif
}

#if UNITY_EDITOR
void EditorUpdatePreview() {
if (this == null || gameObject == null) // The object could be destroyed before the call {
return;
}

if (Application.isEditor && !Application.isPlaying) {
bool localMaterialNeeded = enableDistanceFade && (!overrides.gradientFadeBaseMaterial || localGradientFadeBaseMaterial == null);
bool globalMaterialMightBeUsed = enableDistanceFade && !overrides.gradientFadeBaseMaterial && localGradientFadeBaseMaterial == null;

if (localMaterialNeeded && !globalMaterialMightBeUsed) // Warn if local ovr is on but local material missing {
Debug.LogWarning($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true and 'Override Gradient Material' is true, but 'Local Gradient Fade Base Material' is not assigned. Assign local material or uncheck override.", this);
}
else if (globalMaterialMightBeUsed) // Inform that global will be used if local isn't set {
Debug.Log($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true. If 'Local Gradient Fade Base Material' remains unassigned and ovr is false, the global default from WaterReflectionManager will be used in Play mode.", this);
}

if (reflectionRenderer != null && originalRenderer != null) {
Color previewTint = overrides.reflectionTint ? localReflectionTint : Color.white; // Default to white if no manager
float previewOpacity = overrides.reflectionOpacity ? localReflectionOpacity : 0.5f;
int previewSortOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : -1;

reflectionRenderer.sprite = originalRenderer.sprite;
reflectionRenderer.flipX = originalRenderer.flipX;
reflectionRenderer.flipY = originalRenderer.flipY;
reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + previewSortOffset;
Color baseOriginalSpriteColor = originalRenderer.color;
Color finalReflectionTintedColor = baseOriginalSpriteColor * previewTint;
float finalCombinedAlpha = baseOriginalSpriteColor.a * previewOpacity;
reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);
UpdateReflectionTransform(); // Keep transform updated
}
}
}
#endif

pub void SetLocalReflectionOpacity(float opacity) // Example of changing a local-only value {
localReflectionOpacity = Mathf.Clamp01(opacity);
if (overrides.reflectionOpacity) // Only re-resolve and update if this local value is being used {
ResolveSettings();
if (Application.isPlaying && originalRenderer != null) UpdateReflectionVisuals();
}
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\WaterReflectionManager.cs

﻿using UnityEngine;

pub cls WaterReflectionManager : MonoBehaviour {
pub stat WaterReflectionManager Instance { get; set; }

pub Material defaultGradientFadeMaterial;

[Range(0f, 1f)] pub float defaultReflectionOpacity = 0.5f;

pub Color defaultReflectionTint = Color.white;

pub int defaultSortingOrderOffset = -1;

pub bool defaultUseWaterMasking = true;

pub string defaultWaterTilemapTag = "Water";

pub bool globalShowDebugInfo = false;

void Awake() {
if (Instance != null && Instance != this) {
Debug.LogWarning($"[WaterReflectionManager] Duplicate instance found on {gameObject.name}. Destroying self.", gameObject);
Destroy(gameObject);
return;
}
Instance = this;

if (defaultGradientFadeMaterial == null) {
Debug.LogWarning("[WaterReflectionManager] Default Gradient Fade Material is not assigned. Distance fade may not work correctly for reflections that don't have their own material specified.", this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlantGrowthModifierManager.cs

﻿using System.Collections.Generic;

pub cls PlantGrowthModifierManager : MonoBehaviour {
pub stat PlantGrowthModifierManager Instance { get; set; }

pub cls TileGrowthModifier {
pub TileDefinition tileDefinition;

pub float growthSpeedMultiplier = 1.0f;

pub float energyRechargeMultiplier = 1.0f;
}

pub float defaultGrowthSpeedMultiplier = 1.0f;

pub float defaultEnergyRechargeMultiplier = 1.0f;

pub float tileUpdateInterval = 1.0f;

pub List<TileGrowthModifier> tileModifiers = new List<TileGrowthModifier>();

[SerializeField] TileInteractionManager tileInteractionManager;

[SerializeField] bool showDebugMessages = true;
[SerializeField] bool showTileChangeMessages = true;

Dictionary<TileDefinition, TileGrowthModifier> modifierLookup = new Dictionary<TileDefinition, TileGrowthModifier>();

Dictionary<PlantGrowth, TileDefinition> plantTiles = new Dictionary<PlantGrowth, TileDefinition>();

float tileUpdateTimer = 0f;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

BuildModifierLookup();
}

void Start() {
if (tileInteractionManager == null) {
tileInteractionManager = TileInteractionManager.Instance;
if (tileInteractionManager == null && showDebugMessages) {
Debug.LogWarning("PlantGrowthModifierManager: TileInteractionManager not found!");
}
}

tileUpdateTimer = 0f;
}

void Update() {
tileUpdateTimer -= Time.deltaTime;

if (tileUpdateTimer <= 0f) {
UpdateAllPlantTiles();
tileUpdateTimer = tileUpdateInterval;
}
}

void UpdateAllPlantTiles() {
if (tileInteractionManager == null) {
return;
}

List<PlantGrowth> plantsToCheck = new List<PlantGrowth>(plantTiles.Keys);

foreach (PlantGrowth plant in plantsToCheck) {
if (plant == null) {
plantTiles.Remove(plant);
continue;
}

Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);

TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);

TileDefinition previousTileDef = plantTiles[plant];

if (currentTileDef != previousTileDef) {
plantTiles[plant] = currentTileDef;

if (showTileChangeMessages) {
string previousTileName = previousTileDef != null ? previousTileDef.displayName : "None";
string currentTileName = currentTileDef != null ? currentTileDef.displayName : "None";
Debug.Log($"Plant tile changed: {previousTileName} -> {currentTileName}");
}
}
}
}

void BuildModifierLookup() {
modifierLookup.Clear();
foreach (var modifier in tileModifiers) {
if (modifier.tileDefinition != null && !modifierLookup.ContainsKey(modifier.tileDefinition)) {
modifierLookup.Add(modifier.tileDefinition, modifier);
}
}

if (showDebugMessages) {
Debug.Log($"PlantGrowthModifierManager: Built lookup with {modifierLookup.Count} tile modifiers");
}
}

pub void RegisterPlantTile(PlantGrowth plant, TileDefinition tileDef) {
if (plant == null)
return;

plantTiles[plant] = tileDef;

if (showDebugMessages) {
string tileName = tileDef != null ? tileDef.displayName : "Unknown Tile";
Debug.Log($"Registered plant {plant.name} on tile {tileName}");
}
}

pub void UnregisterPlant(PlantGrowth plant) {
if (plant == null)
return;

if (plantTiles.ContainsKey(plant)) {
plantTiles.Remove(plant);
}
}

pub float GetGrowthSpeedMultiplier(PlantGrowth plant) {
if (plant == null)
ret defaultGrowthSpeedMultiplier;

if (!plantTiles.ContainsKey(plant)) {
RegisterNewPlant(plant);
}

TileDefinition tileDef = plantTiles[plant];
if (tileDef == null) {
ret defaultGrowthSpeedMultiplier;
}

if (modifierLookup.TryGetValue(tileDef, out TileGrowthModifier modifier)) {
ret modifier.growthSpeedMultiplier;
}

ret defaultGrowthSpeedMultiplier;
}

pub float GetEnergyRechargeMultiplier(PlantGrowth plant) {
if (plant == null)
ret defaultEnergyRechargeMultiplier;

if (!plantTiles.ContainsKey(plant)) {
RegisterNewPlant(plant);
}

TileDefinition tileDef = plantTiles[plant];
if (tileDef == null) {
ret defaultEnergyRechargeMultiplier;
}

if (modifierLookup.TryGetValue(tileDef, out TileGrowthModifier modifier)) {
ret modifier.energyRechargeMultiplier;
}

ret defaultEnergyRechargeMultiplier;
}

void RegisterNewPlant(PlantGrowth plant) {
if (plant == null || tileInteractionManager == null)
return;

Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);

plantTiles[plant] = currentTileDef;

if (showDebugMessages) {
string tileName = currentTileDef != null ? currentTileDef.displayName : "Unknown Tile";
Debug.Log($"Auto-registered plant {plant.name} on tile {tileName}");
}
}

pub void OnValidate() {
BuildModifierLookup();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlantPlacementManager.cs

﻿using System.Collections.Generic;
using System.Linq; // Added for LINQ

pub cls PlantPlacementManager : MonoBehaviour {
pub stat PlantPlacementManager Instance { get; set; }

[SerializeField] Transform plantParent;
[SerializeField] TileInteractionManager tileInteractionManager;
[SerializeField] PlantGrowthModifierManager growthModifierManager;
[SerializeField] NodeExecutor nodeExecutor;

[SerializeField] float spawnRadius = 0.25f;
[SerializeField] float spawnRadiusIncrement = 4f;

[SerializeField] List<TileDefinition> invalidPlantingTiles = new List<TileDefinition>();

[SerializeField] bool showDebugMessages = true;

HashSet<TileDefinition> invalidTilesSet = new HashSet<TileDefinition>();
Dictionary<Vector3Int, GameObject> plantsByGridPosition = new Dictionary<Vector3Int, GameObject>();

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;
RebuildInvalidTilesSet();
}

void Start() {
if (plantParent == null && EcosystemManager.Instance != null) plantParent = EcosystemManager.Instance.plantParent;
if (tileInteractionManager == null) tileInteractionManager = TileInteractionManager.Instance;
if (growthModifierManager == null) growthModifierManager = PlantGrowthModifierManager.Instance;
if (nodeExecutor == null) {
nodeExecutor = FindAnyObjectByType<NodeExecutor>();
if (nodeExecutor == null) Debug.LogError("[PlantPlacementManager] NodeExecutor instance not found!");
}
}

void RebuildInvalidTilesSet() {
invalidTilesSet.Clear();
foreach (var tile in invalidPlantingTiles) if (tile != null) invalidTilesSet.Add(tile);
if (showDebugMessages) Debug.Log($"PlantPlacementManager: Invalid tiles set with {invalidTilesSet.Count} entries");
}

void OnValidate() { RebuildInvalidTilesSet(); }

pub bool IsPositionOccupied(Vector3Int gridPosition) {
if (plantsByGridPosition.TryGetValue(gridPosition, out GameObject plant)) {
if (plant == null) { plantsByGridPosition.Remove(gridPosition); ret false; }
ret true;
}
ret false;
}

pub bool IsTileValidForPlanting(TileDefinition tileDef) {
if (tileDef == null) ret false;
ret !invalidTilesSet.Contains(tileDef);
}

pub void CleanupDestroyedPlants() {
List<Vector3Int> keysToRemove = plantsByGridPosition.Where(kvp => kvp.Value == null).Select(kvp => kvp.Key).ToList();
foreach (var key in keysToRemove) plantsByGridPosition.Remove(key);
if (showDebugMessages && keysToRemove.Count > 0) Debug.Log($"PPM: Removed {keysToRemove.Count} destroyed plant refs.");
}

pub bool TryPlantSeed(Vector3Int gridPosition, Vector3 worldPosition) {
CleanupDestroyedPlants();
if (IsPositionOccupied(gridPosition)) {
if (showDebugMessages) Debug.Log($"Cannot plant (from seed slot): Position {gridPosition} occupied.");
ret false;
}

TileDefinition tileDef = tileInteractionManager?.FindWhichTileDefinitionAt(gridPosition);
if (!IsTileValidForPlanting(tileDef)) {
if (showDebugMessages) Debug.Log($"Cannot plant (from seed slot): Tile {tileDef?.displayName ?? "Unknown"} invalid.");
ret false;
}

if (nodeExecutor == null) {
Debug.LogError("Cannot plant (from seed slot): NodeExecutor reference is missing in PlantPlacementManager.");
ret false;
}

Vector3 plantingPosition = GetRandomizedPlantingPosition(worldPosition);
GameObject plantObj = nodeExecutor.SpawnPlantFromSeedInSlot(plantingPosition, plantParent);

if (plantObj != null) {
plantsByGridPosition[gridPosition] = plantObj;
PlantGrowth plantGrowth = plantObj.GetComponent<PlantGrowth>();
if (growthModifierManager != null && plantGrowth != null) {
growthModifierManager.RegisterPlantTile(plantGrowth, tileDef);
if (showDebugMessages) Debug.Log($"Plant (from seed slot) registered with tile: {tileDef?.displayName ?? "Unknown"}");
}
ret true;
}
if (showDebugMessages) Debug.Log($"Failed to plant seed (from seed slot) at {gridPosition} (NodeExecutor returned null).");
ret false;
}

pub bool TryPlantSeedFromInventory(InventoryBarItem seedItem, Vector3Int      gridPosition, Vector3         worldPosition) {
if (seedItem == null || !seedItem.IsSeed())                     ret false;
if (IsPositionOccupied(gridPosition))                           ret false;

TileDefinition tileDef = tileInteractionManager?.FindWhichTileDefinitionAt(gridPosition);
if (!IsTileValidForPlanting(tileDef))                           ret false;
if (nodeExecutor == null)                                       ret false;

Vector3  spawnPos  = GetRandomizedPlantingPosition(worldPosition);
GameObject plantGO = nodeExecutor.SpawnPlantFromInventorySeed(
seedItem.NodeData, spawnPos, plantParent);

if (plantGO == null)                                            ret false;

plantsByGridPosition[gridPosition] = plantGO;

PlantGrowth pg = plantGO.GetComponent<PlantGrowth>();
if (pg != null && growthModifierManager != null)
growthModifierManager.RegisterPlantTile(pg, tileDef);

GardenerController g = FindAnyObjectByType<GardenerController>();
if (g != null) g.Plant();

ret true;
}

Vector3 GetRandomizedPlantingPosition(Vector3 centerPosition) {
if (spawnRadius < 0.01f) ret centerPosition;
float randomAngle = Random.Range(0f, 2f * Mathf.PI);
Vector2 direction = new Vector2(Mathf.Cos(randomAngle), Mathf.Sin(randomAngle));
float randomDistance = Random.Range(0.05f, spawnRadius);
float offsetX = direction.x * randomDistance;
float offsetY = direction.y * randomDistance;
if (spawnRadiusIncrement > 0.001f) {
offsetX = Mathf.Round(offsetX / spawnRadiusIncrement) * spawnRadiusIncrement;
offsetY = Mathf.Round(offsetY / spawnRadiusIncrement) * spawnRadiusIncrement;
}
ret centerPosition + new Vector3(offsetX, offsetY, 0f);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlayerTileInteractor.cs

﻿// Assets\Scripts\WorldInteraction\Placement\PlayerTileInteractor.cs

pub sealed cls PlayerTileInteractor : MonoBehaviour {
[SerializeField] InventoryBarController inventoryBar;
[SerializeField] TileInteractionManager tileInteractionManager;
[SerializeField] Transform playerTransform;
[SerializeField] bool showDebug = false;

bool pendingClick;

void Awake() {
if (playerTransform == null) playerTransform = transform;
}

void Start() {
FindSingletons();
}

void Update() {
if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat) return;
if (Input.GetMouseButtonDown(0)) pendingClick = true;
}

void LateUpdate() {
if (!pendingClick) return;
pendingClick = false;
HandleLeftClick();
}

void HandleLeftClick() {
if (!EnsureManagers()) return;

InventoryBarItem selected = inventoryBar.SelectedItem;
if (selected == null || !selected.IsValid()) {
if (showDebug) Debug.Log("[PlayerTileInteractor] Click handled, but no valid item selected in the bar.");
return;
}

Vector3 mouseW = Camera.main.ScreenToWorldPoint(Input.mousePosition);
mouseW.z = 0f;
Vector3Int cellPos = tileInteractionManager.WorldToCell(mouseW);
Vector3 cellCenter = tileInteractionManager.interactionGrid.GetCellCenterWorld(cellPos);

if (Vector2.Distance(playerTransform.position, cellCenter) > tileInteractionManager.hoverRadius) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Clicked on cell {cellPos}, but it's too far away.");
return;
}

if (PlayerActionManager.Instance == null) {
Debug.LogError("[PlayerTileInteractor] PlayerActionManager not found!");
return;
}

bool actionSuccess = false;

if (selected.Type == InventoryBarItem.ItemType.Tool) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Using tool '{selected.GetDisplayName()}' at cell {cellPos}.");
actionSuccess = PlayerActionManager.Instance.ExecutePlayerAction(
PlayerActionType.UseTool,
cellPos,
selected.ToolDefinition
);
}
else if (selected.Type == InventoryBarItem.ItemType.Node && selected.IsSeed()) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Planting seed '{selected.GetDisplayName()}' at cell {cellPos}.");
actionSuccess = PlayerActionManager.Instance.ExecutePlayerAction(
PlayerActionType.PlantSeed,
cellPos,
selected
);

if (actionSuccess) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Planted successfully. Removing seed from inventory.");
RemoveSeedFromInventory(selected);
inventoryBar.ShowBar(); // Refresh the bar
}
}
}

void RemoveSeedFromInventory(InventoryBarItem seed) {
InventoryGridController grid = InventoryGridController.Instance;
if (grid == null) return;

if (seed.ViewGameObject != null) {
for (int i = 0; i < grid.ActualCellCount; i++) {
NodeCell cell = grid.GetInventoryCellAtIndex(i);
if (cell != null && cell.GetItemView()?.gameObject == seed.ViewGameObject) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Removing seed '{seed.GetDisplayName()}' from inventory cell {i} by view reference.");
cell.RemoveNode();
return;
}
}
}

for (int i = 0; i < grid.ActualCellCount; i++) {
NodeCell cell = grid.GetInventoryCellAtIndex(i);
if (cell != null && cell.GetNodeData()?.nodeId == seed.NodeData.nodeId) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Removing seed '{seed.GetDisplayName()}' from inventory cell {i} by data ID fallback.");
cell.RemoveNode();
return;
}
}
}

bool EnsureManagers() {
if (tileInteractionManager == null || inventoryBar == null) FindSingletons();
ret tileInteractionManager != null && inventoryBar != null;
}

void FindSingletons() {
if (inventoryBar == null) inventoryBar = InventoryBarController.Instance ?? FindAnyObjectByType<InventoryBarController>(FindObjectsInactive.Include);
if (tileInteractionManager == null) tileInteractionManager = TileInteractionManager.Instance ?? FindAnyObjectByType<TileInteractionManager>(FindObjectsInactive.Include);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\GardenerController.cs

﻿// Assets\Scripts\WorldInteraction\Player\GardenerController.cs

using WegoSystem;

pub cls GardenerController : MonoBehaviour, ITickUpdateable {

pub bool flipSpriteWhenMovingLeft = true;
pub bool flipHorizontalDirection = true;

pub bool useAnimations = true;
pub string runningParameterName = "isRunning";
pub string plantingTriggerName = "plantTrigger"; // Changed from a bool parameter name

GridEntity gridEntity;
GridPosition currentTargetPosition;

SortableEntity sortableEntity;
SpriteRenderer spriteRenderer;
Animator animator;

void Awake() {
sortableEntity = GetComponent<SortableEntity>();
spriteRenderer = GetComponent<SpriteRenderer>();
animator = GetComponent<Animator>();
gridEntity = GetComponent<GridEntity>();

if (sortableEntity == null)
sortableEntity = gameObject.AddComponent<SortableEntity>();

if (spriteRenderer == null)
Debug.LogWarning("[GardenerController Awake] Main SpriteRenderer component not found.", gameObject);

if (animator == null && useAnimations)
Debug.LogWarning("[GardenerController Awake] Animator component not found but useAnimations is true.", gameObject);

if (gridEntity == null) {
Debug.Log("[GardenerController] No GridEntity found. Adding one.", gameObject);
gridEntity = gameObject.AddComponent<GridEntity>();
}
}

void Start() {

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
}

void Update() {
if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.Planning) {
HandleImmediateWegoMovement();
}

UpdateAnimations();
UpdateSpriteDirection();
}

void HandleImmediateWegoMovement() {
if (gridEntity == null) return;

GridPosition moveDir = GridPosition.Zero;

if (Input.GetKeyDown(KeyCode.W) || Input.GetKeyDown(KeyCode.UpArrow)) moveDir = GridPosition.Up;
else if (Input.GetKeyDown(KeyCode.S) || Input.GetKeyDown(KeyCode.DownArrow)) moveDir = GridPosition.Down;
else if (Input.GetKeyDown(KeyCode.A) || Input.GetKeyDown(KeyCode.LeftArrow)) moveDir = GridPosition.Left;
else if (Input.GetKeyDown(KeyCode.D) || Input.GetKeyDown(KeyCode.RightArrow)) moveDir = GridPosition.Right;

if (moveDir != GridPosition.Zero) {
GridPosition targetPos = gridEntity.Position + moveDir;

if (GridPositionManager.Instance != null && PlayerActionManager.Instance != null && TickManager.Instance != null &&
GridPositionManager.Instance.IsPositionValid(targetPos) &&
!GridPositionManager.Instance.IsPositionOccupied(targetPos)) {
int moveCost = PlayerActionManager.Instance.GetMovementTickCost(transform.position, this);

gridEntity.SetPosition(targetPos);
currentTargetPosition = targetPos;

TickManager.Instance.AdvanceMultipleTicks(moveCost);
Debug.Log($"[GardenerController] Moved to {targetPos}. Advanced game by {moveCost} tick(s).");
}
else {
Debug.Log($"[GardenerController] Move to {targetPos} is invalid or blocked.");
}
}
}

void UpdateAnimations() {
if (!useAnimations || animator == null) return;

bool isMoving = gridEntity != null && gridEntity.IsMoving;
animator.SetBool(runningParameterName, isMoving);
}

void UpdateSpriteDirection() {
if (spriteRenderer == null || !flipSpriteWhenMovingLeft) return;

Vector2 directionToCheck = Vector2.zero;
if (gridEntity != null && GridPositionManager.Instance != null) {
Vector3 worldTarget = GridPositionManager.Instance.GridToWorld(currentTargetPosition);
Vector3 currentWorld = transform.position;

if (Vector3.Distance(worldTarget, currentWorld) > 0.01f) {
directionToCheck = (worldTarget - currentWorld).normalized;
}
}

if (directionToCheck.x != 0) {
bool shouldFlip = (directionToCheck.x < 0);
if (flipHorizontalDirection) {
spriteRenderer.flipX = shouldFlip;
}
else {
Vector3 scale = transform.localScale;
scale.x = shouldFlip ? -Mathf.Abs(scale.x) : Mathf.Abs(scale.x);
transform.localScale = scale;
}
}
}

pub void Plant() {
if (useAnimations && animator != null) {
animator.SetTrigger(plantingTriggerName);
}
}

pub GridPosition GetCurrentGridPosition() {
ret gridEntity?.Position ?? GridPosition.Zero;
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\PlayerActionManager.cs

﻿// Assets\Scripts\WorldInteraction\Player\PlayerActionManager.cs

using WegoSystem;

pub enum PlayerActionType {
Move,
UseTool,
PlantSeed,
Harvest,
Water,
Interact
}

pub cls PlayerActionManager : MonoBehaviour {
pub stat PlayerActionManager Instance { get; set; }

[SerializeField] bool debugMode = true;
[SerializeField] int tickCostPerAction = 1;

pub event Action<PlayerActionType, bool> OnActionExecuted;
pub event Action<string> OnActionFailed;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void OnDestroy() {
if (Instance == this) Instance = null;
}

pub bool ExecutePlayerAction(PlayerActionType actionType, Vector3Int gridPosition, object actionData = null) {
if (debugMode) Debug.Log($"[PlayerActionManager] Executing {actionType} at {gridPosition}");

bool success = false;
int tickCost = tickCostPerAction;

switch (actionType) {
case PlayerActionType.UseTool:
success = ExecuteToolUse(gridPosition, actionData as ToolDefinition);
break;

case PlayerActionType.PlantSeed:
success = ExecutePlantSeed(gridPosition, actionData as InventoryBarItem);
tickCost = 2;
break;

case PlayerActionType.Water:
success = ExecuteWatering(gridPosition);
break;

case PlayerActionType.Harvest:
success = ExecuteHarvest(gridPosition);
break;

case PlayerActionType.Interact:
success = ExecuteInteraction(gridPosition, actionData);
break;
}

if (success) {
AdvanceGameTick(tickCost);
OnActionExecuted?.Invoke(actionType, true);
}
else {
OnActionFailed?.Invoke($"{actionType} failed");
}

ret success;
}

bool ValidateMovement(GridPosition from, GridPosition to) {
int distance = from.ManhattanDistance(to);
if (distance != 1) {
if (debugMode) Debug.Log($"[PlayerActionManager] Movement validation failed: distance {distance} != 1");
ret false;
}

if (!GridPositionManager.Instance.IsPositionValid(to)) {
if (debugMode) Debug.Log($"[PlayerActionManager] Movement validation failed: position {to} out of bounds");
ret false;
}

if (GridPositionManager.Instance.IsPositionOccupied(to)) {
if (debugMode) Debug.Log($"[PlayerActionManager] Movement validation failed: position {to} occupied");
ret false;
}

ret true;
}

bool ExecuteImmediateMove(GardenerController gardener, GridPosition to) {
var gridEntity = gardener.GetComponent<GridEntity>();
if (gridEntity == null) ret false;

gridEntity.SetPosition(to);
ret true;
}

pub int GetMovementTickCost(Vector3 worldPosition, Component movingEntity = null) {
int baseCost = tickCostPerAction;
int maxAdditionalCost = 0; // Find the highest penalty if zones overlap

Vector3 positionToCheck = worldPosition;
if (movingEntity != null) {
GridEntity gridEntity = movingEntity.GetComponent<GridEntity>();
if (gridEntity != null) {
positionToCheck = gridEntity.GroundWorldPosition;
}
}

SlowdownZone[] allZones = FindObjectsByType<SlowdownZone>(FindObjectsSortMode.None);

foreach (var zone in allZones) {
if (zone.IsPositionInZone(positionToCheck)) {
bool shouldAffect = false;
if (movingEntity == null) // If entity not specified, assume it affects by default {
shouldAffect = true;
}
else if (movingEntity is GardenerController && zone.AffectsPlayer) {
shouldAffect = true;
}
else if (movingEntity is AnimalController && zone.AffectsAnimals) {
shouldAffect = true;
}

if (shouldAffect) {
maxAdditionalCost = Mathf.Max(maxAdditionalCost, zone.GetAdditionalTickCost());
}
}
}

if (maxAdditionalCost > 0 && debugMode) {
string entityName = movingEntity != null ? movingEntity.gameObject.name : "Unknown Entity";
Debug.Log($"[PlayerActionManager] Movement for '{entityName}' from {positionToCheck} is in a slowdown zone. Additional cost: {maxAdditionalCost}. Total cost: {baseCost + maxAdditionalCost} ticks");
}

ret baseCost + maxAdditionalCost;
}

bool ExecuteToolUse(Vector3Int gridPosition, ToolDefinition tool) {
if (tool == null) ret false;

TileInteractionManager.Instance?.ApplyToolAction(tool);
ret true;
}

bool ExecutePlantSeed(Vector3Int gridPosition, InventoryBarItem seedItem) {
if (seedItem == null || !seedItem.IsSeed()) ret false;

ret PlantPlacementManager.Instance?.TryPlantSeedFromInventory(
seedItem, gridPosition, TileInteractionManager.Instance.interactionGrid.GetCellCenterWorld(gridPosition)
) ?? false;
}

bool ExecuteWatering(Vector3Int gridPosition) {
if (debugMode) Debug.Log($"[PlayerActionManager] Watering at {gridPosition} - NOT IMPLEMENTED");
ret false;
}

bool ExecuteHarvest(Vector3Int gridPosition) {
if (debugMode) Debug.Log($"[PlayerActionManager] Harvesting at {gridPosition} - NOT IMPLEMENTED");
ret false;
}

bool ExecuteInteraction(Vector3Int gridPosition, object interactionData) {
if (debugMode) Debug.Log($"[PlayerActionManager] Interaction at {gridPosition}");
ret true;
}

void AdvanceGameTick(int tickCount = 1) {
if (TickManager.Instance == null) {
Debug.LogError("[PlayerActionManager] TickManager not found!");
return;
}

if (debugMode) Debug.Log($"[PlayerActionManager] Advancing {tickCount} tick(s) after player action");

TickManager.Instance.AdvanceMultipleTicks(tickCount);
}

pub bool CanExecuteAction(PlayerActionType actionType, Vector3Int gridPosition, object actionData = null) {
switch (actionType) {
case PlayerActionType.Move:
ret false;

case PlayerActionType.UseTool:
ret actionData is ToolDefinition;

case PlayerActionType.PlantSeed:
var seedItem = actionData as InventoryBarItem;
ret seedItem != null && seedItem.IsSeed();

default:
ret true;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileDefinition.cs

﻿using UnityEngine;
using UnityEngine.Tilemaps;

pub cls TileDefinition : ScriptableObject {
pub string displayName;    // e.g. "Grass", "Dirt", "Wet Dirt"

pub Color tintColor = Color.white;

pub float revertAfterSeconds = 0f;

pub TileDefinition revertToTile;

pub bool keepBottomTile = false;

pub bool isWaterTile = false;

#if UNITY_EDITOR
pub void UpdateColor() {
var manager = UnityEngine.Object.FindAnyObjectByType<TileInteractionManager>();
if (manager == null) return;

foreach (var mapping in manager.tileDefinitionMappings) {
if (mapping.tileDef == this && mapping.tilemapModule != null) {
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
if (renderTilemap != null) {
renderTilemap.color = tintColor;
UnityEditor.EditorUtility.SetDirty(renderTilemap);
}
}
}
}
}
#endif
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionLibrary.cs

﻿using System.Collections.Generic;
using System; // Needed for [Serializable]

[Serializable] // Make it visible in the Inspector
pub cls ToolRefillRule {
pub ToolDefinition toolToRefill;

pub TileDefinition refillSourceTile;
}

pub cls TileInteractionLibrary : ScriptableObject {
pub List<TileInteractionRule> rules; // Existing transformation rules

[Header("Tool Refill Rules")] // <<< NEW HEADER
pub List<ToolRefillRule> refillRules; // <<< NEW LIST FOR REFILLS
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionRule.cs

﻿using System;

pub cls TileInteractionRule {
pub ToolDefinition tool;

pub TileDefinition fromTile;
pub TileDefinition toTile;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolDefinition.cs

﻿using UnityEngine;
using System.Text;

pub cls ToolDefinition : ScriptableObject, ITooltipDataProvider {

pub ToolType toolType;
pub string displayName;

pub Sprite icon;
pub Color iconTint = Color.white;

pub bool limitedUses = false;
pub int initialUses = 10;

pub bool autoAddToInventory = true;

pub string GetTooltipTitle() {
ret displayName ?? "Unknown Tool";
}

pub string GetTooltipDescription() {
ret $"Tool Type: {toolType}";
}

pub string GetTooltipDetails(object source = null) {
var sb = new StringBuilder();
sb.Append(limitedUses ? $"<b>Uses:</b> {initialUses}" : "<b>Uses:</b> Unlimited");
ret sb.ToString().TrimEnd();
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolSwitcher.cs

﻿using UnityEngine;

pub cls ToolSwitcher : MonoBehaviour {
pub ToolDefinition[] toolDefinitions;

int currentIndex = 0;

pub ToolDefinition CurrentTool { get; set; } = null;
pub int CurrentRemainingUses { get; set; } = -1; // <<< NEW: Track remaining uses (-1 for unlimited)

pub event Action<ToolDefinition> OnToolChanged;
pub event Action<int> OnUsesChanged; // <<< NEW EVENT for UI updates

void Start() {
InitializeToolState(true); // Initialize and fire events
}

void Update() {
if (toolDefinitions == null || toolDefinitions.Length == 0) return;

bool toolChanged = false;
int previousIndex = currentIndex;

if (Input.GetKeyDown(KeyCode.Q)) {
currentIndex--;
if (currentIndex < 0)
currentIndex = toolDefinitions.Length - 1;
toolChanged = true;
}
else if (Input.GetKeyDown(KeyCode.E)) {
currentIndex++;
if (currentIndex >= toolDefinitions.Length)
currentIndex = 0;
toolChanged = true;
}

if (toolChanged) {
if (currentIndex >= 0 && currentIndex < toolDefinitions.Length && toolDefinitions[currentIndex] != null) {
InitializeToolState(false); // Update state for the new tool and fire events
}
else {
Debug.LogError($"[ToolSwitcher Update] Attempted to switch to an invalid/NULL tool definition at index {currentIndex}. Reverting.");
currentIndex = previousIndex; // Revert to the last valid index
}
}
}

void InitializeToolState(bool isInitialSetup) {
ToolDefinition previousTool = CurrentTool; // Store previous tool for change check
int previousUses = CurrentRemainingUses; // Store previous uses

if (toolDefinitions == null || toolDefinitions.Length == 0 || currentIndex < 0 || currentIndex >= toolDefinitions.Length || toolDefinitions[currentIndex] == null) {
CurrentTool = null;
CurrentRemainingUses = -1; // No tool = unlimited uses conceptually
}
else {
CurrentTool = toolDefinitions[currentIndex];
if (CurrentTool.limitedUses) {
CurrentRemainingUses = CurrentTool.initialUses;
}
else {
CurrentRemainingUses = -1; // Mark as unlimited
}
}

LogToolChange("[ToolSwitcher InitializeToolState]"); // Log the state after update

bool toolActuallyChanged = previousTool != CurrentTool;
bool usesActuallyChanged = previousUses != CurrentRemainingUses;

if (isInitialSetup || toolActuallyChanged) {
Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnToolChanged for tool: {CurrentTool?.displayName ?? "NULL"}");
OnToolChanged?.Invoke(CurrentTool);
}
if (isInitialSetup || usesActuallyChanged || toolActuallyChanged) // Fire uses changed if tool changed too (to reset UI) {
Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnUsesChanged with value: {CurrentRemainingUses}");
OnUsesChanged?.Invoke(CurrentRemainingUses);
}
}

pub void SelectToolByDefinition(ToolDefinition toolDef) {
if (toolDef == null || toolDefinitions == null) return;

for (int i = 0; i < toolDefinitions.Length; i++) {
if (toolDefinitions[i] == toolDef) {
currentIndex = i;
InitializeToolState(false);
Debug.Log($"[ToolSwitcher] Externally selected tool: {toolDef.displayName} at index {i}");
return;
}
}

Debug.LogWarning($"[ToolSwitcher] Tool '{toolDef.displayName}' not found in definitions array");
}

pub void RefillCurrentTool() // <<< NEW METHOD {
if (CurrentTool == null) {
Debug.LogWarning("[ToolSwitcher RefillCurrentTool] Cannot refill: No tool selected.");
return;
}

if (!CurrentTool.limitedUses) {
Debug.LogWarning($"[ToolSwitcher RefillCurrentTool] Cannot refill tool '{CurrentTool.displayName}': It has unlimited uses.");
return;
}

if (CurrentRemainingUses == CurrentTool.initialUses) {
if(Debug.isDebugBuild) Debug.Log($"[ToolSwitcher RefillCurrentTool] Tool '{CurrentTool.displayName}' is already full ({CurrentRemainingUses} uses).");
return;
}

int previousUses = CurrentRemainingUses;
CurrentRemainingUses = CurrentTool.initialUses;

Debug.Log($"[ToolSwitcher RefillCurrentTool] Refilled tool '{CurrentTool.displayName}' to {CurrentRemainingUses} uses (was {previousUses}).");

OnUsesChanged?.Invoke(CurrentRemainingUses);
}

pub bool TryConsumeUse() {
if (CurrentTool == null) {
Debug.LogWarning("[ToolSwitcher TryConsumeUse] Cannot consume use: No tool selected.");
ret false; // Cannot use a non-existent tool
}

if (!CurrentTool.limitedUses || CurrentRemainingUses == -1) {
ret true;
}

if (CurrentRemainingUses > 0) {
CurrentRemainingUses--;
Debug.Log($"[ToolSwitcher TryConsumeUse] Consumed use for '{CurrentTool.displayName}'. Remaining: {CurrentRemainingUses}");
OnUsesChanged?.Invoke(CurrentRemainingUses); // Notify listeners
ret true;
}
else {
Debug.Log($"[ToolSwitcher TryConsumeUse] Tool '{CurrentTool.displayName}' is out of uses (0 remaining).");
ret false;
}
}

void LogToolChange(string prefix = "[ToolSwitcher]") {
string toolName = (CurrentTool != null && !string.IsNullOrEmpty(CurrentTool.displayName))
? CurrentTool.displayName
: "(none)";
string usesSuffix = "";
if (CurrentTool != null && CurrentTool.limitedUses && CurrentRemainingUses >= 0) {
usesSuffix = $" ({CurrentRemainingUses}/{CurrentTool.initialUses})";
}
else if (CurrentTool != null && !CurrentTool.limitedUses) {
}

Debug.Log($"{prefix} Switched tool to: {toolName}{usesSuffix} (Index: {currentIndex})");
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolType.cs

﻿pub enum ToolType {
None,
Hoe,
WateringCan,
SeedPouch // New tool type
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridEntity.cs

﻿// Assets/Scripts/Ticks/GridEntity.cs

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
pub cls GridEntity : MonoBehaviour {

GridPosition gridPosition;

Vector3 groundPointOffset = Vector3.zero;
Vector3 visualOffset = Vector3.zero;

float visualInterpolationSpeed = 5f;
AnimationCurve movementCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

GridPosition previousGridPosition;
Vector3 visualStartPosition;
Vector3 visualTargetPosition;
float movementProgress = 1f;
bool isMoving = false;

pub GridPosition Position {
get => gridPosition;
set // Keep setter to be controlled by SetPosition method {
if (gridPosition != value) {
previousGridPosition = gridPosition;
gridPosition = value;
OnGridPositionChanged();
}
}
}

pub GridPosition PreviousPosition => previousGridPosition;
pub bool IsMoving => isMoving;
pub float MovementProgress => movementProgress;

pub Vector3 GroundWorldPosition => transform.position + groundPointOffset;

pub event Action<GridPosition, GridPosition> OnPositionChanged;
pub event Action<GridPosition> OnMovementComplete;
pub event Action OnMovementStart;

prot virt void Start() {

visualStartPosition = transform.position;
visualTargetPosition = transform.position;
previousGridPosition = gridPosition;

GridPositionManager.Instance?.RegisterEntity(this);
}

prot virt void OnDestroy() {
GridPositionManager.Instance?.UnregisterEntity(this);
}

prot virt void Update() {
if (movementProgress < 1f) {
movementProgress += Time.deltaTime * visualInterpolationSpeed;
movementProgress = Mathf.Clamp01(movementProgress);

float curvedProgress = movementCurve.Evaluate(movementProgress);
transform.position = Vector3.Lerp(visualStartPosition, visualTargetPosition, curvedProgress);

if (movementProgress >= 1f) {
transform.position = visualTargetPosition;
isMoving = false;
OnMovementComplete?.Invoke(gridPosition);
}
}
}

#if UNITY_EDITOR
void OnDrawGizmosSelected() {
Vector3 groundWorldPosition = transform.position + groundPointOffset;
Gizmos.color = Color.green;
Gizmos.DrawLine(transform.position, groundWorldPosition);
Gizmos.DrawWireSphere(groundWorldPosition, 0.1f);
UnityEditor.Handles.Label(groundWorldPosition + Vector3.up * 0.2f, "Ground Point");

if (Application.isPlaying && GridPositionManager.Instance != null) {
Gizmos.color = Color.yellow;
Vector3 gridCenter = GridPositionManager.Instance.GetCellCenter(gridPosition);
Gizmos.DrawSphere(gridCenter, 0.08f);
}
}
#endif

prot virt void OnGridPositionChanged() {
visualStartPosition = transform.position;

Vector3 groundTargetPosition = GridPositionManager.Instance.GridToWorld(gridPosition);
visualTargetPosition = groundTargetPosition - groundPointOffset + visualOffset;

movementProgress = 0f;

if (!isMoving) {
isMoving = true;
OnMovementStart?.Invoke();
}

OnPositionChanged?.Invoke(previousGridPosition, gridPosition);
}

pub void SetPosition(GridPosition newPosition, bool instant = false) {
Position = newPosition; // This invokes OnGridPositionChanged which sets up the tween

if (instant) {
if (GridPositionManager.Instance == null) return;

Vector3 groundTargetPosition = GridPositionManager.Instance.GridToWorld(Position);
transform.position = groundTargetPosition - groundPointOffset + visualOffset;

visualStartPosition = transform.position;
visualTargetPosition = transform.position;
movementProgress = 1f;
isMoving = false;
}
}

pub void SnapToGrid() {
if (GridPositionManager.Instance == null) return;

Vector3 groundWorldPos = transform.position + groundPointOffset;
GridPosition currentGridPos = GridPositionManager.Instance.WorldToGrid(groundWorldPos);
SetPosition(currentGridPos, true);
}

pub void MoveInDirection(GridPosition direction) {
SetPosition(gridPosition + direction);
}

pub bool CanMoveTo(GridPosition targetPosition) {
ret GridPositionManager.Instance?.IsPositionValid(targetPosition) ?? false;
}

pub void CompleteMovement() {
if (isMoving) {
transform.position = visualTargetPosition;
movementProgress = 1f;
isMoving = false;
OnMovementComplete?.Invoke(gridPosition);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridPosition.cs

﻿// Assets/Scripts/Ticks/GridPosition.cs

namespace WegoSystem {
pub struct GridPosition : IEquatable<GridPosition> {
pub int x;
pub int y;

pub GridPosition(int x, int y) {
this.x = x;
this.y = y;
}

pub GridPosition(Vector3Int vector3Int) {
this.x = vector3Int.x;
this.y = vector3Int.y;
}

pub GridPosition(Vector2Int vector2Int) {
this.x = vector2Int.x;
this.y = vector2Int.y;
}

pub stat GridPosition operator +(GridPosition a, GridPosition b) {
ret new GridPosition(a.x + b.x, a.y + b.y);
}

pub stat GridPosition operator -(GridPosition a, GridPosition b) {
ret new GridPosition(a.x - b.x, a.y - b.y);
}

pub stat bool operator ==(GridPosition a, GridPosition b) {
ret a.x == b.x && a.y == b.y;
}

pub stat bool operator !=(GridPosition a, GridPosition b) {
ret !(a == b);
}

pub Vector3Int ToVector3Int() => new Vector3Int(x, y, 0);
pub Vector2Int ToVector2Int() => new Vector2Int(x, y);
pub Vector3 ToWorldPosition(float cellSize = 1f) => new Vector3(x * cellSize, y * cellSize, 0);

pub stat ro GridPosition Up = new GridPosition(0, 1);
pub stat ro GridPosition Down = new GridPosition(0, -1);
pub stat ro GridPosition Left = new GridPosition(-1, 0);
pub stat ro GridPosition Right = new GridPosition(1, 0);
pub stat ro GridPosition UpLeft = new GridPosition(-1, 1);
pub stat ro GridPosition UpRight = new GridPosition(1, 1);
pub stat ro GridPosition DownLeft = new GridPosition(-1, -1);
pub stat ro GridPosition DownRight = new GridPosition(1, -1);
pub stat ro GridPosition Zero = new GridPosition(0, 0);

pub int ManhattanDistance(GridPosition other) {
ret Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y);
}

pub int ChebyshevDistance(GridPosition other) {
ret Mathf.Max(Mathf.Abs(x - other.x), Mathf.Abs(y - other.y));
}

pub float EuclideanDistance(GridPosition other) {
int dx = x - other.x;
int dy = y - other.y;
ret Mathf.Sqrt(dx * dx + dy * dy);
}

pub GridPosition[] GetNeighbors(bool includeDiagonals = false) {
if (includeDiagonals) {
ret new GridPosition[] {
this + Up, this + Down, this + Left, this + Right,
this + UpLeft, this + UpRight, this + DownLeft, this + DownRight
};
}
else {
ret new GridPosition[] {
this + Up, this + Down, this + Left, this + Right
};
}
}

pub bool Equals(GridPosition other) {
ret x == other.x && y == other.y;
}

pub ovr bool Equals(object obj) {
ret obj is GridPosition other && Equals(other);
}

pub ovr int GetHashCode() {
ret HashCode.Combine(x, y);
}

pub ovr string ToString() {
ret $"({x}, {y})";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridPositionManager.cs

﻿using System;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
pub cls GridPositionManager : MonoBehaviour {
pub stat GridPositionManager Instance { get; set; }

[SerializeField] TileInteractionManager tileInteractionManager;

Grid _tilemapGrid;

Grid TilemapGrid {
get {
if (_tilemapGrid == null) {
SyncWithTileGrid(); // Attempt to sync again if it's null
}
ret _tilemapGrid;
}
}

[SerializeField] Vector2Int gridBounds = new Vector2Int(100, 100);

[SerializeField] bool showGridGizmos = true;
[SerializeField] Color gridColor = new Color(0.5f, 0.5f, 0.5f, 0.3f);
[SerializeField] int gizmoGridSize = 20;
[SerializeField] bool debugMode = false;

ro Dictionary<GridPosition, HashSet<GridEntity>> entitiesByPosition = new Dictionary<GridPosition, HashSet<GridEntity>>();
ro HashSet<GridEntity> allEntities = new HashSet<GridEntity>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

SyncWithTileGrid();
}

void OnDestroy() {
if (Instance == this) {
Instance = null;
}
}

pub void SyncWithTileGrid() {
if (tileInteractionManager != null && tileInteractionManager.interactionGrid != null) {
this._tilemapGrid = tileInteractionManager.interactionGrid;
if (debugMode) {
Debug.Log($"[GridPositionManager] Synced with assigned TileInteractionManager's grid: '{this._tilemapGrid.name}'.");
}
return; // Success
}

if (TileInteractionManager.Instance != null && TileInteractionManager.Instance.interactionGrid != null) {
this._tilemapGrid = TileInteractionManager.Instance.interactionGrid;
tileInteractionManager = TileInteractionManager.Instance;
if (debugMode) {
Debug.Log($"[GridPositionManager] Synced with singleton TileInteractionManager.Instance's grid: '{this._tilemapGrid.name}'.");
}
return; // Success
}

if (_tilemapGrid == null) {
Debug.LogError("[GridPositionManager] Could not find TileInteractionManager or its grid to sync with! Grid system may be misaligned. Please assign the TileInteractionManager in the Inspector.");
}
}

pub GridPosition WorldToGrid(Vector3 worldPosition) {
if (TilemapGrid == null) ret GridPosition.Zero;
Vector3Int cellPos = TilemapGrid.WorldToCell(worldPosition);
ret new GridPosition(cellPos);
}

pub Vector3 GridToWorld(GridPosition gridPosition) {
if (TilemapGrid == null) ret Vector3.zero;
ret TilemapGrid.GetCellCenterWorld(gridPosition.ToVector3Int());
}

pub Vector3 GetCellCenter(GridPosition gridPosition) {
ret GridToWorld(gridPosition);
}

pub bool IsPositionValid(GridPosition position) {
ret position.x >= -gridBounds.x / 2 && position.x < gridBounds.x / 2 &&
position.y >= -gridBounds.y / 2 && position.y < gridBounds.y / 2;
}

pub bool IsPositionOccupied(GridPosition position) {
ret entitiesByPosition.ContainsKey(position) && entitiesByPosition[position].Count > 0;
}

pub void RegisterEntity(GridEntity entity) {
if (entity == null || allEntities.Contains(entity)) return;

allEntities.Add(entity);
AddEntityToPosition(entity, entity.Position);

entity.OnPositionChanged += OnEntityPositionChanged;
}

pub void UnregisterEntity(GridEntity entity) {
if (entity == null || !allEntities.Contains(entity)) return;

allEntities.Remove(entity);
RemoveEntityFromPosition(entity, entity.Position);

entity.OnPositionChanged -= OnEntityPositionChanged;
}

void OnEntityPositionChanged(GridPosition oldPosition, GridPosition newPosition) {
var entity = allEntities.FirstOrDefault(e => e.Position == newPosition && e.PreviousPosition == oldPosition);
if (entity != null) {
RemoveEntityFromPosition(entity, oldPosition);
AddEntityToPosition(entity, newPosition);
}
}

void AddEntityToPosition(GridEntity entity, GridPosition position) {
if (!entitiesByPosition.ContainsKey(position)) {
entitiesByPosition[position] = new HashSet<GridEntity>();
}
entitiesByPosition[position].Add(entity);
}

void RemoveEntityFromPosition(GridEntity entity, GridPosition position) {
if (entitiesByPosition.ContainsKey(position)) {
entitiesByPosition[position].Remove(entity);
if (entitiesByPosition[position].Count == 0) {
entitiesByPosition.Remove(position);
}
}
}

pub HashSet<GridEntity> GetEntitiesAt(GridPosition position) {
ret entitiesByPosition.ContainsKey(position)
? new HashSet<GridEntity>(entitiesByPosition[position])
: new HashSet<GridEntity>();
}

pub List<GridEntity> GetEntitiesInRadius(GridPosition center, int radius, bool useCircle = true) {
var result = new List<GridEntity>();

if (useCircle) {
var tilesInRadius = GridRadiusUtility.GetTilesInCircle(center, radius);
foreach (var pos in tilesInRadius) {
if (entitiesByPosition.ContainsKey(pos)) {
result.AddRange(entitiesByPosition[pos]);
}
}
} else {
for (int x = -radius; x <= radius; x++) {
for (int y = -radius; y <= radius; y++) {
var checkPos = new GridPosition(center.x + x, center.y + y);
if (checkPos.ManhattanDistance(center) <= radius && entitiesByPosition.ContainsKey(checkPos)) {
result.AddRange(entitiesByPosition[checkPos]);
}
}
}
}

ret result;
}

pub bool IsPositionWithinRadius(GridPosition position, GridPosition center, int radius, bool useCircle = true) {
if (useCircle) {
ret GridRadiusUtility.IsWithinCircleRadius(position, center, radius);
} else {
ret position.ManhattanDistance(center) <= radius;
}
}

pub GridEntity GetNearestEntity(GridPosition position, System.Func<GridEntity, bool> predicate = null) {
GridEntity nearest = null;
float nearestDistance = float.MaxValue;

foreach (var entity in allEntities) {
if (predicate != null && !predicate(entity)) continue;

float distance = entity.Position.EuclideanDistance(position);
if (distance < nearestDistance) {
nearest = entity;
nearestDistance = distance;
}
}
ret nearest;
}

pub Grid GetTilemapGrid() {
ret TilemapGrid;
}

pub List<GridPosition> GetPath(GridPosition start, GridPosition end, bool allowDiagonal = false) {
var path = new List<GridPosition>();

if (!IsPositionValid(start) || !IsPositionValid(end)) {
ret path;
}

var openSet = new HashSet<GridPosition>();
var closedSet = new HashSet<GridPosition>();
var cameFrom = new Dictionary<GridPosition, GridPosition>();
var gScore = new Dictionary<GridPosition, float>();
var fScore = new Dictionary<GridPosition, float>();

openSet.Add(start);
gScore[start] = 0;
fScore[start] = HeuristicCost(start, end);

while (openSet.Count > 0) {
GridPosition current = GetLowestFScore(openSet, fScore);

if (current == end) {
while (cameFrom.ContainsKey(current)) {
path.Add(current);
current = cameFrom[current];
}
path.Reverse();
ret path;
}

openSet.Remove(current);
closedSet.Add(current);

foreach (var neighbor in current.GetNeighbors(allowDiagonal)) {
if (!IsPositionValid(neighbor) || IsPositionOccupied(neighbor) || closedSet.Contains(neighbor)) {
continue;
}

float tentativeGScore = gScore[current] + 1;

if (!openSet.Contains(neighbor)) {
openSet.Add(neighbor);
}
else if (gScore.ContainsKey(neighbor) && tentativeGScore >= gScore[neighbor]) {
continue;
}

cameFrom[neighbor] = current;
gScore[neighbor] = tentativeGScore;
fScore[neighbor] = gScore[neighbor] + HeuristicCost(neighbor, end);
}
}
ret path; // No path found
}

float HeuristicCost(GridPosition a, GridPosition b) {
ret a.ManhattanDistance(b);
}

GridPosition GetLowestFScore(HashSet<GridPosition> openSet, Dictionary<GridPosition, float> fScore) {
GridPosition lowest = openSet.First();
float lowestScore = fScore.ContainsKey(lowest) ? fScore[lowest] : float.MaxValue;

foreach (var pos in openSet) {
float score = fScore.ContainsKey(pos) ? fScore[pos] : float.MaxValue;
if (score < lowestScore) {
lowest = pos;
lowestScore = score;
}
}
ret lowest;
}

pub bool PathExists(GridPosition start, GridPosition end, bool allowDiagonal = false) {
var path = GetPath(start, end, allowDiagonal);
ret path.Count > 0;
}

pub void SnapEntityToGrid(GameObject entity) {
if (entity == null) return;

GridEntity gridEntity = entity.GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = entity.AddComponent<GridEntity>();
}

gridEntity.SnapToGrid();

if (debugMode) {
Debug.Log($"[GridPositionManager] Snapped {entity.name} to grid {gridEntity.Position}");
}
}

pub void SnapAllEntitiesToGrid<T>() where T : Component {
T[] entities = FindObjectsOfType<T>();
foreach (var entity in entities) {
SnapEntityToGrid(entity.gameObject);
}
Debug.Log($"[GridPositionManager] Snapped {entities.Length} entities of type {typeof(T).Name} to grid");
}

pub stat List<GridPosition> GetTilesInRadius(GridPosition center, int radius, bool useManhattan = true) {
var result = new List<GridPosition>();

for (int x = -radius; x <= radius; x++) {
for (int y = -radius; y <= radius; y++) {
var offset = new GridPosition(x, y);
var checkPos = center + offset;

int distance = useManhattan
? Mathf.Abs(x) + Mathf.Abs(y)
: Mathf.Max(Mathf.Abs(x), Mathf.Abs(y));

if (distance <= radius) {
result.Add(checkPos);
}
}
}

ret result;
}

void OnDrawGizmos() {
if (!showGridGizmos || TilemapGrid == null) return;

Gizmos.color = gridColor;

int halfWidth = gizmoGridSize / 2;
int halfHeight = gizmoGridSize / 2;

for (int x = -halfWidth; x <= halfWidth; x++) {
Vector3 start = GridToWorld(new GridPosition(x, -halfHeight));
Vector3 end = GridToWorld(new GridPosition(x, halfHeight));
Gizmos.DrawLine(start, end);
}

for (int y = -halfHeight; y <= halfHeight; y++) {
Vector3 start = GridToWorld(new GridPosition(-halfWidth, y));
Vector3 end = GridToWorld(new GridPosition(halfWidth, y));
Gizmos.DrawLine(start, end);
}

Gizmos.color = Color.red;
foreach (var kvp in entitiesByPosition) {
if (kvp.Value.Count > 0) {
Vector3 cellCenter = GridToWorld(kvp.Key);
Gizmos.DrawWireCube(cellCenter, Vector3.one * TilemapGrid.cellSize.x * 0.8f);
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridRadiusUtility.cs

﻿using UnityEngine;
using WegoSystem;

ns WegoSystem {
pub stat cls GridRadiusUtility {
pub stat List<GridPosition> GetTilesInCircle(GridPosition center, int radius, bool filled = true) {
var result = new List<GridPosition>();

if (radius <= 0) {
result.Add(center);
ret result;
}

for (int dx = -radius; dx <= radius; dx++) {
for (int dy = -radius; dy <= radius; dy++) {
float distance = Mathf.Sqrt(dx * dx + dy * dy);

if (filled) {
if (distance <= radius + 0.5f) {
result.Add(new GridPosition(center.x + dx, center.y + dy));
}
} else {
if (distance >= radius - 0.5f && distance <= radius + 0.5f) {
result.Add(new GridPosition(center.x + dx, center.y + dy));
}
}
}
}

ret result;
}

pub stat List<GridPosition> GetPerfectCircleTiles(GridPosition center, int radius) {
var result = new HashSet<GridPosition>();

if (radius == 0) {
result.Add(center);
ret new List<GridPosition>(result);
}

int x = 0;
int y = radius;
int d = 3 - 2 * radius;

while (x <= y) {
AddCirclePoints(result, center, x, y);

if (d < 0) {
d = d + 4 * x + 6;
} else {
d = d + 4 * (x - y) + 10;
y--;
}
x++;
}

var filledResult = new List<GridPosition>();
int minX = center.x - radius;
int maxX = center.x + radius;

for (int scanY = center.y - radius; scanY <= center.y + radius; scanY++) {
bool inside = false;
int startX = minX;

for (int scanX = minX; scanX <= maxX; scanX++) {
var pos = new GridPosition(scanX, scanY);
if (result.Contains(pos)) {
if (!inside) {
inside = true;
startX = scanX;
}
} else if (inside) {
for (int fillX = startX; fillX < scanX; fillX++) {
filledResult.Add(new GridPosition(fillX, scanY));
}
inside = false;
}
}

if (inside) {
for (int fillX = startX; fillX <= maxX; fillX++) {
var pos = new GridPosition(fillX, scanY);
if (result.Contains(pos) || fillX == maxX) {
for (int fill = startX; fill <= fillX; fill++) {
filledResult.Add(new GridPosition(fill, scanY));
}
break;
}
}
}
}

ret filledResult;
}

stat void AddCirclePoints(HashSet<GridPosition> result, GridPosition center, int x, int y) {
result.Add(new GridPosition(center.x + x, center.y + y));
result.Add(new GridPosition(center.x - x, center.y + y));
result.Add(new GridPosition(center.x + x, center.y - y));
result.Add(new GridPosition(center.x - x, center.y - y));
result.Add(new GridPosition(center.x + y, center.y + x));
result.Add(new GridPosition(center.x - y, center.y + x));
result.Add(new GridPosition(center.x + y, center.y - x));
result.Add(new GridPosition(center.x - y, center.y - x));
}

pub stat bool IsWithinCircleRadius(GridPosition position, GridPosition center, int radius) {
int dx = position.x - center.x;
int dy = position.y - center.y;
float distance = Mathf.Sqrt(dx * dx + dy * dy);
ret distance <= radius + 0.5f;
}

pub stat List<GridPosition> GetCircleOutline(GridPosition center, int radius) {
ret GetTilesInCircle(center, radius, false);
}

pub stat void DebugPrintRadius(GridPosition center, int radius) {
var tiles = GetTilesInCircle(center, radius);
var tileSet = new HashSet<GridPosition>(tiles);

Debug.Log($"Circle pattern for radius {radius}:");

for (int y = radius; y >= -radius; y--) {
string line = "";
for (int x = -radius; x <= radius; x++) {
var pos = new GridPosition(center.x + x, center.y + y);
if (pos.Equals(center)) {
line += "◉ "; // Center
} else if (tileSet.Contains(pos)) {
line += "● "; // Included tile
} else {
line += "· "; // Not included
}
}
Debug.Log(line);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickConfiguration.cs

﻿using UnityEngine;
using WegoSystem;

ns WegoSystem {
pub cls TickConfiguration : ScriptableObject {
[SerializeField] pub float ticksPerRealSecond = 2f;

pub int ticksPerDay = 100;
pub int dayPhaseTicks = 60;
pub int nightPhaseTicks = 40;
pub int transitionTicks = 10;

pub int ticksPerWave = 50;
pub bool wavesDependOnDayCycle = false;

pub int maxPlanningPhaseTicks = 0; // 0 = unlimited
pub int executionPhaseTicks = 5;

pub int animalHungerTickInterval = 3;
pub int animalThinkingInterval = 3;

pub int defaultPlantGrowthTicksPerStage = 5;
pub int defaultPlantMaturityCycleTicks = 20;

pub int movementTicksPerTile = 1;
pub int movementCooldownTicks = 0;

pub float GetRealSecondsPerTick() {
ret ticksPerRealSecond > 0 ? 1f / ticksPerRealSecond : 0.5f;
}

pub int ConvertSecondsToTicks(float seconds) {
ret Mathf.RoundToInt(seconds * ticksPerRealSecond);
}

pub float ConvertTicksToSeconds(int ticks) {
ret ticks / ticksPerRealSecond;
}

pub int GetDayProgress(int currentTick) {
ret currentTick % ticksPerDay;
}

pub float GetDayProgressNormalized(int currentTick) {
ret (float)(currentTick % ticksPerDay) / ticksPerDay;
}

pub void SetTicksPerSecond(float newRate) {
ticksPerRealSecond = Mathf.Max(0.1f, newRate);
}

void OnValidate() {
ticksPerRealSecond = Mathf.Max(0.1f, ticksPerRealSecond);
ticksPerDay = Mathf.Max(10, ticksPerDay);
ticksPerWave = Mathf.Max(10, ticksPerWave);
dayPhaseTicks = Mathf.Max(1, dayPhaseTicks);
nightPhaseTicks = Mathf.Max(1, nightPhaseTicks);
transitionTicks = Mathf.Max(1, transitionTicks);
executionPhaseTicks = Mathf.Max(1, executionPhaseTicks);
animalHungerTickInterval = Mathf.Max(1, animalHungerTickInterval);
animalThinkingInterval = Mathf.Max(1, animalThinkingInterval);
defaultPlantGrowthTicksPerStage = Mathf.Max(1, defaultPlantGrowthTicksPerStage);
defaultPlantMaturityCycleTicks = Mathf.Max(1, defaultPlantMaturityCycleTicks);
}

void ApplySlowPacedPreset() {
ticksPerRealSecond = 1f;
ticksPerDay = 200;
ticksPerWave = 100;
dayPhaseTicks = 120;
nightPhaseTicks = 80;
transitionTicks = 20;
executionPhaseTicks = 10;
defaultPlantGrowthTicksPerStage = 8;
animalHungerTickInterval = 5;
}

void ApplyFastPacedPreset() {
ticksPerRealSecond = 4f;
ticksPerDay = 50;
ticksPerWave = 25;
dayPhaseTicks = 30;
nightPhaseTicks = 20;
transitionTicks = 5;
executionPhaseTicks = 3;
defaultPlantGrowthTicksPerStage = 2;
animalHungerTickInterval = 2;
}

void ApplyBalancedPreset() {
ticksPerRealSecond = 2f;
ticksPerDay = 100;
ticksPerWave = 50;
dayPhaseTicks = 60;
nightPhaseTicks = 40;
transitionTicks = 10;
executionPhaseTicks = 5;
defaultPlantGrowthTicksPerStage = 5;
animalHungerTickInterval = 3;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickManager.cs

﻿// Assets\Scripts\Ticks\TickManager.cs

ns WegoSystem {
pub ifc ITickUpdateable {
void OnTickUpdate(int currentTick);
}

pub cls TickManager : MonoBehaviour {
pub stat TickManager Instance { get; set; }

[SerializeField] TickConfiguration tickConfig;
[SerializeField] bool debugMode = false;
[SerializeField] int currentTick = 0;

pub int CurrentTick => currentTick;
pub TickConfiguration Config => tickConfig;

pub event Action<int> OnTickAdvanced;
pub event Action<int> OnTickStarted;
pub event Action<int> OnTickCompleted;

ro List<ITickUpdateable> tickUpdateables = new List<ITickUpdateable>();
ro List<ITickUpdateable> pendingAdditions = new List<ITickUpdateable>();
ro List<ITickUpdateable> pendingRemovals = new List<ITickUpdateable>();
bool isProcessingTick = false;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}

Instance = this;

if (tickConfig == null) {
Debug.LogError("[TickManager] No TickConfiguration assigned! Creating default config.");
tickConfig = ScriptableObject.CreateInstance<TickConfiguration>();
}
}

void OnDestroy() {
if (Instance == this) {
Instance = null;
}
}

void Update() {
#if UNITY_EDITOR
if (debugMode && Input.GetKeyDown(KeyCode.T)) {
Debug.Log("[TickManager] Debug: Manual tick advance");
AdvanceTick();
}
#endif
}

pub void AdvanceTick() {
AdvanceMultipleTicks(1);
}

pub void AdvanceMultipleTicks(int tickCount) {
if (tickCount <= 0) return;

for (int i = 0; i < tickCount; i++) {
currentTick++;
ProcessTick();
}
}

void ProcessTick() {
if (debugMode) {
Debug.Log($"[TickManager] Processing tick {currentTick}");
}

OnTickStarted?.Invoke(currentTick);

ProcessPendingUpdates();

isProcessingTick = true;
foreach (var tickUpdateable in tickUpdateables) {
try {
tickUpdateable?.OnTickUpdate(currentTick);
}
catch (Exception e) {
Debug.LogError($"[TickManager] Error in tick update: {e.Message}");
}
}
isProcessingTick = false;

OnTickAdvanced?.Invoke(currentTick);
OnTickCompleted?.Invoke(currentTick);
}

pub void RegisterTickUpdateable(ITickUpdateable updateable) {
if (updateable == null) return;

if (isProcessingTick) {
if (!pendingAdditions.Contains(updateable))
pendingAdditions.Add(updateable);
}
else {
if (!tickUpdateables.Contains(updateable))
tickUpdateables.Add(updateable);
}
}

pub void UnregisterTickUpdateable(ITickUpdateable updateable) {
if (updateable == null) return;

if (isProcessingTick) {
if (!pendingRemovals.Contains(updateable))
pendingRemovals.Add(updateable);
}
else {
tickUpdateables.Remove(updateable);
}
}

void ProcessPendingUpdates() {
foreach (var updateable in pendingAdditions) {
if (!tickUpdateables.Contains(updateable))
tickUpdateables.Add(updateable);
}
pendingAdditions.Clear();

foreach (var updateable in pendingRemovals) {
tickUpdateables.Remove(updateable);
}
pendingRemovals.Clear();
}

pub void ResetTicks() {
currentTick = 0;
if (debugMode) Debug.Log("[TickManager] Reset tick counter");
}

pub int GetTicksSince(int pastTick) {
ret currentTick - pastTick;
}

pub bool HasTicksPassed(int lastTick, int tickInterval) {
ret GetTicksSince(lastTick) >= tickInterval;
}

pub int GetNextIntervalTick(int tickInterval) {
ret currentTick + tickInterval;
}

pub void DebugAdvanceTick() {
if (Application.isEditor || Debug.isDebugBuild) {
AdvanceTick();
}
}

pub int GetRegisteredUpdateableCount() {
ret tickUpdateables.Count;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionManager.cs

﻿using System.Collections;
using UnityEngine.Tilemaps;
using skner.DualGrid; // Assuming this is the correct ns for your DualGrid package
using TMPro;
using WegoSystem;
#if UNITY_EDITOR
using UnityEditor; // Correct placement for editor-specific using directive
#endif

pub cls TileInteractionManager : MonoBehaviour {
pub stat TileInteractionManager Instance { get; set; }
[System.Serializable] pub cls TileDefinitionMapping { pub TileDefinition tileDef; pub DualGridTilemapModule tilemapModule; }
[Header("Tile Definition Mappings")] pub List<TileDefinitionMapping> tileDefinitionMappings;
[Header("Interaction Library")] pub TileInteractionLibrary interactionLibrary; // Now contains both rule types
[Header("Grid & Scene References")] pub Grid interactionGrid; pub Camera mainCamera; pub Transform player; pub float hoverRadius = 3f; pub GameObject hoverHighlightObject;
[Header("Tilemap Rendering Settings")] pub int baseSortingOrder = 0;
[Header("Debug / UI")] pub bool debugLogs = false; pub TextMeshProUGUI hoveredTileText; pub TextMeshProUGUI currentToolText;
Dictionary<TileDefinition, DualGridTilemapModule> moduleByDefinition;
Dictionary<DualGridTilemapModule, TileDefinition> definitionByModule;
Vector3Int? currentlyHoveredCell = null;
TileDefinition hoveredTileDef = null;
struct TimedTileState { pub TileDefinition tileDef; pub float timeLeft; }
Dictionary<Vector3Int, TimedTileState> timedCells = new Dictionary<Vector3Int, TimedTileState>();

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;

moduleByDefinition = new Dictionary<TileDefinition, DualGridTilemapModule>();
definitionByModule = new Dictionary<DualGridTilemapModule, TileDefinition>();

SetupTilemaps(); // Setup tilemaps after dictionaries are created
}

void Start() {
if (moduleByDefinition == null || moduleByDefinition.Count == 0 || definitionByModule == null || definitionByModule.Count == 0) {
Debug.LogWarning("[TileInteractionManager Start] Dictionaries were empty or null, re-running SetupTilemaps.");
SetupTilemaps();
}

}

void SetupTilemaps() {
moduleByDefinition.Clear();
definitionByModule.Clear();

if (tileDefinitionMappings == null) {
Debug.LogError("[TileInteractionManager SetupTilemaps] Tile Definition Mappings list is null!", this);
return;
}

for (int i = 0; i < tileDefinitionMappings.Count; i++) {
var mapping = tileDefinitionMappings[i];
if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) {
Debug.LogWarning($"[TileInteractionManager SetupTilemaps] Skipping null or incomplete mapping at index {i}.");
continue;
}

if (!moduleByDefinition.ContainsKey(mapping.tileDef)) {
moduleByDefinition[mapping.tileDef] = mapping.tilemapModule;
definitionByModule[mapping.tilemapModule] = mapping.tileDef;

Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
if (renderer != null) {
renderer.sortingOrder = baseSortingOrder - i;
if (debugLogs) Debug.Log($"Setting sorting order for {mapping.tileDef.displayName} to {renderer.sortingOrder}");
}
else { Debug.LogWarning($"RenderTilemap for {mapping.tileDef.displayName} missing TilemapRenderer.", renderTilemapTransform); }

Tilemap tilemap = renderTilemapTransform.GetComponent<Tilemap>();
if (tilemap != null) {
tilemap.color = mapping.tileDef.tintColor;
if (debugLogs) Debug.Log($"Setting color for {mapping.tileDef.displayName} to {tilemap.color}");
}
else { Debug.LogWarning($"RenderTilemap for {mapping.tileDef.displayName} missing Tilemap component.", renderTilemapTransform); }
}
else { Debug.LogWarning($"Could not find 'RenderTilemap' child for module of {mapping.tileDef.displayName}.", mapping.tilemapModule.gameObject); }

if (debugLogs) Debug.Log($"[Mapping] Added: {mapping.tileDef.displayName} => {mapping.tilemapModule.gameObject.name}");
}
else {
Debug.LogWarning($"[TileInteractionManager SetupTilemaps] Duplicate TileDefinition '{mapping.tileDef.displayName}' found in mappings. Ignoring subsequent entries.", mapping.tileDef);
}
}
if (debugLogs) Debug.Log($"[TileInteractionManager SetupTilemaps] Setup complete. {moduleByDefinition.Count} definitions mapped.");
}

pub void UpdateSortingOrder() {
if (tileDefinitionMappings == null) return;
for (int i = 0; i < tileDefinitionMappings.Count; i++) {
var mapping = tileDefinitionMappings[i];
if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;

Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
if (renderer != null) {
renderer.sortingOrder = baseSortingOrder - i;
#if UNITY_EDITOR
if (!Application.isPlaying) EditorUtility.SetDirty(renderer);
#endif
if (debugLogs) Debug.Log($"Updated sorting order for {mapping.tileDef.displayName} to {renderer.sortingOrder}");
}
}
}
}

pub void UpdateAllColors() {
if (tileDefinitionMappings == null) return;
foreach (var mapping in tileDefinitionMappings) {
if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;

Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
if (renderTilemap != null) {
renderTilemap.color = mapping.tileDef.tintColor;
#if UNITY_EDITOR
if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
if (debugLogs) Debug.Log($"Updated color for {mapping.tileDef.displayName} to {renderTilemap.color}");
}
}
}
}

void Update() {
HandleTileHover();
UpdateReversion();
UpdateDebugUI(); // Update UI every frame
}

void UpdateReversion() {
if (timedCells.Count == 0) return;

List<Vector3Int> cellsToRevert = null; // Initialize null

foreach (var kvp in timedCells.ToList()) {
Vector3Int cellPos = kvp.Key;
TimedTileState state = kvp.Value;

if (state.tileDef == null) {
timedCells.Remove(cellPos); // Clean up invalid entry
continue;
}

state.timeLeft -= Time.deltaTime;

if (state.timeLeft <= 0f) {
if (cellsToRevert == null) cellsToRevert = new List<Vector3Int>();
cellsToRevert.Add(cellPos);
}
else {
timedCells[cellPos] = state; // Update time left
}
}

if (cellsToRevert != null) {
foreach (var cellPos in cellsToRevert) {
if (timedCells.TryGetValue(cellPos, out TimedTileState stateToRevert)) {
timedCells.Remove(cellPos); // Remove before acting

RemoveTile(stateToRevert.tileDef, cellPos);

if (stateToRevert.tileDef.revertToTile != null) {
if (debugLogs) Debug.Log($"Reverting tile at {cellPos} from {stateToRevert.tileDef.displayName} to {stateToRevert.tileDef.revertToTile.displayName}");
PlaceTile(stateToRevert.tileDef.revertToTile, cellPos);
} else {
if (debugLogs) Debug.Log($"Tile {stateToRevert.tileDef.displayName} at {cellPos} expired and removed (no revert target).");
}
}
}
}
}

void RegisterTimedTile(Vector3Int cellPos, TileDefinition tileDef) {
if (tileDef != null && tileDef.revertAfterSeconds > 0f) {
TimedTileState newState = new TimedTileState {
tileDef = tileDef,
timeLeft = tileDef.revertAfterSeconds
};
timedCells[cellPos] = newState;
if (debugLogs) Debug.Log($"Registered timed reversion for {tileDef.displayName} at {cellPos} ({tileDef.revertAfterSeconds}s).");
}
else if (timedCells.ContainsKey(cellPos)) {
timedCells.Remove(cellPos);
if (debugLogs) Debug.Log($"Cleared timed reversion for {cellPos} because revert time is not positive.");
}
}

pub void PlaceTile(TileDefinition tileDef, Vector3Int cellPos) {
if (tileDef == null) { Debug.LogWarning($"PlaceTile: Attempted to place a NULL TileDefinition at {cellPos}."); return; }

if (moduleByDefinition == null || !moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) || module == null) {
Debug.LogWarning($"PlaceTile: No mapped module found for TileDefinition '{tileDef.displayName}'. Cannot place tile.");
return;
}

if (!tileDef.keepBottomTile) {
TileDefinition existingDef = FindWhichTileDefinitionAt(cellPos);
if (existingDef != null && existingDef != tileDef) {
if (debugLogs) Debug.Log($"Placing '{tileDef.displayName}' (KeepBottom=false), removing existing '{existingDef.displayName}' at {cellPos}.");
RemoveTile(existingDef, cellPos);
}
} else {
if (debugLogs) Debug.Log($"Placing '{tileDef.displayName}' (KeepBottom=true) over whatever is at {cellPos}.");
}

if (module.DataTilemap != null) {
TileBase dataTile = ScriptableObject.CreateInstance<Tile>();
module.DataTilemap.SetTile(cellPos, dataTile);
} else { Debug.LogWarning($"Module for '{tileDef.displayName}' has no DataTilemap assigned.", module.gameObject); }

Transform renderTilemapTransform = module.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
if (renderTilemap != null) {
renderTilemap.color = tileDef.tintColor;
#if UNITY_EDITOR
if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
}
}

RegisterTimedTile(cellPos, tileDef);
}

pub void RemoveTile(TileDefinition tileDef, Vector3Int cellPos) {
if (tileDef == null) { Debug.LogWarning($"RemoveTile: Attempted to remove a NULL TileDefinition at {cellPos}."); return; }

if (moduleByDefinition == null || !moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) || module == null) {
if (debugLogs) Debug.LogWarning($"RemoveTile: No mapped module found for TileDefinition '{tileDef.displayName}'. Cannot remove tile.");
return;
}

if (module.DataTilemap != null) {
if (module.DataTilemap.HasTile(cellPos)) {
module.DataTilemap.SetTile(cellPos, null);
if (debugLogs) Debug.Log($"Removed '{tileDef.displayName}' from DataTilemap at {cellPos}.");
} else {
if (debugLogs) Debug.Log($"RemoveTile: Tile '{tileDef.displayName}' not found on DataTilemap at {cellPos}, skipping removal.");
}
} else { Debug.LogWarning($"Module for '{tileDef.displayName}' has no DataTilemap assigned.", module.gameObject); }

if (timedCells.TryGetValue(cellPos, out TimedTileState timedState) && timedState.tileDef == tileDef) {
timedCells.Remove(cellPos);
if (debugLogs) Debug.Log($"Cleared timed reversion for {tileDef.displayName} at {cellPos} during removal.");
}
}

pub TileDefinition FindWhichTileDefinitionAt(Vector3Int cellPos) {
if (definitionByModule == null || tileDefinitionMappings == null) {
Debug.LogError("[FindWhichTileDefinitionAt] Dictionaries not initialized!");
ret null;
}

TileDefinition foundDef = null;

foreach (var mapping in tileDefinitionMappings) {
if (mapping?.tileDef != null && mapping.tilemapModule?.DataTilemap != null && mapping.tileDef.keepBottomTile) {
if (mapping.tilemapModule.DataTilemap.HasTile(cellPos)) {
foundDef = mapping.tileDef;
break; // Found the top overlay tile
}
}
}

if (foundDef == null) {
foreach (var kvp in definitionByModule) {
DualGridTilemapModule module = kvp.Key;
TileDefinition def = kvp.Value;

if (module?.DataTilemap != null && def != null && !def.keepBottomTile) {
if (module.DataTilemap.HasTile(cellPos)) {
foundDef = def;
break; // Found the base tile
}
}
}
}

ret foundDef;
}

void HandleTileHover() {
if (mainCamera == null || player == null) return;

Vector3 mouseWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
mouseWorldPos.z = 0f;
Vector3Int cellPos = WorldToCell(mouseWorldPos);

GridEntity playerGrid = player.GetComponent<GridEntity>();
if (playerGrid == null) return;

int gridRadius = Mathf.CeilToInt(hoverRadius);

GridPosition playerGridPos = playerGrid.Position;
GridPosition hoveredGridPos = new GridPosition(cellPos.x, cellPos.y);

bool withinRadius = GridRadiusUtility.IsWithinCircleRadius(hoveredGridPos, playerGridPos, gridRadius);

TileDefinition foundTile = FindWhichTileDefinitionAt(cellPos);

if (withinRadius) {
currentlyHoveredCell = cellPos;
hoveredTileDef = foundTile;

if (hoverHighlightObject != null) {
hoverHighlightObject.SetActive(true);
hoverHighlightObject.transform.position = CellCenterWorld(cellPos);
}

if (GridDebugVisualizer.Instance != null && Debug.isDebugBuild) {
GridDebugVisualizer.Instance.VisualizeToolUseRadius(playerGridPos, gridRadius, 0.1f);
}
}
else {
currentlyHoveredCell = null;
hoveredTileDef = null;
if (hoverHighlightObject != null) {
hoverHighlightObject.SetActive(false);
}
}
}

void UpdateDebugUI() {
if (hoveredTileText != null) {
string tileName = hoveredTileDef != null ? hoveredTileDef.displayName : "None";
hoveredTileText.text = $"Hover: {tileName}";
}

if (currentToolText != null) {
if (InventoryBarController.Instance != null && InventoryBarController.Instance.SelectedItem != null) {
var selectedItem = InventoryBarController.Instance.SelectedItem;
if (selectedItem.Type == InventoryBarItem.ItemType.Tool) {
currentToolText.text = $"Tool: {selectedItem.GetDisplayName()}";
}
else if (selectedItem.Type == InventoryBarItem.ItemType.Node && selectedItem.IsSeed()) {
currentToolText.text = $"Seed: {selectedItem.GetDisplayName()}";
}
else {
currentToolText.text = $"Selected: {selectedItem.GetDisplayName()}";
}
}
else {
currentToolText.text = "Nothing Selected";
}
}
}

pub Vector3Int WorldToCell(Vector3 worldPos) {
if (interactionGrid != null) ret interactionGrid.WorldToCell(worldPos);

if (tileDefinitionMappings != null && tileDefinitionMappings.Count > 0) {
foreach(var mapping in tileDefinitionMappings) {
if (mapping?.tilemapModule?.DataTilemap?.layoutGrid != null) {
ret mapping.tilemapModule.DataTilemap.layoutGrid.WorldToCell(worldPos);
}
}
}

Debug.LogWarning("[WorldToCell] No valid interactionGrid or mapped Tilemap found to determine cell position.");
ret Vector3Int.zero;
}

Vector3 CellCenterWorld(Vector3Int cellPos) {
if (interactionGrid != null) ret interactionGrid.GetCellCenterWorld(cellPos);

if (tileDefinitionMappings != null && tileDefinitionMappings.Count > 0) {
foreach(var mapping in tileDefinitionMappings) {
if (mapping?.tilemapModule?.DataTilemap?.layoutGrid != null) {
ret mapping.tilemapModule.DataTilemap.layoutGrid.GetCellCenterWorld(cellPos);
}
}
}

Debug.LogWarning("[CellCenterWorld] No valid interactionGrid or mapped Tilemap found to determine cell center.");
ret Vector3.zero; // Or grid.CellToWorld(cellPos) + grid.cellSize * 0.5f if grid guaranteed?
}

void HandleSeedPlanting(Vector3Int cellPosition) {
PlantPlacementManager plantManager = PlantPlacementManager.Instance;
if (plantManager == null) { Debug.LogError("Cannot plant: PlantPlacementManager not found!"); return; }

TileDefinition tileDef = FindWhichTileDefinitionAt(cellPosition);
if (!plantManager.IsTileValidForPlanting(tileDef)) {
if (debugLogs) Debug.Log($"Cannot plant on {tileDef?.displayName ?? "Unknown"} - invalid tile.");
return;
}

GardenerController gardener = player?.GetComponent<GardenerController>();
if (gardener == null) { Debug.LogError("Cannot plant: GardenerController not found on player!"); return; }

gardener.Plant(); // Trigger one-shot animation

Vector3 worldPosition = CellCenterWorld(cellPosition); // Plant near cell center

bool planted = plantManager.TryPlantSeed(cellPosition, worldPosition);
if (debugLogs) Debug.Log(planted ? $"Planted seed successfully at {cellPosition}" : $"Failed to plant seed at {cellPosition}");
}

pub void ApplyToolAction(ToolDefinition toolDef) {
if (toolDef == null) { Debug.LogWarning("ApplyToolAction called with a NULL toolDef."); return; }
if (!currentlyHoveredCell.HasValue) return;
if (hoveredTileDef == null) { if (debugLogs) Debug.Log("ApplyToolAction: No recognized tile at hovered cell."); return; }

float distance = Vector2.Distance(player.position, CellCenterWorld(currentlyHoveredCell.Value));
if (distance > hoverRadius) { if (debugLogs) Debug.Log($"ApplyToolAction: Cell too far ({distance:F2} > {hoverRadius})."); return; }

if (debugLogs) Debug.Log($"[ApplyToolAction] Using Tool='{toolDef.toolType}', On Tile='{hoveredTileDef.displayName}', At Cell={currentlyHoveredCell.Value}");

bool wasRefillAction = false;
if (interactionLibrary != null && interactionLibrary.refillRules != null) {
foreach (var refillRule in interactionLibrary.refillRules) {
if (refillRule != null && refillRule.toolToRefill == toolDef && refillRule.refillSourceTile == hoveredTileDef) {
if (debugLogs) Debug.Log($"Refill rule matched: Tool '{toolDef.displayName}' on Tile '{hoveredTileDef.displayName}'.");

Debug.Log($"[TileInteractionManager] Tool refill not implemented for inventory-based tools yet.");
wasRefillAction = true;
break;
}
}
}

if (wasRefillAction) return;

if (interactionLibrary == null || interactionLibrary.rules == null) { Debug.LogWarning("Interaction Library or its standard rules list is null!"); return; }
TileInteractionRule rule = interactionLibrary.rules.FirstOrDefault(r => r != null && r.tool == toolDef && r.fromTile == hoveredTileDef);

if (rule == null) {
if (debugLogs) Debug.Log($"No standard interaction rule found for tool '{toolDef.toolType}' on tile '{hoveredTileDef.displayName}'.");
return;
}

if (rule.toTile != null) {
if (debugLogs) Debug.Log($"Applying standard rule: '{hoveredTileDef.displayName}' -> '{rule.toTile.displayName}'");
if (!rule.toTile.keepBottomTile) {
RemoveTile(hoveredTileDef, currentlyHoveredCell.Value);
}
PlaceTile(rule.toTile, currentlyHoveredCell.Value);
}
else {
if (debugLogs) Debug.Log($"Applying standard rule: Remove '{hoveredTileDef.displayName}'");
RemoveTile(hoveredTileDef, currentlyHoveredCell.Value);
}
}
}
