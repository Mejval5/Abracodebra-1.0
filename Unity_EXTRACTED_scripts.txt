This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-06-05 23:29:41
================================================================================

DIRECTORY STRUCTURE
--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantOutline.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.InventoryBar.prefab
│   │       ├── NodeView.SeedSlot.prefab
│   │       ├── NodeView.ToolView.prefab
│   │       ├── NodeView.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           ├── DualGridRuleTile_Grass.asset
│           └── DualGridRuleTile_Water.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_PoopFertilizer.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       ├── Wave_001.asset
│       └── Wave_002.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── LeafData.cs
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.Cell.cs
│   │   │   ├── PlantGrowth.Growth.cs
│   │   │   ├── PlantGrowth.NodeExecution.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   ├── RunManager.cs
│   │   ├── SortableEntity.cs
│   │   └── UIManager.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── SlowdownZone.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── InventoryBarController.cs
│   │       ├── InventoryBarItem.cs
│   │       ├── InventoryGridController.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManagement.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       ├── ToolType.cs
│   │       └── ToolView.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── OutlinePartController.cs
│       ├── PixelPerfectSetup.cs
│       ├── PlantOutlineController.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       ├── ShadowPartController.cs
│       ├── WaterReflection.cs
│       └── WaterReflectionManager.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Custom_WaterReflectionGradient.mat
│   ├── Sprite-Lit-Advanced_Overlay_Base.mat
│   ├── Sprite-Lit-Default_OverlayAdvanced.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   ├── SpriteEmissiveUnlit.shader
│   ├── WaterReflection.shader
│   └── WaterReflectionSimple.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionAutoAdder.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionAutoAdder : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets,
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string folderPath = Path.GetDirectoryName(assetPath);
                string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
                if (libraryFiles.Length > 0)
                {
                    NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
                    if (library != null && !library.definitions.Contains(nodeDef))
                    {
                        library.definitions.Add(nodeDef);
                        EditorUtility.SetDirty(library);
                        AssetDatabase.SaveAssets();
                    }
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionCreator.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;

public static class NodeDefinitionCreator
{
    private const string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

    [MenuItem(MenuPath, false, 50)]
    public static void CreateNodeDefinition()
    {
        // Figure out which folder the user is in, or use Assets/
        string folder = GetSelectedPathOrFallback();

        // Determine the next numeric index for "Node_XXX_"
        int nextNumber = GetNextNodeNumber(folder);

        // e.g., "Node_007_"
        string newName = $"Node_{nextNumber:D3}_";
        string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

        // Create the NodeDefinition
        NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
        AssetDatabase.CreateAsset(nodeDef, newPath);
        
        // Save and refresh, but DO NOT select or focus the ProjectWindow.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        Debug.Log($"Created NodeDefinition at: {newPath}");
        // Notice we don't call Selection.activeObject = nodeDef
        // or EditorUtility.FocusProjectWindow()
        // or ProjectWindowUtil.ShowCreatedAsset(nodeDef)
        // thus we avoid changing the user's folder.
    }

    // (Optional) Validate the menu item so it’s disabled if the game is running
    [MenuItem(MenuPath, true)]
    private static bool ValidateCreateNodeDefinition()
    {
        return !Application.isPlaying;
    }

    private static string GetSelectedPathOrFallback()
    {
        // Attempt to get the folder the user has selected in the Project window
        string path = "Assets";
        foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets))
        {
            path = AssetDatabase.GetAssetPath(obj);
            if (!string.IsNullOrEmpty(path))
            {
                // If it's a file, get its parent folder
                if (File.Exists(path))
                {
                    path = Path.GetDirectoryName(path);
                }
                break;
            }
        }
        return path;
    }

    private static int GetNextNodeNumber(string folderPath)
    {
        int nextNumber = 1;
        // Look for existing Node_XXX_ files
        string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
        foreach (var file in files)
        {
            string fName = Path.GetFileNameWithoutExtension(file);
            if (fName.StartsWith("Node_") && fName.Length >= 8)
            {
                // extract the 3-digit number from Node_000_
                string numberPart = fName.Substring(5, 3);
                if (int.TryParse(numberPart, out int num) && num >= nextNumber)
                {
                    nextNumber = num + 1;
                }
            }
        }
        return nextNumber;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(NodeDefinition))]
public class NodeDefinitionEditor : Editor
{
    // Serialized properties for all the fields in NodeDefinition
    SerializedProperty displayName;
    SerializedProperty description;
    SerializedProperty thumbnail;
    SerializedProperty thumbnailTintColor;
    SerializedProperty backgroundColor;
    SerializedProperty nodeViewPrefab;
    SerializedProperty effects;

    private void OnEnable()
    {
        displayName = serializedObject.FindProperty("displayName");
        description = serializedObject.FindProperty("description");
        thumbnail = serializedObject.FindProperty("thumbnail");
        thumbnailTintColor = serializedObject.FindProperty("thumbnailTintColor");
        backgroundColor = serializedObject.FindProperty("backgroundColor");
        nodeViewPrefab = serializedObject.FindProperty("nodeViewPrefab");
        effects = serializedObject.FindProperty("effects");
    }

    public override void OnInspectorGUI()
    {
        serializedObject.Update();

        // "Display" section
        EditorGUILayout.LabelField("Display", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(displayName);
        EditorGUILayout.PropertyField(description);
        EditorGUILayout.PropertyField(thumbnail);
        EditorGUILayout.PropertyField(thumbnailTintColor);
        EditorGUILayout.PropertyField(backgroundColor);

        EditorGUILayout.Space();

        // "Prefab & Effects" section
        EditorGUILayout.LabelField("Prefab & Effects", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(nodeViewPrefab);

        // Draw the effects field with a minimum height
        EditorGUILayout.PropertyField(effects, new GUIContent("Effects"), true, GUILayout.MinHeight(1300f));

        serializedObject.ApplyModifiedProperties();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionLibraryEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;

[CustomEditor(typeof(NodeDefinitionLibrary))]
public class NodeDefinitionLibraryEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("UPDATE"))
        {
            UpdateLibrary();
        }
    }

    private void UpdateLibrary()
    {
        NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

        // Get the folder of the current library asset.
        string libraryPath = AssetDatabase.GetAssetPath(library);
        string folderPath = Path.GetDirectoryName(libraryPath);

        // Find all .asset files in the folder.
        string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

        // Load NodeDefinition assets from that folder.
        List<NodeDefinition> defs = new List<NodeDefinition>();
        foreach (string file in assetFiles)
        {
            // Ignore the library asset itself.
            if (file == libraryPath)
                continue;

            NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
            if (def != null)
                defs.Add(def);
        }

        // Sort definitions by the numeric portion in the file name (assumes "Node_XXX_...").
        defs = defs.OrderBy(d => {
            string name = d.name;
            if (name.StartsWith("Node_") && name.Length >= 8)
            {
                string numStr = name.Substring(5, 3);
                if (int.TryParse(numStr, out int num))
                    return num;
            }
            return int.MaxValue; // if no number is found, sort last.
        }).ToList();

        library.definitions = defs;
        EditorUtility.SetDirty(library);
        AssetDatabase.SaveAssets();
        Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeDefinitionPostprocessor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class NodeDefinitionPostprocessor : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, 
        string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
            if (nodeDef != null)
            {
                string fileName = Path.GetFileNameWithoutExtension(assetPath);
                // Check if file name already starts with "Node_"
                if (!fileName.StartsWith("Node_"))
                {
                    string folderPath = Path.GetDirectoryName(assetPath);
                    // Get all files in folder that start with "Node_"
                    var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
                    int nextNumber = 1;
                    foreach (var file in files)
                    {
                        string fName = Path.GetFileNameWithoutExtension(file);
                        string[] parts = fName.Split('_');
                        if (parts.Length >= 2 && int.TryParse(parts[1], out int num))
                        {
                            if (num >= nextNumber)
                                nextNumber = num + 1;
                        }
                    }
                    string newName = $"Node_{nextNumber:D3}_";
                    AssetDatabase.RenameAsset(assetPath, newName);
                    AssetDatabase.SaveAssets();
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Editor\NodeEffectDrawer.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Editor/NodeEffectDrawer.cs
using UnityEngine;
using UnityEditor;

[CustomPropertyDrawer(typeof(NodeEffectData))]
public class NodeEffectDrawer : PropertyDrawer
{
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        EditorGUI.BeginProperty(position, label, property);

        // Get properties
        var effectTypeProp = property.FindPropertyRelative("effectType");
        var primaryValueProp = property.FindPropertyRelative("primaryValue");
        var secondaryValueProp = property.FindPropertyRelative("secondaryValue");
        var isPassiveProp = property.FindPropertyRelative("isPassive");
        // var scentIdentifierProp = property.FindPropertyRelative("scentIdentifier"); // REMOVED
        var scentDefRefProp = property.FindPropertyRelative("scentDefinitionReference"); // ADDED

        // Calculate rects - basic vertical layout
        Rect typeRect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);
        Rect passiveRect = new Rect(position.x, typeRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight);
        Rect primaryRect = new Rect(position.x, passiveRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight);
        Rect secondaryRect = new Rect(position.x, primaryRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight);
        Rect scentRect = new Rect(position.x, secondaryRect.yMax + EditorGUIUtility.standardVerticalSpacing, position.width, EditorGUIUtility.singleLineHeight); // Reuse rect position

        // Draw fields
        EditorGUI.PropertyField(typeRect, effectTypeProp);
        EditorGUI.PropertyField(passiveRect, isPassiveProp);

        // Determine labels based on type
        GUIContent primaryLabel = new GUIContent(primaryValueProp.displayName);
        GUIContent secondaryLabel = new GUIContent(secondaryValueProp.displayName);

        NodeEffectType currentType = (NodeEffectType)effectTypeProp.enumValueIndex;

        bool showScentField = false;
        switch (currentType)
        {
            case NodeEffectType.ScentModifier:
                primaryLabel.text = "Radius Bonus"; // Contextual label
                secondaryLabel.text = "Strength Bonus"; // Contextual label
                showScentField = true;
                break;
            case NodeEffectType.Damage:
                primaryLabel.text = "Damage Multiplier Add";
                break;
             // Add other cases...
            default:
                break;
        }

        EditorGUI.PropertyField(primaryRect, primaryValueProp, primaryLabel);
        EditorGUI.PropertyField(secondaryRect, secondaryValueProp, secondaryLabel);

        // Conditionally draw scent definition Object Field
        if (showScentField)
        {
            // Draw Object Field restricted to ScentDefinition type
            EditorGUI.ObjectField(scentRect, scentDefRefProp, typeof(ScentDefinition), new GUIContent("Scent Definition")); // Use correct label
        }

        EditorGUI.EndProperty();
    }

    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
    {
        float height = EditorGUIUtility.singleLineHeight; // Type
        height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Passive
        height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Primary
        height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Secondary

        // Add height for scent field only if needed
        var effectTypeProp = property.FindPropertyRelative("effectType");
        NodeEffectType currentType = (NodeEffectType)effectTypeProp.enumValueIndex;
        if (currentType == NodeEffectType.ScentModifier)
        {
            height += EditorGUIUtility.standardVerticalSpacing + EditorGUIUtility.singleLineHeight; // Scent Definition Reference
        }

        return height;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\LeafData.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/LeafData.cs
using UnityEngine;

/// <summary>
/// Class to store information about leaves for regrowth tracking
/// </summary>
[System.Serializable]
public class LeafData
{
    public Vector2Int GridCoord;
    public bool IsActive; // True if the leaf exists, false if it was eaten
    
    public LeafData(Vector2Int coord, bool isActive = true)
    {
        GridCoord = coord;
        IsActive = isActive;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantCell.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantCell.cs (Fix Leaf Tracking)

using UnityEngine;

// Define the enum here if it's closely tied to PlantCell,
// or move it to a separate file (e.g., PlantEnums.cs) for better organization.
public enum PlantCellType { Seed, Stem, Leaf, Flower, Fruit } // <<< ADDED ENUM DEFINITION

public class PlantCell : MonoBehaviour
{
    // Set these references when the cell is spawned by PlantGrowth
    [HideInInspector] public PlantGrowth ParentPlantGrowth;
    [HideInInspector] public Vector2Int GridCoord;
    [HideInInspector] public PlantCellType CellType; // Uses the enum defined above

    // Called automatically by Unity when this GameObject is destroyed
    private void OnDestroy()
    {
        // Notify the parent plant that this cell is gone, if the parent still exists
        if (ParentPlantGrowth != null)
        {
            // If it's a leaf being destroyed, ensure it's marked as inactive for potential regrowth
            if (CellType == PlantCellType.Leaf)
            {
                // Call the plant growth to let it know this is a leaf being destroyed
                // This helps ensure we mark it as inactive for regrowth
                if (Debug.isDebugBuild)
                    Debug.Log($"[PlantCell OnDestroy] Leaf at {GridCoord} is being destroyed - notifying parent plant", gameObject);
            }
            
            // Notify parent to update tracking and handle removal
            ParentPlantGrowth.ReportCellDestroyed(GridCoord);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.Cell.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.Cell.cs
using System.Collections.Generic;
using System.Linq; // Added this namespace for OrderBy()
using UnityEngine;

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- CELL MANAGEMENT METHODS ---
    // ------------------------------------------------

    public void ReportCellDestroyed(Vector2Int coord)
    {
        if (cells.ContainsKey(coord))
        {
            // Check what type of cell is being destroyed
            PlantCellType cellType = cells[coord];
        
            // If it's a leaf, mark it as inactive for potential regrowth
            if (cellType == PlantCellType.Leaf)
            {
                // Find and update the leaf data
                for (int i = 0; i < leafDataList.Count; i++)
                {
                    if (leafDataList[i].GridCoord == coord)
                    {
                        LeafData updatedData = leafDataList[i];
                        updatedData.IsActive = false; // Mark as eaten/missing
                        leafDataList[i] = updatedData;
                    
                        if (Debug.isDebugBuild)
                            Debug.Log($"[{gameObject.name}] Leaf at {coord} marked as missing for potential regrowth via ReportCellDestroyed.");
                    
                        break;
                    }
                }
            }
        
            cells.Remove(coord);
            // Assume RemovePlantCell(GameObject) will be called externally for proper cleanup
            // We still need to clean the GO list if destruction happened unexpectedly
            activeCellGameObjects.RemoveAll(go => go == null || (go.GetComponent<PlantCell>()?.GridCoord == coord));

            // Trigger outline update after internal state change
            if (enableOutline && outlineController != null)
            {
                outlineController.OnPlantCellRemoved(coord);
            }
        }
    }

    // RemovePlantCell (Handles shadow AND outline unregistration)
    public void RemovePlantCell(GameObject cellToRemove)
    {
        if (cellToRemove == null) return;

        PlantCell cellComp = cellToRemove.GetComponent<PlantCell>();
        if (cellComp == null) { Destroy(cellToRemove); return; } // Destroy if no component

        Vector2Int coord = cellComp.GridCoord;
        
        // NEW: Check if this is a leaf and mark it as inactive in our leaf data list
        if (cellComp.CellType == PlantCellType.Leaf)
        {
            // Find matching leaf data and mark as inactive (missing)
            for (int i = 0; i < leafDataList.Count; i++)
            {
                if (leafDataList[i].GridCoord == coord)
                {
                    LeafData updatedData = leafDataList[i];
                    updatedData.IsActive = false; // Mark as eaten/missing
                    leafDataList[i] = updatedData;
                    
                    if (Debug.isDebugBuild)
                        Debug.Log($"[{gameObject.name}] Leaf at {coord} marked as missing for potential regrowth.");
                    
                    break;
                }
            }
        }

        // --- Unregister Visuals FIRST ---
        // Shadow
        SpriteRenderer partRenderer = cellToRemove.GetComponentInChildren<SpriteRenderer>(); // More robust check
        if (shadowController != null && partRenderer != null) {
            shadowController.UnregisterPlantPart(partRenderer);
        }

        // Outline (this now triggers the update based on internal state)
        // No direct call to outlineController needed here, ReportCellDestroyed handles it.

        // --- Remove from internal tracking ---
        if (cells.ContainsKey(coord)) {
            cells.Remove(coord);
        }
        activeCellGameObjects.Remove(cellToRemove);

        // --- Destroy the GameObject ---
        Destroy(cellToRemove);

        // --- Trigger Outline Update AFTER internal state reflects the removal ---
        // Moved notification to ReportCellDestroyed which should be called by PlantCell OnDestroy
        // If called directly, ensure ReportCellDestroyed is also called or call the outline update here:
        // if (enableOutline && outlineController != null) {
        //     outlineController.OnPlantCellRemoved(coord);
        // }
    }


    // ClearAllVisuals (Combined cleanup helper for Shadows and Outlines)
    private void ClearAllVisuals()
    {
        // Create a copy because RemovePlantCell modifies the list
        List<GameObject> cellsToClear = new List<GameObject>(activeCellGameObjects);
        foreach (GameObject cellGO in cellsToClear) {
            if (cellGO != null) {
                // Directly destroy, OnDestroy in PlantCell calls ReportCellDestroyed -> Outline Update
                Destroy(cellGO);
            }
        }
        // Ensure lists/dicts are clear after iteration
        activeCellGameObjects.Clear();
        cells.Clear();

        // Also clear any outlines that might be orphaned
        if (outlineController != null) {
             // This assumes OutlineController has a method to clear all its parts
             // outlineController.ClearAllOutlineParts();
             // Or simply destroy/recreate the outline controller if simpler
        }

        rootCellInstance = null;
    }


    // SpawnCellVisual - Creates a cell visual GameObject
    private GameObject SpawnCellVisual(PlantCellType cellType, Vector2Int coords,
                                 Dictionary<ScentDefinition, float> accumulatedScentRadiusBonus = null,
                                 Dictionary<ScentDefinition, float> accumulatedScentStrengthBonus = null)
    {
        if (cells.ContainsKey(coords)) {
             Debug.LogWarning($"[{gameObject.name}] Trying to spawn {cellType} at occupied coord {coords}.");
            return null;
        }

        GameObject prefab = null;
        switch (cellType) {
            case PlantCellType.Seed: prefab = seedCellPrefab; break;
            case PlantCellType.Stem: prefab = stemCellPrefab; break;
            case PlantCellType.Leaf: prefab = leafCellPrefab; break;
            case PlantCellType.Fruit: prefab = berryCellPrefab; break;
        }

        if (prefab == null) {
            Debug.LogError($"[{gameObject.name}] Prefab for PlantCellType.{cellType} is null!");
            return null;
        }

        // Create visual cell
        Vector2 worldPos = (Vector2)transform.position + ((Vector2)coords * cellSpacing);
        GameObject instance = Instantiate(prefab, worldPos, Quaternion.identity, transform);
        instance.name = $"{gameObject.name}_{cellType}_{coords.x}_{coords.y}";

        // Set up PlantCell component
        PlantCell cellComp = instance.GetComponent<PlantCell>() ?? instance.AddComponent<PlantCell>();
        cellComp.ParentPlantGrowth = this;
        cellComp.GridCoord = coords;
        cellComp.CellType = cellType;

        // Add to tracking
        cells[coords] = cellType;
        activeCellGameObjects.Add(instance);

        // Set up SortableEntity
        SortableEntity sorter = instance.GetComponent<SortableEntity>() ?? instance.AddComponent<SortableEntity>();
        if (cellType == PlantCellType.Seed) {
            sorter.SetUseParentYCoordinate(false);
        } else {
            sorter.SetUseParentYCoordinate(true);
        }

        // Apply scent data if it's a fruit
        if (cellType == PlantCellType.Fruit) {
            ApplyScentDataToObject(instance, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
        }

        // Register visual effects
        RegisterShadowForCell(instance, cellType.ToString());
        // Outline registration now happens via OnPlantCellAdded call
        if (enableOutline && outlineController != null)
        {
             outlineController.OnPlantCellAdded(coords, instance);
        }

        return instance;
    }

    // --- Helper Methods for Shadow & Outline Integration ---
    private void RegisterShadowForCell(GameObject cellInstance, string cellTypeName)
    {
        if (shadowController == null || shadowPartPrefab == null || cellInstance == null) return;

        SpriteRenderer partRenderer = cellInstance.GetComponentInChildren<SpriteRenderer>(); // More robust
        if (partRenderer != null) {
            shadowController.RegisterPlantPart(partRenderer, shadowPartPrefab);
        } else {
            Debug.LogWarning($"Plant '{gameObject.name}': {cellTypeName} missing SpriteRenderer. No shadow.", cellInstance);
        }
    }

    // REMOVED: RegisterOutlineForCell (Logic moved to SpawnCellVisual calling outlineController.OnPlantCellAdded)

    // --- Stat Calculation ---
    private void CalculateAndApplyStats()
    {
        // (Function body remains the same as before)
        if (nodeGraph == null) {
            Debug.LogError($"[{gameObject.name}] CalculateAndApplyStats called with null NodeGraph!");
            return;
        }

        float baseEnergyStorage = 10f;
        float basePhotosynthesisRate = 0.5f;
        int baseStemMin = 3;
        int baseStemMax = 5;
        float baseGrowthSpeedInterval = 0.5f; // Base time per step
        int baseLeafGap = 1;
        int baseLeafPattern = 0;
        float baseGrowthRandomness = 0.1f;
        float baseCooldown = 5f;
        float baseCastDelay = 0.1f;

        float accumulatedEnergyStorage = 0f;
        float accumulatedPhotosynthesis = 0f;
        int stemLengthModifier = 0;
        float growthSpeedTimeModifier = 0f;
        int leafGapModifier = 0;
        int currentLeafPattern = baseLeafPattern;
        float growthRandomnessModifier = 0f;
        float cooldownModifier = 0f;
        float castDelayModifier = 0f;
        bool seedFound = false;
        
        // Initialize poop fertilizer values to zero
        poopDetectionRadius = 0f;
        poopEnergyBonus = 0f; // Renamed from poopAbsorptionRate

        foreach (NodeData node in nodeGraph.nodes.OrderBy(n => n.orderIndex)) {
            if (node?.effects == null) continue;
            foreach (var effect in node.effects) {
                if (effect == null || !effect.isPassive) continue;
                switch (effect.effectType) {
                    case NodeEffectType.SeedSpawn:
                        seedFound = true;
                        break;
                    case NodeEffectType.EnergyStorage:
                        accumulatedEnergyStorage += effect.primaryValue;
                        break;
                    case NodeEffectType.EnergyPhotosynthesis:
                        accumulatedPhotosynthesis += effect.primaryValue;
                        break;
                    case NodeEffectType.StemLength:
                        stemLengthModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.GrowthSpeed:
                        // Modify the *time interval* per step
                        growthSpeedTimeModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.LeafGap:
                        leafGapModifier += Mathf.RoundToInt(effect.primaryValue);
                        break;
                    case NodeEffectType.LeafPattern:
                        currentLeafPattern = Mathf.Clamp(Mathf.RoundToInt(effect.primaryValue), 0, 4); // Assuming max 4 patterns defined
                        break;
                    case NodeEffectType.StemRandomness:
                        growthRandomnessModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.Cooldown:
                        cooldownModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.CastDelay:
                        castDelayModifier += effect.primaryValue;
                        break;
                    case NodeEffectType.PoopFertilizer:
                        poopDetectionRadius = Mathf.Max(0f, effect.primaryValue);
                        poopEnergyBonus = Mathf.Max(0f, effect.secondaryValue); // Renamed from poopAbsorptionRate
                        break;
                        // Add other passive effects here if needed
                }
            }
        }

        finalMaxEnergy = Mathf.Max(1f, baseEnergyStorage + accumulatedEnergyStorage);
        finalPhotosynthesisRate = Mathf.Max(0f, basePhotosynthesisRate + accumulatedPhotosynthesis);
        int finalStemMin = Mathf.Max(1, baseStemMin + stemLengthModifier);
        int finalStemMax = Mathf.Max(finalStemMin, baseStemMax + stemLengthModifier);
        finalGrowthSpeed = Mathf.Max(0.01f, baseGrowthSpeedInterval + growthSpeedTimeModifier); // This is now TIME PER STEP
        finalLeafGap = Mathf.Max(0, baseLeafGap + leafGapModifier);
        finalLeafPattern = currentLeafPattern;
        finalGrowthRandomness = Mathf.Clamp01(baseGrowthRandomness + growthRandomnessModifier);
        cycleCooldown = Mathf.Max(0.1f, baseCooldown + cooldownModifier);
        nodeCastDelay = Mathf.Max(0.01f, baseCastDelay + castDelayModifier);

        targetStemLength = seedFound ? Random.Range(finalStemMin, finalStemMax + 1) : 0;
        // REMOVED: totalGrowthDuration calculation (less relevant)

        if (!seedFound) {
            Debug.LogWarning($"[{gameObject.name}] NodeGraph lacks SeedSpawn effect. Growth aborted.", gameObject);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.Growth.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.Growth.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq; // Keep for OrderBy

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- TIME-BASED GROWTH SYSTEM ---                // <<< NEW SYSTEM
    // ------------------------------------------------

    // Helper class to store pre-calculated growth steps (same as before)
    private class GrowthStep
    {
        public PlantCellType CellType;
        public Vector2Int Position;
        public int StemIndex; // Track which stem this belongs to (for percentage)
    }

    // --- GrowthCoroutine_TimeBased ---              // <<< FIXED COROUTINE
    private IEnumerator GrowthCoroutine_TimeBased()
    {
        if (targetStemLength <= 0)
        {
            currentState = PlantState.GrowthComplete;
            growthCoroutine = null;
            yield break;
        }

        List<GrowthStep> growthPlan = PreCalculateGrowthPlan();
        
        // Reset all growth tracking variables
        totalPlannedSteps = growthPlan.Count;
        stepsCompleted = 0;
        actualGrowthProgress = 0f;
        
        if (totalPlannedSteps == 0)
        {
            currentState = PlantState.GrowthComplete;
            growthCoroutine = null;
            yield break;
        }

        // --- Count stem steps for better time estimation ---
        int stemStepsCount = growthPlan.Count(step => step.CellType == PlantCellType.Stem);
        if (stemStepsCount == 0) stemStepsCount = 1; // Safety check

        // --- Initialize Time Variables ---
        currentGrowthElapsedTime = 0f; // Reset elapsed time for this growth cycle
        float baseTimePerStep = finalGrowthSpeed;
        if (baseTimePerStep <= 0.001f) baseTimePerStep = 0.01f;

        // --- Calculate Initial Estimated Total Time (for continuous mode) ---
        float initialTileMultiplier = 1.0f;
        if (PlantGrowthModifierManager.Instance != null)
        {
            initialTileMultiplier = PlantGrowthModifierManager.Instance.GetGrowthSpeedMultiplier(this);
            initialTileMultiplier = Mathf.Clamp(initialTileMultiplier, 0.1f, 10.0f);
        }
        float initialEffectiveTimePerStep = baseTimePerStep / initialTileMultiplier;
        if (initialEffectiveTimePerStep < 0.001f) initialEffectiveTimePerStep = 0.001f;
        
        // --- Use stem count for time estimate, not total steps ---
        estimatedTotalGrowthTime = stemStepsCount * initialEffectiveTimePerStep;
        // Ensure estimated time is at least a small positive value
        if (estimatedTotalGrowthTime < 0.01f) estimatedTotalGrowthTime = 0.01f;

        float lastUpdateTime = Time.time;
        float updateProgressInterval = 0.1f; // Update progress at least every 0.1 seconds

        // --- Track actual progress toward next step ---
        float progressTowardNextStep = 0f;

        // --- Growth Loop ---
        while (stepsCompleted < totalPlannedSteps && currentState == PlantState.Growing)
        {
            // 1. Get Current Frame's Delta Time
            float frameDeltaTime = Time.deltaTime;
            currentGrowthElapsedTime += frameDeltaTime;

            // 2. Get Current Tile Modifier
            float currentTileMultiplier = 1.0f;
            if (PlantGrowthModifierManager.Instance != null)
            {
                currentTileMultiplier = PlantGrowthModifierManager.Instance.GetGrowthSpeedMultiplier(this);
                currentTileMultiplier = Mathf.Clamp(currentTileMultiplier, 0.1f, 10.0f);
            }

            // 3. Calculate current effective time per step
            float currentEffectiveTimePerStep = baseTimePerStep / currentTileMultiplier;
            if (currentEffectiveTimePerStep < 0.001f) currentEffectiveTimePerStep = 0.001f;

            // 4. FIXED: Calculate progress rate - how quickly we accumulate progress relative to base rate
            //    When growth speed increases, we accumulate progress faster proportionally
            float progressRate = initialEffectiveTimePerStep / currentEffectiveTimePerStep;
            
            // 5. Add progress toward next step based on adjusted progress rate
            progressTowardNextStep += frameDeltaTime * progressRate;
            
            // 6. Calculate partial progress (0-1) toward next step for UI smoothness
            actualGrowthProgress = Mathf.Clamp01(progressTowardNextStep / initialEffectiveTimePerStep);
            
            // 7. Check if we've accumulated enough progress for one or more steps
            int stepsToProcessThisFrame = 0;
            
            while (progressTowardNextStep >= initialEffectiveTimePerStep && stepsCompleted < totalPlannedSteps) 
            {
                stepsToProcessThisFrame++;
                progressTowardNextStep -= initialEffectiveTimePerStep;
                
                // Limit steps per frame to prevent lag
                if (stepsToProcessThisFrame >= 3) break;
            }

            // 8. Process the steps
            if (stepsToProcessThisFrame > 0)
            {
                for (int i = 0; i < stepsToProcessThisFrame; i++)
                {
                    int currentPlanIndex = stepsCompleted;
                    if (currentPlanIndex >= totalPlannedSteps) break;

                    GrowthStep step = growthPlan[currentPlanIndex];
                    GameObject spawnedCell = SpawnCellVisual(step.CellType, step.Position, null, null);

                    // Update stem count for discrete percentage display
                    if (step.CellType == PlantCellType.Stem)
                    {
                        currentStemCount = step.StemIndex;
                        if (!continuousIncrement) // Only update UI from here if discrete
                        {
                             UpdateGrowthPercentageUI();
                        }
                    }
                    
                    stepsCompleted++;
                }
                
                lastUpdateTime = Time.time;
                
                // Update partial progress after steps
                actualGrowthProgress = Mathf.Clamp01(progressTowardNextStep / initialEffectiveTimePerStep);
            }
            
            // 9. Update UI based on time interval regardless of steps processed
            if (Time.time - lastUpdateTime > updateProgressInterval)
            {
                if (continuousIncrement)
                {
                    UpdateGrowthPercentageUI();
                }
                lastUpdateTime = Time.time;
            }

            // 10. Yield
            yield return null;
        }

        // Final update to ensure we reach 100%
        currentState = PlantState.GrowthComplete;
        stepsCompleted = totalPlannedSteps;
        actualGrowthProgress = 1.0f;
        growthCoroutine = null;
    }


    // --- PreCalculateGrowthPlan ---                     // <<< NEW HELPER
    /// <summary>
    /// Generates the full sequence of stem and leaf placements based on calculated stats.
    /// </summary>
    /// <returns>A list of GrowthStep objects defining the growth sequence.</returns>
    private List<GrowthStep> PreCalculateGrowthPlan()
    {
        List<GrowthStep> plan = new List<GrowthStep>();
        Vector2Int currentPos = Vector2Int.zero; // Start relative to the seed
        int spiralDir = 1; // Used for spiral pattern
        int patternCount = 0; // Used for alternating patterns

        // Simulate the growth stem by stem
        for (int stemIndex = 1; stemIndex <= targetStemLength; stemIndex++)
        {
            // Determine growth direction for this stem
            Vector2Int growthDir = GetStemDirection(); // Use the randomness calculated in stats
            Vector2Int nextStemPos = currentPos + growthDir;

            // Add stem step to the plan
            plan.Add(new GrowthStep {
                CellType = PlantCellType.Stem,
                Position = nextStemPos,
                StemIndex = stemIndex
            });

            currentPos = nextStemPos; // Update position for leaf calculation

            // Check if leaves should be added for this stem segment
            if ((finalLeafGap >= 0) && (stemIndex % (finalLeafGap + 1)) == 0)
            {
                patternCount++;

                // Base positions for leaves relative to the *new* stem position
                Vector2Int leftBase = currentPos + Vector2Int.left;
                Vector2Int rightBase = currentPos + Vector2Int.right;

                // Calculate leaf positions based on the chosen pattern
                List<Vector2Int> leafPositions = CalculateLeafPositions(
                    currentPos, // Current stem position
                    leftBase,   // Potential left leaf position
                    rightBase,  // Potential right leaf position
                    patternCount, // Counter for alternating patterns
                    ref spiralDir // Ref for spiral direction state
                );

                // Add leaf steps to the plan
                foreach (Vector2Int leafPos in leafPositions)
                {
                    plan.Add(new GrowthStep {
                        CellType = PlantCellType.Leaf,
                        Position = leafPos,
                        StemIndex = stemIndex // Associate leaf with the stem it grew from
                    });
                }
            }
        }
        
        // Track all leaf positions for potential regrowth
        foreach (GrowthStep step in plan)
        {
            if (step.CellType == PlantCellType.Leaf)
            {
                leafDataList.Add(new LeafData(step.Position, true));
            }
        }
        
        return plan;
    }


    // --- GetStemDirection - Determines the next stem growth direction ---
    // (Logic remains the same, uses finalGrowthRandomness)
    private Vector2Int GetStemDirection()
    {
        // Use pre-calculated randomness factor
        if (Random.value < finalGrowthRandomness) // Check against the final calculated value
        {
            // Randomly choose left-up or right-up diagonal
            return (Random.value < 0.5f) ? (Vector2Int.up + Vector2Int.left) : (Vector2Int.up + Vector2Int.right);
        }
        // Default to straight up
        return Vector2Int.up;
    }

    // --- CalculateLeafPositions - Calculates leaf positions based on pattern ---
    // (Logic remains the same, uses finalLeafPattern)
    private List<Vector2Int> CalculateLeafPositions(
        Vector2Int stemPos, Vector2Int leftBase, Vector2Int rightBase, int counter, ref int spiralDir)
    {
        List<Vector2Int> leafPositions = new List<Vector2Int>();

        switch (finalLeafPattern) // Use the final calculated pattern
        {
            case 0: // Parallel leaves
                leafPositions.Add(leftBase);
                leafPositions.Add(rightBase);
                break;

            case 1: // Alternating Offset leaves
                 // Initialize random offset ONCE per plant growth instance
                if (offsetRightForPattern1 == null)
                    offsetRightForPattern1 = Random.value < 0.5f;

                if (offsetRightForPattern1.Value) { // Offset right leaf up
                    leafPositions.Add(leftBase);
                    leafPositions.Add(rightBase + Vector2Int.up);
                } else { // Offset left leaf up
                    leafPositions.Add(leftBase + Vector2Int.up);
                    leafPositions.Add(rightBase);
                }
                break;

            case 2: // Alternating Parallel/Offset combination
                switch (counter % 4) {
                    case 0: // Treat 0 like 2 for parallel
                    case 2: // Parallel
                        leafPositions.Add(leftBase);
                        leafPositions.Add(rightBase);
                        break;
                    case 1: // Offset left up
                        leafPositions.Add(leftBase + Vector2Int.up);
                        leafPositions.Add(rightBase);
                        break;
                    case 3: // Offset right up
                        leafPositions.Add(leftBase);
                        leafPositions.Add(rightBase + Vector2Int.up);
                        break;
                }
                break;

            case 3: // Spiral leaves
                // Place one leaf normally, offset the other based on spiral direction
                if (spiralDir > 0) { // e.g., Right leaf is higher
                    leafPositions.Add(leftBase);
                    leafPositions.Add(rightBase + Vector2Int.up);
                } else { // e.g., Left leaf is higher
                    leafPositions.Add(leftBase + Vector2Int.up);
                    leafPositions.Add(rightBase);
                }
                spiralDir *= -1; // Flip direction for next time
                break;

            case 4: // Example: Symmetric double leaves on both sides
                leafPositions.Add(leftBase);
                leafPositions.Add(leftBase + Vector2Int.up);
                leafPositions.Add(rightBase);
                leafPositions.Add(rightBase + Vector2Int.up);
                break;

             default: // Fallback to parallel
                 leafPositions.Add(leftBase);
                 leafPositions.Add(rightBase);
                 break;
        }

        return leafPositions;
    }

} // End PARTIAL Class


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.NodeExecution.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.NodeExecution.cs
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- NODE EXECUTION METHODS ---
    // ------------------------------------------------

    private IEnumerator ExecuteMatureCycle()
    {
        if (nodeGraph?.nodes == null || nodeGraph.nodes.Count == 0) {
             Debug.LogError($"[{gameObject.name}] NodeGraph missing or empty!", gameObject);
             currentState = PlantState.Mature_Idle;
             cycleTimer = cycleCooldown; // Reset timer even on error
             yield break;
        }

        // --- Accumulation Phase ---
        float damageMultiplier = 1.0f;
        Dictionary<ScentDefinition, float> accumulatedScentRadiusBonus = new Dictionary<ScentDefinition, float>();
        Dictionary<ScentDefinition, float> accumulatedScentStrengthBonus = new Dictionary<ScentDefinition, float>();
        float totalEnergyCostForCycle = 0f;

        // Process all nodes to accumulate effects
        foreach (var node in nodeGraph.nodes.OrderBy(n => n.orderIndex))
        {
            if (node?.effects == null || node.effects.Count == 0) continue;

            foreach (var effect in node.effects)
            {
                 if (effect == null || effect.isPassive) continue; // Skip passive effects

                 // Accumulate specific non-passive effects
                 switch (effect.effectType)
                 {
                    case NodeEffectType.EnergyCost:
                         totalEnergyCostForCycle += Mathf.Max(0f, effect.primaryValue);
                         break;
                    case NodeEffectType.Damage:
                         damageMultiplier = Mathf.Max(0.1f, damageMultiplier + effect.primaryValue);
                         break;
                    case NodeEffectType.ScentModifier:
                        if (effect.scentDefinitionReference != null)
                        {
                             ScentDefinition key = effect.scentDefinitionReference;
                             // Use TryGetValue for cleaner addition
                             accumulatedScentRadiusBonus.TryGetValue(key, out float currentRad);
                             accumulatedScentRadiusBonus[key] = currentRad + effect.primaryValue;

                             accumulatedScentStrengthBonus.TryGetValue(key, out float currentStr);
                             accumulatedScentStrengthBonus[key] = currentStr + effect.secondaryValue;
                        }
                        else {
                             Debug.LogWarning($"Node '{node.nodeDisplayName ?? "Unnamed"}' has ScentModifier effect but ScentDefinition reference is NULL.");
                        }
                        break;
                    // Other accumulation effects could go here
                 }
            }
        }
        
        // --- NEW: Check for poop to absorb in this cycle ---
        if (poopDetectionRadius > 0f)
        {
            CheckForPoopAndAbsorb();
        }

        // --- Execution Phase ---
        // Check Energy Cost *before* executing actions
        if (currentEnergy < totalEnergyCostForCycle) {
             if(Debug.isDebugBuild) Debug.Log($"[{gameObject.name}] Not enough energy ({currentEnergy}/{totalEnergyCostForCycle}) for mature cycle.");
             currentState = PlantState.Mature_Idle;
             cycleTimer = cycleCooldown; // Reset timer
             yield break; // Exit if not enough energy
        }

        // Spend energy
        currentEnergy = Mathf.Max(0f, currentEnergy - totalEnergyCostForCycle);
        UpdateUI(); // Update UI after spending energy

        // Execute node effects in order
        foreach (var node in nodeGraph.nodes.OrderBy(n => n.orderIndex))
        {
            if (node?.effects == null || node.effects.Count == 0) continue;

            // Check if this node contains any *active* effects that require a delay
            bool hasActionEffectInNode = node.effects.Any(eff => eff != null && !eff.isPassive &&
                                            eff.effectType != NodeEffectType.EnergyCost && // Don't delay for cost
                                            eff.effectType != NodeEffectType.Damage &&   // Don't delay for damage mod
                                            eff.effectType != NodeEffectType.ScentModifier); // Don't delay for scent mod

            // Apply delay BEFORE processing effects of this node if applicable
            if (hasActionEffectInNode && nodeCastDelay > 0.01f) {
                 yield return new WaitForSeconds(nodeCastDelay);
            }

            // Execute individual active effects
            foreach (var effect in node.effects)
            {
                 // Skip passive and accumulation-only effects during execution
                 if (effect == null || effect.isPassive ||
                     effect.effectType == NodeEffectType.EnergyCost ||
                     effect.effectType == NodeEffectType.Damage ||
                     effect.effectType == NodeEffectType.ScentModifier) continue;

                 // Execute the actual active effect
                 switch (effect.effectType) {
                     case NodeEffectType.Output:
                        // Find component on THIS plant root or its children
                        OutputNodeEffect outputComp = GetComponentInChildren<OutputNodeEffect>();
                        if (outputComp != null) {
                             outputComp.Activate(damageMultiplier, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
                        } else {
                             Debug.LogWarning($"[{gameObject.name}] Node requested Output effect, but no OutputNodeEffect component found.", this);
                        }
                         break;
                     case NodeEffectType.GrowBerry:
                         TrySpawnBerry(accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
                         break;
                     // Add other ACTIVE effect cases here (e.g., Heal, StatusEffect)
                 }
            }
        }

        // --- Cycle Complete ---
        // Reset timer and state after executing all nodes
        cycleTimer = cycleCooldown;
        currentState = PlantState.Mature_Idle;
    }

    // --- TrySpawnBerry - Tries to create a berry on the plant ---
    private void TrySpawnBerry(Dictionary<ScentDefinition, float> scentRadiiBonus, Dictionary<ScentDefinition, float> scentStrengthsBonus)
    {
        if (berryCellPrefab == null) {
            Debug.LogWarning($"[{gameObject.name}] Berry Prefab not assigned. Cannot spawn berry.", gameObject);
            return;
        }

        // Find potential coordinates adjacent to existing stems/leaves where berries can grow
        // Consider only coords adjacent to stems for typical berry growth
        var potentialCoords = cells
            .Where(cellKvp => cellKvp.Value == PlantCellType.Stem || cellKvp.Value == PlantCellType.Seed) // Only grow off Stem/Seed
            .SelectMany(cellKvp => {
                Vector2Int coord = cellKvp.Key;
                // Define potential relative offsets for berries (e.g., above, left, right)
                Vector2Int[] berryOffsets = { Vector2Int.up, Vector2Int.left, Vector2Int.right };
                List<Vector2Int> candidates = new List<Vector2Int>();
                foreach(var offset in berryOffsets) {
                    candidates.Add(coord + offset);
                }
                return candidates;
            })
            .Where(coord => !cells.ContainsKey(coord)) // Ensure the target coordinate is empty
            .Distinct() // Avoid duplicates if multiple stems border the same empty cell
            .ToList();

        if (potentialCoords.Count > 0) {
            // Choose a random empty valid spot
            Vector2Int chosenCoord = potentialCoords[Random.Range(0, potentialCoords.Count)];
            // Spawn the berry visual, passing accumulated scent data
            GameObject berryGO = SpawnCellVisual(PlantCellType.Fruit, chosenCoord, scentRadiiBonus, scentStrengthsBonus);
             if (berryGO == null) {
                  Debug.LogError($"[{gameObject.name}] Failed to spawn berry visual at {chosenCoord}, SpawnCellVisual returned null.");
             }
        } else {
             if(Debug.isDebugBuild) Debug.Log($"[{gameObject.name}] No valid empty adjacent locations found to spawn a berry.");
        }
    }


    // --- ApplyScentDataToObject - Applies scent to an object like a berry or projectile ---
    public void ApplyScentDataToObject(GameObject targetObject, Dictionary<ScentDefinition, float> scentRadiusBonuses, Dictionary<ScentDefinition, float> scentStrengthBonuses)
    {
        // (Function body remains the same as before)
        if (targetObject == null) {
            Debug.LogError("ApplyScentDataToObject: targetObject is null.");
            return;
        }

        if (EcosystemManager.Instance == null) {
            Debug.LogError("ApplyScentDataToObject: EcosystemManager instance not found.");
            return;
        }

        if (EcosystemManager.Instance.scentLibrary == null) {
            Debug.LogWarning("ApplyScentDataToObject: Scent Library not assigned in EcosystemManager.");
            return;
        }

        // Find the ScentDefinition with the highest accumulated strength bonus
        ScentDefinition strongestScentDef = null;
        float maxStrengthBonus = -1f; // Use -1 to correctly handle 0 bonus values

        if (scentStrengthBonuses != null && scentStrengthBonuses.Count > 0) {
            foreach (var kvp in scentStrengthBonuses) {
                if (kvp.Key != null && kvp.Value > maxStrengthBonus) {
                    maxStrengthBonus = kvp.Value;
                    strongestScentDef = kvp.Key;
                }
            }
        } else {
             // if (Debug.isDebugBuild) Debug.Log($"[{gameObject.name} ApplyScentToObject] No scent strength bonuses provided.");
        }

        // Apply the strongest scent found (if any)
        if (strongestScentDef != null) {
             // if (Debug.isDebugBuild) Debug.Log($"[{gameObject.name} ApplyScentToObject] Applying strongest scent '{strongestScentDef.displayName}' to {targetObject.name} (Str Bonus: {maxStrengthBonus})");

            ScentSource scentSource = targetObject.GetComponent<ScentSource>();
            if (scentSource == null) {
                scentSource = targetObject.AddComponent<ScentSource>();
            }

            // Configure the ScentSource component
            scentSource.definition = strongestScentDef;

            // Retrieve the corresponding bonuses (defaulting to 0 if not found)
            scentRadiusBonuses.TryGetValue(strongestScentDef, out float radiusBonus);
            scentSource.radiusModifier = radiusBonus;
            scentSource.strengthModifier = maxStrengthBonus; // Apply the max strength found

            // Instantiate particle effect if defined and not already present
            if (strongestScentDef.particleEffectPrefab != null) {
                bool particleExists = false;
                // Check immediate children for an existing particle system to avoid duplicates
                foreach(Transform child in targetObject.transform){
                    if(child.TryGetComponent<ParticleSystem>(out _)){
                        particleExists = true;
                        break;
                    }
                }
                if (!particleExists) {
                     // Instantiate under the target object
                    Instantiate(strongestScentDef.particleEffectPrefab, targetObject.transform.position, Quaternion.identity, targetObject.transform);
                }
            }
        } else {
            // if (Debug.isDebugBuild) Debug.Log($"[{gameObject.name} ApplyScentToObject] No strongest scent found to apply to {targetObject.name}.");
        }
    }

} // End PARTIAL Class


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using TMPro;

// --- Enums ---
public enum PlantState { Initializing, Growing, GrowthComplete, Mature_Idle, Mature_Executing }

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- SERIALIZED FIELDS ---
    // ------------------------------------------------

    [Header("UI & Visuals")]
    [SerializeField] private TMP_Text energyText;
    [SerializeField] private GameObject seedCellPrefab;
    [SerializeField] private GameObject stemCellPrefab;
    [SerializeField] private GameObject leafCellPrefab;
    [SerializeField] private GameObject berryCellPrefab; // Used for PlantCellType.Fruit
    [SerializeField] private float cellSpacing = 0.08f;

    [Header("Shadow Setup")]
    [SerializeField] [Tooltip("Assign the PlantShadowController component from the child _ShadowRoot GameObject")]
    private PlantShadowController shadowController;
    [SerializeField] [Tooltip("Assign your 'PlantShadow' prefab (GO + SpriteRenderer + ShadowPartController script)")]
    private GameObject shadowPartPrefab;

    [Header("Outline Setup")]
    [SerializeField] [Tooltip("Enable or disable plant outline visualization")]
    private bool enableOutline = true;
    [SerializeField] [Tooltip("Assign the PlantOutlineController component from the child _OutlineRoot GameObject")]
    private PlantOutlineController outlineController;
    [SerializeField] [Tooltip("Assign your outline part prefab (GO + SpriteRenderer + OutlinePartController script)")]
    private GameObject outlinePartPrefab;

    [Header("Growth & UI Timing")]
    [SerializeField] private bool showGrowthPercentage = true;
    [SerializeField] private bool allowPhotosynthesisDuringGrowth = false;
    [SerializeField] [Tooltip("Percentage UI updates only on these increments (e.g., 5 shows 0, 5, 10...).")]
    [Range(1, 25)] private int percentageIncrement = 5;
    // --- NEW FIELD ---
    [SerializeField] [Tooltip("If true, percentage display approximates smooth progress based on time. If false, it reflects discrete stem cell additions.")]
    private bool continuousIncrement = false;
    // -----------------

    // ------------------------------------------------
    // --- INTERNAL STATE & DATA ---
    // ------------------------------------------------

    private NodeGraph nodeGraph;
    public PlantState currentState = PlantState.Initializing;
    public float currentEnergy = 0f;
    private Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
    private List<GameObject> activeCellGameObjects = new List<GameObject>();
    private FireflyManager fireflyManagerInstance;
    private GameObject rootCellInstance;
    private Coroutine growthCoroutine;
    private bool isGrowthCompletionHandled = false;

    // ------------------------------------------------
    // --- POOP FERTILIZER DATA ---
    // ------------------------------------------------
    private float poopDetectionRadius = 0f;
    private float poopEnergyBonus = 0f; // Renamed from poopAbsorptionRate
    private List<LeafData> leafDataList = new List<LeafData>();

    // ------------------------------------------------
    // --- CALCULATED STATS ---
    // ------------------------------------------------

    private int targetStemLength;
    private float finalGrowthSpeed; // Represents time interval per step
    private int finalLeafGap;
    private int finalLeafPattern;
    private float finalGrowthRandomness;
    private float finalMaxEnergy;
    private float finalPhotosynthesisRate;
    private float cycleCooldown;
    private float nodeCastDelay;

    // ------------------------------------------------
    // --- RUNTIME VARIABLES ---
    // ------------------------------------------------

    private int currentStemCount = 0;
    private float cycleTimer = 0f;
    private int displayedGrowthPercentage = -1;
    private bool? offsetRightForPattern1 = null;
    // --- NEW FIELDS for Continuous Mode ---
    private float currentGrowthElapsedTime = 0f;
    private float estimatedTotalGrowthTime = 1f; // Default to 1 to avoid division by zero
    // --- NEW FIELDS for better growth tracking ---
    private float actualGrowthProgress = 0f; // The normalized progress value (0-1) representing true growth completion
    private int stepsCompleted = 0; // Track how many steps have been completed
    private int totalPlannedSteps = 0; // Total number of steps in the growth plan

    // ------------------------------------------------
    // --- UNITY LIFECYCLE METHODS ---
    // ------------------------------------------------

    void Awake()
    {
        // --- Critical Setup Check ---
        bool setupValid = true;
        if (shadowController == null) { shadowController = GetComponentInChildren<PlantShadowController>(true); if (shadowController == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': PlantShadowController ref missing!", this); setupValid = false; } else { Debug.LogWarning($"PlantGrowth on '{gameObject.name}': Found PlantShadowController dynamically.", this); } }
        if (shadowPartPrefab == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Shadow Part Prefab missing!", this); setupValid = false; }
        if (enableOutline) { if (outlineController == null) { outlineController = GetComponentInChildren<PlantOutlineController>(true); if (outlineController == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': PlantOutlineController ref missing but outline is enabled!", this); setupValid = false; } else { Debug.LogWarning($"PlantGrowth on '{gameObject.name}': Found PlantOutlineController dynamically.", this); } } if (outlinePartPrefab == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Outline Part Prefab missing but outline is enabled!", this); setupValid = false; } }
        if (seedCellPrefab == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Seed Cell Prefab missing!", this); setupValid = false; } if (energyText == null) Debug.LogWarning($"PlantGrowth on '{gameObject.name}': Energy Text (TMP_Text) missing.", this);
        if (!setupValid) { enabled = false; return; }
        if (!enableOutline && outlineController != null) { outlineController.gameObject.SetActive(false); }
        fireflyManagerInstance = FireflyManager.Instance;
        EnsureUIReferences();
    }

    void Start()
    {
        UpdateUI();
    }

    private void Update()
    {
        // Handle frame-dependent UI updates and state transitions
        switch (currentState)
        {
            case PlantState.Growing:
                if (allowPhotosynthesisDuringGrowth)
                    AccumulateEnergy();

                // --- Update percentage UI every frame ONLY if in continuous mode ---
                if (showGrowthPercentage && continuousIncrement)
                {
                    UpdateGrowthPercentageUI();
                }
                // (Discrete mode updates are handled within the coroutine)
                break;

            case PlantState.GrowthComplete:
                if (!isGrowthCompletionHandled)
                {
                    isGrowthCompletionHandled = true;
                    if (showGrowthPercentage && targetStemLength > 0)
                    {
                        UpdateGrowthPercentageUI(true); // Force 100% display
                    }
                    currentState = PlantState.Mature_Idle;
                    cycleTimer = cycleCooldown;
                    UpdateUI(); // Update energy text if needed
                }
                break;

            case PlantState.Mature_Idle:
                AccumulateEnergy();
                UpdateUI();
                cycleTimer -= Time.deltaTime;
                if (cycleTimer <= 0f && currentEnergy >= 1f)
                {
                    currentState = PlantState.Mature_Executing;
                    StartCoroutine(ExecuteMatureCycle()); // Assumes ExecuteMatureCycle is in another partial file
                }
                break;

            case PlantState.Mature_Executing:
                AccumulateEnergy();
                UpdateUI();
                break;

            case PlantState.Initializing:
                break;
        }
    }

    private void OnDestroy()
    {
        StopAllCoroutines(); growthCoroutine = null;
        if (PlantGrowthModifierManager.Instance != null) { PlantGrowthModifierManager.Instance.UnregisterPlant(this); }
        ClearAllVisuals(); // Assumes ClearAllVisuals is in another partial file
    }

    // ------------------------------------------------
    // --- PUBLIC INITIALIZATION ---
    // ------------------------------------------------

    public void InitializeAndGrow(NodeGraph graph)
    {
        if (graph == null || graph.nodes == null) { Debug.LogError($"[{gameObject.name}] Null/empty NodeGraph provided.", gameObject); Destroy(gameObject); return; }
        if (growthCoroutine != null) { StopCoroutine(growthCoroutine); growthCoroutine = null; }
        ClearAllVisuals();
        rootCellInstance = null; currentStemCount = 0; offsetRightForPattern1 = null; isGrowthCompletionHandled = false; displayedGrowthPercentage = -1;
        currentGrowthElapsedTime = 0f; // <-- RESET
        estimatedTotalGrowthTime = 1f; // <-- RESET to default
        stepsCompleted = 0; // <-- RESET new variable
        totalPlannedSteps = 0; // <-- RESET new variable
        actualGrowthProgress = 0f; // <-- RESET new variable
        nodeGraph = graph; currentState = PlantState.Initializing; currentEnergy = 0f;
        // Clear any old leaf data
        leafDataList.Clear();
        CalculateAndApplyStats();
        GameObject spawnedSeed = SpawnCellVisual(PlantCellType.Seed, Vector2Int.zero, null, null);
        if (spawnedSeed != null) {
            rootCellInstance = spawnedSeed;
            if (PlantGrowthModifierManager.Instance != null && TileInteractionManager.Instance != null) { Vector3Int gridPos = TileInteractionManager.Instance.WorldToCell(transform.position); TileDefinition currentTile = TileInteractionManager.Instance.FindWhichTileDefinitionAt(gridPos); PlantGrowthModifierManager.Instance.RegisterPlantTile(this, currentTile); }
            if (targetStemLength > 0) {
                currentState = PlantState.Growing;
                UpdateGrowthPercentageUI(); // Initial UI update (0%)
                growthCoroutine = StartCoroutine(GrowthCoroutine_TimeBased());
            } else {
                Debug.LogWarning($"[{gameObject.name}] Target stem length is {targetStemLength}. Skipping visual growth phase.", gameObject);
                currentState = PlantState.GrowthComplete; isGrowthCompletionHandled = false; UpdateUI();
            }
        } else { Debug.LogError($"[{gameObject.name}] Failed to spawn initial seed! Aborting growth.", gameObject); currentState = PlantState.Mature_Idle; Destroy(gameObject, 0.1f); }
        UpdateUI();
    }

    // ------------------------------------------------
    // --- ENERGY & UI ---
    // ------------------------------------------------

    private void AccumulateEnergy()
    {
        if (finalPhotosynthesisRate <= 0 || finalMaxEnergy <= 0) return; float sunlight = WeatherManager.Instance ? WeatherManager.Instance.sunIntensity : 1f; int leafCount = cells.Values.Count(c => c == PlantCellType.Leaf); float tileMultiplier = (PlantGrowthModifierManager.Instance != null) ? PlantGrowthModifierManager.Instance.GetEnergyRechargeMultiplier(this) : 1.0f; float fireflyBonusRate = 0f; if (fireflyManagerInstance != null) { int nearbyFlyCount = fireflyManagerInstance.GetNearbyFireflyCount(transform.position, fireflyManagerInstance.photosynthesisRadius); fireflyBonusRate = Mathf.Min(nearbyFlyCount * fireflyManagerInstance.photosynthesisIntensityPerFly, fireflyManagerInstance.maxPhotosynthesisBonus); } float standardPhotosynthesis = finalPhotosynthesisRate * leafCount * sunlight; float totalRate = (standardPhotosynthesis + fireflyBonusRate) * tileMultiplier; float delta = totalRate * Time.deltaTime; currentEnergy = Mathf.Clamp(currentEnergy + delta, 0f, finalMaxEnergy);
    }

    // --- FIXED: UpdateGrowthPercentageUI with Continuous Mode Logic ---
    /// <summary>
    /// Calculates the target display percentage based on chosen mode (discrete/continuous)
    /// and updates the UI text ONLY if the snapped value has changed.
    /// </summary>
    /// <param name="forceComplete">If true, forces the display to 100%.</param>
    private void UpdateGrowthPercentageUI(bool forceComplete = false)
    {
        if (!showGrowthPercentage || energyText == null) return;

        float rawPercentageFloat = 0f; // The calculated percentage before snapping

        if (forceComplete || currentState == PlantState.GrowthComplete)
        {
            rawPercentageFloat = 100f;
        }
        // --- Check Continuous Flag Here ---
        else if (continuousIncrement) // --- CONTINUOUS MODE ---
        {
            // NEW: Use actual growth progress instead of elapsed time
            if (totalPlannedSteps > 0) 
            {
                // Calculate percentage based on steps completed
                rawPercentageFloat = ((float)stepsCompleted / totalPlannedSteps) * 100f;
                
                // Add partial progress toward next step based on actual growth progress
                if (actualGrowthProgress > 0f && stepsCompleted < totalPlannedSteps)
                {
                    float stepSize = 100f / totalPlannedSteps;
                    float partialStepProgress = actualGrowthProgress * stepSize;
                    rawPercentageFloat = (stepsCompleted * stepSize) + partialStepProgress;
                }
            }
            else
            {
                // Fallback if no planned steps (shouldn't happen)
                rawPercentageFloat = (currentState == PlantState.Growing) ? 0f : 100f;
            }
        }
        else // --- DISCRETE MODE ---
        {
            // Calculate based on current stem count vs target
            if (targetStemLength <= 0)
            {
                rawPercentageFloat = 0f; // No stems to grow
            }
            else
            {
                rawPercentageFloat = Mathf.Clamp(((float)currentStemCount / targetStemLength) * 100f, 0f, 100f);
            }
        }

        // --- Snap the calculated percentage (Applies to BOTH modes) ---
        int targetDisplayValue; // The final value to show (snapped)
        if (percentageIncrement <= 1)
        {
            targetDisplayValue = Mathf.FloorToInt(rawPercentageFloat);
        }
        else
        {
            // Use proper rounding to closest increment rather than floor
            targetDisplayValue = Mathf.RoundToInt(rawPercentageFloat / percentageIncrement) * percentageIncrement;
        }
        targetDisplayValue = Mathf.Min(targetDisplayValue, 100); // Clamp final value
        
        // Ensure we don't show 100% until growth is complete, unless forced
        if (targetDisplayValue == 100 && currentState == PlantState.Growing && !forceComplete)
        {
            targetDisplayValue = 95; // Cap at 95% until actually complete
        }

        // --- Update TextMeshPro only if the snapped value changed ---
        if (targetDisplayValue != displayedGrowthPercentage)
        {
            displayedGrowthPercentage = targetDisplayValue;
            energyText.text = $"{displayedGrowthPercentage}%";
        }
    }


    // --- UpdateUI (Consolidated) ---
    private void UpdateUI()
    {
        if (energyText == null) return;

        // If showing percentage AND in a state where it's relevant (Growing or just completed)
        // Let UpdateGrowthPercentageUI handle it (called from Update or completion logic)
        if (showGrowthPercentage && (currentState == PlantState.Growing || currentState == PlantState.GrowthComplete))
        {
           // If not using continuous increment, the discrete update happens in the coroutine.
           // If using continuous, it happens in Update(). If complete, it happens in Update().
           // No need to directly modify text here for percentage display.
        }
        else // Otherwise (Idle, Executing, or not showing percentage), show Energy
        {
            energyText.text = $"{Mathf.FloorToInt(currentEnergy)}/{Mathf.FloorToInt(finalMaxEnergy)}";
        }
    }

    // ------------------------------------------------
    // --- UI REFERENCE HELPER ---
    // ------------------------------------------------

    private void EnsureUIReferences()
    {
        if (energyText) return; energyText = GetComponentInChildren<TMP_Text>(true); if (!energyText) { Debug.LogWarning($"[{gameObject.name}] Energy Text (TMP_Text) UI reference not assigned in Inspector and not found in children.", gameObject); }
    }

    // ------------------------------------------------
    // --- POOP FERTILIZER METHODS ---
    // ------------------------------------------------
    
    private void CheckForPoopAndAbsorb()
    {
        // Skip if no missing leaves to regrow and no energy bonus
        bool hasMissingLeaves = leafDataList.Any(leaf => !leaf.IsActive);
        bool canAddEnergy = poopEnergyBonus > 0f;
        
        if (Debug.isDebugBuild && poopDetectionRadius > 0f)
        {
            string leafStatus = hasMissingLeaves ? 
                $"Has {leafDataList.Count(l => !l.IsActive)} missing leaves" : 
                "No missing leaves";
            Debug.Log($"[{gameObject.name}] PoopFertilizer: {leafStatus}, Radius: {poopDetectionRadius}, Energy bonus: {poopEnergyBonus}");
        }
        
        if (!hasMissingLeaves && !canAddEnergy) return;
        
        // Look for poop in range
        Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, poopDetectionRadius);
        
        if (Debug.isDebugBuild && poopDetectionRadius > 0f)
        {
            Debug.Log($"[{gameObject.name}] PoopFertilizer: Found {colliders.Length} colliders in radius {poopDetectionRadius}");
            int poopCount = 0;
            foreach (Collider2D col in colliders)
            {
                if (col.GetComponent<PoopController>() != null)
                    poopCount++;
            }
            Debug.Log($"[{gameObject.name}] PoopFertilizer: {poopCount} of those colliders have PoopController");
        }
        
        // Process poop that we find
        foreach (Collider2D collider in colliders)
        {
            PoopController poop = collider.GetComponent<PoopController>();
            if (poop != null)
            {
                bool absorbed = false;
                
                // First try to regrow a leaf if there are missing leaves
                if (hasMissingLeaves)
                {
                    absorbed = TryRegrowLeaf();
                }
                
                // If we couldn't regrow a leaf (or didn't need to) but have energy bonus, add energy
                if ((!absorbed || !hasMissingLeaves) && canAddEnergy)
                {
                    currentEnergy = Mathf.Min(finalMaxEnergy, currentEnergy + poopEnergyBonus);
                    absorbed = true;
                    
                    if (Debug.isDebugBuild)
                        Debug.Log($"[{gameObject.name}] Added {poopEnergyBonus} energy from poop fertilizer. Current energy: {currentEnergy}");
                }
                
                // Destroy the poop if it was successfully used
                if (absorbed)
                {
                    Destroy(poop.gameObject);
                    break; // Process only one poop per cycle
                }
            }
        }
    }

    private bool TryRegrowLeaf()
    {
        // Look for a missing leaf to regrow
        int missingLeafIndex = -1;
        
        // Debug counts
        if (Debug.isDebugBuild)
        {
            int totalLeaves = leafDataList.Count;
            int missingLeaves = leafDataList.Count(leaf => !leaf.IsActive);
            Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Total leaves: {totalLeaves}, Missing leaves: {missingLeaves}");
        }
        
        for (int i = 0; i < leafDataList.Count; i++)
        {
            if (!leafDataList[i].IsActive)
            {
                missingLeafIndex = i;
                break;
            }
        }
        
        if (missingLeafIndex == -1)
        {
            if (Debug.isDebugBuild)
                Debug.Log($"[{gameObject.name}] TryRegrowLeaf: No missing leaves found to regrow.");
            return false; // No missing leaves found
        }
        
        // Get the leaf coordinate and mark it as active
        Vector2Int leafCoord = leafDataList[missingLeafIndex].GridCoord;
        
        // IMPORTANT: Check if the coordinate is already occupied by another cell
        if (cells.ContainsKey(leafCoord))
        {
            if (Debug.isDebugBuild)
                Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Cannot regrow leaf at {leafCoord} because cell is already occupied.");
            return false;
        }
        
        // Create the new leaf visual
        GameObject newLeaf = SpawnCellVisual(PlantCellType.Leaf, leafCoord);
        
        if (newLeaf != null)
        {
            // Update the leaf data to mark it as active ONLY if spawn succeeded
            leafDataList[missingLeafIndex] = new LeafData(leafCoord, true);
            
            if (Debug.isDebugBuild)
                Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Successfully regrew leaf at {leafCoord} using poop fertilizer!");
            return true;
        }
        
        // If we get here, the leaf couldn't be created
        if (Debug.isDebugBuild)
            Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Failed to spawn new leaf at {leafCoord}");
        
        // Leave the leaf marked as inactive in the tracking list
        return false;
    }

    // -----------------------------------------------
    // --- PUBLIC ACCESSORS FOR OUTLINES ---
    // -----------------------------------------------

    public bool DoesCellExistAt(Vector2Int coord) { return cells.ContainsKey(coord); }
    public float GetCellSpacing() { return this.cellSpacing; }
    public GameObject GetCellGameObjectAt(Vector2Int coord) { return activeCellGameObjects.FirstOrDefault(go => go != null && go.GetComponent<PlantCell>()?.GridCoord == coord); }
    public bool IsOutlineEnabled() { return enableOutline; }
    
    // Accessor for poop fertilizer visualization
    public float GetPoopDetectionRadius() { return poopDetectionRadius; }

    // --- PARTIAL CLASS METHODS (Assumed in other files) ---
    // Define these methods in the corresponding partial class files:
    // In PlantGrowth.Cell.cs: ReportCellDestroyed, RemovePlantCell, ClearAllVisuals, SpawnCellVisual, CalculateAndApplyStats, RegisterShadowForCell
    // In PlantGrowth.Growth.cs: GrowthStep class, GrowthCoroutine_TimeBased, PreCalculateGrowthPlan, GetStemDirection, CalculateLeafPositions
    // In PlantGrowth.NodeExecution.cs: ExecuteMatureCycle, TrySpawnBerry, ApplyScentDataToObject

} // End PARTIAL Class definition


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\WeatherManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/WeatherManager.cs
using UnityEngine;
using System;

public class WeatherManager : MonoBehaviour
{
    public static WeatherManager Instance { get; private set; }

    public enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }

    [Header("Day/Night Cycle Settings")]
    public bool dayNightCycleEnabled = true;
    public float dayDuration = 20f;
    public float nightDuration = 20f;
    public float transitionDuration = 5f;
    public AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

    [Header("Sunlight Settings")]
    [Range(0f, 1f)]
    public float sunIntensity = 1f;

    [Header("Fixed Sunlight When Cycle Off")]
    [Range(0f, 1f)]
    public float fixedSunIntensity = 1f;

    [Header("Sunlight Visualization")]
    public SpriteRenderer fadeSprite;
    public float minAlpha = 0f;
    public float maxAlpha = 1f;

    [Header("Time Scaling & Pausing")]
    [Range(1f, 100f)]
    public float timeScaleMultiplier = 1f; // This scales the internal phaseTimer speed
    public bool IsPaused { get; private set; } = false; // MODIFIED: Made setter private

    public CyclePhase CurrentPhase => currentPhase;
    public event Action<CyclePhase> OnPhaseChanged;
    public float CurrentPhaseTimer => phaseTimer;
    public float CurrentTotalPhaseTime => totalPhaseTime;

    private CyclePhase currentPhase = CyclePhase.Day;
    private float phaseTimer = 0f;
    private float totalPhaseTime = 0f;
    private bool forceDaylight = false; // NEW: Flag to hold daylight

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;
    }

    void Start()
    {
        EnterPhase(CyclePhase.Day, true); // Start at day
    }

    void Update()
    {
        // If RunManager has globally paused time, WeatherManager effectively pauses too.
        // The IsPaused flag here is for internal cycle pausing by RunManager.
        if (Time.timeScale == 0f && !IsPaused) // If global time is 0 but we aren't internally paused, we should probably respect that.
        {
            UpdateFadeSprite(); // Still update visual representation of current sunIntensity
            return;
        }


        if (IsPaused)
        {
            // If explicitly paused by RunManager
            if (forceDaylight)
            {
                sunIntensity = 1.0f; // Maintain full daylight if forced
            }
            // else, sunIntensity remains as it was when PauseCycle() was called.
            UpdateFadeSprite();
            return;
        }

        // Normal cycle update
        if (!dayNightCycleEnabled)
        {
            sunIntensity = fixedSunIntensity;
            UpdateFadeSprite();
            // if (timeScaleMultiplier != 1f) timeScaleMultiplier = 1f; // This seems redundant if cycle is off
            return;
        }

        // Apply our internal timeScaleMultiplier to the phase timer
        phaseTimer -= Time.deltaTime * timeScaleMultiplier; // Time.deltaTime is already affected by Time.timeScale

        if (phaseTimer <= 0f)
        {
            CyclePhase nextPhase = currentPhase;
            switch (currentPhase)
            {
                case CyclePhase.Day: nextPhase = CyclePhase.TransitionToNight; break;
                case CyclePhase.TransitionToNight: nextPhase = CyclePhase.Night; break;
                case CyclePhase.Night: nextPhase = CyclePhase.TransitionToDay; break;
                case CyclePhase.TransitionToDay: nextPhase = CyclePhase.Day; break;
            }
            EnterPhase(nextPhase);
        }
        else
        {
            UpdateSunIntensity();
        }

        UpdateFadeSprite();
    }

    private void EnterPhase(CyclePhase nextPhase, bool forceEvent = false)
    {
        CyclePhase previousPhase = currentPhase;
        currentPhase = nextPhase;

        switch (nextPhase)
        {
            case CyclePhase.Day: totalPhaseTime = dayDuration; break;
            case CyclePhase.Night: totalPhaseTime = nightDuration; break;
            case CyclePhase.TransitionToNight:
            case CyclePhase.TransitionToDay: totalPhaseTime = transitionDuration; break;
        }
        totalPhaseTime = Mathf.Max(0.01f, totalPhaseTime); // Avoid division by zero
        phaseTimer = totalPhaseTime;

        UpdateSunIntensity(); // Calculate intensity for the new phase start

        if (previousPhase != currentPhase || forceEvent)
        {
            if (Debug.isDebugBuild) Debug.Log($"[WeatherManager] Phase Changed To: {currentPhase}");
            OnPhaseChanged?.Invoke(currentPhase);
        }
    }

    private void UpdateSunIntensity()
    {
        if (forceDaylight && IsPaused) // If forced to day and paused, keep it at 1
        {
            sunIntensity = 1.0f;
            return;
        }
        if (totalPhaseTime <= 0) return; // Should be prevented by EnterPhase

        float progress = 1f - Mathf.Clamp01(phaseTimer / totalPhaseTime);
        switch (currentPhase)
        {
            case CyclePhase.Day: sunIntensity = 1f; break;
            case CyclePhase.TransitionToNight: sunIntensity = Mathf.Lerp(1f, 0f, transitionCurve.Evaluate(progress)); break;
            case CyclePhase.Night: sunIntensity = 0f; break;
            case CyclePhase.TransitionToDay: sunIntensity = Mathf.Lerp(0f, 1f, transitionCurve.Evaluate(progress)); break;
        }
        sunIntensity = Mathf.Clamp01(sunIntensity);
    }

    private void UpdateFadeSprite()
    {
        if (fadeSprite != null)
        {
            float alpha = Mathf.Lerp(maxAlpha, minAlpha, sunIntensity); // Lerp between minAlpha and maxAlpha
            Color c = fadeSprite.color; c.a = alpha; fadeSprite.color = c;
        }
    }

    // --- NEW PUBLIC METHODS FOR RunManager CONTROL ---

    /// <summary>
    /// Pauses the day/night cycle and forces the sun intensity to full day.
    /// This is typically used during the Planning phase.
    /// </summary>
    public void PauseCycleAtDay()
    {
        Debug.Log("[WeatherManager] PauseCycleAtDay called.");
        IsPaused = true;
        forceDaylight = true;
        sunIntensity = 1.0f; // Immediately set to full day
        // Optionally, set currentPhase to Day and reset phaseTimer if needed for consistency,
        // but just forcing sunIntensity might be enough for visual and gameplay effects.
        // currentPhase = CyclePhase.Day;
        // phaseTimer = dayDuration;
        // totalPhaseTime = dayDuration;
        UpdateFadeSprite(); // Update visuals immediately
        OnPhaseChanged?.Invoke(CyclePhase.Day); // Notify that effectively it's day
    }

    /// <summary>
    /// Resumes the normal day/night cycle from its current state.
    /// This is typically used when transitioning to the Growth & Threat phase.
    /// </summary>
    public void ResumeCycle()
    {
        Debug.Log("[WeatherManager] ResumeCycle called.");
        IsPaused = false;
        forceDaylight = false;
        // No need to change sunIntensity here, it will update naturally in Update()
    }

    /// <summary>
    /// Pauses the day/night cycle at its current sun intensity and phase progress.
    /// This is typically used during the Recovery phase or for other general pauses.
    /// </summary>
    public void PauseCycle()
    {
        Debug.Log("[WeatherManager] PauseCycle called.");
        IsPaused = true;
        forceDaylight = false; // Don't force daylight, just pause current state
        // SunIntensity and phaseTimer will remain as they are.
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\SpellProjectile.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SpellProjectile : MonoBehaviour
{
    [Header("Projectile Stats")]
    public float damage;
    public float speed;
    [Tooltip("If true, the projectile will be destroyed upon hitting a wizard.")]
    public bool destroyOnHit = true;

    [Header("Burning Effect (optional)")]
    public float burningDamage;   // DPS
    public float burningDuration; // Duration in seconds

    [Header("Friendly Fire")]
    public bool friendlyFire = false;
    public bool casterIsEnemy = false;

    public void Initialize(float dmg, float spd)
    {
        damage = dmg;
        speed = spd;
    }

    private void Update()
    {
        transform.Translate(Vector2.up * speed * Time.deltaTime);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\BurningStatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public class BurningStatusEffect : StatusEffect
{
    public BurningStatusEffect(float d, float dps) : base(d, dps) { }

    
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\StatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public abstract class StatusEffect
{
    public float duration; // Total duration.
    public float damagePerSecond;
    protected float elapsed = 0f;

    // Public property to expose elapsed time.
    public float Elapsed { get { return elapsed; } }

    public StatusEffect(float d, float dps)
    {
        duration = d;
        damagePerSecond = dps;
    }

    public bool IsExpired() => elapsed >= duration;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\RunManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Core/RunManager.cs
using UnityEngine;
using System;

public enum RunState
{
    Planning,
    GrowthAndThreat,
    Recovery
}

public class RunManager : MonoBehaviour
{
    public static RunManager Instance { get; private set; }

    [Header("State & Timing")]
    [SerializeField] private RunState currentState = RunState.Planning;
    [Tooltip("Time scale multiplier during the Growth & Threat phase.")]
    [SerializeField] private float growthPhaseTimeScale = 6f;
    [Tooltip("Current round number, starts at 1.")]
    [SerializeField] private int currentRoundNumber = 1;

    [Header("Manager References (Assign in Inspector)")]
    [SerializeField] private WeatherManager weatherManager;
    [SerializeField] private WaveManager waveManager;

    public RunState CurrentState => currentState;
    public int CurrentRoundNumber => currentRoundNumber;
    public event Action<RunState> OnRunStateChanged;
    public event Action<int> OnRoundChanged;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Debug.LogWarning($"[RunManager] Duplicate instance found on {gameObject.name}. Destroying this one.", gameObject);
            Destroy(gameObject); // Destroy this duplicate instance
            return;
        }
        Instance = this;

        // This line will work without warning IF this GameObject is a root object in the scene.
        // If you intend for RunManager to persist across scene loads.
        // If your game is single-scene, you might not even need DontDestroyOnLoad.
        if (transform.parent == null) // Only call DontDestroyOnLoad if it's a root GameObject
        {
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Debug.LogWarning($"[RunManager] {gameObject.name} is not a root GameObject. DontDestroyOnLoad will not be called for it directly. If its parent is persistent, that's fine. Otherwise, make RunManager a root object if it needs to persist across scenes.", gameObject);
        }


        SetState(RunState.Planning, true);
    }

    private void SetState(RunState newState, bool force = false)
    {
        if (currentState == newState && !force) return;

        currentState = newState;
        Debug.Log($"[RunManager] State changed to: {currentState}");

        switch (currentState)
        {
            case RunState.Planning:
                Time.timeScale = 0f;
                weatherManager?.PauseCycleAtDay();
                break;
            case RunState.GrowthAndThreat:
                Time.timeScale = growthPhaseTimeScale;
                weatherManager?.ResumeCycle();
                waveManager?.StartWaveForRound(currentRoundNumber);
                break;
            case RunState.Recovery:
                Time.timeScale = 0f;
                weatherManager?.PauseCycle();
                break;
        }
        OnRunStateChanged?.Invoke(currentState);
    }

    public void StartGrowthAndThreatPhase()
    {
        if (currentState == RunState.Planning)
        {
            Debug.Log($"[RunManager] Transitioning: Planning -> Growth & Threat for Round {currentRoundNumber}");
            SetState(RunState.GrowthAndThreat);
        }
        else
        {
            Debug.LogWarning($"[RunManager] Cannot start Growth phase from state: {currentState}");
        }
    }

    public void StartRecoveryPhase()
    {
        if (currentState == RunState.GrowthAndThreat)
        {
            Debug.Log("[RunManager] Transitioning: Growth & Threat -> Recovery");
            waveManager?.StopCurrentWaveSpawning();
            SetState(RunState.Recovery);
        }
        else
        {
            Debug.LogWarning($"[RunManager] Cannot start Recovery phase from state: {currentState}");
        }
    }

    public void StartNewPlanningPhase()
    {
        if (currentState == RunState.Recovery)
        {
            currentRoundNumber++;
            Debug.Log($"[RunManager] Transitioning: Recovery -> Planning (New Round: {currentRoundNumber})");
            waveManager?.ResetForNewRound();
            SetState(RunState.Planning);
            OnRoundChanged?.Invoke(currentRoundNumber);
        }
        else
        {
            Debug.LogWarning($"[RunManager] Cannot start new Planning phase from state: {currentState}");
        }
    }

    void Update()
    {
        if (currentState == RunState.GrowthAndThreat)
        {
            if (waveManager != null && waveManager.IsCurrentWaveDefeated())
            {
                Debug.Log("[RunManager] Current wave defeated. Transitioning to Recovery.");
                StartRecoveryPhase();
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\SortableEntity.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SortableEntity : MonoBehaviour
{
    [Header("Sorting Configuration")]
    [Tooltip("Offset added to Y position for sorting calculation")]
    [SerializeField] private float sortingLayerYOffset = 0f;

    [Tooltip("Use parent's Y coordinate for sorting")]
    [SerializeField] private bool useParentYCoordinate = false;

    [Tooltip("Debug logging for sorting")]
    public bool debugSorting = false;

    private SpriteRenderer spriteRenderer;

    private void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        // If no SpriteRenderer, try to find one in children
        if (spriteRenderer == null)
            spriteRenderer = GetComponentInChildren<SpriteRenderer>();

        // Ensure sprite renderer exists
        if (spriteRenderer == null)
        {
            Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
        }
    }

    private void Start()
    {
        UpdateSortingOrder();
    }

    private void LateUpdate()
    {
        UpdateSortingOrder();
    }

    public void UpdateSortingOrder()
    {
        if (spriteRenderer == null) return;

        // Determine Y position for sorting
        float yPositionForSorting = useParentYCoordinate && transform.parent != null 
            ? transform.parent.position.y 
            : transform.position.y;

        int sortOrder = CalculateSortOrder(yPositionForSorting);
        spriteRenderer.sortingOrder = sortOrder;

        if (debugSorting)
        {
            Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
        }
    }

    private int CalculateSortOrder(float yPosition)
    {
        // Subtract offset to effectively move the sorting position
        return Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
    }

    // Public method to get current sorting order
    public int GetCurrentSortOrder()
    {
        if (spriteRenderer == null) return 0;
        return spriteRenderer.sortingOrder;
    }

    // Public method to set sorting order directly if needed
    public void SetSortingOrder(int order)
    {
        if (spriteRenderer != null)
            spriteRenderer.sortingOrder = order;
    }

    // Public method to set the parent Y coordinate usage flag
    // This eliminates the need for reflection in other scripts
    public void SetUseParentYCoordinate(bool value)
    {
        useParentYCoordinate = value;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\UIManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Core/UIManager.cs
using UnityEngine;
using UnityEngine.UI;

public class UIManager : MonoBehaviour
{
    public static UIManager Instance { get; private set; }

    [Header("Phase Panels (Assign in Inspector)")]
    [SerializeField] private GameObject planningPanel;
    [SerializeField] private GameObject growthAndThreatPanel;
    [SerializeField] private GameObject recoveryPanel;

    [Header("Buttons (Assign in Inspector)")]
    [SerializeField] private Button startGrowthPhaseButton;
    [SerializeField] private Button startRecoveryPhaseButton;
    [SerializeField] private Button startNewPlanningPhaseButton;

    [Header("Node Editor Integration")]
    [SerializeField] private GameObject nodeEditorPanel;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    private void Start()
    {
        // ENSURE PLANNING PANEL IS ACTIVE FIRST FOR INVENTORY INITIALIZATION
        if (planningPanel != null) 
        {
            planningPanel.SetActive(true);
            if (nodeEditorPanel != null) nodeEditorPanel.SetActive(true);
        }

        if (RunManager.Instance == null)
        {
            Debug.LogError("[UIManager] RunManager.Instance not found! UI will not function correctly.");
            return;
        }

        RunManager.Instance.OnRunStateChanged += HandleRunStateChanged;

        // Setup button listeners
        if (startGrowthPhaseButton != null)
            startGrowthPhaseButton.onClick.AddListener(OnStartGrowthPhaseClicked);
        else Debug.LogError("[UIManager] Start Growth Phase Button not assigned!");

        if (startRecoveryPhaseButton != null)
            startRecoveryPhaseButton.onClick.AddListener(OnStartRecoveryPhaseClicked);

        if (startNewPlanningPhaseButton != null)
            startNewPlanningPhaseButton.onClick.AddListener(OnStartNewPlanningPhaseClicked);
        else Debug.LogError("[UIManager] Start New Planning Phase Button not assigned!");
        
        // Initial UI setup - this will be called after inventory is initialized
        HandleRunStateChanged(RunManager.Instance.CurrentState);
    }

    private void OnDestroy()
    {
        if (RunManager.Instance != null)
        {
            RunManager.Instance.OnRunStateChanged -= HandleRunStateChanged;
        }

        if (startGrowthPhaseButton != null) startGrowthPhaseButton.onClick.RemoveAllListeners();
        if (startRecoveryPhaseButton != null) startRecoveryPhaseButton.onClick.RemoveAllListeners();
        if (startNewPlanningPhaseButton != null) startNewPlanningPhaseButton.onClick.RemoveAllListeners();
    }

    private void HandleRunStateChanged(RunState newState)
    {
        Debug.Log($"[UIManager] Handling state change to: {newState}");

        switch (newState)
        {
            case RunState.Planning:
                // Activate planning panel and inventory grid
                if (planningPanel != null) planningPanel.SetActive(true);
                if (nodeEditorPanel != null) nodeEditorPanel.SetActive(true);
                
                if (InventoryGridController.Instance != null) 
                    InventoryGridController.Instance.gameObject.SetActive(true);
                if (InventoryBarController.Instance != null) 
                    InventoryBarController.Instance.HideBar();
                
                // Hide other panels
                if (growthAndThreatPanel != null) growthAndThreatPanel.SetActive(false);
                if (recoveryPanel != null) recoveryPanel.SetActive(false);
                
                // Button states
                if (startGrowthPhaseButton != null) startGrowthPhaseButton.interactable = true;
                if (startRecoveryPhaseButton != null) startRecoveryPhaseButton.interactable = false;
                if (startNewPlanningPhaseButton != null) startNewPlanningPhaseButton.interactable = false;
                break;
                
            case RunState.GrowthAndThreat:
                // FIXED: Hide planning panel first, then show growth panel
                if (planningPanel != null) planningPanel.SetActive(false);
                if (nodeEditorPanel != null) nodeEditorPanel.SetActive(false);
                
                // Activate growth panel and inventory bar
                if (growthAndThreatPanel != null) growthAndThreatPanel.SetActive(true);
                
                if (InventoryGridController.Instance != null) 
                    InventoryGridController.Instance.gameObject.SetActive(false);
                    
                // FIXED: Add safety check and delay for inventory bar
                if (InventoryBarController.Instance != null) 
                {
                    // Small delay to ensure inventory is properly initialized before showing bar
                    StartCoroutine(ShowInventoryBarDelayed());
                }
                
                // Hide recovery panel
                if (recoveryPanel != null) recoveryPanel.SetActive(false);
                
                // Button states
                if (startGrowthPhaseButton != null) startGrowthPhaseButton.interactable = false;
                if (startRecoveryPhaseButton != null) startRecoveryPhaseButton.interactable = true;
                if (startNewPlanningPhaseButton != null) startNewPlanningPhaseButton.interactable = false;
                break;
                
            case RunState.Recovery:
                // Activate recovery panel
                if (recoveryPanel != null) recoveryPanel.SetActive(true);
                
                // Hide both inventory systems
                if (InventoryGridController.Instance != null) 
                    InventoryGridController.Instance.gameObject.SetActive(false);
                if (InventoryBarController.Instance != null) 
                    InventoryBarController.Instance.HideBar();
                
                // Hide other panels
                if (planningPanel != null) planningPanel.SetActive(false);
                if (nodeEditorPanel != null) nodeEditorPanel.SetActive(false);
                if (growthAndThreatPanel != null) growthAndThreatPanel.SetActive(false);
                
                // Button states
                if (startGrowthPhaseButton != null) startGrowthPhaseButton.interactable = false;
                if (startRecoveryPhaseButton != null) startRecoveryPhaseButton.interactable = false;
                if (startNewPlanningPhaseButton != null) startNewPlanningPhaseButton.interactable = true;
                break;
        }
    }
    
    // FIXED: Add coroutine to safely show inventory bar with delay
    private System.Collections.IEnumerator ShowInventoryBarDelayed()
    {
        // Wait one frame to ensure everything is properly set up
        yield return null;
        
        if (InventoryBarController.Instance != null)
        {
            try
            {
                InventoryBarController.Instance.ShowBar();
                Debug.Log("[UIManager] Successfully showed inventory bar after delay");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"[UIManager] Error showing inventory bar: {e.Message}\n{e.StackTrace}");
            }
        }
    }

    private void OnStartGrowthPhaseClicked()
    {
        Debug.Log("[UIManager] StartGrowthPhaseButton Clicked");
        RunManager.Instance?.StartGrowthAndThreatPhase();
    }

    private void OnStartRecoveryPhaseClicked()
    {
        Debug.Log("[UIManager] StartRecoveryPhaseButton Clicked");
        RunManager.Instance?.StartRecoveryPhase();
    }

    private void OnStartNewPlanningPhaseClicked()
    {
        Debug.Log("[UIManager] StartNewPlanningPhaseButton Clicked");
        RunManager.Instance?.StartNewPlanningPhase();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "Animal_", menuName = "Ecosystem/Animal Definition (Simplified)")]
public class AnimalDefinition : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("The species name (e.g., 'Bunny', 'Fox').")]
    public string animalName = "DefaultAnimal";

    [Header("Core Stats")]
    public float maxHealth = 10f; // Keep health for potential future damage/predators
    public float movementSpeed = 2f;

    [Header("Diet")]
    [Tooltip("Reference to the AnimalDiet ScriptableObject defining eating habits.")]
    public AnimalDiet diet; // Needs to reference the simplified AnimalDiet SO

    [Header("Visuals")]
    [Tooltip("The prefab to instantiate for this animal.")]
    public GameObject prefab;

    // Removed meatFoodType
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "AnimalLibrary", menuName = "Ecosystem/Animal Library")]
public class AnimalLibrary : ScriptableObject
{
    public List<AnimalDefinition> animals;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using TMPro;

[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(SortableEntity))]
[RequireComponent(typeof(Collider2D))]
public class AnimalController : MonoBehaviour
{
    // --- Fields ---
    private AnimalDefinition definition;
    private AnimalDiet animalDiet;
    
    [Header("Optional Features")]
    public AnimalThoughtLibrary thoughtLibrary;
    public GameObject thoughtBubblePrefab;
    public Transform bubbleSpawnTransform;
    public Transform poopSpawnPoint;
    public List<GameObject> poopPrefabs;
    public Animator animator;
    
    [Header("UI References")]
    [SerializeField] private TextMeshProUGUI hpText;
    [SerializeField] private TextMeshProUGUI hungerText; // NEW: Hunger text reference

    [Header("UI Settings")] // NEW HEADER
    [Tooltip("Which key to hold to display HP and Hunger texts")]
    [SerializeField] private KeyCode showStatsKey = KeyCode.LeftAlt; // NEW: Configurable key for showing stats
    
    [Header("Behavior Tuning")]
    public float searchRadius = 5f;
    public float eatDistance = 0.5f;
    public float eatDuration = 1.5f;
    [Range(0f, 1f)]
    public float wanderPauseChance = 0.3f;
    public float wanderMinMoveDuration = 1f;
    public float wanderMaxMoveDuration = 3f;
    public float wanderMinPauseDuration = 0.5f;
    public float wanderMaxPauseDuration = 2f;
    public float minPoopDelay = 5f;
    public float maxPoopDelay = 10f;
    public float poopDuration = 1f;
    public float poopColorVariation = 0.1f;
    public float thoughtCooldownTime = 5f;
    [SerializeField] private List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();
    [SerializeField] private List<ScentDefinition> repellentScentDefinitions = new List<ScentDefinition>();

    // --- NEW: Food reassessment timer fields ---
    [Header("Food Seeking Improvements")]
    [Tooltip("How often (in seconds) to reassess nearby food even when current target is valid")]
    public float foodReassessmentInterval = 0.5f;
    private float foodReassessmentTimer = 0f;

    // --- NEW: Starvation damage settings ---
    [Header("Starvation Settings")]
    [Tooltip("Damage per second when hunger is at maximum")]
    public float starvationDamageRate = 2f;

    // --- NEW: Visual feedback settings ---
    [Header("Visual Effects")]
    [Tooltip("Duration of red flash when taking damage")]
    public float damageFlashDuration = 0.2f;
    [Tooltip("Duration of fade out when dying")]
    public float deathFadeDuration = 1.5f;
    [Tooltip("Color to flash when taking damage")]
    public Color damageFlashColor = Color.red;

    // --- Internal State ---
    private float currentHealth;
    private float currentHunger;
    private GameObject currentTargetFood = null;
    private Vector2 moveDirection = Vector2.zero;
    private bool isEating = false;
    private float eatTimer = 0f;
    private bool isWanderPaused = false;
    private float wanderStateTimer = 0f;
    private bool isPooping = false;
    private float poopTimer = 0f;
    private float poopDelayTimer = 0f;
    private bool hasPooped = true;
    private float thoughtCooldownTimer = 0f;
    private bool isSeekingScreenCenter = false;
    private Vector2 screenCenterTarget;

    // --- NEW: Visual effect state ---
    private bool isDying = false;
    private Color originalColor;
    private bool isFlashing = false;

    // --- Component References ---
    private Rigidbody2D rb;
    private SpriteRenderer spriteRenderer;
    private Collider2D animalCollider;

    // --- Movement Bounds (Shifted Padded Screen Bounds) ---
    private Vector2 minBounds;
    private Vector2 maxBounds;

    // --- Public Accessors ---
    public float CurrentHealth => currentHealth;
    public string SpeciesName => definition ? definition.animalName : "Uninitialized";

    // --- NEW: Fields for slowdown system ---
    private float baseMovementSpeed;
    private List<float> activeSpeedMultipliers = new List<float>();

    // --- Initialize ---
    public void Initialize(AnimalDefinition def, Vector2 shiftedMinBounds, Vector2 shiftedMaxBounds, bool spawnedOffscreen = false)
    {
        definition = def; 
        if (definition == null) { Destroy(gameObject); return; }
        
        animalDiet = def.diet; 
        if (animalDiet == null) { enabled = false; return; }
        
        rb = GetComponent<Rigidbody2D>(); 
        spriteRenderer = GetComponentInChildren<SpriteRenderer>(); 
        animalCollider = GetComponent<Collider2D>();
        
        if (animalCollider == null) 
        { 
            Debug.LogError($"[{gameObject.name}] Missing Collider2D!", gameObject); 
            enabled = false; 
            return; 
        }

        // Store original color for visual effects
        if (spriteRenderer != null)
        {
            originalColor = spriteRenderer.color;
        }

        // Store base movement speed - NEW
        baseMovementSpeed = definition.movementSpeed;
        activeSpeedMultipliers.Clear(); // NEW

        currentHealth = definition.maxHealth;
        currentHunger = 0f;
        hasPooped = true;
        poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);
        foodReassessmentTimer = Random.Range(0f, foodReassessmentInterval); // Randomize initial timer

        // Store the SHIFTED bounds received from FaunaManager
        minBounds = shiftedMinBounds;
        maxBounds = shiftedMaxBounds;
        
        // Calculate the target center based on the SHIFTED bounds
        screenCenterTarget = (minBounds + maxBounds) / 2f;

        isSeekingScreenCenter = spawnedOffscreen;
        if (isSeekingScreenCenter)
        {
            if(Debug.isDebugBuild) 
                Debug.Log($"[{gameObject.name} Initialize] Offscreen spawn. Seeking SHIFTED center ({screenCenterTarget}). SHIFTED Bounds: min{minBounds}, max{maxBounds}", gameObject);
            
            moveDirection = (screenCenterTarget - (Vector2)transform.position).normalized;
            if (moveDirection == Vector2.zero) 
                moveDirection = Random.insideUnitCircle.normalized;
        }
    
        EnsureUITextReferences();
    
        // Hide text elements initially
        SetStatsTextVisibility(false);
    
        UpdateHpText(); 
        UpdateHungerText();
    
        if (spriteRenderer == null) { /* Warning */ }
    }
    
    private void EnsureUITextReferences() 
    { 
        if (hpText == null) 
        {
            hpText = GetComponentInChildren<TextMeshProUGUI>(true);
            // If we found a TMP_Text but it should be for HP, don't assign it to both
            if (hpText != null && hpText.gameObject.name.Contains("Hunger"))
            {
                hungerText = hpText;
                hpText = null;
            }
        }
    
        if (hungerText == null)
        {
            // Try to find any TextMeshProUGUI component that's not the HP text
            TextMeshProUGUI[] allTexts = GetComponentsInChildren<TextMeshProUGUI>(true);
            foreach (var text in allTexts)
            {
                if (text != hpText)
                {
                    hungerText = text;
                    break;
                }
            }
        }
    }

    // --- Update ---
    void Update()
    {
        if (!enabled || rb == null || isDying) return;

        // Check for ALT key (or configured key) press to show/hide stats
        bool showStats = Input.GetKey(showStatsKey);
        SetStatsTextVisibility(showStats);

        if (isSeekingScreenCenter)
        {
            Vector2 currentPos = rb.position;
            // Check if center is within the SHIFTED padded bounds
            bool centerWithinBounds =
                currentPos.x >= minBounds.x && currentPos.x <= maxBounds.x &&
                currentPos.y >= minBounds.y && currentPos.y <= maxBounds.y;

            if (centerWithinBounds)
            {
                if(Debug.isDebugBuild) 
                    Debug.Log($"[{gameObject.name} Update] Center reached SHIFTED bounds! Pos: {currentPos}. MinB: {minBounds}, MaxB: {maxBounds}. Switching to normal AI.", gameObject);
                
                isSeekingScreenCenter = false;
                moveDirection = Vector2.zero;
            }
            else
            {
                // Seek the SHIFTED center target
                moveDirection = (screenCenterTarget - currentPos).normalized;
                if (moveDirection == Vector2.zero) 
                    moveDirection = Random.insideUnitCircle.normalized;
                
                FlipSpriteBasedOnDirection();
                UpdateAnimationState();
                return; // Skip normal AI
            }
        }

        // Normal AI Logic
        UpdateHunger();
        HandlePooping();
        UpdateThoughts();
        
        if (isEating) 
        { 
            HandleEating(); 
            moveDirection = Vector2.zero; 
        }
        else if (isPooping) 
        { 
            moveDirection = Vector2.zero; 
        }
        else 
        { 
            DecideNextAction(); 
        }

        FlipSpriteBasedOnDirection();
        UpdateAnimationState();
    }
    
    private void SetStatsTextVisibility(bool visible)
    {
        if (hpText != null)
        {
            hpText.gameObject.SetActive(visible);
        }
    
        if (hungerText != null)
        {
            hungerText.gameObject.SetActive(visible);
        }
    }

    // --- FixedUpdate ---
    void FixedUpdate()
    {
        if (rb == null || isDying) return;
        
        if (!isEating && !isPooping && moveDirection != Vector2.zero)
        {
            Vector2 currentPos = rb.position;
            Vector2 desiredMove = moveDirection.normalized * definition.movementSpeed * Time.fixedDeltaTime;
            Vector2 nextPos = currentPos + desiredMove;

            if (!isSeekingScreenCenter) // Clamp only when NOT seeking
            {
                // Clamp the CENTER position using the SHIFTED bounds
                nextPos.x = Mathf.Clamp(nextPos.x, minBounds.x, maxBounds.x);
                nextPos.y = Mathf.Clamp(nextPos.y, minBounds.y, maxBounds.y);
            }
            rb.MovePosition(nextPos);
        }
    }

    void UpdateHunger() 
    { 
        currentHunger += animalDiet.hungerIncreaseRate * Time.deltaTime; 
        currentHunger = Mathf.Min(currentHunger, animalDiet.maxHunger);
        
        // Check for starvation damage when hunger reaches maximum
        if (currentHunger >= animalDiet.maxHunger)
        {
            ApplyStarvationDamage();
        }
        
        // Update hunger text when hunger changes
        UpdateHungerText();
    }
    
    void ApplyStarvationDamage() 
    { 
        // Apply damage over time when starving
        float damage = starvationDamageRate * Time.deltaTime;
        currentHealth -= damage;
        currentHealth = Mathf.Max(0f, currentHealth);
        
        // Flash red when taking damage
        if (!isFlashing)
        {
            StartCoroutine(FlashDamage());
        }
        
        UpdateHpText();
        
        // Die if health reaches zero
        if (currentHealth <= 0f)
        {
            Die(CauseOfDeath.Starvation);
        }
    }
    
    // --- NEW: Visual effect coroutines ---
    private IEnumerator FlashDamage()
    {
        if (spriteRenderer == null) yield break;
        
        isFlashing = true;
        spriteRenderer.color = damageFlashColor;
        yield return new WaitForSeconds(damageFlashDuration);
        spriteRenderer.color = originalColor;
        isFlashing = false;
    }
    
    private IEnumerator FadeOutAndDestroy()
    {
        if (spriteRenderer == null)
        {
            Destroy(gameObject);
            yield break;
        }
        
        isDying = true;
        float elapsedTime = 0f;
        Color startColor = spriteRenderer.color;
        
        while (elapsedTime < deathFadeDuration)
        {
            elapsedTime += Time.deltaTime;
            float alpha = Mathf.Lerp(startColor.a, 0f, elapsedTime / deathFadeDuration);
            spriteRenderer.color = new Color(startColor.r, startColor.g, startColor.b, alpha);
            yield return null;
        }
        
        Destroy(gameObject);
    }
    
    void HandlePooping() 
    { 
        if (!isEating && !hasPooped) 
        { 
            poopDelayTimer -= Time.deltaTime; 
            if (!isPooping && poopDelayTimer <= 0f) 
            { 
                StartPooping(); 
            } 
            if (isPooping) 
            { 
                poopTimer -= Time.deltaTime; 
                if (poopTimer <= 0f) 
                { 
                    FinishPooping(); 
                } 
            } 
        } 
    }
    
    void UpdateThoughts() 
    { 
        if (thoughtCooldownTimer > 0) 
        { 
            thoughtCooldownTimer -= Time.deltaTime; 
        } 
    }
    
    void DecideNextAction() 
    { 
        if (currentHunger >= animalDiet.hungerThreshold) 
        { 
            SeekFood(); 
        } 
        else 
        { 
            Wander(); 
            currentTargetFood = null; 
        } 
    }
    
    // --- Food seeking with periodic reassessment ---
    void SeekFood() 
    { 
        if (CanShowThought()) ShowThought(ThoughtTrigger.Hungry);
        
        // Reassess food periodically even if current target is valid
        foodReassessmentTimer -= Time.deltaTime;
        bool shouldReassess = foodReassessmentTimer <= 0f;
        bool targetValid = currentTargetFood != null && currentTargetFood.activeInHierarchy && 
                          currentTargetFood.GetComponent<FoodItem>() != null;
        
        // Reassess when timer expires or if target is invalid
        if (shouldReassess || !targetValid) 
        {
            // Store position of old target for comparison
            Vector3 oldTargetPosition = targetValid ? currentTargetFood.transform.position : Vector3.zero;
            
            // Find potentially better food
            GameObject potentialBetterFood = FindNearestFood();
            
            if (potentialBetterFood != null) 
            {
                // Always switch to new target if no current target
                if (!targetValid) 
                {
                    currentTargetFood = potentialBetterFood;
                    if(Debug.isDebugBuild) 
                        Debug.Log($"[{gameObject.name} SeekFood] Found new food target (no previous): {potentialBetterFood.name}");
                }
                // Switch to new target if it's better than current
                else if (potentialBetterFood != currentTargetFood) 
                {
                    // Get preferences for comparison
                    FoodItem currentFoodItem = currentTargetFood.GetComponent<FoodItem>();
                    FoodItem newFoodItem = potentialBetterFood.GetComponent<FoodItem>();
                    
                    if (currentFoodItem != null && newFoodItem != null) 
                    {
                        float currentPriority = animalDiet.GetPreference(currentFoodItem.foodType)?.preferencePriority ?? 0f;
                        float newPriority = animalDiet.GetPreference(newFoodItem.foodType)?.preferencePriority ?? 0f;
                        
                        // Switch if new food has higher priority
                        if (newPriority > currentPriority) 
                        {
                            if(Debug.isDebugBuild) 
                                Debug.Log($"[{gameObject.name} SeekFood] Switching to higher priority food: {newFoodItem.foodType.foodName} (priority: {newPriority}) from {currentFoodItem.foodType.foodName} (priority: {currentPriority})");
                            
                            currentTargetFood = potentialBetterFood;
                        }
                    }
                }
            }
            
            // Reset timer
            foodReassessmentTimer = foodReassessmentInterval;
        }
        
        // Proceed with target as before
        if (currentTargetFood != null) 
        {
            MoveTowardFood(currentTargetFood);
        } 
        else 
        {
            Wander();
        }
    }

    GameObject FindNearestFood() 
    { 
        Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, searchRadius); 
        return animalDiet.FindBestFood(colliders, transform.position); 
    }
    
    void MoveTowardFood(GameObject foodObj) 
    { 
        if (foodObj == null) return; 
        
        float distance = Vector2.Distance(transform.position, foodObj.transform.position); 
        if (distance <= eatDistance) 
        { 
            StartEating(); 
        } 
        else 
        { 
            moveDirection = (foodObj.transform.position - transform.position).normalized; 
            isWanderPaused = false; 
            wanderStateTimer = 0f; 
        } 
    }
    
    void StartEating() 
    { 
        isEating = true; 
        eatTimer = eatDuration; 
        moveDirection = Vector2.zero; 
        if (CanShowThought()) ShowThought(ThoughtTrigger.Eating); 
    }
    
    void HandleEating() 
    { 
        eatTimer -= Time.deltaTime; 
        if (eatTimer <= 0f) 
        { 
            isEating = false; 
            FinishEatingAction(); 
        } 
    }
    
    void FinishEatingAction() 
    { 
        if (currentTargetFood == null) return; 
        
        FoodItem foodItem = currentTargetFood.GetComponent<FoodItem>(); 
        if (foodItem != null && foodItem.foodType != null) 
        { 
            float satiationGain = animalDiet.GetSatiationValue(foodItem.foodType); 
            currentHunger -= satiationGain; 
            currentHunger = Mathf.Max(0f, currentHunger); 
            Destroy(currentTargetFood); 
            hasPooped = false; 
            poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay); 
            currentTargetFood = null;
            // Update hunger text
            UpdateHungerText();
        } 
        else 
        { 
            currentTargetFood = null; 
        } 
    }
    
    void StartPooping() 
    { 
        isPooping = true; 
        poopTimer = poopDuration; 
        moveDirection = Vector2.zero; 
        if (CanShowThought()) ShowThought(ThoughtTrigger.Pooping); 
    }
    
    void FinishPooping() 
    { 
        SpawnPoop(); 
        isPooping = false; 
        hasPooped = true; 
    }
    
    void SpawnPoop() 
    { 
        if (poopPrefabs == null || poopPrefabs.Count == 0) return; 
        
        int index = Random.Range(0, poopPrefabs.Count); 
        GameObject prefab = poopPrefabs[index]; 
        if (prefab == null) return; 
        
        Transform spawnT = poopSpawnPoint ? poopSpawnPoint : transform; 
        GameObject poopObj = Instantiate(prefab, spawnT.position, Quaternion.identity); 
        
        SpriteRenderer sr = poopObj.GetComponent<SpriteRenderer>(); 
        if (sr != null) 
        { 
            sr.flipX = Random.value > 0.5f; 
            Color c = sr.color; 
            float v = poopColorVariation; 
            sr.color = new Color(
                Mathf.Clamp01(c.r + Random.Range(-v, v)),
                Mathf.Clamp01(c.g + Random.Range(-v, v)),
                Mathf.Clamp01(c.b + Random.Range(-v, v)),
                c.a
            ); 
        } 
        
        PoopController pc = poopObj.GetComponent<PoopController>() ?? poopObj.AddComponent<PoopController>(); 
        pc.Initialize(); 
    }
    
    void Wander() 
    { 
        if (wanderStateTimer <= 0f) 
        { 
            if (isWanderPaused) 
            { 
                isWanderPaused = false; 
                moveDirection = Random.insideUnitCircle.normalized; 
                wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration); 
            } 
            else 
            { 
                if (Random.value < wanderPauseChance) 
                { 
                    isWanderPaused = true; 
                    moveDirection = Vector2.zero; 
                    wanderStateTimer = Random.Range(wanderMinPauseDuration, wanderMaxPauseDuration); 
                } 
                else 
                { 
                    moveDirection = Random.insideUnitCircle.normalized; 
                    wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration); 
                } 
            } 
        } 
        else 
        { 
            wanderStateTimer -= Time.deltaTime; 
        } 
    }
    
    void FlipSpriteBasedOnDirection() 
    { 
        if (spriteRenderer != null && Mathf.Abs(moveDirection.x) > 0.01f) 
        { 
            spriteRenderer.flipX = moveDirection.x < 0; 
        } 
    }
    
    void UpdateAnimationState() 
    { 
        if (animator == null) return; 
        bool isMoving = !isEating && !isPooping && moveDirection.sqrMagnitude > 0.01f; 
        animator.SetBool("IsMoving", isMoving); 
        animator.SetBool("IsEating", isEating); 
    }
    
    bool CanShowThought() 
    { 
        return thoughtLibrary != null && thoughtBubblePrefab != null && thoughtCooldownTimer <= 0f; 
    }
    
    void ShowThought(ThoughtTrigger trigger) 
    { 
        if (thoughtLibrary == null || thoughtLibrary.allThoughts == null) return; 
        
        var entry = thoughtLibrary.allThoughts.FirstOrDefault(t => 
            t != null && t.speciesName == SpeciesName && t.trigger == trigger
        ); 
        
        if (entry != null && entry.lines != null && entry.lines.Count > 0) 
        { 
            string line = entry.lines[Random.Range(0, entry.lines.Count)]; 
            Transform spawnT = bubbleSpawnTransform ? bubbleSpawnTransform : transform; 
            GameObject bubbleGO = Instantiate(thoughtBubblePrefab, spawnT.position, Quaternion.identity, spawnT); 
            bubbleGO.transform.localPosition = Vector3.zero; 
            
            ThoughtBubbleController bubble = bubbleGO.GetComponent<ThoughtBubbleController>(); 
            if (bubble) 
            { 
                bubble.Initialize(line, spawnT, 2f); 
                thoughtCooldownTimer = thoughtCooldownTime; 
            } 
            else 
            { 
                Destroy(bubbleGO); 
            } 
        } 
    }
    
    public enum CauseOfDeath { Unknown, Starvation, EatenByPredator }
    
    private void Die(CauseOfDeath cause) 
    { 
        Debug.Log($"[{SpeciesName} died: {cause}]", gameObject);
        
        // Start fade out effect instead of immediate destruction
        StartCoroutine(FadeOutAndDestroy());
    }
    
    public bool SpeciesNameEquals(string other) 
    { 
        return definition != null && definition.animalName == other; 
    }
    
    private void UpdateHpText() 
    { 
        if (hpText == null || definition == null) return; 
        hpText.text = $"HP: {Mathf.FloorToInt(currentHealth)}/{Mathf.FloorToInt(definition.maxHealth)}"; 
    }
    
    private void UpdateHungerText()
    {
        if (hungerText == null || animalDiet == null) return;
        hungerText.text = $"Hunger: {Mathf.FloorToInt(currentHunger)}/{Mathf.FloorToInt(animalDiet.maxHunger)}";
    }

    // --- NEW METHODS FOR SLOWDOWN SYSTEM ---
    
    // Method to apply speed multiplier from SlowdownZone
    public void ApplySpeedMultiplier(float multiplier)
    {
        if (!activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Add(multiplier);
            UpdateMovementSpeed();
            
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Applied speed multiplier: {multiplier}. New speed: {definition.movementSpeed}");
            }
        }
    }

    // Method to remove speed multiplier when leaving SlowdownZone
    public void RemoveSpeedMultiplier(float multiplier)
    {
        if (activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Remove(multiplier);
            UpdateMovementSpeed();
            
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Removed speed multiplier: {multiplier}. New speed: {definition.movementSpeed}");
            }
        }
    }

    // Method to recalculate movement speed based on active multipliers
    private void UpdateMovementSpeed()
    {
        // Start with base speed (original speed from definition)
        float newSpeed = baseMovementSpeed;
        
        // Apply all active multipliers
        if (activeSpeedMultipliers.Count > 0)
        {
            // Use the most restrictive (lowest) multiplier
            float lowestMultiplier = 1.0f;
            foreach (float multiplier in activeSpeedMultipliers)
            {
                if (multiplier < lowestMultiplier)
                {
                    lowestMultiplier = multiplier;
                }
            }
            
            newSpeed *= lowestMultiplier;
        }
        
        // Update the definition's movement speed (which is used in FixedUpdate)
        definition.movementSpeed = newSpeed;
        
        // Optionally update animation speed to match movement
        if (animator != null)
        {
            float speedRatio = newSpeed / baseMovementSpeed;
            animator.speed = Mathf.Max(0.5f, speedRatio); // Don't go below half speed
        }
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalSpawnData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[System.Serializable]
public class AnimalSpawnData {
    public AnimalDefinition animalDefinition;
    [Range(0f, 1f)]
    [Tooltip("Spawn rate multiplier (0 = no spawn; lower values = less frequent spawns).")]
    public float spawnRateMultiplier = 1f;
    [Tooltip("Maximum number of this animal type allowed to be spawned (0 = no limit).")]
    public int maximumSpawned = 0;
    
    [HideInInspector]
    public float spawnTimer = 0f;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalThoughtLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "AnimalThoughtLibrary", menuName = "Ecosystem/Animal Thought Library")]
public class AnimalThoughtLibrary : ScriptableObject
{
    public List<AnimalThoughtLine> allThoughts;
}

[System.Serializable]
public class AnimalThoughtLine
{
    [Header("Which Animal?")]
    public string speciesName; // e.g. "Bunny", "Fox", "Bird"

    [Header("Trigger Condition")]
    public ThoughtTrigger trigger;

    [Header("Possible Lines to Randomly Choose From")]
    public List<string> lines;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\EcosystemManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/EcosystemManager.cs
using UnityEngine;

public class EcosystemManager : MonoBehaviour
{
    public static EcosystemManager Instance { get; private set; }

    [Header("Parent Transforms")]
    public Transform animalParent;
    public Transform plantParent;

    [Header("Libraries")]
    [Tooltip("Reference to the Scent Library asset.")]
    public ScentLibrary scentLibrary; // <<< ADDED

    [Header("Sorting Options")]
    public bool sortAnimalsBySpecies = true;
    public bool sortPlantsBySpecies = true;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // Validate Library Reference
        if (scentLibrary == null)
        {
            Debug.LogWarning($"[{nameof(EcosystemManager)}] Scent Library not assigned! Scent effects will not work.", this);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FaunaManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/FaunaManager.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class FaunaManager : MonoBehaviour
{
    [Header("Spawning Area (Global)")]
    [SerializeField] private Vector2 spawnCenter = Vector2.zero;
    [SerializeField] private Vector2 spawnAreaSize = new Vector2(20f, 10f);

    [Header("General Settings")]
    [SerializeField] private Transform ecosystemParent;
    [Tooltip("How far INSIDE the screen edge the effective animal movement bounds are.")]
    [SerializeField][Min(0f)] private float screenBoundsPadding = 0.5f;
    [Tooltip("How far OUTSIDE the screen edge the 'Offscreen' spawn area starts.")]
    [SerializeField][Min(0f)] private float offscreenSpawnMargin = 2.0f;

    [Header("Debugging")]
    [Tooltip("Show gizmos visualizing the Margin (Red) and Padding (Green) bounds.")]
    [SerializeField] private bool showBoundsGizmos = false;

    [Header("Functional Bounds Offset")]
    [Tooltip("Functional horizontal shift for gameplay bounds and spawning relative to camera view.")]
    [SerializeField][Range(-10f, 10f)] private float boundsOffsetX = 0f;
    [Tooltip("Functional vertical shift for gameplay bounds and spawning relative to camera view.")]
    [SerializeField][Range(-10f, 10f)] private float boundsOffsetY = 0f;

    private List<Coroutine> activeSpawnCoroutines = new List<Coroutine>();
    private Camera mainCamera; // Ensure this is assigned or found

    void Start()
    {
        InitializeManager();
    }

    void InitializeManager()
    {
        activeSpawnCoroutines.Clear();
        // Attempt to get camera from WaveManager first, then fallback
        if (WaveManager.Instance != null) mainCamera = WaveManager.Instance.GetMainCamera();
        if (mainCamera == null) mainCamera = Camera.main;
        if (mainCamera == null) Debug.LogError("[FaunaManager] Cannot find Main Camera!", this);

        if (ecosystemParent == null)
        {
            if (EcosystemManager.Instance != null && EcosystemManager.Instance.animalParent != null)
            {
                ecosystemParent = EcosystemManager.Instance.animalParent;
                Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned from EcosystemManager.animalParent.", this);
            }
            else
            {
                ecosystemParent = transform;
                Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned to self as fallback.", this);
            }
        }
    }

    public void ExecuteSpawnWave(WaveDefinition waveDef)
    {
        if (waveDef == null) { Debug.LogError("[FaunaManager] ExecuteSpawnWave called with null WaveDefinition!", this); return; }
        if (waveDef.spawnEntries == null || waveDef.spawnEntries.Count == 0) { Debug.LogWarning($"[FaunaManager] Wave '{waveDef.waveName}' has no spawn entries.", this); return; }

        Debug.Log($"[FaunaManager] Executing spawn for Wave: '{waveDef.waveName}'");
        // Stop any previously running spawn coroutines for this FaunaManager instance
        StopAllSpawnCoroutines(); // Ensures only one waveDef's entries are spawning at a time from this manager

        foreach (WaveSpawnEntry entry in waveDef.spawnEntries)
        {
            if (entry.animalDefinition == null) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', null AnimalDefinition for wave '{waveDef.waveName}'."); continue; }
            if (entry.spawnCount <= 0) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', Spawn Count <= 0 for wave '{waveDef.waveName}'."); continue; }

            // Check RunManager state before starting new coroutines
            if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat)
            {
                Debug.Log($"[FaunaManager] Halting further spawn entry processing for wave '{waveDef.waveName}', RunManager not in GrowthAndThreat state.");
                break; // Don't start new coroutines if not in the correct game state
            }

            WaveSpawnEntry currentEntry = entry; // Closure capture
            Coroutine spawnCoroutine = StartCoroutine(SpawnWaveEntryCoroutine(currentEntry, waveDef.waveName));
            activeSpawnCoroutines.Add(spawnCoroutine);
        }
        Debug.Log($"[FaunaManager] Started {activeSpawnCoroutines.Count} spawn entry coroutine(s) for '{waveDef.waveName}'.");
    }

    public void StopAllSpawnCoroutines()
    {
        if (activeSpawnCoroutines.Count > 0)
        {
            Debug.Log($"[FaunaManager] Stopping all ({activeSpawnCoroutines.Count}) active spawn coroutines.");
            foreach (Coroutine co in activeSpawnCoroutines)
            {
                if (co != null) StopCoroutine(co);
            }
            activeSpawnCoroutines.Clear();
        }
    }

    private IEnumerator SpawnWaveEntryCoroutine(WaveSpawnEntry entry, string waveNameForDebug)
    {
        if (entry.delayAfterSpawnTime > 0)
        {
            yield return new WaitForSeconds(entry.delayAfterSpawnTime);
        }

        for (int i = 0; i < entry.spawnCount; i++)
        {
            // Check RunManager state before each spawn
            if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat)
            {
                Debug.Log($"[FaunaManager] Halting spawn for entry '{entry.description}' in wave '{waveNameForDebug}', RunManager no longer in GrowthAndThreat state.");
                break; // Exit loop if game state changed
            }

            // WaveManager.IsRunActive is now less reliable here, use RunManager state.
            // if (WaveManager.Instance != null && !WaveManager.Instance.IsRunActive)
            // {
            //     Debug.Log($"[FaunaManager] Halting spawn '{entry.description}', run no longer active.");
            //     break;
            // }

            Vector2 spawnPos = CalculateSpawnPosition(entry.spawnLocationType, entry.spawnRadius);
            bool isOffscreen = entry.spawnLocationType == WaveSpawnLocationType.Offscreen;
            GameObject spawnedAnimal = SpawnAnimal(entry.animalDefinition, spawnPos, isOffscreen);

            if (entry.spawnInterval > 0 && i < entry.spawnCount - 1) // Don't wait after the last one
            {
                yield return new WaitForSeconds(entry.spawnInterval);
            }
        }
        // Coroutine completes, remove itself from the list if it was added
        // This removal is a bit tricky if coroutines are stopped externally.
        // A more robust way is to check `activeSpawnCoroutines.Remove(thisCoroutineInstance)`
        // but `thisCoroutineInstance` is not directly available here.
        // For simplicity, we'll rely on StopAllSpawnCoroutines to clear the list.
        // Or, pass the coroutine itself into this method and remove it.
        // For now, let's clear it more carefully in StopAll and on completion.
    }


    private Vector2 CalculateSpawnPosition(WaveSpawnLocationType locationType, float radius)
    {
        if (mainCamera == null) { Debug.LogError("[FaunaManager] Missing Main Camera for CalculateSpawnPosition!"); return spawnCenter; }

        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

        Vector2 spawnPos = Vector2.zero;
        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;

        switch (locationType)
        {
            case WaveSpawnLocationType.Offscreen:
                float marginMinX = effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin;
                float marginMaxX = effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin;
                float marginMinY = effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin;
                float marginMaxY = effectiveCamPos.y + camHeight / 2f + offscreenSpawnMargin;
                float extraOffset = 0.1f;
                int edge = Random.Range(0, 4);
                if (edge == 0) { spawnPos.x = marginMinX - extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
                else if (edge == 1) { spawnPos.x = marginMaxX + extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
                else if (edge == 2) { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMinY - extraOffset; }
                else { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMaxY + extraOffset; }
                break;

            case WaveSpawnLocationType.RandomNearPlayer:
                 Transform playerT = FindPlayerTransform();
                 if (playerT != null) {
                    spawnPos = (Vector2)playerT.position + Random.insideUnitCircle * radius;
                 } else {
                     Debug.LogWarning("[FaunaManager] Player not found for RandomNearPlayer. Falling back to Global.");
                     goto case WaveSpawnLocationType.GlobalSpawnArea;
                 }
                 break;

            case WaveSpawnLocationType.GlobalSpawnArea:
            default:
                spawnPos.x = effectiveCamPos.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
                spawnPos.y = effectiveCamPos.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
                break;
        }
        return spawnPos;
    }

    private Transform FindPlayerTransform()
    {
        // This can be simplified if player is consistently tagged or has a singleton reference
        GameObject playerGO = GameObject.FindGameObjectWithTag("Player");
        if (playerGO != null) return playerGO.transform;

        // Fallback or more specific searches
        PlayerTileInteractor pti = FindAnyObjectByType<PlayerTileInteractor>();
        if (pti != null) return pti.transform;

        GardenerController gc = FindAnyObjectByType<GardenerController>();
        if (gc != null) return gc.transform;

        return null;
    }

    private GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position, bool isOffscreenSpawn)
    {
        if (definition == null || definition.prefab == null) { Debug.LogError("[FaunaManager] Cannot spawn animal: null definition or prefab."); return null; }
        if (mainCamera == null) { Debug.LogError("[FaunaManager] Missing Main Camera for SpawnAnimal bounds calculation!"); return null; }

        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

        Vector2 minPaddedBounds, maxPaddedBounds;
        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;

        minPaddedBounds.x = effectiveCamPos.x - camWidth / 2f + screenBoundsPadding;
        maxPaddedBounds.x = effectiveCamPos.x + camWidth / 2f - screenBoundsPadding;
        minPaddedBounds.y = effectiveCamPos.y - camHeight / 2f + screenBoundsPadding;
        maxPaddedBounds.y = effectiveCamPos.y + camHeight / 2f - screenBoundsPadding;

        GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

        if (ecosystemParent != null)
        {
            Transform speciesParent = ecosystemParent;
            if (EcosystemManager.Instance != null && EcosystemManager.Instance.sortAnimalsBySpecies && !string.IsNullOrEmpty(definition.animalName))
            {
                speciesParent = ecosystemParent.Find(definition.animalName);
                if (speciesParent == null)
                {
                    GameObject subParentGO = new GameObject(definition.animalName);
                    subParentGO.transform.SetParent(ecosystemParent);
                    speciesParent = subParentGO.transform;
                }
            }
            animalObj.transform.SetParent(speciesParent);
        }

        AnimalController controller = animalObj.GetComponent<AnimalController>();
        if (controller != null) {
            controller.Initialize(definition, minPaddedBounds, maxPaddedBounds, isOffscreenSpawn);
        } else { Debug.LogError($"[FaunaManager] Spawned animal prefab '{definition.prefab.name}' missing AnimalController script!", animalObj); Destroy(animalObj); return null; }
        return animalObj;
    }

    void OnDrawGizmos()
    {
        if (!showBoundsGizmos || mainCamera == null) return;
        Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
        Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;
        float camHeight = mainCamera.orthographicSize * 2f;
        float camWidth = camHeight * mainCamera.aspect;
        Vector2 paddedMin = new Vector2(effectiveCamPos.x - camWidth / 2f + screenBoundsPadding, effectiveCamPos.y - camHeight / 2f + screenBoundsPadding);
        Vector2 paddedMax = new Vector2(effectiveCamPos.x + camWidth / 2f - screenBoundsPadding, effectiveCamPos.y + camHeight / 2f - screenBoundsPadding);
        DrawWireRectangleGizmo(paddedMin, paddedMax, Color.green);
        Vector2 marginMin = new Vector2(effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin, effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin);
        Vector2 marginMax = new Vector2(effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin, effectiveCamPos.y + camHeight / 2f - offscreenSpawnMargin);
        DrawWireRectangleGizmo(marginMin, marginMax, Color.red);
    }

    void DrawWireRectangleGizmo(Vector2 min, Vector2 max, Color color) { Gizmos.color = color; Gizmos.DrawLine(new Vector3(min.x, min.y, 0), new Vector3(max.x, min.y, 0)); Gizmos.DrawLine(new Vector3(max.x, min.y, 0), new Vector3(max.x, max.y, 0)); Gizmos.DrawLine(new Vector3(max.x, max.y, 0), new Vector3(min.x, max.y, 0)); Gizmos.DrawLine(new Vector3(min.x, max.y, 0), new Vector3(min.x, min.y, 0)); }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\FloraManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/FloraManager.cs
using UnityEngine;
using System.Collections.Generic; // Added for Dictionary
#if UNITY_EDITOR
using UnityEditor;
#endif

public class FloraManager : MonoBehaviour
{
    public static FloraManager Instance { get; private set; }

    [Header("Debugging - Scents")]
    [Tooltip("Show scent radii circle renderers in Game View during runtime.")]
    [SerializeField] private bool showScentRadiiRuntime = false;
    [SerializeField] private Color scentRadiusColorRuntime = Color.yellow;
    [SerializeField] private bool logGizmoCalls = false;
    [Space]
    [Tooltip("Prefab used to draw scent circles at runtime.")]
    [SerializeField] private GameObject circleVisualizerPrefab; // <<< ADDED
    [Tooltip("Parent transform for instantiated circle visualizers.")]
    [SerializeField] private Transform circleContainer; // <<< ADDED

    [Header("Debugging - Poop Absorption")] // <<< NEW HEADER
    [Tooltip("Show poop absorption radii circle renderers in Game View during runtime.")]
    [SerializeField] private bool showPoopAbsorptionRadiiRuntime = false;
    [Tooltip("Color of the poop absorption radius visualization.")]
    [SerializeField] private Color poopAbsorptionRadiusColorRuntime = new Color(0.6f, 0.4f, 0.2f, 0.5f); // Brown-ish color

    // --- Public Accessors ---
    public bool ShowScentRadiiRuntime => showScentRadiiRuntime;
    public Color ScentRadiusColorRuntime => scentRadiusColorRuntime;
    // <<< NEW ACCESSORS for poop absorption radius visualization >>>
    public bool ShowPoopAbsorptionRadiiRuntime => showPoopAbsorptionRadiiRuntime;
    public Color PoopAbsorptionRadiusColorRuntime => poopAbsorptionRadiusColorRuntime;

    // Dictionary to track circle visualizers per ScentSource
    private Dictionary<ScentSource, RuntimeCircleDrawer> activeCircleVisualizers = new Dictionary<ScentSource, RuntimeCircleDrawer>();
    // NEW: Dictionary to track poop absorption circle visualizers per PlantGrowth
    private Dictionary<PlantGrowth, RuntimeCircleDrawer> activePoopAbsorptionCircleVisualizers = new Dictionary<PlantGrowth, RuntimeCircleDrawer>();


    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Validate Debug Dependencies
        if (circleVisualizerPrefab == null) { Debug.LogError($"[{nameof(FloraManager)}] Circle Visualizer Prefab is not assigned!", this); }
        if (circleContainer == null) { Debug.LogError($"[{nameof(FloraManager)}] Circle Container transform is not assigned!", this); }
    }

     void Update() // Added Update loop
     {
         if (!Application.isPlaying) return;
         UpdateRuntimeCircleVisualizers();
         // NEW: Update poop absorption radius visualizers
         UpdatePoopAbsorptionCircleVisualizers();
     }

    void OnDestroy()
    {
        if (Instance == this) Instance = null;
        // Clean up any remaining visualizers when manager is destroyed
        foreach (var kvp in activeCircleVisualizers)
        {
            if (kvp.Value != null) Destroy(kvp.Value.gameObject);
        }
        activeCircleVisualizers.Clear();
        
        // NEW: Clean up poop absorption visualizers
        foreach (var kvp in activePoopAbsorptionCircleVisualizers)
        {
            if (kvp.Value != null) Destroy(kvp.Value.gameObject);
        }
        activePoopAbsorptionCircleVisualizers.Clear();
    }
    
    // NEW: Method to update poop absorption radius visualizers
    void UpdatePoopAbsorptionCircleVisualizers()
    {
        if (!Application.isPlaying) return;
        
        // Check if visualization is enabled
        bool showCircles = showPoopAbsorptionRadiiRuntime && circleVisualizerPrefab != null && circleContainer != null;
        
        if (!showCircles)
        {
            // If visualization is disabled, clean up any existing visualizers
            foreach (var kvp in activePoopAbsorptionCircleVisualizers)
            {
                if (kvp.Value != null) Destroy(kvp.Value.gameObject);
            }
            activePoopAbsorptionCircleVisualizers.Clear();
            return;
        }
        
        // Find all plants with the poop fertilizer effect
        PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
        HashSet<PlantGrowth> currentPlantsSet = new HashSet<PlantGrowth>(plants);
        
        // Track plants to remove (no longer exist or don't have the effect)
        List<PlantGrowth> plantsToRemove = new List<PlantGrowth>();
        
        // First, update existing visualizers
        foreach (var kvp in activePoopAbsorptionCircleVisualizers)
        {
            PlantGrowth plant = kvp.Key;
            RuntimeCircleDrawer drawer = kvp.Value;
            
            if (plant == null || drawer == null || !plant.gameObject.activeInHierarchy ||
                !currentPlantsSet.Contains(plant))
            {
                plantsToRemove.Add(plant);
                if (drawer != null) Destroy(drawer.gameObject);
                continue;
            }
            
            // Check if the plant still has a valid poop detection radius
            float poopRadius = GetPlantPoopDetectionRadius(plant);
            bool shouldShowThis = showCircles && poopRadius > 0.01f;
            
            if (shouldShowThis)
            {
                // Update drawer position and radius
                drawer.transform.position = plant.transform.position;
                drawer.UpdateCircle(poopRadius, poopAbsorptionRadiusColorRuntime);
            }
            else
            {
                drawer.HideCircle();
                plantsToRemove.Add(plant); // If radius is too small or zero, remove the visualizer
            }
        }
        
        // Remove plants that no longer need visualization
        foreach (var plant in plantsToRemove)
        {
            if (activePoopAbsorptionCircleVisualizers.TryGetValue(plant, out RuntimeCircleDrawer drawer))
            {
                if (drawer != null) Destroy(drawer.gameObject);
                activePoopAbsorptionCircleVisualizers.Remove(plant);
            }
        }
        
        // Create new visualizers for plants with poop fertilizer effect
        foreach (PlantGrowth plant in plants)
        {
            if (plant == null || activePoopAbsorptionCircleVisualizers.ContainsKey(plant)) continue;
            
            float poopRadius = GetPlantPoopDetectionRadius(plant);
            if (poopRadius <= 0.01f) continue; // Skip if radius is too small
            
            // Create new visualizer
            GameObject circleGO = Instantiate(circleVisualizerPrefab, plant.transform.position, 
                                             Quaternion.identity, circleContainer);
            RuntimeCircleDrawer newDrawer = circleGO.GetComponent<RuntimeCircleDrawer>();
            
            if (newDrawer != null)
            {
                newDrawer.UpdateCircle(poopRadius, poopAbsorptionRadiusColorRuntime);
                activePoopAbsorptionCircleVisualizers.Add(plant, newDrawer);
            }
            else
            {
                Debug.LogError($"Circle Visualizer Prefab '{circleVisualizerPrefab.name}' missing RuntimeCircleDrawer script!", circleVisualizerPrefab);
                Destroy(circleGO);
            }
        }
    }
    
    // NEW: Helper method to get poop detection radius from a plant
    private float GetPlantPoopDetectionRadius(PlantGrowth plant)
    {
        if (plant == null) return 0f;
        return plant.GetPoopDetectionRadius();
    }

    // --- Runtime Visualizer Update ---
    void UpdateRuntimeCircleVisualizers()
    {
        if (!Application.isPlaying) return; // Only run in play mode

        // Check if lines should be shown globally
        bool showCircles = showScentRadiiRuntime && circleVisualizerPrefab != null && circleContainer != null;

        // --- Update existing circles and create new ones ---
        // Use a temporary list to avoid modifying dictionary while iterating
        List<ScentSource> sourcesToRemove = new List<ScentSource>();

        foreach (var kvp in activeCircleVisualizers)
        {
            ScentSource source = kvp.Key;
            RuntimeCircleDrawer line = kvp.Value;

            if (source == null || line == null || !source.gameObject.activeInHierarchy) // Source or drawer destroyed unexpectedly
            {
                sourcesToRemove.Add(source); // Mark for removal
                if(line != null) Destroy(line.gameObject); // Destroy orphan drawer
                continue;
            }

            // Check if circles should be shown globally and if this source is valid
            bool shouldShowThis = showCircles && source.enabled && source.definition != null && source.EffectiveRadius > 0.01f;

            if (shouldShowThis)
            {
                 // Update drawer position to match source and update circle params
                 line.transform.position = source.transform.position;
                 line.transform.rotation = source.transform.rotation; // Match rotation? Optional.
                 line.UpdateCircle(source.EffectiveRadius, scentRadiusColorRuntime);
            }
            else
            {
                 line.HideCircle(); // Hide if shouldn't be shown
            }
        }

        // Remove entries for sources that are gone
        foreach (var source in sourcesToRemove)
        {
            if (activeCircleVisualizers.TryGetValue(source, out RuntimeCircleDrawer drawer) && drawer != null)
                Destroy(drawer.gameObject);
            activeCircleVisualizers.Remove(source);
        }

        // --- Add circles for new sources ---
        if (showCircles)
        {
            // Find all active ScentSources
            ScentSource[] currentSources = FindObjectsByType<ScentSource>(FindObjectsSortMode.None);
            
            foreach (ScentSource source in currentSources)
            {
                // Skip if already has a visualizer or is invalid
                if (source == null || activeCircleVisualizers.ContainsKey(source) || !source.enabled || 
                    source.definition == null || source.EffectiveRadius <= 0.01f) continue;

                 // Create new visualizer
                 GameObject circleGO = Instantiate(circleVisualizerPrefab, source.transform.position, 
                                                 source.transform.rotation, circleContainer);
                 RuntimeCircleDrawer newDrawer = circleGO.GetComponent<RuntimeCircleDrawer>();

                 if (newDrawer != null)
                 {
                      newDrawer.UpdateCircle(source.EffectiveRadius, scentRadiusColorRuntime);
                      activeCircleVisualizers.Add(source, newDrawer); // Add to tracking
                 }
                 else
                 {
                    Debug.LogError($"Circle Visualizer Prefab '{circleVisualizerPrefab.name}' is missing RuntimeCircleDrawer script!", circleVisualizerPrefab);
                    Destroy(circleGO);
                 }
            }
        }
        // --- Hide/Destroy all if global flag turned off ---
        else if (!showCircles && activeCircleVisualizers.Count > 0)
        {
             foreach (var kvp in activeCircleVisualizers)
             {
                 if (kvp.Value != null) Destroy(kvp.Value.gameObject);
             }
             activeCircleVisualizers.Clear();
        }
    }


    // --- Gizmo Drawing (Editor Visualization - Unchanged) ---
    #if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        // Use the runtime flag to ALSO control the editor gizmo
        if (showScentRadiiRuntime) {
             if (logGizmoCalls) { /*...*/ }
             Gizmos.color = scentRadiusColorRuntime; // Use runtime color for gizmo too
             ScentSource[] scentSources = FindObjectsByType<ScentSource>(FindObjectsSortMode.None);
             if (logGizmoCalls) { /*...*/ }
             int drawnCount = 0;
             foreach (ScentSource source in scentSources) {
                if (source == null || !source.enabled || source.definition == null) continue;
                float radius = source.EffectiveRadius;
                if (radius > 0.01f) { Gizmos.DrawWireSphere(source.transform.position, radius); drawnCount++; }
             }
             if (logGizmoCalls && drawnCount > 0) { /*...*/ }
             else if (logGizmoCalls && scentSources.Length > 0) { /*...*/ }
        }
        
        // NEW: Draw poop absorption radius in editor
        if (showPoopAbsorptionRadiiRuntime) {
             Gizmos.color = poopAbsorptionRadiusColorRuntime;
             PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
             int drawnCount = 0;
             
             foreach (PlantGrowth plant in plants) {
                if (plant == null) continue;
                float radius = GetPlantPoopDetectionRadius(plant);
                if (radius > 0.01f) {
                    Gizmos.DrawWireSphere(plant.transform.position, radius);
                    drawnCount++;
                }
             }
             
             if (logGizmoCalls && drawnCount > 0) {
                 Debug.Log($"[FloraManager] Drew {drawnCount} poop absorption radius gizmos");
             }
        }
    }
    #endif
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\PoopController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/PoopController.cs (Ensure Collider is Added)

using UnityEngine;
using TMPro;

[RequireComponent(typeof(Collider2D))] // Add RequireComponent for Collider2D
public class PoopController : MonoBehaviour
{
    [Tooltip("Total lifetime of this poop (in seconds) before disappearing.")]
    public float lifetime = 10f;
    [Tooltip("Duration at the end of the lifetime during which the poop fades out.")]
    public float fadeDuration = 2f;
    [Tooltip("Fadeout curve to control the alpha during fade-out. X axis goes from 0 (start of fade) to 1 (end of fade).")]
    public AnimationCurve fadeCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);

    private SpriteRenderer sr;
    private float timer = 0f;
    private Color initialColor;
    private Collider2D poopCollider; // Reference to the collider

    private void Awake()
    {
        sr = GetComponent<SpriteRenderer>();
        if (sr != null)
        {
            initialColor = sr.color;
        }
        
        // Ensure there's a collider and it's properly configured
        poopCollider = GetComponent<Collider2D>();
        if (poopCollider == null)
        {
            // If no collider exists, add a CircleCollider2D
            poopCollider = gameObject.AddComponent<CircleCollider2D>();
            Debug.Log($"Added CircleCollider2D to {gameObject.name} for poop detection", gameObject);
        }
        
        // Make sure it's a trigger so it doesn't block movement
        poopCollider.isTrigger = true;
    }

    private void Update()
    {
        timer += Time.deltaTime;
        if (timer >= lifetime)
        {
            Destroy(gameObject);
            return;
        }

        // If within fadeDuration at the end, apply fade-out using the fadeCurve.
        float remaining = lifetime - timer;
        if (remaining < fadeDuration && sr != null)
        {
            // Normalize fade time (0 = start, 1 = end)
            float t = 1f - (remaining / fadeDuration);
            float alphaMultiplier = fadeCurve.Evaluate(t);
            Color newColor = initialColor;
            newColor.a = alphaMultiplier;
            sr.color = newColor;
        }
    }

    // Initialize with default parameters if none are provided.
    public void Initialize(float lifetimeValue = -1f, float fadeDurationValue = -1f)
    {
        if (lifetimeValue > 0f)
            lifetime = lifetimeValue;
        if (fadeDurationValue > 0f)
            fadeDuration = fadeDurationValue;
        timer = 0f;
        if (sr != null)
            initialColor = sr.color;
            
        // Ensure collider is configured properly
        if (poopCollider == null)
        {
            poopCollider = GetComponent<Collider2D>();
            if (poopCollider == null)
            {
                poopCollider = gameObject.AddComponent<CircleCollider2D>();
            }
            poopCollider.isTrigger = true;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ScentSource.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/ScentSource.cs
using UnityEngine;

// No longer requires RuntimeCircleDrawer directly
// REMOVED: [RequireComponent(typeof(RuntimeCircleDrawer))]
public class ScentSource : MonoBehaviour
{
    [Header("Scent Definition")]
    [Tooltip("The base Scent Definition applied to this object.")]
    public ScentDefinition definition; // Assigned by PlantGrowth/Node effects

    [Header("Applied Modifiers")]
    [Tooltip("Bonus radius added by node effects.")]
    public float radiusModifier = 0f;
    [Tooltip("Bonus strength added by node effects.")]
    public float strengthModifier = 0f;

    // REMOVED: Debugging Reference private RuntimeCircleDrawer circleDrawer;

    // --- Calculated Effective Properties ---
    /// <summary> Gets the effective scent radius (Base Radius + Modifier), clamped >= 0. </summary>
    public float EffectiveRadius => Mathf.Max(0f, (definition != null ? definition.baseRadius : 0f) + radiusModifier);
    /// <summary> Gets the effective scent strength (Base Strength + Modifier), clamped >= 0. </summary>
    public float EffectiveStrength => Mathf.Max(0f, (definition != null ? definition.baseStrength : 0f) + strengthModifier);


    void Awake()
    {
        // No longer needs to get or manage the circle drawer component here
        // REMOVED: circleDrawer = GetComponent<RuntimeCircleDrawer>();
        // REMOVED: circleDrawer?.HideCircle();
    }

    // REMOVED: Update() method (FloraManager handles creating/updating/hiding the external visualizer)


    // Keep Gizmo for Editor visualization (runs independently of Update and runtime drawers)
    void OnDrawGizmosSelected()
    {
        float effectiveRadius = EffectiveRadius; // Calculate radius for gizmo

        if (definition != null) // Check if a definition is assigned
        {
            if (effectiveRadius > 0.01f) // Only draw if radius is meaningful
            {
                // Use definition name hash for consistent random color
                // Note: Random.InitState affects the *next* Random call globally,
                // which might be undesirable if other Gizmos rely on it.
                // A more robust way might be a custom color mapping or a simple hash function.
                // For simplicity, we'll keep Random.InitState for now.
                int prevState = Random.state.GetHashCode(); // Store previous state
                Random.InitState(definition.name.GetHashCode());
                Color gizmoColor = Random.ColorHSV(0f, 1f, 0.7f, 0.9f, 0.8f, 1f);
                gizmoColor.a = 0.3f; // Set alpha for gizmo
                Random.InitState(prevState); // Restore previous state

                Gizmos.color = gizmoColor;
                Gizmos.DrawWireSphere(transform.position, effectiveRadius);
            }
        }
        else // Draw default gray if no definition assigned yet
        {
            Gizmos.color = new Color(0.8f, 0.8f, 0.8f, 0.2f);
            Gizmos.DrawWireSphere(transform.position, 1f); // Default size for editor only
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\SlowdownZone.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets\Scripts\Ecosystem\Core\SlowdownZone.cs
using UnityEngine;
using System.Collections.Generic;

public class SlowdownZone : MonoBehaviour
{
    [Header("Slowdown Settings")]
    [Tooltip("How much to multiply movement speed by (0.5 = half speed)")]
    [Range(0.1f, 1.0f)]
    public float speedMultiplier = 0.5f;

    [Header("Collider Adjustment")]
    [Tooltip("How much to shrink the collider from its edges (in units). Only works with BoxCollider2D.")]
    [Range(0f, 1f)]
    public float colliderShrinkAmount = 0.2f; // Defaulted to 0.2f in original, if 0 no warning will show for non-BoxColliders

    [Header("Debug")]
    [SerializeField] private bool showDebugMessages = false;

    private Dictionary<int, AnimalController> affectedAnimals = new Dictionary<int, AnimalController>();
    private Dictionary<int, GardenerController> affectedPlayers = new Dictionary<int, GardenerController>();

    private Vector2 originalSize;
    private Vector2 originalOffset;
    private BoxCollider2D boxCollider; // Cached BoxCollider2D, null if not a BoxCollider2D

    private const float SHRINK_EPSILON = 0.001f; // For comparing colliderShrinkAmount against zero

    private void Awake()
    {
        Collider2D col = GetComponent<Collider2D>();
        if (col == null)
        {
            Debug.LogError($"SlowdownZone on '{gameObject.name}' requires a Collider2D component!", gameObject);
            enabled = false;
            return;
        }

        if (!col.isTrigger)
        {
            col.isTrigger = true;
            // Optional: Log that trigger was auto-enabled
            // if (showDebugMessages) Debug.Log($"SlowdownZone on '{gameObject.name}' automatically enabled isTrigger on its collider.");
        }

        boxCollider = col as BoxCollider2D; // Attempt to cast to BoxCollider2D

        if (boxCollider != null)
        {
            // It's a BoxCollider2D
            originalSize = boxCollider.size;
            originalOffset = boxCollider.offset;

            if (colliderShrinkAmount > SHRINK_EPSILON)
            {
                ShrinkCollider();
            }
            // No warning needed if it's a BoxCollider2D, regardless of shrinkAmount
        }
        else
        {
            // It's NOT a BoxCollider2D (e.g., TilemapCollider2D, PolygonCollider2D)
            if (colliderShrinkAmount > SHRINK_EPSILON) // Only warn if shrinking was actually intended
            {
               // Debug.LogWarning($"SlowdownZone on '{gameObject.name}' has a 'Collider Shrink Amount' of {colliderShrinkAmount} but is using a '{col.GetType().Name}'. This collider type does not support automatic shrinking. Shrinking will be ignored.", gameObject);
            }
            // If colliderShrinkAmount is 0 (or very close), no warning is issued, which is correct.
        }
    }

    private void ShrinkCollider()
    {
        if (boxCollider == null) return; // Should not happen if called correctly, but safety first

        Vector2 newSize = new Vector2(
            Mathf.Max(0.1f, originalSize.x - (colliderShrinkAmount * 2f)),
            Mathf.Max(0.1f, originalSize.y - (colliderShrinkAmount * 2f))
        );

        boxCollider.size = newSize;
        // Note: originalOffset is not changed by this shrinking method.

        if (showDebugMessages)
        {
            Debug.Log($"SlowdownZone on '{gameObject.name}': Shrunk BoxCollider2D from {originalSize} to {newSize}");
        }
    }

    private void RestoreCollider()
    {
        if (boxCollider == null) return;

        boxCollider.size = originalSize;
        boxCollider.offset = originalOffset; // Ensure offset is also restored

        if (showDebugMessages)
        {
            Debug.Log($"SlowdownZone on '{gameObject.name}': Restored BoxCollider2D to original size {originalSize} and offset {originalOffset}");
        }
    }

    private void OnValidate()
    {
        // This method is called in the editor when a script's properties are changed.
        // It's also called when the script is first loaded or a value is changed in the Inspector.

        // If we have a cached BoxCollider2D (meaning it was a BoxCollider2D at Awake)
        if (boxCollider != null)
        {
            if (colliderShrinkAmount > SHRINK_EPSILON)
            {
                // If playing, originalSize should be set. If not playing, Awake might not have run.
                // To be safe, only shrink if originalSize seems valid (not zero).
                if (originalSize != Vector2.zero || Application.isPlaying) // Application.isPlaying ensures Awake has run
                {
                     ShrinkCollider();
                }
                else if (showDebugMessages && !Application.isPlaying)
                {
                    // Debug.Log($"SlowdownZone OnValidate (Editor): '{gameObject.name}' BoxCollider2D detected, but originalSize not cached (Awake likely not run yet for this specific validation). Shrinking will apply on Play.");
                }
            }
            else // colliderShrinkAmount is effectively zero
            {
                // If originalSize is known, restore it.
                if (originalSize != Vector2.zero || Application.isPlaying)
                {
                    RestoreCollider();
                }
                else if (showDebugMessages && !Application.isPlaying)
                {
                    // Debug.Log($"SlowdownZone OnValidate (Editor): '{gameObject.name}' BoxCollider2D detected, shrink amount is zero, but originalSize not cached. Restoration will apply on Play if needed.");
                }
            }
        }
        // If boxCollider is null, it means it wasn't a BoxCollider2D at Awake (or Awake hasn't run).
        // In this case, OnValidate won't attempt to shrink or restore, aligning with Awake's logic.
        // The warning about non-BoxCollider shrinking (if applicable) is handled by Awake at runtime.
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        AnimalController animal = other.GetComponent<AnimalController>();
        if (animal != null)
        {
            int id = animal.GetInstanceID();
            if (!affectedAnimals.ContainsKey(id)) // Ensure not already added
            {
                affectedAnimals.Add(id, animal);
                animal.ApplySpeedMultiplier(speedMultiplier);
                if (showDebugMessages)
                    Debug.Log($"SlowdownZone: '{animal.name}' entered zone, applied multiplier {speedMultiplier}");
            }
            return;
        }

        GardenerController player = other.GetComponent<GardenerController>();
        if (player != null)
        {
            int id = player.GetInstanceID();
            if (!affectedPlayers.ContainsKey(id)) // Ensure not already added
            {
                affectedPlayers.Add(id, player);
                player.ApplySpeedMultiplier(speedMultiplier);
                if (showDebugMessages)
                    Debug.Log($"SlowdownZone: Player '{player.name}' entered zone, applied multiplier {speedMultiplier}");
            }
        }
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        AnimalController animal = other.GetComponent<AnimalController>();
        if (animal != null)
        {
            int id = animal.GetInstanceID();
            if (affectedAnimals.ContainsKey(id))
            {
                animal.RemoveSpeedMultiplier(speedMultiplier); // Call RemoveSpeedMultiplier on the animal
                affectedAnimals.Remove(id);
                if (showDebugMessages)
                    Debug.Log($"SlowdownZone: '{animal.name}' exited zone, removed multiplier");
            }
            return;
        }

        GardenerController player = other.GetComponent<GardenerController>();
        if (player != null)
        {
            int id = player.GetInstanceID();
            if (affectedPlayers.ContainsKey(id))
            {
                player.RemoveSpeedMultiplier(speedMultiplier); // Call RemoveSpeedMultiplier on the player
                affectedPlayers.Remove(id);
                if (showDebugMessages)
                    Debug.Log($"SlowdownZone: Player '{player.name}' exited zone, removed multiplier");
            }
        }
    }

    private void OnDestroy()
    {
        foreach (var animalEntry in affectedAnimals)
        {
            if (animalEntry.Value != null) // Check if animal still exists
            {
                animalEntry.Value.RemoveSpeedMultiplier(speedMultiplier);
            }
        }
        affectedAnimals.Clear();

        foreach (var playerEntry in affectedPlayers)
        {
            if (playerEntry.Value != null) // Check if player still exists
            {
                playerEntry.Value.RemoveSpeedMultiplier(speedMultiplier);
            }
        }
        affectedPlayers.Clear();

        // Restore collider on destroy if it was shrunk
        if (boxCollider != null && colliderShrinkAmount > SHRINK_EPSILON)
        {
             // Check if originalSize is valid before restoring.
             // This is mostly relevant if OnDestroy is called before Awake fully completes,
             // or if the object is destroyed from the editor without playing.
            if (originalSize != Vector2.zero)
            {
                RestoreCollider();
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtBubbleController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using TMPro;

public class ThoughtBubbleController : MonoBehaviour
{
    public TMP_Text messageText;
    public float lifetime = 2f;

    private Transform followTarget;

    public void Initialize(string message, Transform target, float duration = 2f)
    {
        if (messageText != null)
            messageText.text = message;
        followTarget = target;
        lifetime = duration;
    }

    private void Update()
    {
        lifetime -= Time.deltaTime;
        if (lifetime <= 0f)
            Destroy(gameObject);

        // Follow the target if needed (optional if already a child)
        if (followTarget != null)
        {
            transform.position = followTarget.position;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\ThoughtTrigger.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public enum ThoughtTrigger
{
    Hungry,
    Eating,
    HealthLow,
    Fleeing,
    Pooping,
    // Add more triggers as needed
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\WaveDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/WaveDefinition.cs
using UnityEngine;
using System.Collections.Generic;

// Enum WaveSpawnLocationType remains the same
public enum WaveSpawnLocationType
{
    GlobalSpawnArea,
    RandomNearPlayer,
    Offscreen
}

// Class WaveSpawnEntry remains the same
[System.Serializable]
public class WaveSpawnEntry
{
    [Tooltip("Optional description for this specific spawn group within the wave.")]
    public string description = "Spawn Group";
    [Tooltip("The type of animal to spawn.")]
    public AnimalDefinition animalDefinition;
    [Tooltip("How many of this animal to spawn in this specific entry.")]
    [Min(1)]
    public int spawnCount = 1;
    [Tooltip("Delay (in seconds) AFTER the designated wave spawn time (e.g. Day 50%) before *this entry* begins spawning.")] // Clarified Tooltip
    [Min(0)]
    public float delayAfterSpawnTime = 0f; // Renamed from delayAfterWaveStart
    [Tooltip("Time (in seconds) between spawning each individual animal in this entry (0 = spawn all instantly).")]
    [Min(0)]
    public float spawnInterval = 0.5f;
    [Tooltip("Where these animals should spawn.")]
    public WaveSpawnLocationType spawnLocationType = WaveSpawnLocationType.GlobalSpawnArea;
    [Tooltip("Radius used for spawning (e.g., if Spawn Location Type is RandomNearPlayer).")]
    [Min(0)]
    public float spawnRadius = 5f;
}

// WaveDefinition ScriptableObject is simplified further
[CreateAssetMenu(fileName = "Wave_", menuName = "Ecosystem/Wave Definition")]
public class WaveDefinition : ScriptableObject
{
    [Header("Wave Identification")]
    [Tooltip("Editor-only name for this wave.")]
    public string waveName = "New Wave";

    [Header("Wave Content")]
    [Tooltip("Define the groups of animals that spawn during this wave.")]
    public List<WaveSpawnEntry> spawnEntries = new List<WaveSpawnEntry>();

    // REMOVED all timing, duration, end condition, delay fields.
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\WaveManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/WaveManager.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using TMPro; // Keep for legacy UI if any part is still used
using UnityEngine.UI; // Keep for legacy UI

// Renamed internal state for clarity, as RunManager now controls overall game state
public enum InternalWaveState
{
    Idle,                // Not currently processing a wave
    WaitingForSpawnTime, // Wave active, waiting for correct time in WeatherManager cycle to spawn
    SpawningInProgress,  // FaunaManager has been told to execute spawn entries
    WaveActive           // Spawns done for this wave def, wave duration timer running (dayCyclesRemaining)
}

public class WaveManager : MonoBehaviour
{
    public static WaveManager Instance { get; private set; }

    [Header("Core Dependencies")]
    [SerializeField] private FaunaManager faunaManager;
    [SerializeField] private WeatherManager weatherManager;
    [SerializeField] private Camera mainCamera; // Keep for FaunaManager if it still needs it

    [Header("Wave Sequence (Played sequentially per round)")]
    [SerializeField] private List<WaveDefinition> wavesSequence;

    [Header("Wave Timing & Spawning (For a single WaveDefinition)")]
    [Tooltip("How many full Day+Night cycles each WaveDefinition lasts.")]
    [SerializeField][Range(1, 10)] private int waveDurationInDayCycles = 1;
    [Tooltip("The phase during which spawning should occur each cycle for the active WaveDefinition.")]
    [SerializeField] private WeatherManager.CyclePhase spawnStartPhase = WeatherManager.CyclePhase.Day;
    [Tooltip("The percentage progress within the Spawn Start Phase when spawning triggers (0-100).")]
    [SerializeField][Range(0f, 100f)] private float spawnStartPercentage = 50f;
    // REMOVED: loopSequence - RunManager handles overall game looping/progression
    [Tooltip("If checked, animals from the previous wave are destroyed when a new wave (within the same round or new round) starts.")]
    [SerializeField] private bool deletePreviousWaveAnimals = true;

    [Header("UI & Feedback (Legacy - May be replaced by UIManager)")]
    [SerializeField] private TextMeshProUGUI waveStatusText;
    [SerializeField] private TextMeshProUGUI timeTrackerText;
    // REMOVED: startRunButton - UIManager controls this

    [Header("State (Read Only - Internal)")]
    [SerializeField] private InternalWaveState currentInternalState = InternalWaveState.Idle;
    [SerializeField] private int activeWaveDefinitionIndex = -1; // Index within wavesSequence for the current round's wave

    private WaveDefinition currentActiveWaveDef = null;
    private int dayCyclesRemainingForThisWaveDef = 0;
    private bool hasSpawnedForThisWeatherCycle = false;
    private Coroutine activeWaveExecutionCoroutine; // To manage FaunaManager spawning for current WaveDef

    // Public property for RunManager to check
    public bool IsCurrentWaveDefeated()
    {
        // A wave is "defeated" if:
        // 1. It's in Idle state (meaning it finished or was never started properly for the round)
        // 2. OR its dayCyclesRemainingForThisWaveDef is <= 0 (duration met)
        //    AND no animals are left (this part is trickier and might need FaunaManager input)
        // For now, let's simplify: duration met means "wave part" is done.
        // RunManager might have additional conditions (like all animals cleared).
        bool durationMet = currentInternalState == InternalWaveState.WaveActive && dayCyclesRemainingForThisWaveDef <= 0;
        bool isIdle = currentInternalState == InternalWaveState.Idle;

        // For a more robust check, we'd also ask FaunaManager if any wave-spawned animals are left.
        // bool noActiveThreats = faunaManager != null ? faunaManager.AreAllSpawnedAnimalsDefeated() : true;
        // For now, relying on duration or being idle.
        if (isIdle && activeWaveDefinitionIndex != -1)
        {
            // This means a wave was processed and finished, ready for next.
            return true;
        }
        return durationMet;
    }


    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        if (faunaManager == null) Debug.LogError("[WaveManager] FaunaManager missing!", this);
        if (weatherManager == null) Debug.LogError("[WaveManager] WeatherManager missing!", this);
        // if (mainCamera == null) Debug.LogError("[WaveManager] Main Camera missing!", this); // Less critical now if FaunaManager has its own
        if (wavesSequence == null || wavesSequence.Count == 0) Debug.LogWarning("[WaveManager] Wave Sequence empty. No waves will spawn.", this);
    }

    void Start()
    {
        if (weatherManager != null) weatherManager.OnPhaseChanged += HandleWeatherPhaseChange;
        SetInternalState(InternalWaveState.Idle); // Start idle, wait for RunManager
    }

    void OnDestroy()
    {
        if (weatherManager != null) weatherManager.OnPhaseChanged -= HandleWeatherPhaseChange;
        StopAllCoroutines(); // Ensure any wave execution stops
    }

    private void SetInternalState(InternalWaveState newState)
    {
        if (currentInternalState == newState) return;
        if (Debug.isDebugBuild) Debug.Log($"[WaveManager] Internal State Change: {currentInternalState} -> {newState}");
        currentInternalState = newState;
        UpdateLegacyWaveStatusText();
    }

    public void StartWaveForRound(int roundNumber)
    {
        if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat)
        {
            Debug.LogWarning("[WaveManager] Attempted to StartWaveForRound, but RunManager not in GrowthAndThreat state.");
            return;
        }

        // Determine which wave definition to use for this round.
        // Simple approach: use roundNumber as an index (1-based round to 0-based index)
        // This assumes wavesSequence contains definitions for multiple rounds.
        activeWaveDefinitionIndex = roundNumber - 1;

        if (wavesSequence == null || activeWaveDefinitionIndex < 0 || activeWaveDefinitionIndex >= wavesSequence.Count)
        {
            Debug.LogWarning($"[WaveManager] No WaveDefinition for round {roundNumber} (index {activeWaveDefinitionIndex}). Max index: {(wavesSequence?.Count - 1) ?? -1}. No wave will start.");
            currentActiveWaveDef = null;
            SetInternalState(InternalWaveState.Idle); // Effectively, this round has no wave.
            return;
        }

        currentActiveWaveDef = wavesSequence[activeWaveDefinitionIndex];
        if (currentActiveWaveDef == null)
        {
            Debug.LogError($"[WaveManager] WaveDefinition at index {activeWaveDefinitionIndex} for round {roundNumber} is NULL.");
            SetInternalState(InternalWaveState.Idle);
            return;
        }

        if (deletePreviousWaveAnimals)
        {
            ClearAllActiveAnimals();
        }

        Debug.Log($"[WaveManager] Starting wave '{currentActiveWaveDef.waveName}' for Round {roundNumber}. Duration: {waveDurationInDayCycles} day cycles.");
        dayCyclesRemainingForThisWaveDef = waveDurationInDayCycles;
        hasSpawnedForThisWeatherCycle = false;
        SetInternalState(InternalWaveState.WaitingForSpawnTime);
        Update_WaitingForSpawnTimeCheck(); // Initial check in case conditions are already met
    }

    public void StopCurrentWaveSpawning()
    {
        Debug.Log("[WaveManager] StopCurrentWaveSpawning called (e.g., round ending).");
        if (activeWaveExecutionCoroutine != null)
        {
            StopCoroutine(activeWaveExecutionCoroutine);
            activeWaveExecutionCoroutine = null;
        }
        // FaunaManager itself should also stop its individual spawn coroutines if it has any running
        // from a previous ExecuteSpawnWave call that might not have completed all its entries.
        faunaManager?.StopAllSpawnCoroutines();
        SetInternalState(InternalWaveState.Idle); // Wave is considered done for this round.
    }

    void HandleWeatherPhaseChange(WeatherManager.CyclePhase newPhase)
    {
        if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat || currentActiveWaveDef == null) return;

        if (newPhase == WeatherManager.CyclePhase.TransitionToDay) // A new day starts
        {
            if (currentInternalState == InternalWaveState.WaveActive || currentInternalState == InternalWaveState.SpawningInProgress || currentInternalState == InternalWaveState.WaitingForSpawnTime)
            {
                dayCyclesRemainingForThisWaveDef--;
                hasSpawnedForThisWeatherCycle = false; // Reset for the new day cycle
                if (Debug.isDebugBuild) Debug.Log($"[WaveManager] Day cycle ended for wave '{currentActiveWaveDef.waveName}'. Cycles remaining: {dayCyclesRemainingForThisWaveDef}");

                if (dayCyclesRemainingForThisWaveDef <= 0)
                {
                    Debug.Log($"[WaveManager] Wave '{currentActiveWaveDef.waveName}' duration met. Marking as complete for this round.");
                    StopCurrentWaveSpawning(); // This will set state to Idle
                    // RunManager will detect IsCurrentWaveDefeated()
                }
                else
                {
                    // Still more days for this wave definition
                    SetInternalState(InternalWaveState.WaitingForSpawnTime);
                }
            }
        }
        // If the phase changed TO our spawnStartPhase, re-evaluate spawning
        else if (newPhase == spawnStartPhase && (currentInternalState == InternalWaveState.WaitingForSpawnTime || currentInternalState == InternalWaveState.WaveActive) )
        {
            Update_WaitingForSpawnTimeCheck();
        }
    }

    void Update_WaitingForSpawnTimeCheck()
    {
        if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat || currentActiveWaveDef == null) return;
        if (currentInternalState != InternalWaveState.WaitingForSpawnTime && currentInternalState != InternalWaveState.WaveActive) return; // Only proceed if waiting or already active (for subsequent day spawns)
        if (hasSpawnedForThisWeatherCycle) return; // Already spawned in this specific weather cycle

        if (weatherManager == null) return;
        WeatherManager.CyclePhase currentPhase = weatherManager.CurrentPhase;
        float totalPhaseTime = weatherManager.CurrentTotalPhaseTime;
        float remainingPhaseTime = weatherManager.CurrentPhaseTimer;
        float progressPercent = (totalPhaseTime > 0) ? (1f - (remainingPhaseTime / totalPhaseTime)) * 100f : 0f;

        if (currentPhase == spawnStartPhase && progressPercent >= spawnStartPercentage)
        {
            TriggerFaunaSpawning();
        }
    }

    private void TriggerFaunaSpawning()
    {
        if (currentActiveWaveDef == null) return;
        if (faunaManager == null) { Debug.LogError("[WaveManager] FaunaManager missing, cannot spawn!"); return; }

        Debug.Log($"[WaveManager] Spawning animals for WaveDefinition: '{currentActiveWaveDef.waveName}' (Phase: {spawnStartPhase} >= {spawnStartPercentage}%)");
        SetInternalState(InternalWaveState.SpawningInProgress); // Indicate spawning has started
        hasSpawnedForThisWeatherCycle = true; // Mark as spawned for *this* specific day's spawn window

        // FaunaManager's ExecuteSpawnWave will run its coroutines.
        // We might not need to hold onto the coroutine here if FaunaManager manages its own lifecycle.
        // However, if WaveDefinition contains multiple entries with delays,
        // ExecuteSpawnWave might be a long-running operation.
        faunaManager.ExecuteSpawnWave(currentActiveWaveDef);

        // After telling FaunaManager to spawn, transition to WaveActive.
        // This implies the wave is "active" for its duration, even if FaunaManager is still
        // trickling out spawns from the definition's entries.
        SetInternalState(InternalWaveState.WaveActive);
    }

    void ClearAllActiveAnimals()
    {
        if(Debug.isDebugBuild) Debug.Log("[WaveManager] Clearing all active animals.");
        AnimalController[] activeAnimals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
        int count = 0;
        foreach(AnimalController animal in activeAnimals)
        {
            if(animal != null) { Destroy(animal.gameObject); count++; }
        }
        if(Debug.isDebugBuild) Debug.Log($"[WaveManager] Destroyed {count} animals.");
    }

    public void ResetForNewRound()
    {
        Debug.Log("[WaveManager] Resetting for new round.");
        StopCurrentWaveSpawning(); // Stop any ongoing coroutines and clear FaunaManager
        if (deletePreviousWaveAnimals) // This flag can decide if animals carry over or not
        {
            ClearAllActiveAnimals();
        }
        currentActiveWaveDef = null;
        activeWaveDefinitionIndex = -1;
        dayCyclesRemainingForThisWaveDef = 0;
        hasSpawnedForThisWeatherCycle = false;
        SetInternalState(InternalWaveState.Idle);
    }

    // --- Legacy UI Update Methods (can be phased out if UIManager takes full control) ---
    void Update() // Keep this for legacy UI or other periodic checks if necessary
    {
        if (RunManager.Instance?.CurrentState == RunState.GrowthAndThreat)
        {
            // If we are in WaitingForSpawnTime, constantly check if conditions are met
            if (currentInternalState == InternalWaveState.WaitingForSpawnTime)
            {
                Update_WaitingForSpawnTimeCheck();
            }
        }
        UpdateLegacyTimeTrackerUI();
        UpdateLegacyWaveStatusText();
    }

    private void UpdateLegacyTimeTrackerUI()
    {
        if (timeTrackerText == null || weatherManager == null) return;
        // ... (same as before, but consider if this UI is still needed)
        WeatherManager.CyclePhase phase = weatherManager.CurrentPhase;
        float total = weatherManager.CurrentTotalPhaseTime;
        float remaining = weatherManager.CurrentPhaseTimer;
        float progressPercent = (total > 0) ? (1f - (remaining / total)) * 100f : 0f;
        string phaseName = phase.ToString().Replace("Transition", "");
        timeTrackerText.text = $"{phaseName} [{progressPercent:F0}%]";
         if (RunManager.Instance != null)
         {
            if(RunManager.Instance.CurrentState == RunState.Planning) timeTrackerText.text += " (Planning)";
            else if(RunManager.Instance.CurrentState == RunState.Recovery) timeTrackerText.text += " (Recovery)";
         }
    }

    private void UpdateLegacyWaveStatusText()
    {
        if (waveStatusText == null) return;
        if (RunManager.Instance == null) return;

        if (RunManager.Instance.CurrentState == RunState.Planning)
        {
            waveStatusText.text = $"Prepare for Round {RunManager.Instance.CurrentRoundNumber}";
        }
        else if (RunManager.Instance.CurrentState == RunState.GrowthAndThreat)
        {
            if (currentActiveWaveDef != null)
            {
                string waveNamePart = string.IsNullOrEmpty(currentActiveWaveDef.waveName) ? $"Wave {activeWaveDefinitionIndex + 1}" : currentActiveWaveDef.waveName;
                if (currentInternalState == InternalWaveState.WaitingForSpawnTime)
                    waveStatusText.text = $"{waveNamePart} - Waiting...";
                else if (currentInternalState == InternalWaveState.SpawningInProgress)
                    waveStatusText.text = $"{waveNamePart} - Spawning...";
                else if (currentInternalState == InternalWaveState.WaveActive)
                    waveStatusText.text = $"{waveNamePart} [{dayCyclesRemainingForThisWaveDef} cycles left]";
                else if (currentInternalState == InternalWaveState.Idle && dayCyclesRemainingForThisWaveDef <=0) // Wave finished
                     waveStatusText.text = $"{waveNamePart} - Cleared";
            }
            else if (currentInternalState == InternalWaveState.Idle) // No wave for this round, or sequence finished
            {
                waveStatusText.text = "All waves for round complete.";
            }
        }
        else if (RunManager.Instance.CurrentState == RunState.Recovery)
        {
            waveStatusText.text = "Round Recovering";
        }
    }
    public Camera GetMainCamera() { return mainCamera; } // If FaunaManager still needs it via WaveManager
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Effects\FireflyController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Rendering.Universal;
using System.Collections.Generic;

public class FireflyController : MonoBehaviour
{
    [Header("References (Optional)")]
    [Tooltip("Optional Light2D component for local glow.")]
    [SerializeField] private Light2D pointLight;
    [Tooltip("SpriteRenderer for flickering emission and alpha fade.")]
    [SerializeField] private SpriteRenderer spriteRenderer;

    [Header("Movement")]
    [Tooltip("Min/Max movement speed")]
    [SerializeField] private Vector2 speedRange = new Vector2(0.5f, 1.5f);
    [Tooltip("How often (in seconds) the firefly changes direction while wandering")]
    [SerializeField] private float directionChangeInterval = 2.0f;
    [Tooltip("Chance (0-1) that the firefly will pause when changing direction")]
    [SerializeField] [Range(0f, 1f)] private float pauseChance = 0.2f;
    [Tooltip("Min/Max duration (in seconds) for pauses")]
    [SerializeField] private Vector2 pauseDurationRange = new Vector2(0.5f, 1.5f);

    [Header("Lifetime & Fade")]
    [Tooltip("Min/Max lifetime (in seconds) before the firefly despawns")]
    [SerializeField] private Vector2 lifetimeRange = new Vector2(8f, 18f);
    [Tooltip("Duration (in seconds) of the fade-in effect when spawning")]
    [SerializeField] private float fadeInDuration = 0.75f;
    [Tooltip("Duration (in seconds) of the fade-out effect before despawning")]
    [SerializeField] private float fadeOutDuration = 1.5f;

    [Header("Normal Glow Flicker")]
    [Tooltip("If true, the firefly will have a subtle flickering effect during its lifetime")]
    [SerializeField] private bool enableFlicker = true;
    [Tooltip("Min/Max intensity values for normal flickering")]
    [SerializeField] private Vector2 intensityRange = new Vector2(1.5f, 3.0f);
    [Tooltip("Speed of normal flickering (cycles per second) - higher values create more rapid changes")]
    [SerializeField] private float flickerSpeed = 5.0f;

    [Header("Spawn Flicker Effect")]
    [Tooltip("If true, the firefly will have a special flickering effect when first spawned")]
    [SerializeField] private bool enableSpawnEffect = true;
    [Tooltip("Duration (in seconds) of the special spawn effect")]
    [SerializeField] private float spawnEffectDuration = 0.5f;
    [Tooltip("Base brightness to gradually increase to during spawn effect")]
    [SerializeField] private float spawnBaseIntensity = 2.0f;
    [Tooltip("Probability (0-1) of short blackout flickers during spawn effect")]
    [SerializeField] [Range(0f, 1f)] private float spawnBlackoutChance = 0.3f;
    [Tooltip("Min/Max duration (in seconds) of blackout flickers during spawn")]
    [SerializeField] private Vector2 blackoutDurationRange = new Vector2(0.01f, 0.08f);
    [Tooltip("Min/Max spacing (in seconds) between blackout flickers")]
    [SerializeField] private Vector2 blackoutSpacingRange = new Vector2(0.05f, 0.2f);

    [Header("Scent Attraction")]
    [Tooltip("How often (in seconds) the firefly checks for nearby scent sources.")]
    [SerializeField] private float scentCheckInterval = 1.0f;
    [Tooltip("Maximum distance squared the OverlapCircle will check.")]
    [SerializeField] private float scentOverlapCheckRadius = 10f;
    [Tooltip("How strongly the firefly steers towards the scent target.")]
    [SerializeField] private float attractionStrength = 2.0f;
    [Tooltip("Preferred distance to orbit the scent source.")]
    [SerializeField] private float orbitDistance = 0.8f;
    [Tooltip("How much randomness/wobble in the attracted movement.")]
    [SerializeField] private float attractionWobble = 0.5f;
    [Tooltip("Which Scent Definitions attract this firefly.")]
    [SerializeField] private List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();

    // --- Public Accessor ---
    public Transform AttractionTarget => attractionTarget;

    // --- Internal State ---
    private FireflyManager manager;
    private Vector2 currentVelocity;
    private float currentSpeed;
    private float stateTimer;
    private bool isPaused;
    private float lifetime;
    private float age = 0f;
    private float currentAlpha = 0f; // Overall transparency/fade progress
    private float flickerOffset;
    private Material spriteMaterialInstance; // Instanced material for modification

    // Scent State
    private Transform attractionTarget = null;
    private float scentCheckTimer;
    private ScentDefinition currentTargetScentDef = null;

    // Movement Bounds
    private Vector2 minBounds;
    private Vector2 maxBounds;

    // Store the original emission color *without* intensity scaling from the material asset
    private Color baseEmissionColor = Color.black; // Default to black if reading fails
    
    // New fields for tracking the improved spawn effect
    private float nextBlackoutTime = 0f;
    private float blackoutEndTime = 0f;
    private bool isInBlackout = false;

    void Awake()
    {
        if (spriteRenderer == null) spriteRenderer = GetComponent<SpriteRenderer>();
        if (spriteRenderer != null && spriteRenderer.material != null) {
            // Create instance BEFORE reading base emission
            spriteMaterialInstance = spriteRenderer.material;
            // Try to read the base emission color set in the material asset
            if (spriteMaterialInstance.HasProperty("_EmissionColor")) {
                 // Important: Get the color value directly. If it's HDR, this value
                 // might already have some intensity baked in, depending on how it was set.
                 // Ideally, set the material's emission color to the desired *hue/saturation*
                 // with an intensity of 1 in the editor, and control brightness purely via script.
                 baseEmissionColor = spriteMaterialInstance.GetColor("_EmissionColor");
                 // If the color read already has intensity > 1 baked in, we might need to normalize it.
                 // For simplicity, let's assume the user sets the base color correctly.
                 // Example normalization (if needed):
                 // float currentIntensity = Mathf.Max(baseEmissionColor.r, baseEmissionColor.g, baseEmissionColor.b);
                 // if (currentIntensity > 1.0f) baseEmissionColor /= currentIntensity;
            } else {
                 Debug.LogWarning($"[{gameObject.name}] Material '{spriteMaterialInstance.name}' does not have an '_EmissionColor' property.", gameObject);
            }
        } else if (spriteRenderer == null || spriteRenderer.material == null) {
            Debug.LogWarning($"[{gameObject.name}] FireflyController: Cannot modify material properties (flicker/fade), SpriteRenderer or its material is missing.", gameObject);
            enableFlicker = false;
            enableSpawnEffect = false;
        }

        flickerOffset = Random.Range(0f, 100f);
    }

    public void Initialize(FireflyManager owner, Vector2 minB, Vector2 maxB)
    {
        manager = owner; 
        minBounds = minB; 
        maxBounds = maxB;
        
        lifetime = Random.Range(lifetimeRange.x, lifetimeRange.y);
        age = 0f; 
        currentAlpha = 0f;
        
        attractionTarget = null; 
        currentTargetScentDef = null;
        scentCheckTimer = Random.Range(0, scentCheckInterval);
        
        // Initialize blackout effect timing based on spawnBlackoutChance
        isInBlackout = false;
        
        // Only schedule blackouts if the chance is above zero
        if (Random.value < spawnBlackoutChance) {
            float initialDelay = Random.Range(0.01f, 0.1f); // Small random delay before first blackout
            nextBlackoutTime = Time.time + initialDelay;
        } else {
            // Set to a time after spawn effect is over if we don't want blackouts for this instance
            nextBlackoutTime = Time.time + spawnEffectDuration + 1f;
        }
        blackoutEndTime = 0f;
        
        PickNewWanderState();
        // Apply initial state (fully transparent, potentially zero intensity)
        ApplyVisualState(0f);
    }

    void Update()
    {
        age += Time.deltaTime;

        HandleLifetimeAndFade(); // Calculates currentAlpha
        if (currentAlpha <= 0f && age > fadeInDuration) { Die(); return; }

        HandleScentDetection();
        HandleMovement();
        HandleGlowAndFlicker(); // Calculates target intensity & calls ApplyVisualState
    }

    void HandleLifetimeAndFade()
    {
        // Calculate target alpha based on age and lifetime
        if (age < fadeInDuration) {
            currentAlpha = Mathf.Clamp01(age / fadeInDuration); // Fade In
        } else if (lifetime - age < fadeOutDuration) {
            currentAlpha = Mathf.Clamp01((lifetime - age) / fadeOutDuration); // Fade Out
        } else {
            currentAlpha = 1.0f; // Fully Visible
        }

        // Check if lifetime naturally expired
        if (age >= lifetime && currentAlpha > 0) {
             currentAlpha = Mathf.Clamp01((lifetime - age + fadeOutDuration) / fadeOutDuration);
             if(currentAlpha <= 0) Die();
        }
    }

    void HandleScentDetection()
    {
        scentCheckTimer -= Time.deltaTime;
        if (scentCheckTimer <= 0f) { FindAttractionTarget(); scentCheckTimer = scentCheckInterval; }
        if (attractionTarget != null) { if (!attractionTarget.gameObject.activeInHierarchy || !attractionTarget.TryGetComponent<ScentSource>(out var currentScent) || currentScent.definition != currentTargetScentDef || (attractionTarget.position - transform.position).sqrMagnitude > (currentScent.EffectiveRadius * currentScent.EffectiveRadius) ) { attractionTarget = null; currentTargetScentDef = null; } }
    }

    void FindAttractionTarget()
    {
        Transform bestTarget = null; ScentDefinition bestScentDef = null; float bestScore = -1f;
        Collider2D[] hits = Physics2D.OverlapCircleAll(transform.position, scentOverlapCheckRadius);
        foreach (Collider2D hit in hits) {
            if (hit.TryGetComponent<ScentSource>(out ScentSource scent) && scent.definition != null) {
                if (attractiveScentDefinitions.Contains(scent.definition)) {
                    float distSq = (hit.transform.position - transform.position).sqrMagnitude; float scentRadiusSq = scent.EffectiveRadius * scent.EffectiveRadius;
                    if (distSq <= scentRadiusSq) { float score = 1.0f / (distSq + 0.01f); if (score > bestScore) { bestScore = score; bestTarget = hit.transform; bestScentDef = scent.definition; } }
                }
            }
        }
        if (bestTarget != attractionTarget) { attractionTarget = bestTarget; currentTargetScentDef = bestScentDef; if (attractionTarget != null) { isPaused = false; } }
    }

    void HandleMovement()
    {
        stateTimer -= Time.deltaTime;
        if (attractionTarget != null) {
            Vector2 directionToTarget = (attractionTarget.position - transform.position); float distanceToTarget = directionToTarget.magnitude; if (distanceToTarget > 0.01f) { directionToTarget /= distanceToTarget; }
            Vector2 orbitOffsetDir = new Vector2(-directionToTarget.y, directionToTarget.x) * Mathf.Sign(currentSpeed + 0.1f); Vector2 desiredDirection = directionToTarget * attractionStrength;
            if (distanceToTarget <= orbitDistance) { desiredDirection += orbitOffsetDir * (currentSpeed * 0.5f); } desiredDirection += Random.insideUnitCircle * attractionWobble;
            currentVelocity = Vector2.Lerp(currentVelocity.normalized, desiredDirection.normalized, Time.deltaTime * 5f) * currentSpeed;
        } else { if (stateTimer <= 0f) { PickNewWanderState(); } }
        if (!isPaused) {
             Vector2 currentPos = transform.position; Vector2 newPos = currentPos + currentVelocity * Time.deltaTime; bool clampedX = false; bool clampedY = false;
             if (newPos.x <= minBounds.x || newPos.x >= maxBounds.x) { clampedX = true; newPos.x = Mathf.Clamp(newPos.x, minBounds.x, maxBounds.x); } if (newPos.y <= minBounds.y || newPos.y >= maxBounds.y) { clampedY = true; newPos.y = Mathf.Clamp(newPos.y, minBounds.y, maxBounds.y); }
             if (clampedX || clampedY) { Vector2 reflectionNormal = Vector2.zero; if(clampedX) reflectionNormal.x = -Mathf.Sign(currentVelocity.x); if(clampedY) reflectionNormal.y = -Mathf.Sign(currentVelocity.y); currentVelocity = Vector2.Reflect(currentVelocity, reflectionNormal.normalized + Random.insideUnitCircle * 0.1f).normalized * currentSpeed; if (currentVelocity.sqrMagnitude < 0.01f) { currentVelocity = Random.insideUnitCircle.normalized * currentSpeed; } PickNewWanderState(true); }
            transform.position = newPos;
        }
    }

    void PickNewWanderState(bool forceMove = false)
    {
        if (attractionTarget != null && !forceMove) return;
        if (!forceMove && Random.value < pauseChance) { isPaused = true; currentVelocity = Vector2.zero; stateTimer = Random.Range(pauseDurationRange.x, pauseDurationRange.y); }
        else { isPaused = false; currentSpeed = Random.Range(speedRange.x, speedRange.y); if(currentVelocity.sqrMagnitude < 0.01f || forceMove) currentVelocity = Random.insideUnitCircle.normalized * currentSpeed; else currentVelocity = (currentVelocity.normalized + Random.insideUnitCircle * 0.5f).normalized * currentSpeed; stateTimer = directionChangeInterval * Random.Range(0.7f, 1.3f); }
    }

    void HandleGlowAndFlicker()
    {
        float targetFlickerIntensity;

        // New spawn flickering effect that simulates a fluorescent tube turning on
        if (enableSpawnEffect && age < spawnEffectDuration) 
        {
            // Base linear brightening from 0 to spawnBaseIntensity based on progress
            float progress = age / spawnEffectDuration;
            float baseIntensity = Mathf.Lerp(0f, spawnBaseIntensity, progress);
            
            // Blackout flickering logic - Check if we need to schedule a new blackout
            if (Time.time >= nextBlackoutTime && !isInBlackout) 
            {
                // Start a new blackout with probability based on spawnBlackoutChance
                if (Random.value < spawnBlackoutChance) {
                    isInBlackout = true;
                    float blackoutDuration = Random.Range(blackoutDurationRange.x, blackoutDurationRange.y);
                    blackoutEndTime = Time.time + blackoutDuration;
                    
                    // Schedule the next potential blackout check
                    float spacingTime = Random.Range(blackoutSpacingRange.x, blackoutSpacingRange.y);
                    nextBlackoutTime = blackoutEndTime + spacingTime;
                } else {
                    // No blackout this time, but schedule next check
                    float spacingTime = Random.Range(blackoutSpacingRange.x, blackoutSpacingRange.y);
                    nextBlackoutTime = Time.time + spacingTime;
                }
            }
            
            // Update blackout state
            if (isInBlackout && Time.time > blackoutEndTime) 
            {
                isInBlackout = false;
            }
            
            // Apply blackout if active
            targetFlickerIntensity = isInBlackout ? 0f : baseIntensity;
        }
        else if (enableFlicker) 
        {
            // Normal runtime flickering (unchanged)
            float noise = Mathf.PerlinNoise(Time.time * flickerSpeed, flickerOffset);
            targetFlickerIntensity = Mathf.Lerp(intensityRange.x, intensityRange.y, noise);
        }
        else 
        {
            // Steady state if flickering disabled
            targetFlickerIntensity = intensityRange.x;
        }

        // Apply the calculated intensity and the current fade alpha
        ApplyVisualState(targetFlickerIntensity);
    }

    /// <summary>
    /// Applies the visual state based on calculated flicker intensity and fade alpha.
    /// </summary>
    /// <param name="flickerIntensity">The target brightness intensity for emission/light.</param>
    void ApplyVisualState(float flickerIntensity)
    {
        // 1. Apply overall transparency (Alpha Fade) to the SpriteRenderer's base color alpha
        if (spriteMaterialInstance != null)
        {
            // Ensure _Color property exists before trying to set it
            if (spriteMaterialInstance.HasProperty("_Color"))
            {
                Color baseColor = spriteMaterialInstance.GetColor("_Color");
                baseColor.a = currentAlpha; // Apply fade alpha
                spriteMaterialInstance.SetColor("_Color", baseColor);
            }

            // 2. Apply Flicker Intensity to Emission Color's brightness
            if (spriteMaterialInstance.HasProperty("_EmissionColor"))
            {
                 // Apply intensity to the base emission color we stored in Awake
                 // Use LinearToGammaSpace if in Linear color space for more visually correct intensity scalinG
                 Color finalEmissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(flickerIntensity);
                 // Alternative if baseEmissionColor already has intensity: Multiply directly
                 // Color finalEmissionColor = baseEmissionColor * flickerIntensity;
                 spriteMaterialInstance.SetColor("_EmissionColor", finalEmissionColor);
            }
        }

        // 3. Apply Flicker Intensity (modulated by alpha fade) to Light2D
        if (pointLight != null)
        {
            // Light intensity should reflect both flicker and fade
            pointLight.intensity = flickerIntensity * currentAlpha;
        }
    }

    void Die()
    {
        if (manager != null) manager.ReportFireflyDespawned(this);
        currentAlpha = 0f; ApplyVisualState(0f); // Ensure visuals are off
        Destroy(gameObject);
    }

    void OnDestroy() 
    { 
        if (spriteMaterialInstance != null) Destroy(spriteMaterialInstance); 
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Effects\FireflyManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Effects/FireflyManager.cs

using UnityEngine;
using UnityEngine.Rendering.Universal;
using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif

public class FireflyManager : MonoBehaviour
{
    public static FireflyManager Instance { get; private set; }

    [Header("Core Dependencies")]
    [SerializeField] private WeatherManager weatherManager;
    [SerializeField] private GameObject fireflyPrefab;
    [SerializeField] private Transform fireflyParent;

    // (Keep Spawning Settings, Spawn Area, Movement Bounds, Photosynthesis Bonus)
    [Header("Spawning Settings")]
    [SerializeField] private int maxFireflies = 50;
    [SerializeField] private float spawnInterval = 0.5f;
    [SerializeField] [Range(0f, 1f)] private float nightThreshold = 0.25f;

    [Header("Spawn Area")]
    [SerializeField] private Vector2 spawnCenter = Vector2.zero;
    [SerializeField] private Vector2 spawnAreaSize = new Vector2(20f, 10f);

    [Header("Movement Bounds (for Fireflies)")]
    [SerializeField] private Vector2 movementMinBounds = new Vector2(-12f, -7f);
    [SerializeField] private Vector2 movementMaxBounds = new Vector2(12f, 7f);

    [Header("Photosynthesis Bonus Settings")]
    public float photosynthesisRadius = 3f;
    public float photosynthesisIntensityPerFly = 0.05f;
    public float maxPhotosynthesisBonus = 0.5f;


    [Header("Debugging")]
    [Tooltip("Show attraction lines in Game View during runtime.")]
    [SerializeField] private bool showAttractionLinesRuntime = false;
    [SerializeField] private Color attractionLineColorRuntime = Color.magenta; // Renamed for Gizmo
    [SerializeField] private bool logGizmoCalls = false;
    [Space] // Add space for visual separation
    [Tooltip("Prefab used to draw attraction lines at runtime.")]
    [SerializeField] private GameObject lineVisualizerPrefab; // <<< ADDED
    [Tooltip("Parent transform for instantiated line visualizers.")]
    [SerializeField] private Transform lineContainer; // <<< ADDED

    // --- Public Accessor ---
    public bool ShowAttractionLinesRuntime => showAttractionLinesRuntime;

    // --- Internal State ---
    private List<FireflyController> activeFireflies = new List<FireflyController>();
    private float spawnTimer;
    private bool isNight = false;
    
    

    // Dictionary to track line visualizers per firefly
    private Dictionary<FireflyController, LineRenderer> activeLineVisualizers = new Dictionary<FireflyController, LineRenderer>();

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;
        // Validate Core Dependencies
        if (weatherManager == null) { Debug.LogError($"[{nameof(FireflyManager)}] WeatherManager missing!", this); enabled = false; return; }
        if (fireflyPrefab == null) { Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing!", this); enabled = false; return; }
        if (fireflyPrefab.GetComponent<FireflyController>() == null) { Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing Controller script!", this); enabled = false; return; }
        if (fireflyParent == null) { fireflyParent = transform; }

        // Validate Debug Dependencies
        if (lineVisualizerPrefab == null) { Debug.LogError($"[{nameof(FireflyManager)}] Line Visualizer Prefab is not assigned!", this); }
        if (lineContainer == null) { Debug.LogError($"[{nameof(FireflyManager)}] Line Container transform is not assigned!", this); }
    }

    void Update()
    {
        isNight = weatherManager.sunIntensity <= nightThreshold;

        if (isNight) {
            spawnTimer -= Time.deltaTime;
            if (spawnTimer <= 0f) { TrySpawnFirefly(); spawnTimer = spawnInterval; }
        } else { spawnTimer = spawnInterval; }

        // Update runtime visualizers in Update
        UpdateRuntimeLineVisualizers();
    }

    void TrySpawnFirefly()
    {
        if (activeFireflies.Count >= maxFireflies) return;

        float spawnX = spawnCenter.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
        float spawnY = spawnCenter.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
        Vector2 spawnPos = new Vector2(spawnX, spawnY);

        GameObject fireflyGO = Instantiate(fireflyPrefab, spawnPos, Quaternion.identity, fireflyParent);
        FireflyController controller = fireflyGO.GetComponent<FireflyController>();

        if (controller != null) {
            controller.Initialize(this, movementMinBounds, movementMaxBounds);
            activeFireflies.Add(controller);
            // Don't create line visualizer here, do it in Update when needed
        } else { /* LogError, Destroy */ }
    }

    public void ReportFireflyDespawned(FireflyController firefly)
    {
        activeFireflies.Remove(firefly);

        // Clean up associated line visualizer
        if (activeLineVisualizers.TryGetValue(firefly, out LineRenderer line))
        {
            if (line != null) Destroy(line.gameObject); // Destroy the visualizer GO
            activeLineVisualizers.Remove(firefly);
        }
    }

    // --- Runtime Visualizer Update ---
    void UpdateRuntimeLineVisualizers()
    {
        if (!Application.isPlaying) return; // Only run in play mode

        // Check if lines should be shown globally
        bool showLines = showAttractionLinesRuntime && lineVisualizerPrefab != null && lineContainer != null;

        // --- Update existing lines and create new ones ---
        // Use a temporary list to avoid modifying dictionary while iterating
        List<FireflyController> firefliesToRemoveLine = new List<FireflyController>();

        foreach (var kvp in activeLineVisualizers)
        {
            FireflyController firefly = kvp.Key;
            LineRenderer line = kvp.Value;

            if (firefly == null || line == null) // Firefly or line destroyed unexpectedly
            {
                firefliesToRemoveLine.Add(firefly); // Mark for removal
                if(line != null) Destroy(line.gameObject); // Destroy orphan line
                continue;
            }

            Transform target = firefly.AttractionTarget;

            if (showLines && target != null) // Should be visible and has target
            {
                line.enabled = true;
                line.SetPosition(0, firefly.transform.position);
                line.SetPosition(1, target.position);
                
                // IMPORTANT: Ensure the color is set properly
                if (line.startColor != attractionLineColorRuntime || line.endColor != attractionLineColorRuntime)
                {
                    line.startColor = attractionLineColorRuntime;
                    line.endColor = attractionLineColorRuntime;
                    
                    if (Debug.isDebugBuild)
                        Debug.Log($"[FireflyManager] Set line color to {attractionLineColorRuntime}", line.gameObject);
                }
            }
            else // Should be hidden or lost target
            {
                line.enabled = false;
            }
        }

        // Remove entries whose fireflies are gone
        foreach (var firefly in firefliesToRemoveLine)
        {
            activeLineVisualizers.Remove(firefly);
        }


        // --- Add lines for fireflies that don't have one yet ---
        if (showLines)
        {
            foreach (FireflyController firefly in activeFireflies)
            {
                if (firefly == null || activeLineVisualizers.ContainsKey(firefly)) continue; // Skip nulls or those already processed

                Transform target = firefly.AttractionTarget;
                if (target != null) // Only create if it has a target AND should be shown
                {
                    GameObject lineGO = Instantiate(lineVisualizerPrefab, lineContainer); // Instantiate under container
                    LineRenderer newLine = lineGO.GetComponent<LineRenderer>();
                    if (newLine != null)
                    {
                        // Configure initial points (will be updated next frame anyway)
                        newLine.SetPosition(0, firefly.transform.position);
                        newLine.SetPosition(1, target.position);
                        
                        // IMPORTANT: Set the line color correctly
                        newLine.startColor = attractionLineColorRuntime;
                        newLine.endColor = attractionLineColorRuntime;
                        
                        newLine.enabled = true;
                        activeLineVisualizers.Add(firefly, newLine); // Add to tracking dictionary
                        
                        if (Debug.isDebugBuild)
                            Debug.Log($"[FireflyManager] Created new line with color {attractionLineColorRuntime}", newLine.gameObject);
                    }
                    else
                    {
                         Debug.LogError($"Line Visualizer Prefab '{lineVisualizerPrefab.name}' is missing LineRenderer component!", lineVisualizerPrefab);
                         Destroy(lineGO); // Destroy invalid instance
                    }
                }
            }
        }
        // --- Hide/Destroy lines if global flag turned off ---
        else if (!showLines && activeLineVisualizers.Count > 0)
        {
             // Destroy all active line visualizers if the flag is off
             foreach (var kvp in activeLineVisualizers)
             {
                 if (kvp.Value != null) Destroy(kvp.Value.gameObject);
             }
             activeLineVisualizers.Clear();
        }
    }


    // (Keep GetNearbyFireflyCount)
     public int GetNearbyFireflyCount(Vector3 position, float radius)
    {
        int count = 0; float radiusSq = radius * radius;
        for (int i = activeFireflies.Count - 1; i >= 0; i--)
        {
            if (activeFireflies[i] == null) { activeFireflies.RemoveAt(i); continue; }
            if ((activeFireflies[i].transform.position - position).sqrMagnitude <= radiusSq) { count++; }
        }
        return count;
    }

    // --- Gizmos (Editor Visualization - Unchanged) ---
    #if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.green; Gizmos.DrawWireCube(spawnCenter, spawnAreaSize);
        Gizmos.color = Color.blue;
        Vector3 boundsCenter = (movementMinBounds + movementMaxBounds) / 2f;
        Vector3 boundsSize = movementMaxBounds - movementMinBounds;
        Gizmos.DrawWireCube(boundsCenter, boundsSize);

        // Gizmo drawing for attraction lines
        if (showAttractionLinesRuntime && Application.isPlaying) {
             if (logGizmoCalls) { /*...*/ }
             bool didDrawLine = false;
             Gizmos.color = attractionLineColorRuntime; // Use Gizmo color
             foreach (FireflyController firefly in activeFireflies) {
                if (firefly == null) continue;
                Transform target = firefly.AttractionTarget;
                if (target != null) { Gizmos.DrawLine(firefly.transform.position, target.position); didDrawLine = true; }
             }
             if (logGizmoCalls && !didDrawLine && activeFireflies.Count > 0) { /*...*/ }
        }
    }
    #endif
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\AnimalDiet.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;

// Simplified Preference: Links FoodType to satiation amount and behavior priority
[System.Serializable]
public class DietPreferenceSimplified
{
    [Tooltip("The specific FoodType this preference applies to.")]
    public FoodType foodType;

    [Tooltip("How much satiation (hunger reduction) is gained when this food is eaten.")]
    public float satiationAmount = 5f;

    [Tooltip("Priority for seeking this food (higher value = higher priority). Used for choosing between nearby valid foods.")]
    [Range(0.1f, 5f)]
    public float preferencePriority = 1f;
}


// Simplified Diet: Defines hunger stats and list of preferences
[CreateAssetMenu(fileName = "Diet_", menuName = "Ecosystem/Animal Diet (Simplified)")]
public class AnimalDiet : ScriptableObject
{
    [Header("Diet Preferences")]
    [Tooltip("List of foods this animal can eat and how much they satisfy hunger.")]
    public List<DietPreferenceSimplified> acceptableFoods = new List<DietPreferenceSimplified>();

    [Header("Hunger Mechanics")]
    [Tooltip("Maximum hunger level.")]
    public float maxHunger = 20f;
    [Tooltip("Rate at which hunger increases per second.")]
    public float hungerIncreaseRate = 0.5f;
    [Tooltip("Hunger level above which the animal will actively seek food.")]
    public float hungerThreshold = 10f;

    // Removed starvation for simplicity, can be added back later if needed
    // [Header("Starvation")]
    // public float starvationDamageRate = 0.5f;

    /// <summary>
    /// Checks if a specific FoodType is included in this diet's acceptable foods.
    /// </summary>
    public bool CanEat(FoodType food)
    {
        if (food == null) return false;
        return acceptableFoods.Any(pref => pref.foodType == food);
    }

    /// <summary>
    /// Gets the DietPreferenceSimplified entry for a specific FoodType.
    /// </summary>
    public DietPreferenceSimplified GetPreference(FoodType food)
    {
         if (food == null) return null;
         return acceptableFoods.FirstOrDefault(p => p.foodType == food);
    }

    /// <summary>
    /// Gets the satiation amount provided by a specific FoodType for this diet.
    /// </summary>
    public float GetSatiationValue(FoodType food)
    {
        var pref = GetPreference(food);
        return pref != null ? pref.satiationAmount : 0f;
    }

    /// <summary>
    /// Finds the best food target from nearby colliders based on preference and distance.
    /// </summary>
    public GameObject FindBestFood(Collider2D[] nearbyColliders, Vector3 animalPosition)
    {
        GameObject bestTarget = null;
        float highestScore = -1f; // Start below any possible score

        foreach (var collider in nearbyColliders)
        {
            if (collider == null) continue;

            // BUGFIX: Skip objects with PoopController to prevent animals from eating poop
            PoopController poopController = collider.GetComponent<PoopController>();
            if (poopController != null) continue;

            FoodItem foodItem = collider.GetComponent<FoodItem>();

            // Must have FoodItem and its FoodType must be edible by this diet
            if (foodItem != null && foodItem.foodType != null && CanEat(foodItem.foodType))
            {
                DietPreferenceSimplified pref = GetPreference(foodItem.foodType);
                if (pref == null) continue; // Should be caught by CanEat, but safe check

                float distance = Vector3.Distance(animalPosition, collider.transform.position);
                // Simple score: Higher preference is better, closer is better.
                // Avoid division by zero or very small distances inflating score excessively.
                float score = pref.preferencePriority / (1f + distance); // Inverse distance weighting

                if (score > highestScore)
                {
                    highestScore = score;
                    bestTarget = collider.gameObject;
                }
            }
        }
        return bestTarget;
    }
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[RequireComponent(typeof(Collider2D))] // Still need collider for detection
public class FoodItem : MonoBehaviour
{
    [Header("Food Identification")]
    [Tooltip("Reference to the ScriptableObject defining what type of food this is.")]
    public FoodType foodType;

    private void Start()
    {
        // Simple validation
        if (foodType == null)
        {
            Debug.LogWarning($"FoodItem on GameObject '{gameObject.name}' is missing its FoodType reference!", gameObject);
            // Optionally disable the collider so it can't be detected as food
            // Collider2D col = GetComponent<Collider2D>();
            // if (col != null) col.enabled = false;
            enabled = false; // Disable script if not configured
        }
        // No health, no consume logic needed here anymore.
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodType.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "FoodType_", menuName = "Ecosystem/Food Type (Simplified)")]
public class FoodType : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Identifying name for this food type (e.g., 'Leaf', 'Fruit').")]
    public string foodName = "Default Food";
    [Tooltip("Icon used in UI or debugging.")]
    public Sprite icon;

    // Keep category for potential filtering later, but not actively used by core logic yet
    public enum FoodCategory { Plant_Leaf, Plant_Fruit, Plant_Stem, Plant_Seed, Other }
    [Header("Categorization")]
    [Tooltip("General category this food falls into.")]
    public FoodCategory category = FoodCategory.Other;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Scents\ScentDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Scents/ScentDefinition.cs
using UnityEngine;

[CreateAssetMenu(fileName = "Scent_", menuName = "Ecosystem/Scent Definition")]
public class ScentDefinition : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Unique identifier used internally and potentially for node effects.")]
    public string scentID = "default_scent"; // Still useful for debugging/lookup
    [Tooltip("Display name for UI or debugging.")]
    public string displayName = "Default Scent";

    // [Header("Gameplay Properties")] - Removed scentType enum field

    [Tooltip("Base radius for this scent type if not modified by nodes.")]
    public float baseRadius = 1f;
    [Tooltip("Base strength for this scent type if not modified by nodes.")]
    public float baseStrength = 1f;

    [Header("Visuals (Optional)")]
    [Tooltip("Particle effect prefab to instantiate when this scent is active.")]
    public GameObject particleEffectPrefab;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Scents\ScentLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Scents/ScentLibrary.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "ScentLibrary", menuName = "Ecosystem/Scent Library")]
public class ScentLibrary : ScriptableObject
{
    public List<ScentDefinition> scents;

    // Helper method to find a scent by its ID (still potentially useful)
    public ScentDefinition GetScentByID(string id)
    {
        if (string.IsNullOrEmpty(id) || scents == null) return null;
        return scents.FirstOrDefault(s => s != null && s.scentID == id);
    }

    // Helper to get the actual list of definitions
    public List<ScentDefinition> GetAllDefinitions()
    {
        // Return a copy or filter out nulls
        return scents?.Where(s => s != null).ToList() ?? new List<ScentDefinition>();
    }

}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeData.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeData.cs
using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeData
{
    public string nodeId;
    public string nodeDisplayName;
    public List<NodeEffectData> effects = new List<NodeEffectData>();
    public int orderIndex;

    // Runtime flags
    [HideInInspector] // Don't show in NodeDefinition inspector, set at runtime
    public bool canBeDeleted = true;

    // NEW: For Seed items, this will store their internal node sequence
    [Tooltip("If this NodeData represents a Seed, this holds its internal sequence of nodes.")]
    public NodeGraph storedSequence = new NodeGraph(); // Initialize to avoid nulls

    public NodeData()
    {
        nodeId = Guid.NewGuid().ToString();
        canBeDeleted = true;
        // Ensure storedSequence is initialized, which it is by its declaration.
    }

    // Helper to quickly check if this NodeData represents a seed
    public bool IsSeed()
    {
        if (effects == null) return false;
        foreach (var effect in effects)
        {
            if (effect != null && effect.effectType == NodeEffectType.SeedSpawn && effect.isPassive)
            {
                return true;
            }
        }
        return false;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeDefinition.cs
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NodeDefinition", menuName = "Nodes/NodeDefinition")]
public class NodeDefinition : ScriptableObject
{
    [Header("Display")]
    public string displayName;
    [TextArea]
    public string description;
    public Sprite thumbnail;
    [Tooltip("Tint color applied to the thumbnail image.")]
    public Color thumbnailTintColor = Color.white;
    [Tooltip("Background color for the Node View representation.")]
    public Color backgroundColor = Color.gray;

    [Header("Prefab & Effects")]
    [Tooltip("Optional: Specific NodeView prefab for this node type. If null, the default from NodeEditorGridController is used.")]
    public GameObject nodeViewPrefab;
    [Tooltip("List of effects this node applies. Configure these effects carefully.")]
    public List<NodeEffectData> effects; // This is the list configured in the Inspector

    /// <summary>
    /// Creates a deep copy of the effects list configured in this NodeDefinition asset.
    /// This ensures that runtime NodeData instances get their own copies of effects.
    /// </summary>
    /// <returns>A new list containing copies of the NodeEffectData.</returns>
    public List<NodeEffectData> CloneEffects()
    {
        List<NodeEffectData> copy = new List<NodeEffectData>();
        if (effects == null) {
            // Debug.LogWarning($"NodeDefinition '{this.name}' has a null effects list."); // Optional warning
            return copy; // Handle null list
        }

        foreach (var originalEffect in effects)
        {
            if (originalEffect == null) {
                 Debug.LogWarning($"NodeDefinition '{this.name}' contains a null effect in its list."); // Optional warning
                 continue; // Skip null effects
            }

            // Create a new instance and copy ALL relevant fields
            NodeEffectData newEffect = new NodeEffectData()
            {
                effectType = originalEffect.effectType,
                primaryValue = originalEffect.primaryValue,
                secondaryValue = originalEffect.secondaryValue,
                isPassive = originalEffect.isPassive,
                // --- FIXED: Copy the ScentDefinition reference ---
                scentDefinitionReference = originalEffect.scentDefinitionReference
                // --------------------------------------------------
            };
            copy.Add(newEffect);
        }
        return copy;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeDefinitionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System; // Needed for [Serializable]

// Define the configuration for a single initial node
[Serializable] // Make it visible and editable in the Inspector
public struct InitialNodeConfig
{
    [Tooltip("The Node Definition to spawn.")]
    public NodeDefinition nodeDefinition;

    [Tooltip("The zero-based index of the cell where this node should spawn (0 is the leftmost cell).")]
    [Min(0)]
    public int cellIndex;

    [Tooltip("Can the player drag this initial node to other cells?")]
    public bool canMove;

    [Tooltip("Can the player delete this initial node using the Delete key?")]
    public bool canDelete;
}


[CreateAssetMenu(fileName = "NodeDefinitionLibrary", menuName = "Nodes/NodeDefinitionLibrary")]
public class NodeDefinitionLibrary : ScriptableObject
{
    [Header("Available Node Definitions")]
    [Tooltip("List of all Node Definitions available in the dropdown menu.")]
    public List<NodeDefinition> definitions; // Your existing list

    [Header("Initial Node Layout")]
    [Tooltip("Nodes to automatically spawn in specific slots when the grid initializes.")]
    public List<InitialNodeConfig> initialNodes; // <<< NEW LIST ADDED
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectData.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeEffectData.cs
using System;
using UnityEngine;

[Serializable]
public class NodeEffectData
{
    public NodeEffectType effectType;

    [Tooltip("Primary numeric value for the effect (e.g., Amount, Duration, Radius Bonus).")] // Updated tooltip
    public float primaryValue;
    [Tooltip("Secondary numeric value for the effect (e.g., Speed, Intensity, Strength Bonus).")] // Updated tooltip
    public float secondaryValue;

    [Tooltip("If TRUE, effect runs once during growth. If FALSE, effect executes during mature cycles.")]
    public bool isPassive = false;

    // --- Scent Specific ---
    // [Tooltip("Identifier (scentID from ScentDefinition) of the scent to apply. Used only if effectType is ScentModifier.")]
    // public string scentIdentifier; // <<< REMOVED

    [Tooltip("The Scent Definition to apply/modify. Used only if effectType is ScentModifier.")]
    public ScentDefinition scentDefinitionReference; // <<< ADDED: Direct reference
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\NodeEffectType.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/NodeEffectType.cs
using System;
using UnityEngine;

public enum NodeEffectType
{
    // --- Passive / Growth Phase Effects (isPassive = true) ---
    // These typically run once at the start to define the plant's structure and base stats.

    // [Tooltip("Base cost calculation (Not currently implemented in PlantGrowth execution).")]
    // ManaCost, // REMOVED
    [Tooltip("Determines the maximum energy the plant can store.")]
    EnergyStorage,
    [Tooltip("Determines the base rate of energy generation through photosynthesis per leaf.")]
    EnergyPhotosynthesis,
    [Tooltip("A required marker effect for a node chain to be spawnable as a plant.")]
    SeedSpawn,
    [Tooltip("Modifies the minimum and maximum potential length of the main stem.")]
    StemLength,
    [Tooltip("Modifies the time interval between each step of stem/leaf growth.")]
    GrowthSpeed,
    [Tooltip("Modifies the number of stem segments between leaf spawns.")]
    LeafGap,
    [Tooltip("Sets the pattern in which leaves are spawned (e.g., Parallel, Alternating).")]
    LeafPattern,
    [Tooltip("Modifies the chance for the stem to grow diagonally instead of straight up.")]
    StemRandomness,
    [Tooltip("Modifies the base time duration between Mature Phase execution cycles.")]
    Cooldown,
    [Tooltip("Modifies the base time delay between executing the effects of sequential nodes within a Mature Phase cycle.")]
    CastDelay,
    [Tooltip("Allows the plant to absorb poop within a radius and regrow eaten leaves or gain energy. PrimaryValue=Detection Radius, SecondaryValue=Energy Added.")]
    PoopFertilizer,


    // --- Active / Mature Phase Effects (isPassive = false) ---
    // These execute periodically after the plant has finished growing.

    [Tooltip("Energy cost deducted from the plant when this node's active effects are executed during the mature cycle.")]
    EnergyCost, // <<< RENAMED/ADDED
    [Tooltip("Triggers the spawning of a projectile or other output effect (requires OutputNodeEffect component).")]
    Output,
    [Tooltip("Modifies the damage potential of subsequent 'Output' effects in the same cycle.")]
    Damage,
    [Tooltip("Causes the plant to attempt to spawn a berry in an available adjacent slot during the mature cycle.")]
    GrowBerry,
    // Add potentially more active effects: Heal, ApplyStatus, AreaEffect, etc.
    
    
    [Tooltip("Modifies the scent emitted by the next spawned carrier (Berry, Projectile). PrimaryValue=Radius Add, SecondaryValue=Strength Add.")]
    ScentModifier,
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Core\OutputNodeEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Core/OutputNodeEffect.cs
using UnityEngine;
using System.Collections.Generic; // Required for Dictionary

public class OutputNodeEffect : MonoBehaviour
{
    [Header("References")]
    [Tooltip("Prefab for the projectile to spawn.")]
    public GameObject projectilePrefab;

    [Header("Settings")]
    public Vector2 spawnOffset = Vector2.up;

    // Store reference needed to call ApplyScentDataToObject
    private PlantGrowth parentPlantGrowth;

    void Awake()
    {
        // Get reference to parent PlantGrowth to access ApplyScentDataToObject helper
        parentPlantGrowth = GetComponentInParent<PlantGrowth>();
        if (parentPlantGrowth == null)
        {
            // This is a critical error if scent application is expected
            Debug.LogError($"[{nameof(OutputNodeEffect)}] Could not find parent PlantGrowth component! Scent application will fail.", gameObject);
        }
    }

    /// <summary>
    /// Activated by PlantGrowth during the Mature Execution Cycle.
    /// Spawns a projectile and applies accumulated effects (damage, scent).
    /// </summary>
    /// <param name="damageMultiplier">Contextual damage modifier calculated from the node chain.</param>
    /// <param name="scentRadiusBonuses">Accumulated radius bonuses per ScentDefinition.</param> // <<< UPDATED PARAM TYPE
    /// <param name="scentStrengthBonuses">Accumulated strength bonuses per ScentDefinition.</param> // <<< UPDATED PARAM TYPE
    public void Activate(float damageMultiplier,
                         Dictionary<ScentDefinition, float> scentRadiusBonuses, // <<< UPDATED TYPE
                         Dictionary<ScentDefinition, float> scentStrengthBonuses) // <<< UPDATED TYPE
    {
        // --- Validations ---
        if (projectilePrefab == null) {
            Debug.LogError($"[{nameof(OutputNodeEffect)}] Projectile Prefab not assigned!", gameObject);
            return;
        }
        
         if (parentPlantGrowth == null) { // Check again in case Awake failed silently
              Debug.LogError($"[{nameof(OutputNodeEffect)}] Cannot activate, parent PlantGrowth reference is missing. Scent application will fail.", gameObject);
             // Decide if we should still spawn projectile without scent or just return
             // return; // Option: Abort if scent cannot be applied
         }

        // Debug.Log($"[OutputNodeEffect] Activate called. Damage Multiplier: {damageMultiplier}. Spawning projectile.");

        // --- Spawn Projectile ---
        Vector2 spawnPos = (Vector2)transform.position + spawnOffset;
        GameObject projGO = Instantiate(projectilePrefab, spawnPos, transform.rotation); // Use plant's rotation or aim logic

        // --- Apply Accumulated Scents to Projectile ---
        // Call the public helper method on the parent PlantGrowth instance
        if (parentPlantGrowth != null) // Check if reference exists before calling
        {
            // Debug.Log($"[{gameObject.name} Activate] Calling ApplyScentDataToObject for {projGO.name}. Passing {scentStrengthsBonuses?.Count ?? 0} scent strength entries."); /////////// here
            
             // Call the public helper with the NEW dictionaries
             parentPlantGrowth.ApplyScentDataToObject(projGO, scentRadiusBonuses, scentStrengthBonuses);
        }
        // -----------------------------------------------

        // --- Initialize Projectile Stats ---
        SpellProjectile spellProj = projGO.GetComponent<SpellProjectile>();
        if(spellProj != null)
        {
            // TODO: Get base damage/speed from effects or projectile definition?
            float baseDamage = 10f; // Example base value
            float baseSpeed = 5f; // Example base value

            float finalDamage = baseDamage * damageMultiplier; // Apply accumulated multiplier
            float finalSpeed = baseSpeed; // TODO: Apply speed modifiers if implemented

            spellProj.Initialize(finalDamage, finalSpeed);
            // Set other properties like friendly fire based on plant context?
        }
        // else { Debug.LogWarning($"[{nameof(OutputNodeEffect)}] Spawned projectile '{projGO.name}' is missing SpellProjectile component.", projGO); }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeExecutor.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/Runtime/NodeExecutor.cs
using System.Collections.Generic;
using UnityEngine;
using TMPro;
using System.Linq;

public class NodeExecutor : MonoBehaviour
{
    [Header("Plant Spawning")]
    [SerializeField] private GameObject plantPrefab;

    [Header("Debugging")]
    [SerializeField] private TMP_Text debugOutput;

    // Public static helper for cloning effects, useful in other classes too
    public static List<NodeEffectData> CloneEffectsList(List<NodeEffectData> originalList)
    {
        if (originalList == null) return new List<NodeEffectData>();
        List<NodeEffectData> newList = new List<NodeEffectData>(originalList.Count);
        foreach(var originalEffect in originalList) {
            if(originalEffect == null) continue;
            NodeEffectData newEffect = new NodeEffectData {
                 effectType = originalEffect.effectType,
                 primaryValue = originalEffect.primaryValue,
                 secondaryValue = originalEffect.secondaryValue,
                 isPassive = originalEffect.isPassive,
                 scentDefinitionReference = originalEffect.scentDefinitionReference
            };
            newList.Add(newEffect);
        }
        return newList;
    }


    public GameObject SpawnPlantFromSeedInSlot(Vector3 plantingPosition, Transform parentTransform)
    {
        if (NodeEditorGridController.Instance == null) { DebugLogError("Node Editor Grid Controller not found!"); return null; }
        if (plantPrefab == null) { DebugLogError("Plant prefab not assigned!"); return null; }

        NodeData seedNodeDataInSlot = NodeEditorGridController.Instance.GetCurrentSeedInSlot();

        if (seedNodeDataInSlot == null) {
            DebugLog("No seed in slot to plant.");
            return null;
        }
        if (!seedNodeDataInSlot.IsSeed()) {
            DebugLogError("Item in seed slot is not a valid seed!");
            return null;
        }

        // Get a CLONE of the sequence currently being edited in the UI for this seed.
        // This represents the *intended* internal sequence of the seed for planting.
        NodeGraph sequenceForPlant = NodeEditorGridController.Instance.GetCurrentGraphInEditorForSpawning();

        DebugLog($"Attempting to plant seed '{seedNodeDataInSlot.nodeDisplayName}' with {sequenceForPlant.nodes.Count} internal nodes from editor...");

        NodeGraph finalGraphForPlant = new NodeGraph();
        finalGraphForPlant.nodes = new List<NodeData>();

        // 1. Add a CLONE of the seed node itself from the slot.
        NodeData clonedSeedNodeInstance = new NodeData {
            nodeId = System.Guid.NewGuid().ToString(),
            nodeDisplayName = seedNodeDataInSlot.nodeDisplayName,
            effects = CloneEffectsList(seedNodeDataInSlot.effects),
            orderIndex = 0,
            canBeDeleted = false,
            storedSequence = new NodeGraph() // The instance on the plant doesn't store a sequence
        };
        finalGraphForPlant.nodes.Add(clonedSeedNodeInstance);

        // 2. Add CLONES of nodes from the editor's representation of the seed's sequence.
        int currentOrderIndex = 1;
        foreach (NodeData nodeInUISequence in sequenceForPlant.nodes.OrderBy(n => n.orderIndex)) // sequenceForPlant is already a clone
        {
            if (nodeInUISequence == null) continue;
            NodeData clonedSequenceNodeInstance = new NodeData {
                nodeId = System.Guid.NewGuid().ToString(), // New ID for this plant's node instance
                nodeDisplayName = nodeInUISequence.nodeDisplayName,
                effects = CloneEffectsList(nodeInUISequence.effects), // Effects are already cloned if GetCurrentGraphInEditorForSpawning works correctly
                orderIndex = currentOrderIndex++,
                canBeDeleted = false,
                storedSequence = new NodeGraph() // Nodes within the plant graph do not have sub-sequences
            };
            finalGraphForPlant.nodes.Add(clonedSequenceNodeInstance);
        }
        
        DebugLog($"Constructed final graph for plant with {finalGraphForPlant.nodes.Count} total nodes (1 seed + {finalGraphForPlant.nodes.Count -1} from sequence).");

        GameObject plantObj = Instantiate(plantPrefab, plantingPosition, Quaternion.identity, parentTransform);

        PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
        if (growthComponent != null)
        {
            // The finalGraphForPlant is already composed of new NodeData instances with cloned effects.
            // PlantGrowth.InitializeAndGrow should ideally work with this directly.
            // If PlantGrowth further modifies the graph, it should manage its own copies.
            growthComponent.InitializeAndGrow(finalGraphForPlant);
            DebugLog($"Plant '{plantObj.name}' spawned and initialized with seed '{seedNodeDataInSlot.nodeDisplayName}'.");
            return plantObj;
        }
        else
        {
             DebugLogError($"Prefab '{plantPrefab.name}' missing PlantGrowth component! Destroying spawned object.");
             Destroy(plantObj);
             return null;
        }
    }
    
    public GameObject SpawnPlantFromInventorySeed(NodeData seedNodeData, Vector3 plantingPosition, Transform parentTransform)
{
    if (seedNodeData == null || !seedNodeData.IsSeed())
    {
        DebugLogError("Invalid seed data provided!");
        return null;
    }
    
    if (plantPrefab == null)
    {
        DebugLogError("Plant prefab not assigned!");
        return null;
    }
    
    DebugLog($"Spawning plant from inventory seed '{seedNodeData.nodeDisplayName}' with {seedNodeData.storedSequence?.nodes?.Count ?? 0} internal nodes...");
    
    NodeGraph finalGraphForPlant = new NodeGraph();
    finalGraphForPlant.nodes = new List<NodeData>();
    
    // 1. Add a CLONE of the seed node itself
    NodeData clonedSeedNodeInstance = new NodeData
    {
        nodeId = System.Guid.NewGuid().ToString(),
        nodeDisplayName = seedNodeData.nodeDisplayName,
        effects = CloneEffectsList(seedNodeData.effects),
        orderIndex = 0,
        canBeDeleted = false,
        storedSequence = new NodeGraph() // The instance on the plant doesn't store a sequence
    };
    finalGraphForPlant.nodes.Add(clonedSeedNodeInstance);
    
    // 2. Add CLONES of nodes from the seed's stored sequence
    int currentOrderIndex = 1;
    if (seedNodeData.storedSequence != null && seedNodeData.storedSequence.nodes != null)
    {
        foreach (NodeData nodeInSequence in seedNodeData.storedSequence.nodes.OrderBy(n => n.orderIndex))
        {
            if (nodeInSequence == null) continue;
            NodeData clonedSequenceNodeInstance = new NodeData
            {
                nodeId = System.Guid.NewGuid().ToString(),
                nodeDisplayName = nodeInSequence.nodeDisplayName,
                effects = CloneEffectsList(nodeInSequence.effects),
                orderIndex = currentOrderIndex++,
                canBeDeleted = false,
                storedSequence = new NodeGraph()
            };
            finalGraphForPlant.nodes.Add(clonedSequenceNodeInstance);
        }
    }
    
    DebugLog($"Constructed final graph for plant with {finalGraphForPlant.nodes.Count} total nodes (1 seed + {finalGraphForPlant.nodes.Count - 1} from sequence).");
    
    GameObject plantObj = Instantiate(plantPrefab, plantingPosition, Quaternion.identity, parentTransform);
    
    PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
    if (growthComponent != null)
    {
        growthComponent.InitializeAndGrow(finalGraphForPlant);
        DebugLog($"Plant '{plantObj.name}' spawned and initialized with seed '{seedNodeData.nodeDisplayName}'.");
        return plantObj;
    }
    else
    {
        DebugLogError($"Prefab '{plantPrefab.name}' missing PlantGrowth component! Destroying spawned object.");
        Destroy(plantObj);
        return null;
    }
}

    // DebugLog and DebugLogError methods remain the same
    private void DebugLog(string msg) {
        Debug.Log($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += msg + "\n";
    }
    private void DebugLogError(string msg) {
        Debug.LogError($"[NodeExecutor] {msg}");
        if (debugOutput != null) debugOutput.text += $"ERROR: {msg}\n";
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\Runtime\NodeGraph.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeGraph
{
    public List<NodeData> nodes = new List<NodeData>();
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\ColorExtensions.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public static class ColorExtensions
{
    public static Color WithAlpha(this Color c, float alpha)
    {
        return new Color(c.r, c.g, c.b, alpha);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\DeselectOnClickOutside.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems; // Required for IPointerClickHandler

// Add this script to an invisible, fullscreen background UI Image
// Make sure it's the first child of the Canvas to render behind everything else
public class DeselectOnClickOutside : MonoBehaviour, IPointerClickHandler
{
    public void OnPointerClick(PointerEventData eventData)
    {
        // Check if the click was with the left mouse button
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            // If the background is clicked, clear the current node selection
            // Debug.Log("Background Clicked. Clearing Node Selection.");
            NodeCell.ClearSelection();
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\InventoryBarController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/UI/InventoryBarController.cs
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

public class InventoryBarController : MonoBehaviour
{
    public static InventoryBarController Instance { get; private set; }
    
    [Header("Bar Configuration")]
    [SerializeField] private int slotsPerRow = 10;
    [SerializeField] private Vector2 cellSize = new Vector2(64f, 64f);
    [SerializeField] private float cellMargin = 10f;
    
    [Header("UI References")]
    [SerializeField] private Transform cellContainer;
    [SerializeField] private Button upArrowButton;
    [SerializeField] private Button downArrowButton;
    [SerializeField] private GameObject selectionHighlight; // Keep only this one

    [Header("Cell Visuals")]
    [SerializeField] private Sprite emptyCellSprite;
    [SerializeField] private Color emptyCellColor = Color.white;

    [Header("Integration")]
    [SerializeField] private InventoryGridController inventoryGridController;
    
    private List<NodeCell> barCells = new List<NodeCell>();
    private int currentRow = 0;
    private int selectedSlot = 0;
    private int totalRows = 0;
    
    public InventoryBarItem SelectedItem { get; private set; }
    public event System.Action<InventoryBarItem> OnSelectionChanged;
    
    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;
    }
    
    void Start()
    {
        if (upArrowButton != null) upArrowButton.onClick.AddListener(() => ChangeRow(-1));
        if (downArrowButton != null) downArrowButton.onClick.AddListener(() => ChangeRow(1));
        
        SetupBarCells();
        gameObject.SetActive(false); // Start hidden
    }
    
    void Update()
    {
        if (!gameObject.activeInHierarchy) return;
        HandleNumberKeyInput();
        HandleArrowKeyInput();
    }
    
    public void ShowBar()
    {
        if (inventoryGridController == null)
        {
            Debug.LogError("[InventoryBarController] InventoryGridController reference is missing!");
            return;
        }
        
        RefreshFromInventory();
        gameObject.SetActive(true);
        UpdateBarDisplay();
        UpdateSelection();
    }
    
    public void HideBar()
    {
        gameObject.SetActive(false);
    }
    
    private void SetupBarCells()
    {
        if (cellContainer == null) 
        {
            Debug.LogError("[InventoryBarController] Cell Container not assigned!");
            return;
        }
        
        // Clear existing cells
        foreach (Transform child in cellContainer) Destroy(child.gameObject);
        barCells.Clear();
        
        // Setup grid layout
        GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
        if (gridLayout == null) gridLayout = cellContainer.gameObject.AddComponent<GridLayoutGroup>();
        
        gridLayout.cellSize = cellSize;
        gridLayout.spacing = new Vector2(cellMargin, cellMargin);
        gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
        gridLayout.constraintCount = slotsPerRow;
        
        // Create bar cells (same as inventory cells)
        for (int i = 0; i < slotsPerRow; i++)
        {
            GameObject cellGO = new GameObject($"BarCell_{i}", typeof(RectTransform));
            cellGO.transform.SetParent(cellContainer, false);
            
            Image cellImage = cellGO.AddComponent<Image>();
            cellImage.sprite = emptyCellSprite;
            cellImage.color = emptyCellColor;
            cellImage.raycastTarget = true;
            
            NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
            cellLogic.Init(i, null, inventoryGridController, cellImage); // Use inventory controller for shared logic
            
            barCells.Add(cellLogic);
        }
    }
    
    private void RefreshFromInventory()
    {
        if (inventoryGridController == null) return;
    
        // FIXED: Calculate total rows based on actual inventory content
        int totalInventorySlots = inventoryGridController.TotalSlots;
        int inventoryColumns = inventoryGridController.inventoryColumns;
    
        // Ensure inventoryColumns is valid
        if (inventoryColumns <= 0)
        {
            Debug.LogError("[InventoryBarController] Invalid inventory columns count!");
            totalRows = 1;
            currentRow = 0;
            return;
        }
    
        totalRows = Mathf.Max(1, Mathf.CeilToInt((float)totalInventorySlots / inventoryColumns));
    
        // Clamp current row to valid range
        currentRow = Mathf.Clamp(currentRow, 0, totalRows - 1);
    
        Debug.Log($"[InventoryBarController] RefreshFromInventory: TotalSlots={totalInventorySlots}, Columns={inventoryColumns}, TotalRows={totalRows}, CurrentRow={currentRow}");
    }
    
    private void UpdateBarDisplay()
    {
        if (inventoryGridController == null) return;
    
        // Clear all bar cells first
        foreach (var cell in barCells)
        {
            cell.RemoveNode();
        }
    
        // FIXED: Calculate proper inventory access
        int columnsPerRow = inventoryGridController.inventoryColumns;
        int startIndex = currentRow * columnsPerRow;
        int maxInventoryIndex = inventoryGridController.TotalSlots - 1;
    
        Debug.Log($"[InventoryBarController] UpdateBarDisplay: CurrentRow={currentRow}, ColumnsPerRow={columnsPerRow}, StartIndex={startIndex}, MaxIndex={maxInventoryIndex}");
    
        // Populate current row from inventory
        for (int i = 0; i < slotsPerRow && i < columnsPerRow; i++)
        {
            int inventoryIndex = startIndex + i;
        
            // FIXED: Bounds check before accessing inventory
            if (inventoryIndex > maxInventoryIndex)
            {
                Debug.Log($"[InventoryBarController] Skipping bar slot {i}, inventory index {inventoryIndex} is beyond max {maxInventoryIndex}");
                continue;
            }
        
            var inventoryCell = inventoryGridController.GetInventoryCellAtIndex(inventoryIndex);
        
            if (inventoryCell != null && inventoryCell.HasNode())
            {
                // Copy the content from inventory cell to bar cell
                CopyInventoryItemToBarCell(inventoryCell, barCells[i]);
            }
        }
    
        // Update arrow buttons
        if (upArrowButton != null) upArrowButton.interactable = currentRow > 0;
        if (downArrowButton != null) upArrowButton.interactable = currentRow < totalRows - 1;
    
        Debug.Log($"[InventoryBarController] UpdateBarDisplay: Row {currentRow}/{totalRows-1}, StartIndex={startIndex}");
    }
    
    private void CopyInventoryItemToBarCell(NodeCell inventoryCell, NodeCell barCell)
    {
        var nodeData = inventoryCell.GetNodeData();
        var nodeView = inventoryCell.GetNodeView();
        var toolDef = inventoryCell.GetToolDefinition();
        
        if (nodeData != null)
        {
            if (toolDef != null)
            {
                // It's a tool - create a visual copy
                CreateToolCopyInBarCell(toolDef, nodeData, barCell);
            }
            else if (nodeView != null)
            {
                // It's a node - create a visual copy
                var nodeDef = nodeView.GetNodeDefinition();
                if (nodeDef != null)
                {
                    CreateNodeCopyInBarCell(nodeDef, nodeData, barCell);
                }
            }
        }
    }
    
    private void CreateToolCopyInBarCell(ToolDefinition toolDef, NodeData nodeData, NodeCell barCell)
    {
        // Create a visual representation of the tool (not draggable)
        GameObject toolDisplay = new GameObject($"ToolDisplay_{toolDef.displayName}", typeof(RectTransform), typeof(Image));
        toolDisplay.transform.SetParent(barCell.transform, false);
        
        Image toolImage = toolDisplay.GetComponent<Image>();
        toolImage.sprite = toolDef.icon;
        toolImage.color = toolDef.iconTint;
        toolImage.raycastTarget = false; // Not interactive in bar
        
        RectTransform toolRect = toolDisplay.GetComponent<RectTransform>();
        toolRect.anchoredPosition = Vector2.zero;
        toolRect.sizeDelta = cellSize * 0.8f;
        
        // Store reference in the cell (but don't make it draggable)
        barCell.AssignDisplayOnly(toolDisplay, nodeData, toolDef);
    }
    
    private void CreateNodeCopyInBarCell(NodeDefinition nodeDef, NodeData nodeData, NodeCell barCell)
    {
        // Create a visual representation of the node (not draggable)
        GameObject nodeDisplay = new GameObject($"NodeDisplay_{nodeDef.displayName}", typeof(RectTransform), typeof(Image));
        nodeDisplay.transform.SetParent(barCell.transform, false);
        
        Image nodeImage = nodeDisplay.GetComponent<Image>();
        nodeImage.sprite = nodeDef.thumbnail;
        nodeImage.color = nodeDef.thumbnailTintColor;
        nodeImage.raycastTarget = false; // Not interactive in bar
        
        RectTransform nodeRect = nodeDisplay.GetComponent<RectTransform>();
        nodeRect.anchoredPosition = Vector2.zero;
        nodeRect.sizeDelta = cellSize * 0.8f;
        
        // Store reference in the cell (but don't make it draggable)
        barCell.AssignDisplayOnly(nodeDisplay, nodeData, null);
    }
    
    private void HandleNumberKeyInput()
    {
        // FIXED: Handle both QWERTY and QWERTZ layouts properly
        // Check for number keys 1-9 and 0 (which maps to slot 9)
        for (int i = 1; i <= 9; i++)
        {
            KeyCode key = (KeyCode)((int)KeyCode.Alpha1 + (i - 1));
            if (Input.GetKeyDown(key))
            {
                int targetSlot = i - 1; // 1-9 maps to slots 0-8
                if (targetSlot < slotsPerRow)
                {
                    SelectSlot(targetSlot);
                }
                return;
            }
        }
        
        // Handle 0 key (maps to slot 9)
        if (Input.GetKeyDown(KeyCode.Alpha0))
        {
            int targetSlot = 9; // 0 maps to slot 9
            if (targetSlot < slotsPerRow)
            {
                SelectSlot(targetSlot);
            }
        }
    }
    
    private void HandleArrowKeyInput()
    {
        if (Input.GetKeyDown(KeyCode.UpArrow))
        {
            ChangeRow(-1);
        }
        else if (Input.GetKeyDown(KeyCode.DownArrow))
        {
            ChangeRow(1);
        }
    }
    
    private void ChangeRow(int direction)
    {
        int newRow = currentRow + direction;
        if (newRow >= 0 && newRow < totalRows)
        {
            currentRow = newRow;
            Debug.Log($"[InventoryBarController] Changed to row {currentRow}");
            UpdateBarDisplay();
            UpdateSelection();
        }
        else
        {
            Debug.Log($"[InventoryBarController] Cannot change to row {newRow}, out of bounds (0-{totalRows-1})");
        }
    }
    
    private void SelectSlot(int slotIndex)
    {
        selectedSlot = Mathf.Clamp(slotIndex, 0, slotsPerRow - 1);
        Debug.Log($"[InventoryBarController] Selected slot {selectedSlot}");
        UpdateSelection();
    }
    
    private void UpdateSelection()
{
    // Update visual selection
    if (selectionHighlight != null)
    {
        if (selectedSlot < barCells.Count)
        {
            selectionHighlight.transform.SetParent(barCells[selectedSlot].transform, false);
            selectionHighlight.transform.SetAsLastSibling();
            selectionHighlight.SetActive(true);
            
            RectTransform highlightRect = selectionHighlight.GetComponent<RectTransform>();
            if (highlightRect != null)
            {
                highlightRect.anchoredPosition = Vector2.zero;
                highlightRect.sizeDelta = cellSize;
            }
        }
    }
    
    // Update selected item from bar cell
    SelectedItem = null;
    if (selectedSlot < barCells.Count)
    {
        var selectedCell = barCells[selectedSlot];
        if (selectedCell.HasNode())
        {
            var nodeData = selectedCell.GetNodeData();
            var toolDef = selectedCell.GetToolDefinition();
            
            if (toolDef != null)
            {
                SelectedItem = InventoryBarItem.FromTool(toolDef);
            }
            else
            {
                // Find the corresponding NodeDefinition from the original inventory
                int inventoryIndex = currentRow * inventoryGridController.inventoryColumns + selectedSlot;
                
                // FIXED: Add bounds check here too
                if (inventoryIndex < inventoryGridController.TotalSlots)
                {
                    var inventoryCell = inventoryGridController.GetInventoryCellAtIndex(inventoryIndex);
                    if (inventoryCell != null && inventoryCell.HasNode())
                    {
                        var nodeView = inventoryCell.GetNodeView();
                        var nodeDef = nodeView?.GetNodeDefinition();
                        if (nodeData != null && nodeDef != null)
                        {
                            SelectedItem = InventoryBarItem.FromNode(nodeData, nodeDef, nodeView?.gameObject);
                        }
                    }
                }
            }
        }
    }
    
    Debug.Log($"[InventoryBarController] UpdateSelection: SelectedItem = {SelectedItem?.GetDisplayName() ?? "NULL"}");
    OnSelectionChanged?.Invoke(SelectedItem);
}
    
    void OnDestroy()
    {
        if (upArrowButton != null) upArrowButton.onClick.RemoveAllListeners();
        if (downArrowButton != null) downArrowButton.onClick.RemoveAllListeners();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\InventoryBarItem.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/UI/InventoryBarItem.cs
using UnityEngine;

[System.Serializable]
public class InventoryBarItem
{
    public enum ItemType { Node, Tool }
    
    [SerializeField] private ItemType itemType;
    [SerializeField] private NodeData nodeData;
    [SerializeField] private NodeDefinition nodeDefinition;
    [SerializeField] private ToolDefinition toolDefinition;
    [SerializeField] private GameObject viewGameObject;
    
    public ItemType Type => itemType;
    public NodeData NodeData => nodeData;
    public NodeDefinition NodeDefinition => nodeDefinition;
    public ToolDefinition ToolDefinition => toolDefinition;
    public GameObject ViewGameObject => viewGameObject;
    
    // Factory methods
    public static InventoryBarItem FromNode(NodeData data, NodeDefinition def, GameObject viewObj = null)
    {
        return new InventoryBarItem
        {
            itemType = ItemType.Node,
            nodeData = data,
            nodeDefinition = def,
            toolDefinition = null,
            viewGameObject = viewObj
        };
    }
    
    public static InventoryBarItem FromTool(ToolDefinition tool, GameObject viewObj = null)
    {
        return new InventoryBarItem
        {
            itemType = ItemType.Tool,
            nodeData = null,
            nodeDefinition = null,
            toolDefinition = tool,
            viewGameObject = viewObj
        };
    }
    
    public string GetDisplayName()
    {
        return itemType == ItemType.Node ? 
            (nodeDefinition?.displayName ?? nodeData?.nodeDisplayName ?? "Unknown Node") : 
            (toolDefinition?.displayName ?? "Unknown Tool");
    }
    
    public Sprite GetIcon()
    {
        return itemType == ItemType.Node ? nodeDefinition?.thumbnail : toolDefinition?.icon;
    }
    
    public Color GetIconTint()
    {
        return itemType == ItemType.Node ? 
            (nodeDefinition?.thumbnailTintColor ?? Color.white) : 
            (toolDefinition?.iconTint ?? Color.white);
    }
    
    public bool IsValid()
    {
        return itemType == ItemType.Node ? 
            (nodeData != null && nodeDefinition != null) : 
            (toolDefinition != null);
    }
    
    public bool IsSeed()
    {
        return itemType == ItemType.Node && nodeData != null && nodeData.IsSeed();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\InventoryGridController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/UI/InventoryGridController.cs
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Linq;

public class InventoryGridController : MonoBehaviour
{
    public static InventoryGridController Instance { get; private set; }

    [Header("Grid Layout & Appearance")]
    [SerializeField][Min(1)] public int inventoryRows = 2;
    [SerializeField][Min(1)] public int inventoryColumns = 8;
    [SerializeField] private Vector2 cellSize = new Vector2(64f, 64f);
    [SerializeField] private float cellMargin = 10f;

    [Header("Cell Visuals")]
    [SerializeField] private Sprite emptyCellSprite;
    [SerializeField] private Color emptyCellColor = Color.white;
    
    [Header("Tool Auto-Population")]
    [SerializeField] private ToolDefinition[] availableTools;

    [Header("Node Visuals (Shared or Specific)")]
    [SerializeField] private GameObject nodeViewPrefab;
    [SerializeField] private GameObject toolViewPrefab; // NEW: Add this field
    [Tooltip("Uniform scale factor for the gene/item image (thumbnail) within NodeViews. Default is 1.")]
    [SerializeField] private float nodeGlobalImageScale = 1f;
    [Tooltip("Padding to shrink the raycast area of node images. Negative values shrink. Default 0.")]
    [SerializeField] private float nodeImageRaycastPadding = 0f;

    [Header("UI References")]
    [SerializeField] private Transform cellContainer;
    [SerializeField] private Canvas _rootCanvas;

    [Header("Debugging")]
    [SerializeField] private bool logInventoryChanges = true;

    private List<NodeCell> inventoryCells = new List<NodeCell>();

    public GameObject NodeViewPrefab => nodeViewPrefab;
    public Color EmptyCellColor => emptyCellColor;
    public float NodeGlobalImageScale => nodeGlobalImageScale;
    public float NodeImageRaycastPadding => nodeImageRaycastPadding;
    
    // Get total slots
    public int TotalSlots => inventoryRows * inventoryColumns;
    
    // FIXED: Add property to get actual count of created cells
    public int ActualCellCount => inventoryCells?.Count ?? 0;

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;
    
        if (cellContainer == null) Debug.LogError("[InventoryGridController] Cell Container not assigned!", gameObject);
        if (nodeViewPrefab == null) Debug.LogError("[InventoryGridController] Node View Prefab not assigned!", gameObject);
        if (toolViewPrefab == null) Debug.LogWarning("[InventoryGridController] Tool View Prefab not assigned! Will use Node View Prefab for tools.", gameObject);
        if (_rootCanvas == null) Debug.LogError("[InventoryGridController] Root Canvas not assigned!", gameObject);
    }

    void Start()
    {
        if (cellContainer != null)
        {
            CreateInventoryCells();
            PopulateInitialGenesFromLibrary();
        }
    }

    private void CreateInventoryCells()
    {
        foreach (Transform child in cellContainer) Destroy(child.gameObject);
        inventoryCells.Clear();

        GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
        if (gridLayout == null) {
            Debug.LogError("[InventoryGridController] Cell Container MUST have GridLayoutGroup.", cellContainer.gameObject);
            return;
        }
        
        gridLayout.cellSize = cellSize;
        gridLayout.spacing = new Vector2(cellMargin, cellMargin);
        gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
        gridLayout.constraintCount = inventoryColumns;

        int totalCells = inventoryRows * inventoryColumns;
        Debug.Log($"[InventoryGridController] Creating {totalCells} inventory cells ({inventoryRows}x{inventoryColumns})");
        
        for (int i = 0; i < totalCells; i++)
        {
            GameObject cellGO = new GameObject($"InventoryCell_{i}", typeof(RectTransform));
            cellGO.transform.SetParent(cellContainer, false);
            Image cellImage = cellGO.AddComponent<Image>();
            cellImage.sprite = emptyCellSprite;
            cellImage.color = emptyCellColor;
            cellImage.raycastTarget = true;
            NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
            cellLogic.Init(i, this, cellImage); 
            inventoryCells.Add(cellLogic);
        }
        
        Debug.Log($"[InventoryGridController] Created {inventoryCells.Count} inventory cells successfully");
    }

    private void PopulateInitialGenesFromLibrary()
    {
        if (NodeEditorGridController.Instance == null || NodeEditorGridController.Instance.DefinitionLibrary == null) {
            Debug.LogWarning("[InventoryGridController] Cannot populate: NodeEditorGridController or DefinitionLibrary not ready.");
            return;
        }

        // FIXED: First add auto-add tools
        if (availableTools != null)
        {
            foreach (var tool in availableTools)
            {
                if (tool != null && tool.autoAddToInventory)
                {
                    bool success = AddToolToInventory(tool);
                    if (logInventoryChanges)
                    {
                        string prefabUsed = toolViewPrefab != null ? "ToolView prefab" : "NodeView prefab";
                        Debug.Log($"[Inventory] Auto-added tool '{tool.displayName}' using {prefabUsed}: {(success ? "Success" : "Failed - Inventory Full")}");
                    }
                }
            }
        }

        // Then add gene definitions (if there's space remaining)
        NodeDefinitionLibrary lib = NodeEditorGridController.Instance.DefinitionLibrary;
        if (lib.definitions != null) {
            int remainingSlots = TotalSlots - GetUsedSlotCount();
            var definitionsToAdd = lib.definitions.Where(d => d != null).Take(remainingSlots).ToList();
        
            foreach (var def in definitionsToAdd)
            {
                AddGeneToInventoryFromDefinition(def, null); 
            }
        
            if (definitionsToAdd.Count == 0 && lib.definitions.Count > 0)
                Debug.LogWarning("[InventoryGridController] No space remaining for gene definitions after adding tools.");
        }
    }
    
    private bool AddToolToInventory(ToolDefinition tool)
    {
        NodeCell emptyCell = inventoryCells.FirstOrDefault(cell => !cell.HasNode());
        if (emptyCell == null)
        {
            if (logInventoryChanges) Debug.LogWarning($"[Inventory] Could not add tool '{tool.displayName}', inventory full.");
            return false;
        }
    
        // Create NodeData for the tool
        NodeData toolNodeData = new NodeData()
        {
            nodeId = tool.name + "_tool_" + System.Guid.NewGuid().ToString(),
            nodeDisplayName = tool.displayName,
            effects = new List<NodeEffectData>(),
            orderIndex = -1, 
            canBeDeleted = false,
            storedSequence = new NodeGraph()
        };
    
        // Create the tool view
        GameObject toolViewGO = CreateToolView(tool, emptyCell.transform);
        if (toolViewGO != null)
        {
            // Initialize the ToolView component
            ToolView toolView = toolViewGO.GetComponent<ToolView>();
            if (toolView != null)
            {
                toolView.Initialize(toolNodeData, tool);
            }
            else
            {
                Debug.LogError($"[Inventory] Failed to get ToolView component on {toolViewGO.name}");
                Destroy(toolViewGO);
                return false;
            }
        
            // Setup draggable behavior
            NodeDraggable draggable = toolViewGO.GetComponent<NodeDraggable>() ?? toolViewGO.AddComponent<NodeDraggable>();
            draggable.Initialize(invCtrl: this, startingCell: emptyCell);
        
            // Assign to cell
            emptyCell.AssignToolView(toolViewGO, toolNodeData, tool);
        
            if (logInventoryChanges) 
                Debug.Log($"[Inventory] Added tool '{tool.displayName}' to inv cell {emptyCell.CellIndex}.");
            return true;
        }
    
        Debug.LogError($"[Inventory] Failed to create tool view for '{tool.displayName}'");
        return false;
    }

    private GameObject CreateToolView(ToolDefinition tool, Transform parent)
    {
        // FIXED: Use dedicated ToolView prefab if available, fallback to NodeView prefab
        GameObject prefabToUse = toolViewPrefab != null ? toolViewPrefab : nodeViewPrefab;
    
        if (prefabToUse == null)
        {
            Debug.LogError($"[Inventory] No ToolView prefab or NodeView prefab assigned for creating tool '{tool.displayName}'!");
            return null;
        }
    
        GameObject toolView = Instantiate(prefabToUse, parent);
        toolView.name = $"ToolView_{tool.displayName}";
    
        // If using NodeView prefab, convert it to ToolView
        if (prefabToUse == nodeViewPrefab)
        {
            // Remove NodeView component if it exists
            NodeView existingNodeView = toolView.GetComponent<NodeView>();
            if (existingNodeView != null)
            {
                DestroyImmediate(existingNodeView);
            }
        
            // Add ToolView component
            ToolView toolViewComponent = toolView.AddComponent<ToolView>();
        }
        // If using ToolView prefab, it should already have ToolView component
        else
        {
            ToolView toolViewComponent = toolView.GetComponent<ToolView>();
            if (toolViewComponent == null)
            {
                Debug.LogError($"[Inventory] ToolView prefab '{prefabToUse.name}' is missing ToolView component!");
                toolViewComponent = toolView.AddComponent<ToolView>();
            }
        }
    
        return toolView;
    }

    // Get used slot count
    private int GetUsedSlotCount()
    {
        return inventoryCells.Count(cell => cell.HasNode());
    }

    // <<< ENHANCED: Tries to use targetCellHint if provided and empty >>>
    public bool AddGeneToInventoryFromDefinition(NodeDefinition geneDef, NodeCell targetCellHint)
    {
        if (geneDef == null) return false;

        NodeCell cellToUse = null;

        // If a target cell hint is provided and it's actually an empty inventory cell, use it.
        if (targetCellHint != null && targetCellHint.IsInventoryCell && !targetCellHint.HasNode())
        {
            cellToUse = targetCellHint;
            if (logInventoryChanges) Debug.Log($"[Inventory AddGene] Using provided targetCellHint: {targetCellHint.CellIndex}");
        }
        else
        {
            // Fallback: find the first available empty cell
            cellToUse = inventoryCells.FirstOrDefault(cell => !cell.HasNode());
            if (logInventoryChanges && targetCellHint != null) Debug.Log($"[Inventory AddGene] TargetCellHint ({targetCellHint.CellIndex}) was not usable (IsInv: {targetCellHint.IsInventoryCell}, HasNode: {targetCellHint.HasNode()}). Using first available: {cellToUse?.CellIndex ?? -1}");
        }
        
        if (cellToUse != null)
        {
            NodeData inventoryNodeData = new NodeData() {
                nodeId = geneDef.name + "_inventory_" + System.Guid.NewGuid().ToString(),
                nodeDisplayName = geneDef.displayName,
                effects = geneDef.CloneEffects(),
                orderIndex = -1, 
                canBeDeleted = false,
                storedSequence = new NodeGraph()
            };

            GameObject nodeViewGO = Instantiate(nodeViewPrefab, cellToUse.transform);
            NodeView view = nodeViewGO.GetComponent<NodeView>();
            if (view == null) { Destroy(nodeViewGO); return false; }
            
            view.Initialize(inventoryNodeData, geneDef, null);

            NodeDraggable draggable = view.GetComponent<NodeDraggable>() ?? view.gameObject.AddComponent<NodeDraggable>();
            draggable.Initialize(invCtrl: this, startingCell: cellToUse);

            cellToUse.AssignNodeView(view, inventoryNodeData);
            if (logInventoryChanges) Debug.Log($"[Inventory] Added '{geneDef.displayName}' to inv cell {cellToUse.CellIndex}. IsSeed: {inventoryNodeData.IsSeed()}");
            return true;
        }

        if (logInventoryChanges) Debug.LogWarning($"[Inventory] Could not add '{geneDef.displayName}', inventory full or no suitable cell found.");
        return false;
    }
    
    public InventoryBarItem GetItemAtIndex(int index)
    {
        // FIXED: Add bounds checking
        if (index >= 0 && index < inventoryCells.Count)
        {
            var cell = inventoryCells[index];
            if (cell.HasNode())
            {
                var toolDef = cell.GetToolDefinition();
                if (toolDef != null)
                {
                    return InventoryBarItem.FromTool(toolDef, cell.GetNodeView()?.gameObject);
                }
                else
                {
                    var nodeData = cell.GetNodeData();
                    var nodeView = cell.GetNodeView();
                    var nodeDef = nodeView?.GetNodeDefinition();
                
                    if (nodeData != null && nodeDef != null)
                    {
                        return InventoryBarItem.FromNode(nodeData, nodeDef, nodeView.gameObject);
                    }
                }
            }
        }
        else
        {
            Debug.LogWarning($"[InventoryGridController] GetItemAtIndex: Index {index} out of bounds (0-{inventoryCells.Count-1})");
        }
        return null;
    }

    // This method takes an *existing* NodeView and its *existing* NodeData (e.g., from seed slot or sequence editor)
    // and places it into an inventory slot.
    public void ReturnGeneToInventory(NodeView geneViewToReturn, NodeData geneDataToReturn)
    {
        if (geneViewToReturn == null || geneDataToReturn == null)
        {
            Debug.LogError("[InventoryGridController] ReturnGeneToInventory: geneView or geneData is null.");
            if (geneViewToReturn != null) Destroy(geneViewToReturn.gameObject);
            return;
        }

        NodeCell emptyCell = inventoryCells.FirstOrDefault(cell => !cell.HasNode());
        if (emptyCell == null)
        {
            if (logInventoryChanges) Debug.LogWarning($"[Inventory] Full. Cannot return '{geneDataToReturn.nodeDisplayName}'. Destroying item.");
            Destroy(geneViewToReturn.gameObject);
            return;
        }

        // Update NodeData properties for inventory context
        geneDataToReturn.orderIndex = -1;
        geneDataToReturn.canBeDeleted = false;

        emptyCell.AssignNodeView(geneViewToReturn, geneDataToReturn);

        NodeDraggable draggable = geneViewToReturn.GetComponent<NodeDraggable>();
        if (draggable == null) draggable = geneViewToReturn.gameObject.AddComponent<NodeDraggable>();
        draggable.Initialize(invCtrl: this, startingCell: emptyCell);
        draggable.SnapToCell(emptyCell);

        if (logInventoryChanges) Debug.Log($"[Inventory] Returned '{geneDataToReturn.nodeDisplayName}' to inv cell {emptyCell.CellIndex}. IsSeed: {geneDataToReturn.IsSeed()}, StoredSeqCount: {geneDataToReturn.storedSequence?.nodes?.Count ?? 0}");
    }

    public void RemoveGeneFromInventory(NodeCell inventoryCell)
    {
        if (inventoryCell == null || !inventoryCell.HasNode() || !inventoryCell.IsInventoryCell) return;
        NodeData removedData = inventoryCell.GetNodeData();
        if (removedData != null) {
            if (logInventoryChanges) Debug.Log($"[Inventory] Dragged out '{removedData.nodeDisplayName}' from inv cell {inventoryCell.CellIndex}");
        }
        inventoryCell.ClearNodeReference();
    }

    public NodeCell FindInventoryCellAtScreenPosition(Vector2 screenPosition)
    {
        if (_rootCanvas == null) return null;
        foreach (NodeCell cell in inventoryCells) {
            RectTransform cellRect = cell.GetComponent<RectTransform>();
            if (RectTransformUtility.RectangleContainsScreenPoint(cellRect, screenPosition, _rootCanvas.worldCamera)) {
                return cell;
            }
        }
        return null;
    }

    public void HandleDropOnInventoryCell(NodeDraggable draggedDraggable, NodeCell originalCell, NodeCell targetInventoryCell)
{
    if (draggedDraggable == null || originalCell == null || targetInventoryCell == null || !targetInventoryCell.IsInventoryCell) {
        if (logInventoryChanges) Debug.LogWarning($"[Inventory HandleDrop] Pre-condition fail. Dragged: {draggedDraggable != null}, Orig: {originalCell != null}, Target: {targetInventoryCell != null}, TargetIsInv: {targetInventoryCell?.IsInventoryCell}. Resetting.");
        draggedDraggable?.ResetPosition(); return;
    }

    // FIXED: Handle both NodeView and ToolView
    NodeView draggedNodeView = draggedDraggable.GetComponent<NodeView>();
    ToolView draggedToolView = draggedDraggable.GetComponent<ToolView>();
    NodeData draggedData = null;
    NodeDefinition draggedDef = null;
    ToolDefinition draggedToolDef = null;

    if (draggedNodeView != null)
    {
        draggedData = draggedNodeView.GetNodeData();
        draggedDef = draggedNodeView.GetNodeDefinition();
    }
    else if (draggedToolView != null)
    {
        draggedData = draggedToolView.GetNodeData();
        draggedToolDef = draggedToolView.GetToolDefinition();
    }

    if (draggedData == null || (draggedDef == null && draggedToolDef == null)) {
        Debug.LogError($"[InventoryGridController] HandleDrop: Dragged object missing View/Data/Definition! DraggedNodeView: {draggedNodeView != null}, DraggedToolView: {draggedToolView != null}, DraggedData: {draggedData != null}, DraggedDef: {draggedDef != null}, DraggedToolDef: {draggedToolDef != null}. Resetting.", draggedDraggable.gameObject);
        draggedDraggable.ResetPosition(); return;
    }

    if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Attempting drop. Original Cell - IsInv: {originalCell.IsInventoryCell}, IsSeedSlot: {originalCell.IsSeedSlot}. Target Cell: {targetInventoryCell.CellIndex} (HasNode: {targetInventoryCell.HasNode()})");

    // --- Case 1: Node dragged FROM SEED SLOT TO INVENTORY ---
    if (!originalCell.IsInventoryCell && originalCell.IsSeedSlot)
    {
        if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Path: SeedSlot -> Inventory. Seed: '{draggedData.nodeDisplayName}'");

        NodeCell actualTargetInvCell = targetInventoryCell;
        if (actualTargetInvCell.HasNode()) 
        {
            if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Target Inv Cell {actualTargetInvCell.CellIndex} is occupied by {actualTargetInvCell.GetNodeData()?.nodeDisplayName}. Finding empty slot.");
            actualTargetInvCell = inventoryCells.FirstOrDefault(c => !c.HasNode());
        }

        if (actualTargetInvCell == null) { 
            if (logInventoryChanges) Debug.LogWarning($"[Inventory HandleDrop] Inventory Full. Cannot return Seed '{draggedData.nodeDisplayName}'. Resetting drag to original seed slot.");
            draggedDraggable.ResetPosition(); 
            return;
        }
        
        if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Target inventory cell for seed is: {actualTargetInvCell.CellIndex}. Unloading from Node Editor.");
        
        NodeEditorGridController.Instance.UnloadSeedFromSlot();
        
        if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Clearing original seed slot cell ({originalCell.CellIndex}, IsSeedSlot: {originalCell.IsSeedSlot}).");
        originalCell.ClearNodeReference(); 

        if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Assigning dragged seed '{draggedData.nodeDisplayName}' (View: {draggedNodeView.gameObject.name}) to inventory cell {actualTargetInvCell.CellIndex}.");
        actualTargetInvCell.AssignNodeView(draggedNodeView, draggedData); 
        
        if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Snapping '{draggedData.nodeDisplayName}' to inventory cell {actualTargetInvCell.CellIndex}.");
        draggedDraggable.SnapToCell(actualTargetInvCell); 

        if (logInventoryChanges) Debug.Log($"[Inventory] Returned Seed '{draggedData.nodeDisplayName}' from Seed Slot to inv cell {actualTargetInvCell.CellIndex}. StoredSeqCount: {draggedData.storedSequence?.nodes?.Count ?? 0}");
    }
    // --- Case 2: Node dragged FROM SEQUENCE EDITOR TO INVENTORY ---
    else if (!originalCell.IsInventoryCell && !originalCell.IsSeedSlot)
    {
        if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Path: SequenceEditor -> Inventory. Gene: '{draggedDef.displayName}' being dropped on InvCell: {targetInventoryCell.CellIndex}");
        
        NodeCell actualTargetInvCell = targetInventoryCell;

        if (actualTargetInvCell.HasNode()) {
            if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Target InvCell {actualTargetInvCell.CellIndex} for sequence item is occupied by {actualTargetInvCell.GetNodeData()?.nodeDisplayName}. Finding first available empty slot.");
            actualTargetInvCell = inventoryCells.FirstOrDefault(c => !c.HasNode());
        }
        
        if (actualTargetInvCell == null) {
            if (logInventoryChanges) Debug.LogWarning($"[Inventory HandleDrop] Inventory Full. Cannot move '{draggedDef.displayName}' from sequence. Resetting drag.");
            draggedDraggable.ResetPosition();
            return;
        }
        
        NodeEditorGridController.Instance?.GetCellAtIndex(originalCell.CellIndex)?.RemoveNode();
        NodeEditorGridController.Instance?.RefreshGraphAndUpdateSeed();

        AddGeneToInventoryFromDefinition(draggedDef, actualTargetInvCell); 
        Destroy(draggedDraggable.gameObject);

        if (logInventoryChanges) Debug.Log($"[Inventory] Moved '{draggedDef.displayName}' from seq cell {originalCell.CellIndex} to inv cell {actualTargetInvCell.CellIndex}.");
    }
    // --- Case 3: From INVENTORY to INVENTORY (Swapping or Moving) ---
    else if (originalCell.IsInventoryCell)
    {
        if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Path: Inventory -> Inventory. Item: '{draggedData.nodeDisplayName}'");
        if (targetInventoryCell == originalCell) {
            if (logInventoryChanges) Debug.Log("[Inventory HandleDrop] Dropped on self in inventory. Resetting.");
            draggedDraggable.ResetPosition(); return;
        }

        if (targetInventoryCell.HasNode()) { 
            if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Swapping with item in target cell {targetInventoryCell.CellIndex}.");
            
            // FIXED: Handle swapping with both NodeView and ToolView
            NodeView viewInTargetCell = targetInventoryCell.GetNodeView();
            ToolView toolViewInTargetCell = null;
            
            if (viewInTargetCell == null)
            {
                // Check if it's a tool view
                GameObject targetCellGO = null;
                foreach (Transform child in targetInventoryCell.transform)
                {
                    if (child.GetComponent<ToolView>() != null)
                    {
                        toolViewInTargetCell = child.GetComponent<ToolView>();
                        targetCellGO = child.gameObject;
                        break;
                    }
                }
                
                if (toolViewInTargetCell != null)
                {
                    NodeData dataInTargetCell = targetInventoryCell.GetNodeData();
                    ToolDefinition toolDefInTarget = targetInventoryCell.GetToolDefinition();
                    
                    originalCell.ClearNodeReference();
                    originalCell.AssignToolView(targetCellGO, dataInTargetCell, toolDefInTarget);
                    targetCellGO.GetComponent<NodeDraggable>()?.SnapToCell(originalCell);
                }
            }
            else
            {
                NodeData dataInTargetCell = targetInventoryCell.GetNodeData();
                
                originalCell.ClearNodeReference(); 
                originalCell.AssignNodeView(viewInTargetCell, dataInTargetCell);
                viewInTargetCell.GetComponent<NodeDraggable>()?.SnapToCell(originalCell);
            }
            
            targetInventoryCell.ClearNodeReference(); 
        } else { 
            if (logInventoryChanges) Debug.Log($"[Inventory HandleDrop] Moving to empty target cell {targetInventoryCell.CellIndex}.");
            originalCell.ClearNodeReference(); 
        }
        
        // FIXED: Assign based on whether it's a tool or node
        if (draggedToolView != null)
        {
            targetInventoryCell.AssignToolView(draggedToolView.gameObject, draggedData, draggedToolDef);
        }
        else
        {
            targetInventoryCell.AssignNodeView(draggedNodeView, draggedData);
        }
        
        draggedDraggable.SnapToCell(targetInventoryCell);
        if (logInventoryChanges) Debug.Log($"[Inventory] Moved inv item '{draggedData.nodeDisplayName}' from cell {originalCell.CellIndex} to cell {targetInventoryCell.CellIndex}.");
    }
    else
    {
        Debug.LogWarning($"[InventoryGridController HandleDrop] Unhandled drop scenario. Original IsInv: {originalCell.IsInventoryCell}, Original IsSeedSlot: {originalCell.IsSeedSlot}. Target IsInv: {targetInventoryCell.IsInventoryCell}. Resetting.", gameObject);
        draggedDraggable.ResetPosition();
    }
}

    public NodeCell GetInventoryCellAtIndex(int index)
    {
        // FIXED: Add bounds checking
        if (index >= 0 && index < inventoryCells.Count) return inventoryCells[index];
        
        Debug.LogWarning($"[InventoryGridController] GetInventoryCellAtIndex: Index {index} out of bounds (0-{inventoryCells.Count-1})");
        return null;
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeCell.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/UI/NodeCell.cs
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
public class NodeCell : MonoBehaviour, IPointerClickHandler, IDropHandler
{
    public static NodeCell CurrentlySelectedCell { get; private set; }
    public int CellIndex { get; private set; }
    public bool IsInventoryCell { get; private set; }
    public bool IsSeedSlot { get; private set; }

    private NodeEditorGridController _sequenceController;
    private InventoryGridController _inventoryController;

    private NodeData _nodeData;
    private NodeView _nodeView;

    private Image _backgroundImage;
    
    private ToolDefinition _toolDefinition;

    // Init for general cells (sequence or inventory)
    public void Init(int index, NodeEditorGridController sequenceController, InventoryGridController inventoryController, Image bgImage)
    {
        CellIndex = index;
        _sequenceController = sequenceController;
        _inventoryController = inventoryController;
        _backgroundImage = bgImage;
        IsInventoryCell = (_inventoryController != null);
        IsSeedSlot = false; // Default to not being a seed slot

        if (_backgroundImage != null)
        {
            Color emptyColor = Color.gray;
            if (IsInventoryCell && _inventoryController != null) emptyColor = _inventoryController.EmptyCellColor;
            else if (!IsInventoryCell && _sequenceController != null) emptyColor = _sequenceController.EmptyCellColor;
            _backgroundImage.color = emptyColor;
            _backgroundImage.enabled = true;
            _backgroundImage.raycastTarget = true;
        }
        else Debug.LogWarning($"[NodeCell {CellIndex}] Init: Background Image component is not assigned.", gameObject);
    }

    // Simplified Inits
    public void Init(int index, NodeEditorGridController sequenceController, Image bgImage)
    {
        Init(index, sequenceController, null, bgImage);
    }
    public void Init(int index, InventoryGridController inventoryController, Image bgImage)
    {
        Init(index, null, inventoryController, bgImage);
    }

    // Init specifically for the Seed Slot
    public void InitAsSeedSlot(NodeEditorGridController sequenceController, Image bgImage)
    {
        CellIndex = -1; // Or a specific sentinel value for the seed slot
        _sequenceController = sequenceController; // The NodeEditorGridController manages the seed slot
        _inventoryController = null;
        _backgroundImage = bgImage;
        IsInventoryCell = false; // Not an inventory cell
        IsSeedSlot = true;    // This is the seed slot

        if (_backgroundImage != null)
        {
            _backgroundImage.color = _sequenceController != null ? _sequenceController.EmptyCellColor : Color.magenta; // Use sequence empty color or a distinct color
            _backgroundImage.enabled = true;
            _backgroundImage.raycastTarget = true;
        }
        else Debug.LogWarning($"[NodeCell SeedSlot] Init: Background Image component is not assigned.", gameObject);
    }

    public bool HasNode()
    {
        return (_nodeData != null && _nodeView != null) || (_nodeData != null && _toolDefinition != null);
    }

    public NodeData GetNodeData()
    {
        return _nodeData;
    }

    public NodeView GetNodeView()
    {
        return _nodeView;
    }

    public void AssignNode(NodeDefinition def)
    {
        if (def == null)
        {
            Debug.LogError($"[NodeCell {CellIndex}] AssignNode called with a null NodeDefinition.", gameObject);
            return;
        }
        if (IsInventoryCell)
        {
            Debug.LogError($"[NodeCell {CellIndex}] AssignNode (for new sequence nodes) called on an inventory cell. Use InventoryGridController.AddGeneToInventory.", gameObject);
            return;
        }
        if (IsSeedSlot)
        {
            Debug.LogError($"[NodeCell SeedSlot] AssignNode (for new sequence nodes) called on the Seed Slot. Seeds should be dragged here.", gameObject);
            return;
        }
        if (_sequenceController == null)
        {
            Debug.LogError($"[NodeCell {CellIndex}] AssignNode called, but _sequenceController is null.", gameObject);
            return;
        }

        RemoveNode();

        _nodeData = new NodeData() {
            nodeId = System.Guid.NewGuid().ToString(),
            nodeDisplayName = def.displayName,
            effects = def.CloneEffects(),
            orderIndex = this.CellIndex,
            canBeDeleted = true
        };
        // Ensure storedSequence is new for regular nodes added to sequence (it won't be used by them)
        _nodeData.storedSequence = new NodeGraph();

        GameObject prefabToInstantiate = def.nodeViewPrefab != null ? def.nodeViewPrefab : _sequenceController.NodeViewPrefab;
        if (prefabToInstantiate == null) {
            Debug.LogError($"[NodeCell {CellIndex}] No NodeView prefab for '{def.displayName}'.", gameObject);
            _nodeData = null;
            if (_backgroundImage != null) _backgroundImage.raycastTarget = true;
            return;
        }

        GameObject nodeViewGO = Instantiate(prefabToInstantiate, transform);
        _nodeView = nodeViewGO.GetComponent<NodeView>();

        if (_nodeView == null) {
            Debug.LogError($"[NodeCell {CellIndex}] Prefab '{prefabToInstantiate.name}' missing NodeView. Destroying.", gameObject);
            Destroy(nodeViewGO);
            _nodeData = null;
            if (_backgroundImage != null) _backgroundImage.raycastTarget = true;
            return;
        }

        _nodeView.Initialize(_nodeData, def, _sequenceController);

        RectTransform viewRectTransform = _nodeView.GetComponent<RectTransform>();
        if (viewRectTransform != null) viewRectTransform.anchoredPosition = Vector2.zero;

        NodeDraggable draggable = _nodeView.GetComponent<NodeDraggable>() ?? _nodeView.gameObject.AddComponent<NodeDraggable>();
        draggable.Initialize(_sequenceController, null, this);

        if (_backgroundImage != null) _backgroundImage.raycastTarget = false;
    }
    
    // Get tool definition
    public ToolDefinition GetToolDefinition()
    {
        return _toolDefinition;
    }
    
    public void AssignToolView(GameObject toolView, NodeData data, ToolDefinition toolDef)
    {
        RemoveNode();
    
        _nodeView = toolView?.GetComponent<NodeView>(); // Might be null for tools
        _nodeData = data;
        _toolDefinition = toolDef;
    
        if (toolView != null)
        {
            toolView.transform.SetParent(transform, false);
            RectTransform viewRectTransform = toolView.GetComponent<RectTransform>();
            if (viewRectTransform != null) viewRectTransform.anchoredPosition = Vector2.zero;
        
            if (_backgroundImage != null) _backgroundImage.raycastTarget = false;
        }
        else if (_backgroundImage != null) _backgroundImage.raycastTarget = true;
        
        // FIXED: Debug logging to track tool assignment
        Debug.Log($"[NodeCell {CellIndex}] AssignToolView: Tool='{toolDef?.displayName}', HasView={toolView != null}, HasData={data != null}");
    }

    public void AssignNodeView(NodeView view, NodeData data)
    {
         RemoveNode();

         _nodeView = view;
         _nodeData = data;
         _toolDefinition = null; // Clear tool definition when assigning node view

         if (_nodeView != null) {
            _nodeView.transform.SetParent(transform, false);
            RectTransform viewRectTransform = _nodeView.GetComponent<RectTransform>();
            if (viewRectTransform != null) viewRectTransform.anchoredPosition = Vector2.zero;

            if (_nodeData != null && !IsInventoryCell && !IsSeedSlot && _sequenceController != null)
            {
                _nodeData.orderIndex = this.CellIndex;
            }

            if (_backgroundImage != null) _backgroundImage.raycastTarget = false;
         }
         else if (_backgroundImage != null) _backgroundImage.raycastTarget = true;
         
         // FIXED: Debug logging to track node assignment
         Debug.Log($"[NodeCell {CellIndex}] AssignNodeView: Node='{data?.nodeDisplayName}', HasView={view != null}");
    }

    public void RemoveNode()
    {
        bool wasSelected = (CurrentlySelectedCell == this && !IsInventoryCell && !IsSeedSlot);
        if (_nodeView != null) {
            if (wasSelected) _nodeView.Unhighlight();
            Destroy(_nodeView.gameObject);
        }
        _nodeView = null;
        _nodeData = null;
        _toolDefinition = null;
        if (wasSelected) NodeCell.ClearSelection();

        if (_backgroundImage != null) _backgroundImage.raycastTarget = true;
        
        Debug.Log($"[NodeCell {CellIndex}] RemoveNode: Cleared all references");
    }

    // Assign display-only item (for inventory bar)
    public void AssignDisplayOnly(GameObject displayObject, NodeData data, ToolDefinition toolDef)
    {
        RemoveNode();
    
        _nodeView = null; // No NodeView for display-only
        _nodeData = data;
        _toolDefinition = toolDef;
    
        if (displayObject != null)
        {
            displayObject.transform.SetParent(transform, false);
            RectTransform displayRect = displayObject.GetComponent<RectTransform>();
            if (displayRect != null) displayRect.anchoredPosition = Vector2.zero;
        
            if (_backgroundImage != null) _backgroundImage.raycastTarget = false;
        }
        else if (_backgroundImage != null) _backgroundImage.raycastTarget = true;
        
        // FIXED: Debug logging for display-only assignment
        Debug.Log($"[NodeCell {CellIndex}] AssignDisplayOnly: Item='{data?.nodeDisplayName ?? toolDef?.displayName}', IsDisplayOnly=true");
    }

    public void ClearNodeReference()
    {
        _nodeView = null;
        _nodeData = null;
        _toolDefinition = null;
        if (_backgroundImage != null) _backgroundImage.raycastTarget = true;
        
        Debug.Log($"[NodeCell {CellIndex}] ClearNodeReference: References cleared but GameObject not destroyed");
    }

    public static void SelectCell(NodeCell cellToSelect)
    {
        if (cellToSelect == null || !cellToSelect.HasNode() || cellToSelect.IsInventoryCell || cellToSelect.IsSeedSlot)
        {
            ClearSelection();
            return;
        }
        if (CurrentlySelectedCell == cellToSelect) return;
        
        ClearSelection();

        CurrentlySelectedCell = cellToSelect;
        if (CurrentlySelectedCell?.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Highlight();
        }
    }

    public static void ClearSelection()
    {
        if (CurrentlySelectedCell?.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Unhighlight();
        }
        CurrentlySelectedCell = null;
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        if (eventData.button == PointerEventData.InputButton.Right)
        {
            if (!HasNode() && !IsInventoryCell && !IsSeedSlot && _sequenceController != null)
            {
                ClearSelection();
                _sequenceController.OnEmptyCellRightClicked(this, eventData);
            }
            // Right-clicking seed slot or inventory does nothing for now
        }
        else if (eventData.button == PointerEventData.InputButton.Left)
        {
            if (HasNode() && !IsInventoryCell && !IsSeedSlot) SelectCell(this);
            else if (!HasNode()) ClearSelection();
        }
    }

    public void OnDrop(PointerEventData eventData)
    {
        GameObject draggedObject = eventData.pointerDrag;
        if (draggedObject == null) return;

        NodeDraggable draggedDraggable = draggedObject.GetComponent<NodeDraggable>();
        if (draggedDraggable == null) return;

        NodeCell originalCell = draggedDraggable.OriginalCell;
        if (originalCell == null) {
            Debug.LogError($"[NodeCell {CellIndex} OnDrop] Dragged node '{draggedDraggable.name}' missing originalCell. Resetting.", draggedDraggable.gameObject);
            draggedDraggable.ResetPosition();
            return;
        }

        // FIXED: Handle both NodeView and ToolView
        NodeView draggedNodeView = draggedDraggable.GetComponent<NodeView>();
        ToolView draggedToolView = draggedDraggable.GetComponent<ToolView>();
        NodeData draggedData = null;

        if (draggedNodeView != null)
        {
            draggedData = draggedNodeView.GetNodeData();
        }
        else if (draggedToolView != null)
        {
            draggedData = draggedToolView.GetNodeData();
        }

        if (draggedData == null) {
             Debug.LogError($"[NodeCell {CellIndex} OnDrop] Dragged object '{draggedDraggable.name}' missing NodeView/ToolView or NodeData. Resetting.", draggedDraggable.gameObject);
             draggedDraggable.ResetPosition();
             return;
        }

        // --- Drop handling logic ---
        if (this.IsSeedSlot && _sequenceController != null)
        {
            _sequenceController.HandleDropOnSeedSlot(draggedDraggable, originalCell, this);
        }
        else if (!this.IsInventoryCell && _sequenceController != null)
        {
            _sequenceController.HandleDropOnSequenceCell(draggedDraggable, originalCell, this);
        }
        else if (this.IsInventoryCell && _inventoryController != null)
        {
            _inventoryController.HandleDropOnInventoryCell(draggedDraggable, originalCell, this);
        }
        else
        {
            Debug.LogWarning($"[NodeCell {CellIndex} OnDrop] (IsInventory: {IsInventoryCell}, IsSeedSlot: {IsSeedSlot}) Target cell type unhandled or controller missing. Resetting.", gameObject);
            draggedDraggable.ResetPosition();
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeDraggable.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/UI/NodeDraggable.cs
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
public class NodeDraggable : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
    private RectTransform _rectTransform;
    private CanvasGroup _canvasGroup;
    private Vector2 _originalAnchoredPosition;
    private Transform _originalParent;
    private NodeCell _originalCell;
    private NodeEditorGridController _gridController; // Controller if in sequence or seed slot
    private InventoryGridController _inventoryController; // Controller if in inventory
    private Canvas _rootCanvas;
    
    private Transform _temporaryParentStorage;

    public NodeCell OriginalCell => _originalCell;
    public bool IsFromInventoryGrid => _inventoryController != null && _gridController == null; // More specific check

    void Awake()
    {
        _rectTransform = GetComponent<RectTransform>();
        _canvasGroup = GetComponent<CanvasGroup>() ?? gameObject.AddComponent<CanvasGroup>();
    }

    // Call this after the NodeView is placed in a cell
    public void Initialize(NodeEditorGridController gridCtrl, InventoryGridController invCtrl, NodeCell startingCell)
    {
        _gridController = gridCtrl;
        _inventoryController = invCtrl;
        _originalCell = startingCell;

        if (_rootCanvas == null) _rootCanvas = GetComponentInParent<Canvas>()?.rootCanvas;
        if (_rootCanvas == null) _rootCanvas = FindFirstObjectByType<Canvas>(); // Fallback
        if (_rootCanvas == null) Debug.LogError("[NodeDraggable] Could not find root Canvas!", gameObject);

        if (_canvasGroup != null)
        {
            _canvasGroup.blocksRaycasts = true;
            _canvasGroup.alpha = 1f;
        }
    }
    // Convenience initializers
    public void Initialize(NodeEditorGridController gridCtrl, NodeCell startingCell) => Initialize(gridCtrl, null, startingCell);
    public void Initialize(InventoryGridController invCtrl, NodeCell startingCell) => Initialize(null, invCtrl, startingCell);


    public void OnBeginDrag(PointerEventData eventData)
{
    if (eventData.button != PointerEventData.InputButton.Left) return;

    if (_originalCell == null)
    {
        Debug.LogError($"[NodeDraggable OnBeginDrag] Critical error: _originalCell is null for {gameObject.name}. Drag aborted.", gameObject);
        eventData.pointerDrag = null;
        return;
    }

    // FIXED: Handle both NodeView and ToolView components
    NodeView nodeView = GetComponent<NodeView>();
    ToolView toolView = GetComponent<ToolView>();
    NodeData data = null;

    if (nodeView != null)
    {
        data = nodeView.GetNodeData();
    }
    else if (toolView != null)
    {
        data = toolView.GetNodeData();
    }

    if (data == null)
    {
        Debug.LogError($"[NodeDraggable OnBeginDrag] Missing NodeView/ToolView or NodeData on {gameObject.name}. Drag aborted.", gameObject);
        eventData.pointerDrag = null;
        return;
    }

    // --- MODIFIED LOGIC TO ALLOW DRAGGING FROM SEED SLOT ---
    // Prevent dragging if:
    // 1. It's in a SEQUENCE EDITOR cell (not inventory, not seed slot)
    // AND
    // 2. Its NodeData.canBeDeleted is false (which we use as a proxy for non-movable in sequence)
    bool isInSequenceEditorCell = _gridController != null && _originalCell != null && !_originalCell.IsInventoryCell && !_originalCell.IsSeedSlot;

    if (isInSequenceEditorCell && !data.canBeDeleted)
    {
        Debug.Log($"Node '{data.nodeDisplayName}' in sequence editor cell {_originalCell.CellIndex} is configured as non-draggable/non-deletable.", gameObject);
        eventData.pointerDrag = null; // This prevents the drag from starting
        return;
    }

    if (_rootCanvas == null)
    {
        Debug.LogError("[NodeDraggable] OnBeginDrag: Root Canvas is null! Cannot start drag.", gameObject);
        eventData.pointerDrag = null;
        return;
    }

    _originalParent = transform.parent;
    _originalAnchoredPosition = _rectTransform.anchoredPosition;

    _canvasGroup.alpha = 0.6f;
    _canvasGroup.blocksRaycasts = false;

    transform.SetParent(_rootCanvas.transform, true);
    transform.SetAsLastSibling();

    Vector2 mouseLocalPosInCanvas;
    RectTransformUtility.ScreenPointToLocalPointInRectangle(
        _rootCanvas.transform as RectTransform,
        eventData.position,
        _rootCanvas.worldCamera,
        out mouseLocalPosInCanvas
    );
    _rectTransform.localPosition = mouseLocalPosInCanvas;
}

    public void OnDrag(PointerEventData eventData)
    {
        if (eventData.button != PointerEventData.InputButton.Left || _canvasGroup == null || _canvasGroup.blocksRaycasts) return;
        if (_rootCanvas == null || _rectTransform == null) return;

        Vector2 mouseLocalPosInCanvas;
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(
            _rootCanvas.transform as RectTransform,
            eventData.position,
            _rootCanvas.worldCamera,
            out mouseLocalPosInCanvas))
        {
            _rectTransform.localPosition = mouseLocalPosInCanvas;
        }
    }

    public void OnEndDrag(PointerEventData eventData)
    {
        if (_canvasGroup != null)
        {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
        }

        if (eventData.button != PointerEventData.InputButton.Left)
        {
            // If it wasn't a left-drag, or if drag was cancelled by setting pointerDrag = null
            if (transform.parent == _rootCanvas.transform) // Check if it was actually reparented for dragging
            {
                ResetPosition();
            }
            return;
        }
        
        GameObject dropTargetGO = eventData.pointerEnter;
        NodeCell targetCell = dropTargetGO?.GetComponent<NodeCell>();

        // If not dropped on a NodeCell, or if the drag was not processed by a NodeCell's OnDrop
        // (e.g. because targetCell was null or OnDrop did nothing and ResetPosition wasn't called by it),
        // then reset it here.
        // A successful drop via NodeCell.OnDrop would have called SnapToCell, changing the parent.
        if (targetCell == null || transform.parent == _rootCanvas.transform)
        {
            ResetPosition();
        }
        // If dropped on a cell, NodeCell.OnDrop handles the logic, including calling SnapToCell or ResetPosition.
    }
    
    public void SetTemporaryParent(Transform tempParent)
    {
        _temporaryParentStorage = tempParent;
    }
    
    public void RestoreToTemporaryParent()
    {
        if (_temporaryParentStorage != null)
        {
            transform.SetParent(_temporaryParentStorage, false);
            _temporaryParentStorage = null;
        }
    }

    public void ResetPosition()
    {
        if (_originalParent == null || _originalCell == null)
        {
            // This can happen if the original cell/parent was destroyed during drag
            Debug.LogWarning($"[NodeDraggable ResetPosition] {gameObject.name} missing original parent/cell. Object might be orphaned or destroyed.", gameObject);
            // Consider destroying the object if it's truly orphaned to prevent issues
            // if (Application.isPlaying) Destroy(gameObject);
            return;
        }

        transform.SetParent(_originalParent, false);
        _rectTransform.anchoredPosition = _originalAnchoredPosition;

        if (_canvasGroup != null)
        {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
        }
    }

    public void SnapToCell(NodeCell targetCell)
    {
        if (targetCell == null)
        {
            Debug.LogWarning($"[NodeDraggable SnapToCell] TargetCell is null for {gameObject.name}. Attempting Reset.", gameObject);
            ResetPosition();
            return;
        }

        transform.SetParent(targetCell.transform, false);
        _rectTransform.anchoredPosition = Vector2.zero;

        // Update original state to the new cell
        _originalParent = targetCell.transform;
        _originalCell = targetCell;
        _originalAnchoredPosition = Vector2.zero; // It's now centered in the new cell

        if (_canvasGroup != null)
        {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
        }
        
        GetComponent<NodeView>()?.UpdateParentCellReference();

        // Update controller references based on the target cell's type
        if (targetCell.IsInventoryCell)
        {
            _inventoryController = InventoryGridController.Instance;
            _gridController = null;
        }
        else if (targetCell.IsSeedSlot)
        {
            _inventoryController = null;
            _gridController = NodeEditorGridController.Instance; // Seed slot is managed by NodeEditorGridController
        }
        else // It's a sequence editor cell
        {
            _inventoryController = null;
            _gridController = NodeEditorGridController.Instance;
        }
    }

    void OnDisable()
    {
        // If the draggable is disabled mid-drag (e.g. parent panel hidden), ensure raycasts are re-enabled.
        if (_canvasGroup != null && _canvasGroup.blocksRaycasts == false)
        {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
            // Potentially reset position too, if that's desired behavior for an interrupted drag.
            // if (transform.parent == _rootCanvas?.transform) ResetPosition();
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeEditorGridController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/UI/NodeEditorGridController.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using TMPro;
using System.Linq;

public class NodeEditorGridController : MonoBehaviour
{
    public static NodeEditorGridController Instance { get; private set; }

    [Header("Grid Layout & Appearance (Sequence Editor)")]
    [SerializeField][Min(1)] private int emptyCellsCount = 8;
    [SerializeField] private Vector2 cellSize = new Vector2(64f, 64f);
    [SerializeField] private float cellMargin = 10f;

    [Header("Empty Cell Visuals")]
    [SerializeField] private Sprite emptyCellSprite;
    [SerializeField] private Color emptyCellColor = Color.white;
    [SerializeField] private Vector3 emptyCellScale = Vector3.one;

    [Header("Node Visuals")]
    [SerializeField] private GameObject nodeViewPrefab;
    [SerializeField] private Color selectedNodeBackgroundColor = new Color(0.9f, 0.9f, 0.7f, 1f);

    [Header("Node Definitions & Interaction")]
    [SerializeField] private NodeDefinitionLibrary definitionLibrary;
    [SerializeField] private TMP_Dropdown nodeDropdown;

    [Header("UI References")]
    [SerializeField] public GameObject gridUIParent;
    [SerializeField] private Transform cellContainer;

    [Header("Seed Slot Specifics")]
    [SerializeField] private Transform seedSlotContainer;

    private List<NodeCell> nodeCells = new List<NodeCell>();
    private NodeCell _actualSeedSlotCell;
    private Canvas _rootCanvas;
    
    // This represents the sequence CURRENTLY BEING EDITED in the UI.
    // It's populated from the seed's storedSequence when a seed is loaded.
    // Changes here are written back to the loaded seed's storedSequence.
    // To prevent serialization cycles with Unity trying to serialize the controller,
    // and this graph possibly being part of a NodeData that is ALSO serialized elsewhere,
    // we can mark it [System.NonSerialized] if it's purely runtime state.
    // However, the errors point to NodeData.storedSequence recursion.
    [System.NonSerialized] // Let's try this. This means it won't be saved with the scene/prefab.
    private NodeGraph _currentlyEditedSequence = new NodeGraph();


    public GameObject NodeViewPrefab => nodeViewPrefab;
    public NodeDefinitionLibrary DefinitionLibrary => definitionLibrary;
    public Color SelectedNodeBackgroundColor => selectedNodeBackgroundColor;
    public Color EmptyCellColor => emptyCellColor;

    // This method should return a CLONE of the currently edited sequence for spawning,
    // to prevent the plant from holding a direct reference to the UI's graph.
    public NodeGraph GetCurrentGraphInEditorForSpawning()
    {
        NodeGraph clone = new NodeGraph();
        clone.nodes = new List<NodeData>();
        if (_currentlyEditedSequence != null && _currentlyEditedSequence.nodes != null)
        {
            foreach (var nodeData in _currentlyEditedSequence.nodes)
            {
                if (nodeData == null) continue;
                // Create a new NodeData instance for the clone
                NodeData clonedNode = new NodeData
                {
                    nodeId = nodeData.nodeId, // Keep ID for this instance of graph
                    nodeDisplayName = nodeData.nodeDisplayName,
                    effects = NodeExecutor.CloneEffectsList(nodeData.effects), // Deep copy effects
                    orderIndex = nodeData.orderIndex,
                    canBeDeleted = nodeData.canBeDeleted, // This might always be false for runtime plant nodes
                    storedSequence = new NodeGraph() // Nodes *within* a sequence DO NOT have their own stored sequences
                };
                clone.nodes.Add(clonedNode);
            }
        }
        return clone;
    }

    public NodeData GetCurrentSeedInSlot() => _actualSeedSlotCell != null ? _actualSeedSlotCell.GetNodeData() : null;
    public NodeCell SeedSlotCell => _actualSeedSlotCell;

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Initialize _currentlyEditedSequence if it's NonSerialized
        if (_currentlyEditedSequence == null) _currentlyEditedSequence = new NodeGraph();


        if (_rootCanvas == null) _rootCanvas = GetComponentInParent<Canvas>()?.rootCanvas;
        if (_rootCanvas == null) _rootCanvas = FindFirstObjectByType<Canvas>();
        if (_rootCanvas == null) Debug.LogError("[NodeEditorGridController] Root Canvas not found!", gameObject);

        if (gridUIParent == null) Debug.LogError("[NodeEditorGridController] Grid UI Parent (sequence editor panel) not assigned.", gameObject);
        if (cellContainer == null) Debug.LogError("[NodeEditorGridController] Cell Container (for sequence) not assigned.", gameObject);
        if (nodeDropdown == null) Debug.LogWarning("[NodeEditorGridController] Node Dropdown not assigned.", gameObject);
        if (definitionLibrary == null) Debug.LogError("[NodeEditorGridController] Node Definition Library not assigned!", gameObject);
        
        if (seedSlotContainer == null)
        {
            Debug.LogError("[NodeEditorGridController] Seed Slot Container is not assigned in the Inspector! Seed slot will not be created.", gameObject);
        }
    }

    void OnDestroy()
    {
        if (Instance == this) Instance = null;
    }

    void Start()
    {
        if (nodeDropdown != null) nodeDropdown.gameObject.SetActive(false);

        if (seedSlotContainer != null)
        {
            CreateSeedSlot();
        }

        if (cellContainer != null && definitionLibrary != null)
        {
            CreateSequenceCells();
            HideNodeEditorPanel(); // Start hidden
            // RefreshGraph(); // Called by LoadSequenceFromSeed or UnloadSeedFromSlot
        }
        else
        {
            Debug.LogError("[NodeEditorGridController] Cannot initialize sequence grid - Cell Container or Definition Library is missing.", gameObject);
        }
    }

    private void CreateSeedSlot()
    {
        if (seedSlotContainer == null) return;
        foreach (Transform child in seedSlotContainer) Destroy(child.gameObject);

        GameObject seedCellGO = new GameObject("SeedSlot_Cell", typeof(RectTransform));
        seedCellGO.transform.SetParent(seedSlotContainer, false);

        RectTransform rt = seedCellGO.GetComponent<RectTransform>();
        rt.sizeDelta = cellSize;

        Image cellImage = seedCellGO.AddComponent<Image>();
        cellImage.sprite = emptyCellSprite;
        cellImage.color = emptyCellColor;
        cellImage.raycastTarget = true;

        NodeCell cellLogic = seedCellGO.AddComponent<NodeCell>();
        cellLogic.InitAsSeedSlot(this, cellImage);
        _actualSeedSlotCell = cellLogic;

        Debug.Log("[NodeEditorGridController] Seed Slot cell created and initialized.", _actualSeedSlotCell.gameObject);
    }

    private void CreateSequenceCells()
    {
        // ... (no changes from previous version other than RectTransform ensuring)
        if (cellContainer == null) return;

        foreach (Transform child in cellContainer)
        {
            NodeCell nc = child.GetComponent<NodeCell>();
            if (nc != null && !nc.IsSeedSlot) Destroy(child.gameObject);
        }
        nodeCells.Clear();
        NodeCell.ClearSelection();

        GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
        if (gridLayout == null)
        {
            Debug.LogWarning("[NodeEditorGridController] Sequence Cell Container does not have a GridLayoutGroup. Manual layout may be incorrect.", cellContainer.gameObject);
            RectTransform containerRect = cellContainer.GetComponent<RectTransform>();
            if (containerRect == null) { Debug.LogError("CellContainer needs a RectTransform for manual layout!", cellContainer.gameObject); return; }
            float totalWidth = (emptyCellsCount * cellSize.x) + ((emptyCellsCount - 1) * cellMargin);
            float startX = -(totalWidth / 2f) + (cellSize.x / 2f);
            for (int i = 0; i < emptyCellsCount; i++)
            {
                GameObject cellGO = new GameObject($"SequenceCell_{i}", typeof(RectTransform)); 
                cellGO.transform.SetParent(cellContainer, false);

                RectTransform rt_cell = cellGO.GetComponent<RectTransform>(); // rt_cell to avoid conflict with rt from CreateSeedSlot
                rt_cell.sizeDelta = cellSize;
                rt_cell.localScale = emptyCellScale;
                rt_cell.anchorMin = new Vector2(0.5f, 0.5f); rt_cell.anchorMax = new Vector2(0.5f, 0.5f);
                rt_cell.pivot = new Vector2(0.5f, 0.5f);
                rt_cell.anchoredPosition = new Vector2(startX + i * (cellSize.x + cellMargin), 0);
                
                SetupCellComponents(cellGO, i);
            }
        }
        else 
        {
            gridLayout.cellSize = cellSize;
            gridLayout.spacing = new Vector2(cellMargin, cellMargin);
            for (int i = 0; i < emptyCellsCount; i++)
            {
                GameObject cellGO = new GameObject($"SequenceCell_{i}", typeof(RectTransform));
                cellGO.transform.SetParent(cellContainer, false);
                SetupCellComponents(cellGO, i);
            }
        }
    }
    
    private void SetupCellComponents(GameObject cellGO, int index)
    {
        // ... (no changes)
        Image cellImage = cellGO.AddComponent<Image>();
        cellImage.sprite = emptyCellSprite;
        cellImage.color = emptyCellColor;
        cellImage.raycastTarget = true;
        NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
        cellLogic.Init(index, this, null, cellImage);
        nodeCells.Add(cellLogic);
    }

    void Update()
    {
        // ... (no changes regarding Delete/Escape handling)
        if (gridUIParent != null && gridUIParent.activeInHierarchy)
        {
            if (Input.GetKeyDown(KeyCode.Delete))
            {
                if (NodeCell.CurrentlySelectedCell != null && 
                    !NodeCell.CurrentlySelectedCell.IsInventoryCell && 
                    NodeCell.CurrentlySelectedCell != _actualSeedSlotCell)
                {
                    NodeCell selected = NodeCell.CurrentlySelectedCell;
                    NodeData data = selected.GetNodeData();
                    if (data != null && data.canBeDeleted)
                    {
                        selected.RemoveNode();
                        RefreshGraphAndUpdateSeed(); // Modified call
                    }
                    else if (data != null && !data.canBeDeleted) Debug.Log($"Node '{data.nodeDisplayName}' in sequence cannot be deleted.");
                }
            }
            if (Input.GetKeyDown(KeyCode.Escape))
            {
                if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) HideDropdown();
                else if (NodeCell.CurrentlySelectedCell != null) NodeCell.ClearSelection();
            }
        }
    }
    
    public void ShowNodeEditorPanel() { if (gridUIParent != null) gridUIParent.SetActive(true); }
    public void HideNodeEditorPanel() { if (gridUIParent != null) { gridUIParent.SetActive(false); if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) HideDropdown(); NodeCell.ClearSelection(); } }

    public void LoadSequenceFromSeed(NodeData seedData)
    {
        if (_actualSeedSlotCell == null) { Debug.LogError("Seed slot not initialized. Cannot load sequence."); return; }

        if (seedData == null || !seedData.IsSeed())
        {
            Debug.LogError("[NodeEditorGridController] LoadSequenceFromSeed: Invalid or non-seed data.", gameObject);
            HideNodeEditorPanel();
            _currentlyEditedSequence.nodes.Clear(); // Clear editor graph
            return;
        }

        ClearSequenceEditorCells();
        _currentlyEditedSequence.nodes.Clear(); // Clear the internal editor representation first

        if (seedData.storedSequence != null && seedData.storedSequence.nodes != null)
        {
            foreach (NodeData nodeDataInSeed in seedData.storedSequence.nodes.OrderBy(n => n.orderIndex))
            {
                if (nodeDataInSeed == null) continue;
                if (nodeDataInSeed.orderIndex >= 0 && nodeDataInSeed.orderIndex < nodeCells.Count)
                {
                    NodeCell targetCell = nodeCells[nodeDataInSeed.orderIndex];
                    // IMPORTANT: Find the NodeDefinition based on the node's display name or a persistent ID.
                    NodeDefinition def = definitionLibrary.definitions.FirstOrDefault(d => d.displayName == nodeDataInSeed.nodeDisplayName);
                    
                    if (def != null)
                    {
                        GameObject prefabToInstantiate = def.nodeViewPrefab != null ? def.nodeViewPrefab : this.NodeViewPrefab;
                        if (prefabToInstantiate == null) {
                            Debug.LogError($"No NodeView prefab for '{def.displayName}'.", gameObject);
                            continue;
                        }
                        GameObject nodeViewGO = Instantiate(prefabToInstantiate, targetCell.transform);
                        NodeView view = nodeViewGO.GetComponent<NodeView>();
                        if (view != null)
                        {
                            // Initialize NodeView with the NodeData instance from the seed's storedSequence.
                            // This NodeData should already have its `storedSequence` as an empty graph.
                            if (nodeDataInSeed.storedSequence == null || nodeDataInSeed.storedSequence.nodes.Count > 0)
                            {
                                // This is a sanity check. Nodes *within* a seed's sequence should not have their own sub-sequences.
                                // If they do, it's a data setup error.
                                Debug.LogWarning($"Node '{nodeDataInSeed.nodeDisplayName}' inside seed '{seedData.nodeDisplayName}' sequence has its own storedSequence. Clearing it.");
                                nodeDataInSeed.storedSequence = new NodeGraph();
                            }
                            view.Initialize(nodeDataInSeed, def, this);
                            targetCell.AssignNodeView(view, nodeDataInSeed); // Assign the *existing* NodeData from seed's sequence
                            
                            NodeDraggable draggable = view.GetComponent<NodeDraggable>() ?? view.gameObject.AddComponent<NodeDraggable>();
                            draggable.Initialize(this, null, targetCell);

                            // Add this NodeData (which is from the seed's storedSequence) to our editor graph
                            _currentlyEditedSequence.nodes.Add(nodeDataInSeed);
                        }
                        else { Destroy(nodeViewGO); }
                    }
                    else Debug.LogWarning($"Could not find NodeDefinition for '{nodeDataInSeed.nodeDisplayName}' while loading seed.");
                }
            }
            // Ensure _currentlyEditedSequence is sorted
            _currentlyEditedSequence.nodes = _currentlyEditedSequence.nodes.OrderBy(n => n.orderIndex).ToList();
        }
        ShowNodeEditorPanel();
        // RefreshGraphAndUpdateSeed(); // Not needed here, as _currentlyEditedSequence is now directly populated
        Debug.Log($"[NodeEditorGridController] Loaded sequence from seed '{seedData.nodeDisplayName}'. Editor has {_currentlyEditedSequence.nodes.Count} nodes.");
    }

    public void UnloadSeedFromSlot()
    {
        if (_actualSeedSlotCell == null) { Debug.LogWarning("Seed slot not initialized. Cannot unload."); return; }
        
        // Before clearing, if there was a seed, its storedSequence should have been updated by RefreshGraphAndUpdateSeed
        // Ensure this happens if any modifications were made.
        // RefreshGraphAndUpdateSeed(); // This might be redundant if called on every UI change.

        ClearSequenceEditorCells();
        HideNodeEditorPanel();
        _currentlyEditedSequence.nodes.Clear();
        Debug.Log("[NodeEditorGridController] Unloaded seed and cleared editor.");
    }

    private void ClearSequenceEditorCells()
    {
        foreach (NodeCell cell in nodeCells)
        {
            cell.RemoveNode();
        }
        NodeCell.ClearSelection();
    }

    public void OnEmptyCellRightClicked(NodeCell cell, PointerEventData eventData)
    {
        if (cell.IsInventoryCell || cell == _actualSeedSlotCell) return;
        if (nodeDropdown == null) { Debug.LogError("[NodeEditorGridController] Node Dropdown not assigned."); return; }
        if (definitionLibrary == null || definitionLibrary.definitions == null) { Debug.LogError("[NodeEditorGridController] Node Definition Library not assigned/empty."); return; }
        StopCoroutine("ShowDropdownCoroutine");
        StartCoroutine(ShowDropdownCoroutine(cell, eventData));
    }

    private IEnumerator ShowDropdownCoroutine(NodeCell cell, PointerEventData eventData)
    {
        // ... (no changes)
        List<TMP_Dropdown.OptionData> options = new List<TMP_Dropdown.OptionData> { new TMP_Dropdown.OptionData("Select Node...") };
        var sortedDefinitions = definitionLibrary.definitions
                                    .Where(def => def != null && !def.effects.Any(e => e.effectType == NodeEffectType.SeedSpawn)) 
                                    .OrderBy(def => def.displayName)
                                    .ToList();
        foreach (var def in sortedDefinitions) options.Add(new TMP_Dropdown.OptionData { text = def.displayName, image = def.thumbnail });
        
        nodeDropdown.ClearOptions(); nodeDropdown.AddOptions(options);
        nodeDropdown.onValueChanged.RemoveAllListeners();
        nodeDropdown.onValueChanged.AddListener((selectedIndex) => { OnDropdownValueChanged(selectedIndex, cell, sortedDefinitions); });

        RectTransform dropdownRect = nodeDropdown.GetComponent<RectTransform>();
        if (_rootCanvas != null && dropdownRect.parent is RectTransform parentRect) {
            RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRect, eventData.position, _rootCanvas.worldCamera, out Vector2 localPos);
            dropdownRect.localPosition = localPos;
        } else Debug.LogWarning("[NodeEditorGridController] Cannot accurately position dropdown.");
        
        if (!nodeDropdown.gameObject.activeSelf) nodeDropdown.gameObject.SetActive(true);
        yield return null;
        
        try { 
            if (nodeDropdown.template == null) { Debug.LogError("Node Dropdown template is null!", nodeDropdown.gameObject); HideDropdown(); yield break; }
            nodeDropdown.Show(); 
        }
        catch (System.NullReferenceException nre) { Debug.LogError($"Error showing dropdown: {nre.Message}", nodeDropdown.gameObject); HideDropdown(); yield break; }
        
        nodeDropdown.value = 0; nodeDropdown.RefreshShownValue();
    }

    private void OnDropdownValueChanged(int selectedIndex, NodeCell targetCell, List<NodeDefinition> sortedDefinitions)
    {
        // ... (AssignNode will now create a NodeData with an empty storedSequence)
        HideDropdown();
        if (selectedIndex > 0) {
            int definitionIndexInSortedList = selectedIndex - 1;
            if (definitionIndexInSortedList >= 0 && definitionIndexInSortedList < sortedDefinitions.Count) {
                NodeDefinition selectedDef = sortedDefinitions[definitionIndexInSortedList];
                if (selectedDef != null) { 
                    targetCell.AssignNode(selectedDef); // Creates NEW NodeData for the sequence UI cell
                    NodeCell.SelectCell(targetCell);    
                    RefreshGraphAndUpdateSeed(); // Update editor graph & seed's storedSequence
                }
            } else Debug.LogError($"Dropdown selection index {selectedIndex} invalid.");
        }
    }

    public void HideDropdown()
    { 
        // ... (no changes)
        if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) { 
            if (nodeDropdown.IsExpanded) nodeDropdown.Hide(); 
            nodeDropdown.gameObject.SetActive(false); 
        } 
    }

    // Renamed from RefreshGraph to be more explicit
    public void RefreshGraphAndUpdateSeed()
    {
        if (_actualSeedSlotCell == null) { return; }

        // 1. Rebuild _currentlyEditedSequence from UI cells
        if (_currentlyEditedSequence == null) _currentlyEditedSequence = new NodeGraph();
        _currentlyEditedSequence.nodes.Clear();

        if (nodeCells != null) { 
            foreach (var cell in nodeCells.OrderBy(c => c.CellIndex)) {
                NodeData dataFromCell = cell.GetNodeData(); // This is the NodeData instance in the UI cell
                if (dataFromCell != null) {
                    dataFromCell.orderIndex = cell.CellIndex;
                     // Ensure nodes *within* a sequence do not have their own stored sequence
                    if (dataFromCell.storedSequence == null || dataFromCell.storedSequence.nodes.Count > 0) {
                        dataFromCell.storedSequence = new NodeGraph();
                    }
                    _currentlyEditedSequence.nodes.Add(dataFromCell);
                }
            }
        }

        // 2. Update the storedSequence of the seed in the slot
        NodeData currentSeedInSlot = GetCurrentSeedInSlot();
        if (currentSeedInSlot != null && currentSeedInSlot.IsSeed())
        {
            // Create a NEW list of NEW NodeData instances for the seed's storedSequence
            // This ensures the seed stores *copies* of the data, not direct references from UI cells,
            // which helps break potential cycles if NodeData instances were reused across seeds.
            currentSeedInSlot.storedSequence.nodes.Clear();
            foreach (NodeData uiNodeData in _currentlyEditedSequence.nodes)
            {
                if (uiNodeData == null) continue;
                NodeData storedNodeCopy = new NodeData
                {
                    nodeId = uiNodeData.nodeId, // Can be same ID as it's part of *this specific seed's* definition
                    nodeDisplayName = uiNodeData.nodeDisplayName,
                    effects = NodeExecutor.CloneEffectsList(uiNodeData.effects), // Deep copy effects
                    orderIndex = uiNodeData.orderIndex,
                    canBeDeleted = uiNodeData.canBeDeleted,
                    storedSequence = new NodeGraph() // CRITICAL: Nodes in stored sequence don't have sub-sequences
                };
                currentSeedInSlot.storedSequence.nodes.Add(storedNodeCopy);
            }
            // Debug.Log($"[NGEC] Refreshed. Seed '{currentSeedInSlot.nodeDisplayName}' storedSequence now has {currentSeedInSlot.storedSequence.nodes.Count} nodes.");
        }
    }
    
    public NodeCell GetCellAtIndex(int index) 
    {
        // ... (no changes)
        if (nodeCells == null) { Debug.LogError("[NodeEditorGridController] nodeCells list is null."); return null; }
        if (index >= 0 && index < nodeCells.Count) return nodeCells[index];
        Debug.LogWarning($"[NodeEditorGridController] GetCellAtIndex: Index {index} out of bounds for sequence cells.");
        return null;
    }

    public void HandleDropOnSeedSlot(NodeDraggable draggedDraggable, NodeCell originalCell, NodeCell targetSeedSlotCell)
    {
        // ... (RefreshGraphAndUpdateSeed() call is now correct)
        if (_actualSeedSlotCell == null || targetSeedSlotCell != _actualSeedSlotCell) {
             Debug.LogError("HandleDropOnSeedSlot called on an incorrect or uninitialized cell.", targetSeedSlotCell.gameObject);
             draggedDraggable.ResetPosition();
             return;
        }

        NodeView draggedView = draggedDraggable.GetComponent<NodeView>();
        NodeData draggedData = draggedView?.GetNodeData();

        if (draggedView == null || draggedData == null || !draggedData.IsSeed())
        {
            Debug.LogWarning($"[NodeEditorGridController] Item dropped on seed slot is not a valid seed. Resetting drag.", draggedDraggable.gameObject);
            draggedDraggable.ResetPosition();
            return;
        }
        
        NodeData existingSeedInSlotData = _actualSeedSlotCell.GetNodeData();
        if (existingSeedInSlotData != null)
        {
            // Before returning, ensure its storedSequence is up-to-date from the editor
            RefreshGraphAndUpdateSeed(); // Syncs editor UI to existingSeedInSlotData.storedSequence

            NodeView existingSeedViewInSlot = _actualSeedSlotCell.GetNodeView();
            _actualSeedSlotCell.ClearNodeReference(); 
            InventoryGridController.Instance.ReturnGeneToInventory(existingSeedViewInSlot, existingSeedInSlotData);
            Debug.Log($"Returned '{existingSeedInSlotData.nodeDisplayName}' from seed slot to inventory.");
        }

        if (originalCell.IsInventoryCell)
        {
            InventoryGridController.Instance.RemoveGeneFromInventory(originalCell); 
        }
        else
        {
            Debug.LogError($"[NodeEditorGridController] A seed '{draggedData.nodeDisplayName}' was dragged from non-inventory cell ({originalCell.gameObject.name}) to seed slot. Original cell cleared.", originalCell.gameObject);
            originalCell.RemoveNode();
        }

        _actualSeedSlotCell.AssignNodeView(draggedView, draggedData);
        draggedDraggable.SnapToCell(_actualSeedSlotCell);
        
        LoadSequenceFromSeed(draggedData); // This populates _currentlyEditedSequence and UI
        // RefreshGraphAndUpdateSeed(); // LoadSequenceFromSeed now populates _currentlyEditedSequence directly.
                                     // If LoadSequence was to set up UI and then Refresh read from UI to seed, that's one way.
                                     // Or LoadSequence directly populates _currentlyEditedSequence and the seed's sequence too.
                                     // Current LoadSequenceFromSeed populates the UI cells and _currentlyEditedSequence.
                                     // The seed's actual storedSequence is updated by RefreshGraphAndUpdateSeed.
                                     // So, after LoadSequenceFromSeed, we might not need an immediate Refresh if Load is comprehensive.
                                     // However, RefreshGraphAndUpdateSeed ensures the seed in slot has its sequence matching the editor.
                                     // Let's keep it to be safe for now or integrate its logic into LoadSequenceFromSeed.
                                     // For now, LoadSequence sets up the UI, and subsequent interactions call Refresh to update seed.
        Debug.Log($"Seed '{draggedData.nodeDisplayName}' placed in slot. Its storedSequence has {draggedData.storedSequence.nodes.Count} nodes. Editor has {_currentlyEditedSequence.nodes.Count} nodes.");
    }


    public void HandleDropOnSequenceCell(NodeDraggable draggedDraggable, NodeCell originalCell, NodeCell targetSequenceCell)
    {
        // ... (RefreshGraphAndUpdateSeed() call is now correct)
        if (_actualSeedSlotCell == null) { Debug.LogError("Seed slot not initialized. Sequence operations may fail."); }

        if (draggedDraggable == null || originalCell == null || targetSequenceCell == null || targetSequenceCell.IsInventoryCell || targetSequenceCell == _actualSeedSlotCell)
        {
            draggedDraggable?.ResetPosition(); return;
        }

        NodeView draggedView = draggedDraggable.GetComponent<NodeView>();
        NodeDefinition draggedDef = draggedView?.GetNodeDefinition();
        NodeData draggedData = draggedView?.GetNodeData();

        if (draggedView == null || (draggedDef == null && draggedData == null) ) {
            Debug.LogError("[NodeEditorGridController] HandleDropOnSequenceCell: Dragged object missing View/Def/Data.", draggedDraggable.gameObject);
            draggedDraggable.ResetPosition(); return;
        }
        if (draggedDef != null && draggedDef.effects.Any(e => e.effectType == NodeEffectType.SeedSpawn)) {
            Debug.LogWarning("Cannot place Seed definitions into a seed's sequence. Resetting drag.");
            draggedDraggable.ResetPosition();
            return;
        }

        if (targetSequenceCell == originalCell && !originalCell.IsInventoryCell) {
            draggedDraggable.SnapToCell(originalCell); NodeCell.SelectCell(originalCell); return;
        }

        if (originalCell.IsInventoryCell) { // Inventory item (NodeDefinition) to Sequence cell
            InventoryGridController.Instance?.RemoveGeneFromInventory(originalCell); // This clears cell, DraggedView is destroyed by this call.
            
            // We need to create a NEW NodeView and NodeData for the sequence editor.
            NodeView existingViewInTargetSeq = targetSequenceCell.GetNodeView();
            if (existingViewInTargetSeq != null) {
                NodeData dataFromSeqTarget = targetSequenceCell.GetNodeData(); // The actual instance from UI
                targetSequenceCell.ClearNodeReference(); 
                // Return the NodeData (which is an instance) from the sequence cell to inventory.
                // InventoryGridController.ReturnGeneToInventory will create a new view for it.
                InventoryGridController.Instance.ReturnGeneToInventory(existingViewInTargetSeq, dataFromSeqTarget); 
            }
            // AssignNode creates a new NodeData instance from the definition for the sequence cell
            targetSequenceCell.AssignNode(draggedDef); 
            targetSequenceCell.GetNodeView()?.GetComponent<NodeDraggable>()?.SnapToCell(targetSequenceCell);
            NodeCell.SelectCell(targetSequenceCell);
             Destroy(draggedDraggable.gameObject); // Destroy the original dragged view from inventory
        } 
        else if (originalCell == _actualSeedSlotCell) 
        {
            Debug.LogWarning("Cannot drag the main Seed from the Seed Slot directly into its own sequence editor. Resetting drag.");
            draggedDraggable.ResetPosition();
            return;
        }
        else { // Sequence TO Sequence (NodeData instance is moved)
            NodeView existingViewInTarget = targetSequenceCell.GetNodeView(); 
            NodeData existingDataInTarget = targetSequenceCell.GetNodeData();
            NodeCell.ClearSelection(); 
            originalCell.ClearNodeReference();

            if (existingViewInTarget != null) {
                NodeDraggable draggableFromTarget = existingViewInTarget.GetComponent<NodeDraggable>();
                originalCell.AssignNodeView(existingViewInTarget, existingDataInTarget); // Move existing item to original cell
                draggableFromTarget?.SnapToCell(originalCell);
            }
            // Assign the dragged node (which is `draggedView` and its `draggedData`) to the target cell
            targetSequenceCell.AssignNodeView(draggedView, draggedData); // Assigns the existing NodeData
            draggedDraggable.SnapToCell(targetSequenceCell); 
            NodeCell.SelectCell(targetSequenceCell);
        }
        RefreshGraphAndUpdateSeed(); // Update editor graph & seed's storedSequence
    }

    // ... (FindCellAtScreenPosition and OnDrawGizmos remain the same)
    private NodeCell FindCellAtScreenPosition(Vector2 screenPosition)
    {
        NodeCell foundCell = null;
        if (cellContainer == null || _rootCanvas == null) return null;
        foreach (Transform cellTransform in cellContainer) { 
            NodeCell cell = cellTransform.GetComponent<NodeCell>(); if (cell == null) continue;
            RectTransform cellRect = cell.GetComponent<RectTransform>(); if (cellRect == null) continue;
            if (RectTransformUtility.RectangleContainsScreenPoint(cellRect, screenPosition, _rootCanvas.worldCamera))
            { foundCell = cell; break; }
        }
        if (foundCell == null && _actualSeedSlotCell != null)
        {
            RectTransform seedSlotRect = _actualSeedSlotCell.GetComponent<RectTransform>();
            if (seedSlotRect != null && RectTransformUtility.RectangleContainsScreenPoint(seedSlotRect, screenPosition, _rootCanvas.worldCamera))
            {
                return _actualSeedSlotCell;
            }
        }
        return foundCell;
    }

    #if UNITY_EDITOR
    void OnDrawGizmos()
    {
        if (Application.isPlaying) return; 
        
        if (cellContainer != null && cellContainer.gameObject.activeInHierarchy && cellContainer.TryGetComponent<RectTransform>(out var containerRect))
        {
            Gizmos.color = new Color(0f, 1f, 0f, 0.25f); 
            Matrix4x4 originalMatrix = Gizmos.matrix;
            
            GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
            if (gridLayout != null && gridLayout.enabled) {
                Vector3[] corners = new Vector3[4]; 
                containerRect.GetWorldCorners(corners);
                Gizmos.matrix = Matrix4x4.identity;
                Gizmos.DrawLine(corners[0], corners[1]); Gizmos.DrawLine(corners[1], corners[2]);
                Gizmos.DrawLine(corners[2], corners[3]); Gizmos.DrawLine(corners[3], corners[0]);
            } else { 
                float totalWidth = (emptyCellsCount * cellSize.x) + ((emptyCellsCount - 1) * cellMargin);
                float startX_for_gizmo = -(totalWidth / 2f) + (cellSize.x / 2f); 
                for (int i = 0; i < emptyCellsCount; i++) {
                    float xOffset = startX_for_gizmo + i * (cellSize.x + cellMargin);
                    Vector3 localCellCenter = new Vector3(xOffset, 0, 0);
                    Vector3 worldCellCenter = cellContainer.TransformPoint(localCellCenter);
                    Vector3 gizmoSize = new Vector3(cellSize.x * cellContainer.lossyScale.x, cellSize.y * cellContainer.lossyScale.y, 0.1f);
                    Gizmos.matrix = Matrix4x4.TRS(worldCellCenter, cellContainer.rotation, Vector3.one);
                    Gizmos.DrawWireCube(Vector3.zero, gizmoSize);
                }
            }
            Gizmos.matrix = originalMatrix;
        }

        if (seedSlotContainer != null && seedSlotContainer.gameObject.activeInHierarchy && seedSlotContainer.TryGetComponent<RectTransform>(out var seedContainerRect))
        {
            Gizmos.color = new Color(1f, 0f, 1f, 0.35f); 
            Vector3[] corners = new Vector3[4];
            seedContainerRect.GetWorldCorners(corners);
            Matrix4x4 originalMatrix = Gizmos.matrix; 
            Gizmos.matrix = Matrix4x4.identity;
            Gizmos.DrawLine(corners[0], corners[1]); Gizmos.DrawLine(corners[1], corners[2]);
            Gizmos.DrawLine(corners[2], corners[3]); Gizmos.DrawLine(corners[3], corners[0]);
            Gizmos.matrix = originalMatrix;
        }
    }
    #endif
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeSelectable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

public class NodeSelectable : MonoBehaviour, IPointerClickHandler
{
    public static GameObject CurrentSelected { get; set; }

    public void OnPointerClick(PointerEventData eventData)
    {
        Select(gameObject);
    }

    public static void Select(GameObject node)
    {
        if (CurrentSelected != null && CurrentSelected != node)
        {
            // (Optional) Remove highlight from previously selected node.
        }
        CurrentSelected = node;
        // (Optional) Add highlight effect here.
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeView.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Nodes/UI/NodeView.cs
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.EventSystems;
using System.Text;

[RequireComponent(typeof(RectTransform))]
public class NodeView : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler
{
    [Header("UI Elements (Assign in Prefab)")]
    [SerializeField] private Image thumbnailImage;
    [SerializeField] private Image backgroundImage;
    [SerializeField] private GameObject tooltipPanel;
    [SerializeField] private TMP_Text tooltipText;
    [SerializeField] private TMP_Text nodeNameText;

    [Header("Configuration")]
    [SerializeField] private bool displayNodeName = false;

    private NodeData _nodeData;
    private NodeDefinition _nodeDefinition;
    private NodeEditorGridController _sequenceGridControllerRef; // Controller if this view is in the main sequence
    private NodeCell _parentCell; // The cell this view is currently in
    private Color _originalBackgroundColor;

    public void Initialize(NodeData data, NodeDefinition definition, NodeEditorGridController sequenceController)
 {
     _nodeData = data;
     _nodeDefinition = definition;
     _sequenceGridControllerRef = sequenceController; // This will be null if it's an inventory item

     UpdateParentCellReference(); // Call early to know if it's inventory or sequence via _parentCell.IsInventoryCell

     if (_nodeData == null || _nodeDefinition == null)
     {
         Debug.LogError($"[NodeView Initialize] NodeData or NodeDefinition is null for {gameObject.name}. Disabling.", gameObject);
         gameObject.SetActive(false);
         return;
     }

     // --- Get Global Scale and Padding from InventoryGridController (if available) ---
     float globalScaleFactor = 1f;
     float raycastPaddingValue = 0f;

     if (InventoryGridController.Instance != null)
     {
         globalScaleFactor = InventoryGridController.Instance.NodeGlobalImageScale;
         raycastPaddingValue = InventoryGridController.Instance.NodeImageRaycastPadding;
     }
     else
     {
         // This warning is important if InventoryGridController is expected to be present
         Debug.LogWarning("[NodeView] InventoryGridController.Instance not found during Initialize. Using default image scale (1) and padding (0). Ensure InventoryGridController is active in the scene.", gameObject);
     }
     // --- END Get Global Scale and Padding ---

     // Create the padding vector for UI.Image.raycastPadding
     // Order is: Left, Bottom, Right, Top
     Vector4 raycastPaddingVector = new Vector4(raycastPaddingValue, raycastPaddingValue, raycastPaddingValue, raycastPaddingValue);

     if (thumbnailImage != null)
     {
         thumbnailImage.sprite = _nodeDefinition.thumbnail;
         thumbnailImage.color = _nodeDefinition.thumbnailTintColor;
         // Apply uniform global scale to X and Y, Z remains 1
         thumbnailImage.rectTransform.localScale = new Vector3(globalScaleFactor, globalScaleFactor, 1f);
         thumbnailImage.enabled = (_nodeDefinition.thumbnail != null);
         thumbnailImage.raycastTarget = true; // Thumbnail needs to be targetable to initiate drag
         thumbnailImage.raycastPadding = raycastPaddingVector; // Apply padding
     }
     else
     {
         Debug.LogWarning($"[NodeView {gameObject.name}] ThumbnailImage is not assigned in prefab.", gameObject);
     }

     if (backgroundImage != null) // This is the NodeView's own background
     {
         _originalBackgroundColor = _nodeDefinition.backgroundColor;
         backgroundImage.color = _originalBackgroundColor;
         backgroundImage.enabled = true;
         backgroundImage.raycastTarget = true; // NodeView background also needs to be targetable for clicks/drag start
         backgroundImage.raycastPadding = raycastPaddingVector; // Apply padding
     }
     else
     {
         Debug.LogWarning($"[NodeView {gameObject.name}] BackgroundImage for NodeView itself is not assigned in prefab.", gameObject);
     }

     if (tooltipPanel != null) tooltipPanel.SetActive(false);

     if (nodeNameText != null)
     {
         nodeNameText.text = _nodeData.nodeDisplayName;
         nodeNameText.gameObject.SetActive(displayNodeName);
     }
 }

    public void UpdateParentCellReference()
    {
        _parentCell = GetComponentInParent<NodeCell>();
        // No warning here as it can be null during drag's reparenting
    }

    public NodeData GetNodeData() => _nodeData;
    public NodeDefinition GetNodeDefinition() => _nodeDefinition;
    public NodeCell GetParentCell() => _parentCell;

    public void Highlight()
    {
        // Only highlight if it's a sequence node and has the necessary references
        if (backgroundImage != null && _sequenceGridControllerRef != null && _parentCell != null && !_parentCell.IsInventoryCell)
        {
            backgroundImage.color = _sequenceGridControllerRef.SelectedNodeBackgroundColor;
        }
    }

    public void Unhighlight()
    {
        if (backgroundImage != null)
        {
            backgroundImage.color = _originalBackgroundColor; // Revert to its definition's color
        }
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        if (tooltipPanel != null && tooltipText != null && _nodeDefinition != null && _nodeData != null)
        {
            tooltipPanel.SetActive(true);
            tooltipText.text = BuildTooltipString();
        }
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        if (tooltipPanel != null)
        {
            tooltipPanel.SetActive(false);
        }
    }

    public void OnPointerDown(PointerEventData eventData)
    {
        if (_parentCell == null) UpdateParentCellReference(); // Attempt to get parent if null

        if (_parentCell != null && eventData.button == PointerEventData.InputButton.Left)
        {
            if (!_parentCell.IsInventoryCell) // Only select actual sequence nodes
            {
                NodeCell.SelectCell(_parentCell);
            }
            // Left-clicking inventory items will still allow drag to start due to NodeDraggable
        }
    }

    private string BuildTooltipString()
    {
        if (_nodeData == null || _nodeDefinition == null) return "Invalid Node Data";

        StringBuilder sb = new StringBuilder();
        sb.Append("<b>").Append(_nodeData.nodeDisplayName ?? "Unnamed Node").Append("</b>\n");

        if (!string.IsNullOrEmpty(_nodeDefinition.description))
        {
            sb.Append(_nodeDefinition.description).Append("\n");
        }

        // Determine if effects should be shown (i.e., it's a "real" node in the sequence)
        bool showEffects = false;
        if (_parentCell != null && !_parentCell.IsInventoryCell) // If it's in a sequence cell
        {
            showEffects = true;
        }
        else if (_parentCell == null && _sequenceGridControllerRef != null) // If it's being initialized for sequence but not yet in a cell
        {
            showEffects = true;
        }


        if (showEffects && _nodeData.effects != null && _nodeData.effects.Count > 0)
        {
            sb.Append("<i>Effects:</i>\n");
            foreach (var eff in _nodeData.effects)
            {
                if (eff == null) continue;
                sb.Append("- ").Append(eff.effectType.ToString()).Append(": ");
                sb.Append(eff.primaryValue.ToString("G3"));
                if (eff.secondaryValue != 0 || 
                    (eff.effectType == NodeEffectType.ScentModifier && eff.scentDefinitionReference != null) || /* Add other types that use secondaryValue even if 0 */
                    (eff.effectType == NodeEffectType.PoopFertilizer) ) // PoopFertilizer uses secondary for energy
                {
                    sb.Append(" / ").Append(eff.secondaryValue.ToString("G3"));
                }
                if (eff.effectType == NodeEffectType.ScentModifier && eff.scentDefinitionReference != null)
                {
                    sb.Append(" (").Append(eff.scentDefinitionReference.displayName).Append(")");
                }
                sb.Append("\n");
            }
        }
        return sb.ToString().TrimEnd();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Player\GardenerController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Player/GardenerController.cs
using UnityEngine;
using System;
using System.Collections.Generic;

// No longer requires ToolSwitcher on the same GameObject
public class GardenerController : MonoBehaviour
{
    // --- Fields ---
    [Header("Movement Settings")]
    public float moveSpeed = 5f;
    
    [Header("Speed Modifiers")]
    [Tooltip("Current speed including all active modifiers (read-only)")]
    [SerializeField] private float currentMoveSpeed;
    private float baseMoveSpeed;
    private List<float> activeSpeedMultipliers = new List<float>();
    
    [Header("Planting Settings")]
    public Vector2 seedPlantingOffset = new Vector2(0f, -0.5f);

    [Header("Tool References")] // <<< NEW HEADER
    [Tooltip("Assign the SpriteRenderer used to display the current tool's icon.")]
    [SerializeField] private SpriteRenderer toolIconRenderer;
    

    [Header("Visual Settings")]
    public bool flipSpriteWhenMovingLeft = true;
    public bool flipHorizontalDirection = true;

    [Header("Animation Settings")]
    public bool useAnimations = true;
    public string runningParameterName = "isRunning";
    public string plantingParameterName = "isPlanting";
    public float plantingDuration = 0.25f;

    // Private references
    private Rigidbody2D rb;
    private Vector2 movement;
    private SortableEntity sortableEntity;
    private SpriteRenderer spriteRenderer;
    private Animator animator;
    // ToolSwitcher reference is now toolSwitcherInstance (assigned via inspector)

    // Private variables
    private bool isPlanting = false;
    private float plantingTimer = 0f;
    private bool wasMovingBeforePlanting = false;

    void Awake()
    {
        // Store original components and references
        rb = GetComponent<Rigidbody2D>();
        sortableEntity = GetComponent<SortableEntity>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        animator = GetComponent<Animator>();

        // Store base movement speed for multiplier system
        baseMoveSpeed = moveSpeed;
        currentMoveSpeed = moveSpeed;
    
        // Initialize speed multipliers list
        activeSpeedMultipliers = new List<float>();

        if (sortableEntity == null)
            sortableEntity = gameObject.AddComponent<SortableEntity>();

        // Validations for other components
        if (spriteRenderer == null)
            Debug.LogWarning("[GardenerController Awake] Main SpriteRenderer component not found.", gameObject);
    
        if (animator == null && useAnimations)
            Debug.LogWarning("[GardenerController Awake] Animator component not found but useAnimations is true.", gameObject);

        
        if (toolIconRenderer == null)
            Debug.LogError("[GardenerController Awake] Tool Icon Renderer is not assigned in the Inspector! Tool icons will not display.", gameObject);
        else
        {
            Debug.Log("[GardenerController Awake] Tool Icon Renderer found. Initializing as hidden.", gameObject);
            toolIconRenderer.enabled = false;
        }
    }

    private void Start()
    {
        if (InventoryBarController.Instance != null)
        {
            InventoryBarController.Instance.OnSelectionChanged += HandleInventorySelectionChanged;
        }
    }

    private void OnDestroy()
    {
        activeSpeedMultipliers.Clear();
        if (InventoryBarController.Instance != null)
        {
            InventoryBarController.Instance.OnSelectionChanged -= HandleInventorySelectionChanged;
        }
    }

    // --- Update, FixedUpdate, UpdateAnimations, UpdateSpriteDirection, Start/EndPlantingAnimation, GetPlantingPosition, SetPlantingDuration, Plant methods remain the same ---
    private void Update()
    {
        if (!isPlanting)
        {
            movement.x = Input.GetAxisRaw("Horizontal");
            movement.y = Input.GetAxisRaw("Vertical");
            bool isMoving = movement.sqrMagnitude > 0.01f;
            if (isMoving) wasMovingBeforePlanting = true;
        }
        else
        {
            movement = Vector2.zero;
            plantingTimer -= Time.deltaTime;
            if (plantingTimer <= 0) EndPlantingAnimation();
        }
        UpdateAnimations();
        UpdateSpriteDirection();
    }
    
    private void HandleInventorySelectionChanged(InventoryBarItem selectedItem)
    {
        if (selectedItem != null && selectedItem.Type == InventoryBarItem.ItemType.Tool)
        {
            HandleToolChanged(selectedItem.ToolDefinition);
        }
        else
        {
            HandleToolChanged(null);
        }
    }
    
    public void ApplySpeedMultiplier(float multiplier)
    {
        if (!activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Add(multiplier);
            UpdateMovementSpeed();
        
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Applied speed multiplier: {multiplier}. New speed: {currentMoveSpeed}");
            }
        }
    }
    
    private void UpdateMovementSpeed()
    {
        // Start with base speed
        float newSpeed = baseMoveSpeed;
    
        // Apply all active multipliers
        if (activeSpeedMultipliers.Count > 0)
        {
            // Use the most restrictive (lowest) multiplier
            float lowestMultiplier = 1.0f;
            foreach (float multiplier in activeSpeedMultipliers)
            {
                if (multiplier < lowestMultiplier)
                {
                    lowestMultiplier = multiplier;
                }
            }
        
            newSpeed *= lowestMultiplier;
        }
    
        // Update the current move speed
        currentMoveSpeed = newSpeed;
    }
    
    public void RemoveSpeedMultiplier(float multiplier)
    {
        if (activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Remove(multiplier);
            UpdateMovementSpeed();
        
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Removed speed multiplier: {multiplier}. New speed: {currentMoveSpeed}");
            }
        }
    }
    
    
    void FixedUpdate()
    {
        if (!isPlanting)
        {
            // Use currentMoveSpeed (with modifiers) instead of moveSpeed
            rb.MovePosition(rb.position + movement.normalized * currentMoveSpeed * Time.fixedDeltaTime);
        }
    }
    private void UpdateAnimations() { if (!useAnimations || animator == null) return; bool isMoving = movement.sqrMagnitude > 0.01f; animator.SetBool(runningParameterName, isMoving); }
    private void UpdateSpriteDirection() { if (spriteRenderer == null || !flipSpriteWhenMovingLeft) return; if (movement.x != 0) { bool shouldFlip = (movement.x < 0); if (flipHorizontalDirection) { spriteRenderer.flipX = shouldFlip; } else { Vector3 scale = transform.localScale; scale.x = shouldFlip ? -Mathf.Abs(scale.x) : Mathf.Abs(scale.x); transform.localScale = scale; } } }
    public void StartPlantingAnimation() { if (!useAnimations || isPlanting) return; isPlanting = true; plantingTimer = plantingDuration; wasMovingBeforePlanting = movement.sqrMagnitude > 0.01f; if (animator != null) { animator.SetBool(plantingParameterName, true); animator.SetBool(runningParameterName, false); } }
    private void EndPlantingAnimation() { isPlanting = false; if (animator != null) { animator.SetBool(plantingParameterName, false); movement.x = Input.GetAxisRaw("Horizontal"); movement.y = Input.GetAxisRaw("Vertical"); bool shouldResumeRunning = movement.sqrMagnitude > 0.01f; animator.SetBool(runningParameterName, shouldResumeRunning); } }
    public Vector2 GetPlantingPosition() { return (Vector2)transform.position + seedPlantingOffset; }
    public void SetPlantingDuration(float duration) { plantingDuration = Mathf.Max(0.1f, duration); }
    public void Plant() { StartPlantingAnimation(); }
    // ---------------------------------

    // --- HandleToolChanged remains the same (uses toolSwitcherInstance implicitly via Start/OnDestroy) ---
    private void HandleToolChanged(ToolDefinition newTool)
    {
        string toolName = newTool != null ? newTool.displayName : "NULL";
        Debug.Log($"[HandleToolChanged] Received tool: {toolName}", gameObject);

        if (toolIconRenderer == null)
        {
            Debug.LogError("[HandleToolChanged] toolIconRenderer is NULL. Cannot update icon.", gameObject);
            return;
        }

        if (newTool != null)
        {
            string iconName = newTool.icon != null ? newTool.icon.name : "NULL";
            Debug.Log($"[HandleToolChanged] Tool '{toolName}' has icon: {iconName}", gameObject);

            if (newTool.icon != null)
            {
                Debug.Log($"[HandleToolChanged] Assigning sprite '{newTool.icon.name}' and color '{newTool.iconTint}' to toolIconRenderer.", gameObject);
                toolIconRenderer.sprite = newTool.icon;
                toolIconRenderer.color = newTool.iconTint;
                Debug.Log($"[HandleToolChanged] Enabling toolIconRenderer. Current state before: {toolIconRenderer.enabled}", gameObject);
                toolIconRenderer.enabled = true;
                Debug.Log($"[HandleToolChanged] toolIconRenderer.enabled is now: {toolIconRenderer.enabled}", gameObject);
                Debug.Log($"[HandleToolChanged] toolIconRenderer.sprite is now: {toolIconRenderer.sprite?.name ?? "NULL"}", gameObject);
            }
            else
            {
                Debug.LogWarning($"[HandleToolChanged] Tool '{toolName}' has a NULL icon. Hiding renderer.", gameObject);
                toolIconRenderer.enabled = false;
                toolIconRenderer.sprite = null;
            }
        }
        else
        {
            Debug.Log("[HandleToolChanged] newTool is NULL. Hiding renderer.", gameObject);
            toolIconRenderer.enabled = false;
            toolIconRenderer.sprite = null;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlantGrowthModifierManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

public class PlantGrowthModifierManager : MonoBehaviour
{
    public static PlantGrowthModifierManager Instance { get; private set; }

    [System.Serializable]
    public class TileGrowthModifier
    {
        [Tooltip("The tile definition this modifier applies to")]
        public TileDefinition tileDefinition;

        [Tooltip("Multiplier for plant growth speed when on this tile (1.0 = normal)")]
        [Range(0.1f, 3.0f)]
        public float growthSpeedMultiplier = 1.0f;

        [Tooltip("Multiplier for energy recharge speed when on this tile (1.0 = normal)")]
        [Range(0.1f, 3.0f)]
        public float energyRechargeMultiplier = 1.0f;
    }

    [Header("Default Settings")]
    [Tooltip("Default multiplier for tiles that aren't specifically configured")]
    [Range(0.1f, 3.0f)]
    public float defaultGrowthSpeedMultiplier = 1.0f;

    [Tooltip("Default multiplier for energy recharge on tiles that aren't specifically configured")]
    [Range(0.1f, 3.0f)]
    public float defaultEnergyRechargeMultiplier = 1.0f;

    [Header("Tile Update Settings")]
    [Tooltip("How often (in seconds) to check if plants are on different tiles")]
    [Range(0.5f, 5.0f)]
    public float tileUpdateInterval = 1.0f;

    [Header("Tile Growth Modifiers")]
    [Tooltip("Define growth and energy recharge multipliers for specific tiles")]
    public List<TileGrowthModifier> tileModifiers = new List<TileGrowthModifier>();

    [Header("References")]
    [SerializeField] private TileInteractionManager tileInteractionManager;

    [Header("Debug")]
    [SerializeField] private bool showDebugMessages = true;
    [SerializeField] private bool showTileChangeMessages = true;

    // Dictionary for faster lookup of modifiers by tile definition
    private Dictionary<TileDefinition, TileGrowthModifier> modifierLookup = new Dictionary<TileDefinition, TileGrowthModifier>();

    // Dictionary to track what tile each plant is on
    private Dictionary<PlantGrowth, TileDefinition> plantTiles = new Dictionary<PlantGrowth, TileDefinition>();
    
    // Timer for tile updates
    private float tileUpdateTimer = 0f;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // Build lookup dictionary for faster access
        BuildModifierLookup();
    }

    private void Start()
    {
        // Find TileInteractionManager if not assigned
        if (tileInteractionManager == null)
        {
            tileInteractionManager = TileInteractionManager.Instance;
            if (tileInteractionManager == null && showDebugMessages)
            {
                Debug.LogWarning("PlantGrowthModifierManager: TileInteractionManager not found!");
            }
        }
        
        // Start with a tile update
        tileUpdateTimer = 0f;
    }

    private void Update()
    {
        // Update timer
        tileUpdateTimer -= Time.deltaTime;
        
        // Check if it's time to update tiles
        if (tileUpdateTimer <= 0f)
        {
            UpdateAllPlantTiles();
            tileUpdateTimer = tileUpdateInterval;
        }
    }

    // Check all plants to see if their tiles have changed
    private void UpdateAllPlantTiles()
    {
        if (tileInteractionManager == null)
        {
            return;
        }
        
        // We need to copy the keys to avoid modifying the dictionary during iteration
        List<PlantGrowth> plantsToCheck = new List<PlantGrowth>(plantTiles.Keys);
        
        foreach (PlantGrowth plant in plantsToCheck)
        {
            if (plant == null)
            {
                // Plant has been destroyed, remove from dictionary
                plantTiles.Remove(plant);
                continue;
            }
            
            // Convert plant position to grid position
            Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
            
            // Get current tile definition at this position
            TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
            
            // Get previously stored tile definition
            TileDefinition previousTileDef = plantTiles[plant];
            
            // Check if tile has changed
            if (currentTileDef != previousTileDef)
            {
                // Update stored tile
                plantTiles[plant] = currentTileDef;
                
                if (showTileChangeMessages)
                {
                    string previousTileName = previousTileDef != null ? previousTileDef.displayName : "None";
                    string currentTileName = currentTileDef != null ? currentTileDef.displayName : "None";
                    Debug.Log($"Plant tile changed: {previousTileName} -> {currentTileName}");
                }
            }
        }
    }

    private void BuildModifierLookup()
    {
        modifierLookup.Clear();
        foreach (var modifier in tileModifiers)
        {
            if (modifier.tileDefinition != null && !modifierLookup.ContainsKey(modifier.tileDefinition))
            {
                modifierLookup.Add(modifier.tileDefinition, modifier);
            }
        }

        if (showDebugMessages)
        {
            Debug.Log($"PlantGrowthModifierManager: Built lookup with {modifierLookup.Count} tile modifiers");
        }
    }

    // Call this when a plant is created to register its tile
    public void RegisterPlantTile(PlantGrowth plant, TileDefinition tileDef)
    {
        if (plant == null)
            return;

        plantTiles[plant] = tileDef;

        if (showDebugMessages)
        {
            string tileName = tileDef != null ? tileDef.displayName : "Unknown Tile";
            Debug.Log($"Registered plant {plant.name} on tile {tileName}");
        }
    }

    // Call this when a plant is destroyed to clean up
    public void UnregisterPlant(PlantGrowth plant)
    {
        if (plant == null)
            return;

        if (plantTiles.ContainsKey(plant))
        {
            plantTiles.Remove(plant);
        }
    }

    // Get growth speed multiplier for a plant based on its tile
    public float GetGrowthSpeedMultiplier(PlantGrowth plant)
    {
        if (plant == null)
            return defaultGrowthSpeedMultiplier;
        
        // If plant not in dictionary, register it with its current tile
        if (!plantTiles.ContainsKey(plant))
        {
            RegisterNewPlant(plant);
        }
        
        TileDefinition tileDef = plantTiles[plant];
        if (tileDef == null)
        {
            return defaultGrowthSpeedMultiplier;
        }

        if (modifierLookup.TryGetValue(tileDef, out TileGrowthModifier modifier))
        {
            return modifier.growthSpeedMultiplier;
        }

        return defaultGrowthSpeedMultiplier;
    }

    // Get energy recharge multiplier for a plant based on its tile
    public float GetEnergyRechargeMultiplier(PlantGrowth plant)
    {
        if (plant == null)
            return defaultEnergyRechargeMultiplier;
        
        // If plant not in dictionary, register it with its current tile
        if (!plantTiles.ContainsKey(plant))
        {
            RegisterNewPlant(plant);
        }
        
        TileDefinition tileDef = plantTiles[plant];
        if (tileDef == null)
        {
            return defaultEnergyRechargeMultiplier;
        }

        if (modifierLookup.TryGetValue(tileDef, out TileGrowthModifier modifier))
        {
            return modifier.energyRechargeMultiplier;
        }

        return defaultEnergyRechargeMultiplier;
    }
    
    // Helper method to register a new plant with its current tile
    private void RegisterNewPlant(PlantGrowth plant)
    {
        if (plant == null || tileInteractionManager == null)
            return;
            
        Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
        TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
        
        plantTiles[plant] = currentTileDef;
        
        if (showDebugMessages)
        {
            string tileName = currentTileDef != null ? currentTileDef.displayName : "Unknown Tile";
            Debug.Log($"Auto-registered plant {plant.name} on tile {tileName}");
        }
    }

    // For editor support - rebuild lookup when modifiers change
    public void OnValidate()
    {
        BuildModifierLookup();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlantPlacementManagement.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Data/PlantPlacementManager.cs
using System.Collections.Generic;
using UnityEngine;
using System.Linq; // Added for LINQ

public class PlantPlacementManager : MonoBehaviour
{
    public static PlantPlacementManager Instance { get; private set; }

    [Header("References")]
    // REMOVED: [SerializeField] private GameObject plantPrefab; // NodeExecutor now handles this
    // REMOVED: [SerializeField] private NodeEditorGridController nodeEditorGrid; // NodeExecutor accesses this
    [SerializeField] private Transform plantParent; // Still needed for parenting spawned plants
    [SerializeField] private TileInteractionManager tileInteractionManager;
    [SerializeField] private PlantGrowthModifierManager growthModifierManager;
    [SerializeField] private NodeExecutor nodeExecutor; // <<< NEW: Reference to NodeExecutor

    [Header("Planting Settings")]
    [Tooltip("Maximum radius from cell center for random seed placement (in units)")]
    [SerializeField] private float spawnRadius = 0.25f;
    [Tooltip("Increment for position randomization (in pixels, for pixel-perfect placement)")]
    [SerializeField] private float spawnRadiusIncrement = 4f;

    [Header("Tile Restrictions")]
    [Tooltip("List of tiles that cannot be planted on")]
    [SerializeField] private List<TileDefinition> invalidPlantingTiles = new List<TileDefinition>();

    [Header("Debug")]
    [SerializeField] private bool showDebugMessages = true;
    
    private HashSet<TileDefinition> invalidTilesSet = new HashSet<TileDefinition>();
    private Dictionary<Vector3Int, GameObject> plantsByGridPosition = new Dictionary<Vector3Int, GameObject>();
    
    private void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;
        RebuildInvalidTilesSet();
    }

    private void Start()
    {
        if (plantParent == null && EcosystemManager.Instance != null) plantParent = EcosystemManager.Instance.plantParent;
        if (tileInteractionManager == null) tileInteractionManager = TileInteractionManager.Instance;
        if (growthModifierManager == null) growthModifierManager = PlantGrowthModifierManager.Instance;
        // <<< NEW: Ensure NodeExecutor is found >>>
        if (nodeExecutor == null)
        {
            nodeExecutor = FindAnyObjectByType<NodeExecutor>(); // Or however you manage its instance
            if (nodeExecutor == null) Debug.LogError("[PlantPlacementManager] NodeExecutor instance not found!");
        }
    }
    
    private void RebuildInvalidTilesSet()
    {
        invalidTilesSet.Clear();
        foreach (var tile in invalidPlantingTiles) if (tile != null) invalidTilesSet.Add(tile);
        if (showDebugMessages) Debug.Log($"PlantPlacementManager: Invalid tiles set with {invalidTilesSet.Count} entries");
    }
    
    private void OnValidate() { RebuildInvalidTilesSet(); }

    public bool IsPositionOccupied(Vector3Int gridPosition)
    {
        if (plantsByGridPosition.TryGetValue(gridPosition, out GameObject plant)) {
            if (plant == null) { plantsByGridPosition.Remove(gridPosition); return false; }
            return true;
        }
        return false;
    }
    
    public bool IsTileValidForPlanting(TileDefinition tileDef)
    {
        if (tileDef == null) return false;
        return !invalidTilesSet.Contains(tileDef);
    }

    public void CleanupDestroyedPlants()
    {
        List<Vector3Int> keysToRemove = plantsByGridPosition.Where(kvp => kvp.Value == null).Select(kvp => kvp.Key).ToList();
        foreach (var key in keysToRemove) plantsByGridPosition.Remove(key);
        if (showDebugMessages && keysToRemove.Count > 0) Debug.Log($"PPM: Removed {keysToRemove.Count} destroyed plant refs.");
    }

    public bool TryPlantSeed(Vector3Int gridPosition, Vector3 worldPosition)
    {
        CleanupDestroyedPlants();
        if (IsPositionOccupied(gridPosition)) {
            if (showDebugMessages) Debug.Log($"Cannot plant: Position {gridPosition} occupied.");
            return false;
        }
        
        TileDefinition tileDef = tileInteractionManager?.FindWhichTileDefinitionAt(gridPosition);
        if (!IsTileValidForPlanting(tileDef)) {
            if (showDebugMessages) Debug.Log($"Cannot plant: Tile {tileDef?.displayName ?? "Unknown"} invalid.");
            return false;
        }

        // <<< MODIFIED: Use NodeExecutor to spawn plant from the seed in slot >>>
        if (nodeExecutor == null) {
            Debug.LogError("Cannot plant: NodeExecutor reference is missing in PlantPlacementManager.");
            return false;
        }
        
        // NodeExecutor now fetches the seed and its graph from NodeEditorGridController.seedSlotCellReference
        // It needs the planting position and parent.
        Vector3 plantingPosition = GetRandomizedPlantingPosition(worldPosition);
        GameObject plantObj = nodeExecutor.SpawnPlantFromSeedInSlot(plantingPosition, plantParent);
        // <<< END MODIFIED >>>

        if (plantObj != null) {
            plantsByGridPosition[gridPosition] = plantObj;
            PlantGrowth plantGrowth = plantObj.GetComponent<PlantGrowth>();
            if (growthModifierManager != null && plantGrowth != null) {
                growthModifierManager.RegisterPlantTile(plantGrowth, tileDef);
                if (showDebugMessages) Debug.Log($"Plant registered with tile: {tileDef?.displayName ?? "Unknown"}");
            }
            return true;
        }
        if (showDebugMessages) Debug.Log($"Failed to plant seed at {gridPosition} (NodeExecutor returned null).");
        return false;
    }
    
    public bool TryPlantSeedFromInventory(InventoryBarItem seedItem)
{
    if (seedItem == null || !seedItem.IsSeed())
    {
        if (showDebugMessages) Debug.Log("Invalid seed item provided for planting.");
        return false;
    }
    
    // Get mouse position and convert to grid position
    Vector3 mouseWorldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
    mouseWorldPos.z = 0f;
    
    Vector3Int gridPosition = tileInteractionManager?.WorldToCell(mouseWorldPos) ?? Vector3Int.zero;
    
    // Use TileInteractionManager's method to get world position
    Vector3 worldPosition = mouseWorldPos; // Fallback to mouse world position
    if (tileInteractionManager != null)
    {
        // Since GetCellCenterWorld is private, we'll use the grid directly
        if (tileInteractionManager.interactionGrid != null)
        {
            worldPosition = tileInteractionManager.interactionGrid.GetCellCenterWorld(gridPosition);
        }
    }
    
    // Check if position is valid for planting
    CleanupDestroyedPlants();
    if (IsPositionOccupied(gridPosition))
    {
        if (showDebugMessages) Debug.Log($"Cannot plant: Position {gridPosition} occupied.");
        return false;
    }
    
    TileDefinition tileDef = tileInteractionManager?.FindWhichTileDefinitionAt(gridPosition);
    if (!IsTileValidForPlanting(tileDef))
    {
        if (showDebugMessages) Debug.Log($"Cannot plant: Tile {tileDef?.displayName ?? "Unknown"} invalid.");
        return false;
    }
    
    // Use NodeExecutor to spawn plant from the selected seed
    if (nodeExecutor == null)
    {
        Debug.LogError("Cannot plant: NodeExecutor reference is missing in PlantPlacementManager.");
        return false;
    }
    
    Vector3 plantingPosition = GetRandomizedPlantingPosition(worldPosition);
    GameObject plantObj = nodeExecutor.SpawnPlantFromInventorySeed(seedItem.NodeData, plantingPosition, plantParent);
    
    if (plantObj != null)
    {
        plantsByGridPosition[gridPosition] = plantObj;
        PlantGrowth plantGrowth = plantObj.GetComponent<PlantGrowth>();
        if (growthModifierManager != null && plantGrowth != null)
        {
            growthModifierManager.RegisterPlantTile(plantGrowth, tileDef);
            if (showDebugMessages) Debug.Log($"Plant registered with tile: {tileDef?.displayName ?? "Unknown"}");
        }
        
        // Trigger planting animation
        GardenerController gardener = FindAnyObjectByType<GardenerController>();
        if (gardener != null)
        {
            gardener.Plant();
        }
        
        return true;
    }
    
    if (showDebugMessages) Debug.Log($"Failed to plant seed at {gridPosition} (NodeExecutor returned null).");
    return false;
}

    // SpawnPlant method is now effectively inside NodeExecutor.SpawnPlantFromSeedInSlot
    // CloneNodeGraph and CloneEffectsList are also in NodeExecutor

    private Vector3 GetRandomizedPlantingPosition(Vector3 centerPosition)
    {
        if (spawnRadius < 0.01f) return centerPosition;
        float randomAngle = Random.Range(0f, 2f * Mathf.PI);
        Vector2 direction = new Vector2(Mathf.Cos(randomAngle), Mathf.Sin(randomAngle));
        float randomDistance = Random.Range(0.05f, spawnRadius);
        float offsetX = direction.x * randomDistance;
        float offsetY = direction.y * randomDistance;
        if (spawnRadiusIncrement > 0.001f) {
            offsetX = Mathf.Round(offsetX / spawnRadiusIncrement) * spawnRadiusIncrement;
            offsetY = Mathf.Round(offsetY / spawnRadiusIncrement) * spawnRadiusIncrement;
        }
        return centerPosition + new Vector3(offsetX, offsetY, 0f);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlayerTileInteractor.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Data/PlayerTileInteractor.cs
using UnityEngine;

public class PlayerTileInteractor : MonoBehaviour
{
    [Header("Debug")]
    [SerializeField] private bool showDebugMessages = false;
    
    private InventoryBarController inventoryBar;

    private void Awake()
    {
        // Will be set when InventoryBarController is initialized
    }
    
    private void Start()
    {
        inventoryBar = InventoryBarController.Instance;
        if (inventoryBar == null && showDebugMessages)
        {
            Debug.LogWarning("[PlayerTileInteractor] InventoryBarController instance not found!");
        }
    }

    private void Update()
    {
        // Only handle input during Growth & Threat phase
        if (RunManager.Instance == null || RunManager.Instance.CurrentState != RunState.GrowthAndThreat)
            return;
            
        if (Input.GetMouseButtonDown(0))
        {
            HandleLeftClick();
        }
    }
    
    private void HandleLeftClick()
    {
        if (TileInteractionManager.Instance == null)
        {
            Debug.LogError("No TileInteractionManager in scene!");
            return;
        }
        
        if (inventoryBar == null)
        {
            if (showDebugMessages) Debug.LogWarning("No InventoryBarController available!");
            return;
        }
        
        var selectedItem = inventoryBar.SelectedItem;
        if (selectedItem == null || !selectedItem.IsValid())
        {
            if (showDebugMessages) Debug.Log("No valid item selected in inventory bar.");
            return;
        }
        
        if (selectedItem.Type == InventoryBarItem.ItemType.Tool)
        {
            // Handle tool usage
            if (showDebugMessages) Debug.Log($"Using tool: {selectedItem.GetDisplayName()}");
            TileInteractionManager.Instance.ApplyToolAction(selectedItem.ToolDefinition);
        }
        else if (selectedItem.Type == InventoryBarItem.ItemType.Node && selectedItem.IsSeed())
        {
            // Handle seed planting
            if (showDebugMessages) Debug.Log($"Planting seed: {selectedItem.GetDisplayName()}");
            HandleSeedPlanting(selectedItem);
        }
        else
        {
            if (showDebugMessages) Debug.Log($"Selected item '{selectedItem.GetDisplayName()}' cannot be used for tile interaction.");
        }
    }
    
    private void HandleSeedPlanting(InventoryBarItem seedItem)
    {
        if (PlantPlacementManager.Instance == null)
        {
            Debug.LogError("PlantPlacementManager not found!");
            return;
        }
    
        // FIXED: Use the correct method for inventory seed planting
        bool success = PlantPlacementManager.Instance.TryPlantSeedFromInventory(seedItem);
    
        if (success)
        {
            if (showDebugMessages)
                Debug.Log($"Successfully planted seed: {seedItem.GetDisplayName()}");
        
            // FIXED: Remove the seed from inventory after successful planting
            RemoveSeedFromInventory(seedItem);
        
            // Refresh the inventory bar to show updated inventory
            if (inventoryBar != null)
            {
                inventoryBar.ShowBar();
            }
        }
        else
        {
            if (showDebugMessages)
                Debug.Log($"Failed to plant seed: {seedItem.GetDisplayName()}");
        }
    }
    
    private void RemoveSeedFromInventory(InventoryBarItem seedItem)
    {
        if (seedItem?.ViewGameObject == null) return;
    
        var inventoryController = InventoryGridController.Instance;
        if (inventoryController == null) return;
    
        // Find the cell that contains this seed's view GameObject
        for (int i = 0; i < inventoryController.TotalSlots; i++)
        {
            var cell = inventoryController.GetInventoryCellAtIndex(i);
            if (cell != null && cell.HasNode())
            {
                var nodeView = cell.GetNodeView();
                if (nodeView != null && nodeView.gameObject == seedItem.ViewGameObject)
                {
                    // Remove the seed from inventory
                    cell.RemoveNode();
                    Debug.Log($"Removed planted seed from inventory slot {i}");
                    return;
                }
            }
        }
    
        Debug.LogWarning($"Could not find seed {seedItem.GetDisplayName()} in inventory to remove");
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Tilemaps;

[CreateAssetMenu(fileName = "TileDefinition", menuName = "Tiles/Tile Definition")]
public class TileDefinition : ScriptableObject
{
    [Header("Basic Identification")]
    [Tooltip("Display name for this tile type (used in UI and debugging)")]
    public string displayName;    // e.g. "Grass", "Dirt", "Wet Dirt"
    
    [Header("Visual Properties")]
    [Tooltip("Optional tint color to apply to the RenderTilemap")]
    public Color tintColor = Color.white;
    
    [Header("Auto-Reversion (optional)")]
    [Tooltip("If > 0, after this many seconds, the tile reverts to 'revertToTile'.")]
    public float revertAfterSeconds = 0f;

    [Tooltip("If revertAfterSeconds > 0, tile reverts to this tile definition.")]
    public TileDefinition revertToTile;

    [Header("Overlay Option")]
    [Tooltip("If true, this tile will be placed on top without removing the tile underneath ")]
    public bool keepBottomTile = false;
    
    [Header("Special Properties")]
    [Tooltip("If true, this tile will use water reflection shader")]
    public bool isWaterTile = false;

#if UNITY_EDITOR
    // This method will be called from the custom editor
    public void UpdateColor()
    {
        // Find the TileInteractionManager in the scene using the non-deprecated method
        var manager = UnityEngine.Object.FindAnyObjectByType<TileInteractionManager>();
        if (manager == null) return;

        foreach (var mapping in manager.tileDefinitionMappings)
        {
            if (mapping.tileDef == this && mapping.tilemapModule != null)
            {
                Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                if (renderTilemapTransform != null)
                {
                    Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
                    if (renderTilemap != null)
                    {
                        renderTilemap.color = tintColor;
                        UnityEditor.EditorUtility.SetDirty(renderTilemap);
                    }
                }
            }
        }
    }
#endif
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Data/TileInteractionLibrary.cs
using System.Collections.Generic;
using UnityEngine;
using System; // Needed for [Serializable]

// --- NEW: Define the structure for a refill rule ---
[Serializable] // Make it visible in the Inspector
public class ToolRefillRule
{
    [Tooltip("The tool that can be refilled.")]
    public ToolDefinition toolToRefill;

    [Tooltip("The tile that must be interacted with to trigger the refill.")]
    public TileDefinition refillSourceTile;
}
// ----------------------------------------------------

[CreateAssetMenu(fileName = "TileInteractionLibrary", menuName = "Tiles/Tile Interaction Library")]
public class TileInteractionLibrary : ScriptableObject
{
    [Header("Standard Tile Transformations")]
    [Tooltip("List of rules: (Tool, fromTile) => toTile.")]
    public List<TileInteractionRule> rules; // Existing transformation rules

    [Header("Tool Refill Rules")] // <<< NEW HEADER
    [Tooltip("List of rules defining how tools are refilled.")]
    public List<ToolRefillRule> refillRules; // <<< NEW LIST FOR REFILLS
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Data/TileInteractionManager.cs
using System.Collections;
using UnityEngine;
using UnityEngine.Tilemaps;
using skner.DualGrid; // Assuming this is the correct namespace for your DualGrid package
using System.Collections.Generic;
using System.Linq;
using TMPro;
#if UNITY_EDITOR
using UnityEditor; // Correct placement for editor-specific using directive
#endif

public class TileInteractionManager : MonoBehaviour
{
    public static TileInteractionManager Instance { get; private set; }
    [System.Serializable] public class TileDefinitionMapping { public TileDefinition tileDef; public DualGridTilemapModule tilemapModule; }
    [Header("Tile Definition Mappings")] public List<TileDefinitionMapping> tileDefinitionMappings;
    [Header("Interaction Library")] public TileInteractionLibrary interactionLibrary; // Now contains both rule types
    [Header("Grid & Scene References")] public Grid interactionGrid; public Camera mainCamera; public Transform player; public float hoverRadius = 3f; public GameObject hoverHighlightObject;
    [Header("Tilemap Rendering Settings")] public int baseSortingOrder = 0;
    [Header("Debug / UI")] public bool debugLogs = false; public TextMeshProUGUI hoveredTileText; public TextMeshProUGUI currentToolText;
    private Dictionary<TileDefinition, DualGridTilemapModule> moduleByDefinition;
    private Dictionary<DualGridTilemapModule, TileDefinition> definitionByModule;
    private Vector3Int? currentlyHoveredCell = null;
    private TileDefinition hoveredTileDef = null;
    private struct TimedTileState { public TileDefinition tileDef; public float timeLeft; }
    private Dictionary<Vector3Int, TimedTileState> timedCells = new Dictionary<Vector3Int, TimedTileState>();
    private ToolSwitcher playerToolSwitcher;

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Initialize dictionaries here
        moduleByDefinition = new Dictionary<TileDefinition, DualGridTilemapModule>();
        definitionByModule = new Dictionary<DualGridTilemapModule, TileDefinition>();

        SetupTilemaps(); // Setup tilemaps after dictionaries are created
    }

    void Start()
    {
        // Ensure dictionaries are populated if something went wrong in Awake or for runtime recompiles
        if (moduleByDefinition == null || moduleByDefinition.Count == 0 || definitionByModule == null || definitionByModule.Count == 0)
        {
            Debug.LogWarning("[TileInteractionManager Start] Dictionaries were empty or null, re-running SetupTilemaps.");
            SetupTilemaps();
        }

        // Find the Player's ToolSwitcher
        if (player != null)
        {
            // Use GetComponentInChildren to find it even if it's nested
            playerToolSwitcher = player.GetComponentInChildren<ToolSwitcher>(true); // Include inactive just in case
            if (playerToolSwitcher == null)
            {
                Debug.LogError("[TileInteractionManager Start] Could not find ToolSwitcher component on Player or its children!", player);
            }
            else
            {
                 if(debugLogs) Debug.Log("[TileInteractionManager Start] Found Player ToolSwitcher.", playerToolSwitcher.gameObject);
            }
        }
        else
        {
            Debug.LogError("[TileInteractionManager Start] Player Transform reference is not assigned in the Inspector!", this);
        }
    }

    private void SetupTilemaps()
    {
        // Clear dictionaries before rebuilding
        moduleByDefinition.Clear();
        definitionByModule.Clear();

        if (tileDefinitionMappings == null)
        {
            Debug.LogError("[TileInteractionManager SetupTilemaps] Tile Definition Mappings list is null!", this);
            return;
        }

        for (int i = 0; i < tileDefinitionMappings.Count; i++)
        {
            var mapping = tileDefinitionMappings[i];
            if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null)
            {
                 Debug.LogWarning($"[TileInteractionManager SetupTilemaps] Skipping null or incomplete mapping at index {i}.");
                 continue;
            }

            // Add to dictionaries
            if (!moduleByDefinition.ContainsKey(mapping.tileDef))
            {
                moduleByDefinition[mapping.tileDef] = mapping.tilemapModule;
                // *** CORRECTED ASSIGNMENT HERE ***
                definitionByModule[mapping.tilemapModule] = mapping.tileDef;

                // Find the RenderTilemap child
                Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                if (renderTilemapTransform != null)
                {
                    // Set Sorting Order
                    TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
                    if (renderer != null)
                    {
                        renderer.sortingOrder = baseSortingOrder - i;
                        if (debugLogs) Debug.Log($"Setting sorting order for {mapping.tileDef.displayName} to {renderer.sortingOrder}");
                    }
                    else { Debug.LogWarning($"RenderTilemap for {mapping.tileDef.displayName} missing TilemapRenderer.", renderTilemapTransform); }

                    // Set Initial Color
                    Tilemap tilemap = renderTilemapTransform.GetComponent<Tilemap>();
                    if (tilemap != null)
                    {
                        tilemap.color = mapping.tileDef.tintColor;
                        if (debugLogs) Debug.Log($"Setting color for {mapping.tileDef.displayName} to {tilemap.color}");
                    }
                     else { Debug.LogWarning($"RenderTilemap for {mapping.tileDef.displayName} missing Tilemap component.", renderTilemapTransform); }
                }
                 else { Debug.LogWarning($"Could not find 'RenderTilemap' child for module of {mapping.tileDef.displayName}.", mapping.tilemapModule.gameObject); }

                if (debugLogs) Debug.Log($"[Mapping] Added: {mapping.tileDef.displayName} => {mapping.tilemapModule.gameObject.name}");
            }
            else
            {
                Debug.LogWarning($"[TileInteractionManager SetupTilemaps] Duplicate TileDefinition '{mapping.tileDef.displayName}' found in mappings. Ignoring subsequent entries.", mapping.tileDef);
            }
        }
         if (debugLogs) Debug.Log($"[TileInteractionManager SetupTilemaps] Setup complete. {moduleByDefinition.Count} definitions mapped.");
    }

    // Method for editor button: Update Sorting Order
    public void UpdateSortingOrder()
    {
        if (tileDefinitionMappings == null) return;
        for (int i = 0; i < tileDefinitionMappings.Count; i++)
        {
            var mapping = tileDefinitionMappings[i];
            if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;

            Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
            if (renderTilemapTransform != null)
            {
                TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
                if (renderer != null)
                {
                    renderer.sortingOrder = baseSortingOrder - i;
#if UNITY_EDITOR
                    if (!Application.isPlaying) EditorUtility.SetDirty(renderer);
#endif
                    if (debugLogs) Debug.Log($"Updated sorting order for {mapping.tileDef.displayName} to {renderer.sortingOrder}");
                }
            }
        }
    }

    // Method for editor button: Update All Colors
    public void UpdateAllColors()
    {
        if (tileDefinitionMappings == null) return;
        foreach (var mapping in tileDefinitionMappings)
        {
            if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;

            Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
            if (renderTilemapTransform != null)
            {
                Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
                if (renderTilemap != null)
                {
                    renderTilemap.color = mapping.tileDef.tintColor;
#if UNITY_EDITOR
                    if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
                    if (debugLogs) Debug.Log($"Updated color for {mapping.tileDef.displayName} to {renderTilemap.color}");
                }
            }
        }
    }

    void Update()
    {
        HandleTileHover();
        UpdateReversion();
        UpdateDebugUI(); // Update UI every frame
    }

    private void UpdateReversion()
    {
        if (timedCells.Count == 0) return;

        List<Vector3Int> cellsToRevert = null; // Initialize null

        // Iterate over a temporary copy to allow modification
        foreach (var kvp in timedCells.ToList())
        {
            Vector3Int cellPos = kvp.Key;
            TimedTileState state = kvp.Value;

            // Check if the state's tile definition is still valid (safety check)
            if (state.tileDef == null) {
                timedCells.Remove(cellPos); // Clean up invalid entry
                continue;
            }

            state.timeLeft -= Time.deltaTime;

            if (state.timeLeft <= 0f)
            {
                if (cellsToRevert == null) cellsToRevert = new List<Vector3Int>();
                cellsToRevert.Add(cellPos);
            }
            else
            {
                timedCells[cellPos] = state; // Update time left
            }
        }

        if (cellsToRevert != null)
        {
            foreach (var cellPos in cellsToRevert)
            {
                // Check if the entry still exists before processing
                if (timedCells.TryGetValue(cellPos, out TimedTileState stateToRevert))
                {
                    timedCells.Remove(cellPos); // Remove before acting

                    // Always remove the reverting tile itself
                    RemoveTile(stateToRevert.tileDef, cellPos);

                    // Place the revert-to tile *if specified*
                    if (stateToRevert.tileDef.revertToTile != null)
                    {
                        if (debugLogs) Debug.Log($"Reverting tile at {cellPos} from {stateToRevert.tileDef.displayName} to {stateToRevert.tileDef.revertToTile.displayName}");
                        PlaceTile(stateToRevert.tileDef.revertToTile, cellPos);
                    } else {
                        if (debugLogs) Debug.Log($"Tile {stateToRevert.tileDef.displayName} at {cellPos} expired and removed (no revert target).");
                    }
                }
            }
        }
    }

    private void RegisterTimedTile(Vector3Int cellPos, TileDefinition tileDef)
    {
        // Only register if revert time is positive
        // RevertToTile check is now handled during reversion itself
        if (tileDef != null && tileDef.revertAfterSeconds > 0f)
        {
            TimedTileState newState = new TimedTileState
            {
                tileDef = tileDef,
                timeLeft = tileDef.revertAfterSeconds
            };
            timedCells[cellPos] = newState;
            if (debugLogs) Debug.Log($"Registered timed reversion for {tileDef.displayName} at {cellPos} ({tileDef.revertAfterSeconds}s).");
        }
         // Clear any existing timer if revertAfterSeconds is 0 or less
         else if (timedCells.ContainsKey(cellPos))
         {
              timedCells.Remove(cellPos);
              if (debugLogs) Debug.Log($"Cleared timed reversion for {cellPos} because revert time is not positive.");
         }
    }

    public void PlaceTile(TileDefinition tileDef, Vector3Int cellPos)
    {
        if (tileDef == null) { Debug.LogWarning($"PlaceTile: Attempted to place a NULL TileDefinition at {cellPos}."); return; }

        if (moduleByDefinition == null || !moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) || module == null)
        {
            Debug.LogWarning($"PlaceTile: No mapped module found for TileDefinition '{tileDef.displayName}'. Cannot place tile.");
            return;
        }

        // Handle removing existing tiles based on the new tile's 'keepBottomTile' flag
        if (!tileDef.keepBottomTile)
        {
            TileDefinition existingDef = FindWhichTileDefinitionAt(cellPos);
            if (existingDef != null && existingDef != tileDef)
            {
                 if (debugLogs) Debug.Log($"Placing '{tileDef.displayName}' (KeepBottom=false), removing existing '{existingDef.displayName}' at {cellPos}.");
                 RemoveTile(existingDef, cellPos);
            }
        } else {
             if (debugLogs) Debug.Log($"Placing '{tileDef.displayName}' (KeepBottom=true) over whatever is at {cellPos}.");
        }

        // Set the tile on the correct module's DataTilemap
        if (module.DataTilemap != null)
        {
            // Using a basic Tile asset is fine for the data layer
            TileBase dataTile = ScriptableObject.CreateInstance<Tile>();
            module.DataTilemap.SetTile(cellPos, dataTile);
        } else { Debug.LogWarning($"Module for '{tileDef.displayName}' has no DataTilemap assigned.", module.gameObject); }

        // Update RenderTilemap color immediately
        Transform renderTilemapTransform = module.transform.Find("RenderTilemap");
        if (renderTilemapTransform != null)
        {
            Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
            if (renderTilemap != null)
            {
                renderTilemap.color = tileDef.tintColor;
#if UNITY_EDITOR
                if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
            }
        }

        // Register for timed reversion if applicable
        RegisterTimedTile(cellPos, tileDef);
    }

    public void RemoveTile(TileDefinition tileDef, Vector3Int cellPos)
    {
        if (tileDef == null) { Debug.LogWarning($"RemoveTile: Attempted to remove a NULL TileDefinition at {cellPos}."); return; }

        if (moduleByDefinition == null || !moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) || module == null)
        {
            if (debugLogs) Debug.LogWarning($"RemoveTile: No mapped module found for TileDefinition '{tileDef.displayName}'. Cannot remove tile.");
            return;
        }

        // Remove from the module's DataTilemap
        if (module.DataTilemap != null)
        {
             // Check if the tile actually exists before removing
             if (module.DataTilemap.HasTile(cellPos)) {
                 module.DataTilemap.SetTile(cellPos, null);
                 if (debugLogs) Debug.Log($"Removed '{tileDef.displayName}' from DataTilemap at {cellPos}.");
             } else {
                 if (debugLogs) Debug.Log($"RemoveTile: Tile '{tileDef.displayName}' not found on DataTilemap at {cellPos}, skipping removal.");
             }
        } else { Debug.LogWarning($"Module for '{tileDef.displayName}' has no DataTilemap assigned.", module.gameObject); }

        // Also remove from timed reversion tracking if it matches
        if (timedCells.TryGetValue(cellPos, out TimedTileState timedState) && timedState.tileDef == tileDef)
        {
            timedCells.Remove(cellPos);
            if (debugLogs) Debug.Log($"Cleared timed reversion for {tileDef.displayName} at {cellPos} during removal.");
        }
    }

    public TileDefinition FindWhichTileDefinitionAt(Vector3Int cellPos)
    {
        if (definitionByModule == null || tileDefinitionMappings == null) {
             Debug.LogError("[FindWhichTileDefinitionAt] Dictionaries not initialized!");
             return null;
        }

        TileDefinition foundDef = null;

        // Prioritize checking overlay tiles first (those with keepBottomTile = true)
        // Iterate mappings list directly to check the flag easily
        foreach (var mapping in tileDefinitionMappings)
        {
             if (mapping?.tileDef != null && mapping.tilemapModule?.DataTilemap != null && mapping.tileDef.keepBottomTile)
             {
                 if (mapping.tilemapModule.DataTilemap.HasTile(cellPos))
                 {
                     foundDef = mapping.tileDef;
                     break; // Found the top overlay tile
                 }
             }
        }

        // If no overlay found, check non-overlay tiles
        if (foundDef == null)
        {
             // Use the definitionByModule dictionary which maps modules back to definitions
             foreach (var kvp in definitionByModule)
             {
                 DualGridTilemapModule module = kvp.Key;
                 TileDefinition def = kvp.Value;

                 // Ensure it's not an overlay tile (we already checked those) and the module/tilemap are valid
                 if (module?.DataTilemap != null && def != null && !def.keepBottomTile)
                 {
                     if (module.DataTilemap.HasTile(cellPos))
                     {
                         foundDef = def;
                         break; // Found the base tile
                     }
                 }
             }
        }

        // if (debugLogs && foundDef != null) Debug.Log($"[FindWhichTileDefinitionAt] Found '{foundDef.displayName}' at {cellPos}");
        // else if (debugLogs && foundDef == null) Debug.Log($"[FindWhichTileDefinitionAt] Found no tile at {cellPos}");

        return foundDef;
    }

    private void HandleTileHover()
    {
        if (mainCamera == null || player == null) return;

        Vector3 mouseWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
        mouseWorldPos.z = 0f; // Ensure Z is 0 for 2D comparison
        Vector3Int cellPos = WorldToCell(mouseWorldPos);

        // Check distance only if player reference exists
        float distance = (player != null) ? Vector2.Distance(player.position, CellCenterWorld(cellPos)) : float.MaxValue;

        TileDefinition foundTile = FindWhichTileDefinitionAt(cellPos);

        // Only update hover state if within radius
        if (distance <= hoverRadius)
        {
            bool changedCell = !currentlyHoveredCell.HasValue || currentlyHoveredCell.Value != cellPos;
            currentlyHoveredCell = cellPos;
            hoveredTileDef = foundTile;

            if (hoverHighlightObject != null)
            {
                hoverHighlightObject.SetActive(true);
                hoverHighlightObject.transform.position = CellCenterWorld(cellPos);
            }
            //if (debugLogs && changedCell) Debug.Log($"[Hover Enter] Cell={cellPos}, Tile={foundTile?.displayName ?? "None"}, Dist={distance:F2}");
        }
        else
        {
            bool changedCell = currentlyHoveredCell.HasValue;
            currentlyHoveredCell = null;
            hoveredTileDef = null;
            if (hoverHighlightObject != null)
            {
                hoverHighlightObject.SetActive(false);
            }
            //if (debugLogs && changedCell) Debug.Log($"[Hover Exit] Cell outside radius ({distance:F2} > {hoverRadius})");
        }
    }

    private void UpdateDebugUI()
    {
        // Hovered Tile Text
        if (hoveredTileText != null)
        {
            string tileName = hoveredTileDef != null ? hoveredTileDef.displayName : "None";
            hoveredTileText.text = $"Hover: {tileName}";
        }

        // Current Tool Text (includes uses)
        if (currentToolText != null)
        {
            if (playerToolSwitcher != null && playerToolSwitcher.CurrentTool != null)
            {
                ToolDefinition tool = playerToolSwitcher.CurrentTool;
                string toolString = $"Tool: {tool.displayName}";
                if (tool.limitedUses)
                {
                    int uses = playerToolSwitcher.CurrentRemainingUses;
                    toolString += $" ({uses})"; // Show remaining uses
                }
                currentToolText.text = toolString;
            }
            else
            {
                currentToolText.text = "Tool: None";
            }
        }
    }

    public Vector3Int WorldToCell(Vector3 worldPos)
    {
        if (interactionGrid != null) return interactionGrid.WorldToCell(worldPos);

        // Fallback: Try to get grid from the first valid mapping
        if (tileDefinitionMappings != null && tileDefinitionMappings.Count > 0) {
             foreach(var mapping in tileDefinitionMappings) {
                 if (mapping?.tilemapModule?.DataTilemap?.layoutGrid != null) {
                     return mapping.tilemapModule.DataTilemap.layoutGrid.WorldToCell(worldPos);
                 }
             }
        }

        Debug.LogWarning("[WorldToCell] No valid interactionGrid or mapped Tilemap found to determine cell position.");
        return Vector3Int.zero;
    }

    private Vector3 CellCenterWorld(Vector3Int cellPos)
    {
         if (interactionGrid != null) return interactionGrid.GetCellCenterWorld(cellPos);

         // Fallback: Try to get grid from the first valid mapping
         if (tileDefinitionMappings != null && tileDefinitionMappings.Count > 0) {
             foreach(var mapping in tileDefinitionMappings) {
                 if (mapping?.tilemapModule?.DataTilemap?.layoutGrid != null) {
                     return mapping.tilemapModule.DataTilemap.layoutGrid.GetCellCenterWorld(cellPos);
                 }
             }
        }

        Debug.LogWarning("[CellCenterWorld] No valid interactionGrid or mapped Tilemap found to determine cell center.");
        return Vector3.zero; // Or grid.CellToWorld(cellPos) + grid.cellSize * 0.5f if grid guaranteed?
    }

    private void HandleSeedPlanting(Vector3Int cellPosition)
    {
        PlantPlacementManager plantManager = PlantPlacementManager.Instance;
        if (plantManager == null) { Debug.LogError("Cannot plant: PlantPlacementManager not found!"); return; }

        TileDefinition tileDef = FindWhichTileDefinitionAt(cellPosition);
        if (!plantManager.IsTileValidForPlanting(tileDef))
        {
            if (debugLogs) Debug.Log($"Cannot plant on {tileDef?.displayName ?? "Unknown"} - invalid tile.");
            // Maybe add player feedback here (sound/visual)
            return;
        }

        GardenerController gardener = player?.GetComponent<GardenerController>();
        if (gardener == null) { Debug.LogError("Cannot plant: GardenerController not found on player!"); return; }

        Vector3 worldPosition = CellCenterWorld(cellPosition); // Plant near cell center

        gardener.Plant(); // Trigger animation
        StartCoroutine(PlantAfterAnimation(gardener, plantManager, cellPosition, worldPosition));
    }

    private IEnumerator PlantAfterAnimation(GardenerController gardener, PlantPlacementManager plantManager, Vector3Int cellPosition, Vector3 worldPosition)
    {
        // Ensure gardener and duration are valid
        float waitTime = (gardener != null) ? gardener.plantingDuration : 0.1f;
        yield return new WaitForSeconds(waitTime);

        if (plantManager != null) // Check again in case it was destroyed
        {
            bool planted = plantManager.TryPlantSeed(cellPosition, worldPosition);
            if (debugLogs) Debug.Log(planted ? $"Planted seed successfully at {cellPosition}" : $"Failed to plant seed at {cellPosition}");
        }
    }

    // --- ApplyToolAction is MODIFIED ---
    public void ApplyToolAction(ToolDefinition toolDef)
    {
        // --- Initial Checks (unchanged) ---
        if (toolDef == null) { Debug.LogWarning("ApplyToolAction called with a NULL toolDef."); return; }
        if (!currentlyHoveredCell.HasValue) return;
        if (hoveredTileDef == null) { if (debugLogs) Debug.Log("ApplyToolAction: No recognized tile at hovered cell."); return; }
        if (playerToolSwitcher == null) { Debug.LogError("ApplyToolAction: ToolSwitcher reference is missing! Cannot apply tool."); return; }
        float distance = Vector2.Distance(player.position, CellCenterWorld(currentlyHoveredCell.Value));
        if (distance > hoverRadius) { if (debugLogs) Debug.Log($"ApplyToolAction: Cell too far ({distance:F2} > {hoverRadius})."); return; }
        if (playerToolSwitcher.CurrentTool != toolDef) { Debug.LogWarning($"ApplyToolAction: Tool passed ({toolDef.displayName}) does not match current tool ({playerToolSwitcher.CurrentTool?.displayName}). Aborting."); return; }
        // ---------------------------------

        // --- Consume Use Attempt ---
        // We *attempt* to consume first. If it fails (out of uses), we stop.
        // If it succeeds, we proceed to check for refill or transformation.
        bool consumed = playerToolSwitcher.TryConsumeUse();
        // --- Note: We don't stop here even if consumed is false, because a refill action might still be possible even if uses are 0 (e.g. refill an empty can) ---
        // --- UPDATE: Actually, let's only proceed if consumed is TRUE OR if a refill rule applies ---

        if (debugLogs) Debug.Log($"[ApplyToolAction] Using Tool='{toolDef.toolType}', On Tile='{hoveredTileDef.displayName}', At Cell={currentlyHoveredCell.Value}. Consumed Use: {consumed}");


        // --- Check for REFILL Action FIRST ---
        bool wasRefillAction = false;
        if (interactionLibrary != null && interactionLibrary.refillRules != null)
        {
            foreach (var refillRule in interactionLibrary.refillRules)
            {
                // Check if rule matches the current tool and hovered tile
                if (refillRule != null && refillRule.toolToRefill == toolDef && refillRule.refillSourceTile == hoveredTileDef)
                {
                    // Match found! Attempt to refill.
                    if (debugLogs) Debug.Log($"Refill rule matched: Tool '{toolDef.displayName}' on Tile '{hoveredTileDef.displayName}'.");
                    playerToolSwitcher.RefillCurrentTool(); // Call the refill method
                    wasRefillAction = true;
                    break; // Stop checking refill rules once one matches
                }
            }
        }
        // If it was a refill action, we are done. Don't proceed to tile transformation.
        if (wasRefillAction)
        {
            // Note: The use was already consumed before the refill check.
            // If you want to *not* consume a use when refilling, you'd need
            // to add a RefundUse() method to ToolSwitcher and call it here,
            // or move the TryConsumeUse() call *after* the refill check.
            // Current logic: Click on water consumes 1 use, then refills to max.
            return;
        }
        // --------------------------------------


        // --- Proceed ONLY if use was successfully consumed AND it wasn't a refill ---
        if (!consumed)
        {
            if (debugLogs) Debug.Log($"ApplyToolAction: Tool '{toolDef.displayName}' could not be used (out of uses) and no refill rule applied.");
            return; // Stop if out of uses and not refilling
        }


        // --- Handle Standard Tile Transformation ---

        // Special case: SeedPouch (check again after use consumption)
        if (toolDef.toolType == ToolType.SeedPouch)
        {
            HandleSeedPlanting(currentlyHoveredCell.Value);
            return; // Seed planting handles its own logic
        }

        // Find standard matching rule
        if (interactionLibrary == null || interactionLibrary.rules == null) { Debug.LogWarning("Interaction Library or its standard rules list is null!"); return; }
        TileInteractionRule rule = interactionLibrary.rules.FirstOrDefault(r => r != null && r.tool == toolDef && r.fromTile == hoveredTileDef);

        if (rule == null)
        {
            if (debugLogs) Debug.Log($"No standard interaction rule found for tool '{toolDef.toolType}' on tile '{hoveredTileDef.displayName}'.");
            // Since a use was consumed but no action taken, maybe refund here?
            // playerToolSwitcher.RefundUse(); // Requires implementation
            return;
        }

        // Apply the standard rule
        if (rule.toTile != null) // If there's a tile to change TO
        {
            if (debugLogs) Debug.Log($"Applying standard rule: '{hoveredTileDef.displayName}' -> '{rule.toTile.displayName}'");
            if (!rule.toTile.keepBottomTile)
            {
                RemoveTile(hoveredTileDef, currentlyHoveredCell.Value);
            }
            PlaceTile(rule.toTile, currentlyHoveredCell.Value);
        }
        else // If the rule specifies removing the tile (toTile is null)
        {
            if (debugLogs) Debug.Log($"Applying standard rule: Remove '{hoveredTileDef.displayName}'");
            RemoveTile(hoveredTileDef, currentlyHoveredCell.Value);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionRule.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

[Serializable]
public class TileInteractionRule
{
    [Header("Tool Condition")]
    [Tooltip("Which tool triggers this rule.")]
    public ToolDefinition tool;

    [Header("Tile Transformation")]
    [Tooltip("Which tile must be present to apply the rule.")]
    public TileDefinition fromTile;
    [Tooltip("Which tile to transform into.")]
    public TileDefinition toTile;
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Editor\TileDefinitionEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(TileDefinition))]
public class TileDefinitionEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
        
        TileDefinition tileDefinition = (TileDefinition)target;
        
        EditorGUILayout.Space();
        if (GUILayout.Button("UPDATE COLOR IN SCENE", GUILayout.Height(30)))
        {
            tileDefinition.UpdateColor();
        }
    }
}
#endif


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Editor\TileInteractionManagerEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(TileInteractionManager))]
public class TileInteractionManagerEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
        
        TileInteractionManager manager = (TileInteractionManager)target;
        
        EditorGUILayout.Space();
        EditorGUILayout.BeginHorizontal();
        
        if (GUILayout.Button("UPDATE SORTING ORDER", GUILayout.Height(30)))
        {
            manager.UpdateSortingOrder();
            EditorUtility.SetDirty(manager);
        }
        
        if (GUILayout.Button("UPDATE ALL COLORS", GUILayout.Height(30)))
        {
            manager.UpdateAllColors();
            EditorUtility.SetDirty(manager);
        }
        
        EditorGUILayout.EndHorizontal();
        
        EditorGUILayout.HelpBox("Order: First item in list gets highest sorting order value (" + 
                                manager.baseSortingOrder + "). Each subsequent item is " + 
                                (manager.baseSortingOrder - 1) + ", " + 
                                (manager.baseSortingOrder - 2) + ", etc.", MessageType.Info);
    }
}
#endif


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Tools/ToolDefinition.cs
using UnityEngine;

[CreateAssetMenu(fileName = "ToolDefinition", menuName = "Tiles/Tool Definition")]
public class ToolDefinition : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Which tool type this represents (e.g. Hoe, WateringCan).")]
    public ToolType toolType;
    [Tooltip("Human-readable name (for debugging/UI).")]
    public string displayName;

    [Header("Visuals")]
    [Tooltip("Icon sprite for the tool.")]
    public Sprite icon;
    [Tooltip("Tint color to apply to the icon sprite.")]
    public Color iconTint = Color.white;

    [Header("Usage Limits")]
    [Tooltip("If true, this tool has a limited number of uses.")]
    public bool limitedUses = false;
    [Tooltip("The number of uses the tool starts with (only relevant if Limited Uses is true).")]
    [Min(0)]
    public int initialUses = 10;
    
    [Header("Auto-Add to Inventory")] // NEW SECTION
    [Tooltip("If true, this tool will be automatically added to the inventory at the start of planning phase.")]
    public bool autoAddToInventory = true; // NEW FIELD
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolSwitcher.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Tools/ToolSwitcher.cs
using UnityEngine;
using System;

public class ToolSwitcher : MonoBehaviour
{
    [Tooltip("All available tool definitions, e.g. Hoe, WateringCan, etc.")]
    public ToolDefinition[] toolDefinitions;

    private int currentIndex = 0;

    // --- Public Properties ---
    public ToolDefinition CurrentTool { get; private set; } = null;
    /// <summary>
    /// Gets the remaining uses for the current tool. Returns -1 if the tool has unlimited uses.
    /// </summary>
    public int CurrentRemainingUses { get; private set; } = -1; // <<< NEW: Track remaining uses (-1 for unlimited)

    // --- Events ---
    public event Action<ToolDefinition> OnToolChanged;
    /// <summary>
    /// Event fired when the remaining uses of the current tool changes. Passes the new remaining count (-1 for unlimited).
    /// </summary>
    public event Action<int> OnUsesChanged; // <<< NEW EVENT for UI updates

    private void Awake()
    {
        // Debug logs from previous step can be kept or removed
        // Debug.Log("[ToolSwitcher Awake] Initializing...");
    }

    private void Start()
    {
        InitializeToolState(true); // Initialize and fire events
    }

    private void Update()
    {
        if (toolDefinitions == null || toolDefinitions.Length == 0) return;

        bool toolChanged = false;
        int previousIndex = currentIndex;

        if (Input.GetKeyDown(KeyCode.Q))
        {
            currentIndex--;
            if (currentIndex < 0)
                currentIndex = toolDefinitions.Length - 1;
            toolChanged = true;
        }
        else if (Input.GetKeyDown(KeyCode.E))
        {
            currentIndex++;
            if (currentIndex >= toolDefinitions.Length)
                currentIndex = 0;
            toolChanged = true;
        }

        if (toolChanged)
        {
            // Ensure the new index points to a valid definition before updating state
            if (currentIndex >= 0 && currentIndex < toolDefinitions.Length && toolDefinitions[currentIndex] != null)
            {
                InitializeToolState(false); // Update state for the new tool and fire events
            }
            else
            {
                 Debug.LogError($"[ToolSwitcher Update] Attempted to switch to an invalid/NULL tool definition at index {currentIndex}. Reverting.");
                 currentIndex = previousIndex; // Revert to the last valid index
                 // No state change, no events needed here
            }
        }
    }

    /// <summary>
    /// Sets the CurrentTool and resets CurrentRemainingUses based on the tool's definition.
    /// Optionally fires OnToolChanged and OnUsesChanged events.
    /// </summary>
    /// <param name="isInitialSetup">If true, forces event firing even if tool doesn't technically change.</param>
    private void InitializeToolState(bool isInitialSetup)
    {
        ToolDefinition previousTool = CurrentTool; // Store previous tool for change check
        int previousUses = CurrentRemainingUses; // Store previous uses

        if (toolDefinitions == null || toolDefinitions.Length == 0 || currentIndex < 0 || currentIndex >= toolDefinitions.Length || toolDefinitions[currentIndex] == null)
        {
            // Handle cases with no tools or invalid selection
            CurrentTool = null;
            CurrentRemainingUses = -1; // No tool = unlimited uses conceptually
        }
        else
        {
            // Valid tool selected
            CurrentTool = toolDefinitions[currentIndex];
            if (CurrentTool.limitedUses)
            {
                CurrentRemainingUses = CurrentTool.initialUses;
            }
            else
            {
                CurrentRemainingUses = -1; // Mark as unlimited
            }
        }
        
        

        LogToolChange("[ToolSwitcher InitializeToolState]"); // Log the state after update

        // Fire events if state actually changed or if it's the initial setup
        bool toolActuallyChanged = previousTool != CurrentTool;
        bool usesActuallyChanged = previousUses != CurrentRemainingUses;

        if (isInitialSetup || toolActuallyChanged)
        {
             Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnToolChanged for tool: {CurrentTool?.displayName ?? "NULL"}");
             OnToolChanged?.Invoke(CurrentTool);
        }
        if (isInitialSetup || usesActuallyChanged || toolActuallyChanged) // Fire uses changed if tool changed too (to reset UI)
        {
             Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnUsesChanged with value: {CurrentRemainingUses}");
             OnUsesChanged?.Invoke(CurrentRemainingUses);
        }
    }


    /// <summary>
    /// Refills the current tool to its maximum capacity if it's a limited-use tool.
    /// </summary>
    public void RefillCurrentTool() // <<< NEW METHOD
    {
        if (CurrentTool == null)
        {
            Debug.LogWarning("[ToolSwitcher RefillCurrentTool] Cannot refill: No tool selected.");
            return;
        }

        if (!CurrentTool.limitedUses)
        {
            Debug.LogWarning($"[ToolSwitcher RefillCurrentTool] Cannot refill tool '{CurrentTool.displayName}': It has unlimited uses.");
            return;
        }

        // Check if already full to avoid unnecessary event firing
        if (CurrentRemainingUses == CurrentTool.initialUses)
        {
            if(Debug.isDebugBuild) Debug.Log($"[ToolSwitcher RefillCurrentTool] Tool '{CurrentTool.displayName}' is already full ({CurrentRemainingUses} uses).");
            return;
        }

        // Set uses back to initial amount
        int previousUses = CurrentRemainingUses;
        CurrentRemainingUses = CurrentTool.initialUses;

        Debug.Log($"[ToolSwitcher RefillCurrentTool] Refilled tool '{CurrentTool.displayName}' to {CurrentRemainingUses} uses (was {previousUses}).");

        // Notify listeners that uses changed
        OnUsesChanged?.Invoke(CurrentRemainingUses);
    }
    
    /// <summary>
    /// Attempts to consume one use of the current tool.
    /// </summary>
    /// <returns>True if a use was consumed or if the tool has unlimited uses. False if the tool has limited uses and is out of uses.</returns>
    public bool TryConsumeUse()
    {
        if (CurrentTool == null)
        {
            Debug.LogWarning("[ToolSwitcher TryConsumeUse] Cannot consume use: No tool selected.");
            return false; // Cannot use a non-existent tool
        }

        if (!CurrentTool.limitedUses || CurrentRemainingUses == -1)
        {
            // Tool is unlimited, consumption always succeeds
            // Debug.Log($"[ToolSwitcher TryConsumeUse] Tool '{CurrentTool.displayName}' has unlimited uses."); // Optional log
            return true;
        }

        // Tool has limited uses
        if (CurrentRemainingUses > 0)
        {
            CurrentRemainingUses--;
            Debug.Log($"[ToolSwitcher TryConsumeUse] Consumed use for '{CurrentTool.displayName}'. Remaining: {CurrentRemainingUses}");
            OnUsesChanged?.Invoke(CurrentRemainingUses); // Notify listeners
            return true;
        }
        else
        {
            // Out of uses
            Debug.Log($"[ToolSwitcher TryConsumeUse] Tool '{CurrentTool.displayName}' is out of uses (0 remaining).");
            // Optionally play an 'empty click' sound here
            return false;
        }
    }

    // Added prefix parameter for context
    private void LogToolChange(string prefix = "[ToolSwitcher]")
    {
        string toolName = (CurrentTool != null && !string.IsNullOrEmpty(CurrentTool.displayName))
                          ? CurrentTool.displayName
                          : "(none)";
        string usesSuffix = "";
        if (CurrentTool != null && CurrentTool.limitedUses && CurrentRemainingUses >= 0)
        {
            usesSuffix = $" ({CurrentRemainingUses}/{CurrentTool.initialUses})";
        }
        else if (CurrentTool != null && !CurrentTool.limitedUses)
        {
            // usesSuffix = " (Unlimited)"; // Optional: Indicate unlimited
        }

        Debug.Log($"{prefix} Switched tool to: {toolName}{usesSuffix} (Index: {currentIndex})");
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolType.cs
////////////////////////////////////////////////////////////////////////////////
﻿public enum ToolType
{
    None,
    Hoe,
    WateringCan,
    SeedPouch // New tool type
    // etc.
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolView.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/UI/ToolView.cs
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.EventSystems;

[RequireComponent(typeof(RectTransform))]
public class ToolView : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler
{
    [Header("UI Elements (Assign in Prefab)")]
    [SerializeField] private Image thumbnailImage;
    [SerializeField] private Image backgroundImage;
    [SerializeField] private GameObject tooltipPanel;
    [SerializeField] private TMP_Text tooltipText;
    [SerializeField] private TMP_Text nodeNameText;

    private NodeData _nodeData;
    private ToolDefinition _toolDefinition;
    private Color _originalBackgroundColor;

        
    public void Initialize(NodeData data, ToolDefinition toolDef)
{
    _nodeData = data;
    _toolDefinition = toolDef;

    if (_toolDefinition == null)
    {
        Debug.LogError($"[ToolView Initialize] ToolDefinition is null for {gameObject.name}. Disabling.", gameObject);
        gameObject.SetActive(false);
        return;
    }

    // Get global scale and padding from InventoryGridController
    float globalScaleFactor = 1f;
    float raycastPaddingValue = 0f;

    if (InventoryGridController.Instance != null)
    {
        globalScaleFactor = InventoryGridController.Instance.NodeGlobalImageScale;
        raycastPaddingValue = InventoryGridController.Instance.NodeImageRaycastPadding;
    }

    Vector4 raycastPaddingVector = new Vector4(raycastPaddingValue, raycastPaddingValue, raycastPaddingValue, raycastPaddingValue);

    // SIMPLIFIED: Only set up assigned components (from your prefab)
    if (thumbnailImage != null)
    {
        thumbnailImage.sprite = _toolDefinition.icon;
        thumbnailImage.color = _toolDefinition.iconTint;
        thumbnailImage.rectTransform.localScale = new Vector3(globalScaleFactor, globalScaleFactor, 1f);
        thumbnailImage.enabled = (_toolDefinition.icon != null);
        thumbnailImage.raycastTarget = true;
        thumbnailImage.raycastPadding = raycastPaddingVector;
    }
    else
    {
        Debug.LogWarning($"[ToolView {gameObject.name}] ThumbnailImage not assigned in prefab!", gameObject);
    }

    if (backgroundImage != null)
    {
        _originalBackgroundColor = backgroundImage.color; // Use existing color from prefab
        backgroundImage.enabled = true;
        backgroundImage.raycastTarget = true;
        backgroundImage.raycastPadding = raycastPaddingVector;
    }

    if (tooltipPanel != null) 
        tooltipPanel.SetActive(false);

    if (nodeNameText != null)
    {
        nodeNameText.text = _toolDefinition.displayName;
        nodeNameText.gameObject.SetActive(false); // Usually hidden for tools
    }
}

    public NodeData GetNodeData() => _nodeData;
    public ToolDefinition GetToolDefinition() => _toolDefinition;

    public void OnPointerEnter(PointerEventData eventData)
    {
        if (tooltipPanel != null && tooltipText != null && _toolDefinition != null)
        {
            tooltipPanel.SetActive(true);
            tooltipText.text = BuildTooltipString();
        }
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        if (tooltipPanel != null)
        {
            tooltipPanel.SetActive(false);
        }
    }

    public void OnPointerDown(PointerEventData eventData)
    {
        // Tools in inventory don't get selected like nodes do
        // Selection is handled by the inventory bar
    }

    private string BuildTooltipString()
    {
        if (_toolDefinition == null) return "Invalid Tool";

        string tooltip = $"<b>{_toolDefinition.displayName}</b>\n";
        tooltip += $"Tool Type: {_toolDefinition.toolType}\n";
        
        if (_toolDefinition.limitedUses)
        {
            tooltip += $"Uses: {_toolDefinition.initialUses}\n";
        }
        else
        {
            tooltip += "Uses: Unlimited\n";
        }

        return tooltip.TrimEnd();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\NightColorPostProcess.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

// Ensure this script is attached to a GameObject in your scene
public class NightColorPostProcess : MonoBehaviour
{
    [Header("Core References")]
    [Tooltip("Assign the WeatherManager controlling the day/night cycle.")]
    public WeatherManager weatherManager;
    [Tooltip("Assign the Global Post Processing Volume.")]
    public Volume globalVolume;

    // --- Private references to the Volume Overrides ---
    private ColorAdjustments colorAdjustments;
    private FilmGrain filmGrain;
    private Vignette vignette;
    // private Bloom bloom; // Example if you wanted to add Bloom later

    [Header("Color Adjustments")]
    [Tooltip("The color filter at full day (sunIntensity = 1).")]
    public Color dayColorFilter = Color.white;
    [Tooltip("The color filter at full night (sunIntensity ~ 0).")]
    public Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);
    [Tooltip("Daytime Post-Exposure (Higher = brighter).")]
    public float dayPostExposure = 0f;
    [Tooltip("Nighttime Post-Exposure (Lower = darker).")]
    public float nightPostExposure = -0.5f;
    [Tooltip("Saturation at full day (0 = no change, <0 desaturates, >0 saturates).")]
    public float daySaturation = 0f;
    [Tooltip("Saturation at full night (e.g., -50 for more desaturation).")]
    public float nightSaturation = -50f;

    [Header("Film Grain")]
    [Tooltip("Film grain intensity at full day (0 = none).")]
    [Range(0f, 1f)] public float dayFilmGrainIntensity = 0.1f;
    [Tooltip("Film grain intensity at full night (e.g., 0.5 for noticeable grain).")]
    [Range(0f, 1f)] public float nightFilmGrainIntensity = 0.5f;
    // Note: You could also control FilmGrain.response if desired

    [Header("Vignette")]
    [Tooltip("Vignette intensity at full day (0 = none, higher = stronger effect).")]
    [Range(0f, 1f)] public float dayVignetteIntensity = 0.2f;
    [Tooltip("Vignette intensity at full night (e.g., 0.5 for darker edges).")]
    [Range(0f, 1f)] public float nightVignetteIntensity = 0.5f;
    [Tooltip("Vignette smoothness at full day (higher = softer edge).")]
    [Range(0.01f, 1f)] public float dayVignetteSmoothness = 0.2f;
    [Tooltip("Vignette smoothness at full night.")]
    [Range(0.01f, 1f)] public float nightVignetteSmoothness = 0.3f;
    // Note: You could also control Vignette.color or Vignette.rounded if desired


    private void Start()
    {
        // --- Validate Core References ---
        if (!weatherManager)
        {
            Debug.LogError($"[{nameof(NightColorPostProcess)}] WeatherManager not assigned!", this);
            enabled = false; // Disable script if core references are missing
            return;
        }
        if (!globalVolume)
        {
            Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume not assigned!", this);
            enabled = false;
            return;
        }
        if (globalVolume.profile == null)
        {
             Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume has no profile assigned!", this);
             enabled = false;
             return;
        }

        // --- Attempt to Get Volume Overrides ---
        // It's okay if some aren't found, the Update loop will check for null
        if (!globalVolume.profile.TryGet<ColorAdjustments>(out colorAdjustments))
        {
            Debug.LogWarning($"[{nameof(NightColorPostProcess)}] ColorAdjustments override not found in Volume profile.", this);
        }
        if (!globalVolume.profile.TryGet<FilmGrain>(out filmGrain))
        {
             Debug.LogWarning($"[{nameof(NightColorPostProcess)}] FilmGrain override not found in Volume profile.", this);
        }
        if (!globalVolume.profile.TryGet<Vignette>(out vignette))
        {
             Debug.LogWarning($"[{nameof(NightColorPostProcess)}] Vignette override not found in Volume profile.", this);
        }
        // Example for Bloom:
        // if (!globalVolume.profile.TryGet<Bloom>(out bloom))
        // {
        //      Debug.LogWarning($"[{nameof(NightColorPostProcess)}] Bloom override not found in Volume profile.", this);
        // }

        // --- Ensure Overrides are Active ---
        // Make sure the overrides you intend to use are actually enabled on the Volume component itself.
        // You might need to manually check the boxes in the Inspector for ColorAdjustments, FilmGrain, and Vignette.
        // Alternatively, you could force them active here, but it's usually better to configure in the editor:
        // if (colorAdjustments != null) colorAdjustments.active = true;
        // if (filmGrain != null) filmGrain.active = true;
        // if (vignette != null) vignette.active = true;
    }

    private void Update()
    {
        // No need to check weatherManager, Start() already disables if null
        // Check if any overrides are available before proceeding
        if (colorAdjustments == null && filmGrain == null && vignette == null)
            return; // Nothing to update if no overrides were found

        // Get the sun intensity (0 = night, 1 = day) and calculate interpolation factor t
        float sun = Mathf.Clamp01(weatherManager.sunIntensity);
        float t = 1f - sun;  // t=0 at day, t=1 at night

        // --- Interpolate and Apply Color Adjustments ---
        if (colorAdjustments != null)
        {
            colorAdjustments.colorFilter.value = Color.Lerp(dayColorFilter, nightColorFilter, t);
            colorAdjustments.postExposure.value = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
            colorAdjustments.saturation.value = Mathf.Lerp(daySaturation, nightSaturation, t);
        }

        // --- Interpolate and Apply Film Grain ---
        if (filmGrain != null)
        {
            filmGrain.intensity.value = Mathf.Lerp(dayFilmGrainIntensity, nightFilmGrainIntensity, t);
            // You can add Lerp for filmGrain.response here if needed
        }

        // --- Interpolate and Apply Vignette ---
        if (vignette != null)
        {
            vignette.intensity.value = Mathf.Lerp(dayVignetteIntensity, nightVignetteIntensity, t);
            vignette.smoothness.value = Mathf.Lerp(dayVignetteSmoothness, nightVignetteSmoothness, t);
             // You can add Lerp for vignette.color or vignette.rounded here if needed
        }

        // --- Example for Bloom ---
        // if (bloom != null)
        // {
        //     bloom.intensity.value = Mathf.Lerp(dayBloomIntensity, nightBloomIntensity, t);
        // }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\OutlinePartController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/OutlinePartController.cs
using UnityEngine;

[RequireComponent(typeof(SpriteRenderer))]
public class OutlinePartController : MonoBehaviour
{
    private SpriteRenderer outlineRenderer;
    private SpriteRenderer sourcePlantPartRenderer; // The plant part this outline mimics

    [HideInInspector] public Vector2Int gridCoord; // The coordinate *this outline* lives at

    void Awake()
    {
        outlineRenderer = GetComponent<SpriteRenderer>();
        if (outlineRenderer != null)
        {
            outlineRenderer.drawMode = SpriteDrawMode.Simple;
            outlineRenderer.enabled = false;
        }
        else
        {
            Debug.LogError($"[{gameObject.name}] OutlinePartController is missing SpriteRenderer component!", this);
        }
    }

    public void Initialize(SpriteRenderer sourceRenderer, Vector2Int myCoord, PlantOutlineController controller)
    {
        if (sourceRenderer == null || controller == null) 
        { 
            Debug.LogError($"[{gameObject.name}] Initialization failed! Source renderer or controller is null!", this);
            Destroy(gameObject); 
            return; 
        }
        
        sourcePlantPartRenderer = sourceRenderer; // Store initial source
        gridCoord = myCoord;
        
        if (outlineRenderer == null)
        {
            outlineRenderer = GetComponent<SpriteRenderer>();
            if (outlineRenderer == null)
            {
                Debug.LogError($"[{gameObject.name}] Initialize: Cannot find SpriteRenderer component!", this);
                Destroy(gameObject);
                return;
            }
        }
        
        // Set layer & color properties
        outlineRenderer.sortingLayerID = controller.OutlineSortingLayer;
        outlineRenderer.sortingOrder = controller.OutlineSortingOrder;
        outlineRenderer.color = controller.OutlineColor;
        
        // Set parent & position
        transform.SetParent(controller.transform, true); // Parent to controller's transform
        
        // Set initial position based on grid coordinate (controller handles spacing)
        float spacing = controller.GetComponentInParent<PlantGrowth>()?.GetCellSpacing() ?? 0.08f; // Get spacing
        transform.localPosition = (Vector2)myCoord * spacing;

        // Set visibility based on source renderer's state
        outlineRenderer.enabled = IsSourceRendererValid() && 
                                  sourcePlantPartRenderer.enabled && 
                                  sourcePlantPartRenderer.sprite != null;
        
        SyncSpriteAndTransform(); // Initial sync
    }

    void LateUpdate()
    {
        // Skip update if not visible
        if (outlineRenderer == null || !outlineRenderer.enabled) return;

        // Check if source is still valid
        if (!IsSourceRendererValid())
        {
            SetVisibility(false);
            return;
        }
        
        // Check if source is still enabled and has a sprite
        if (!sourcePlantPartRenderer.enabled || sourcePlantPartRenderer.sprite == null)
        {
            SetVisibility(false);
            return;
        }

        // If we are enabled and source is valid, sync visuals
        SyncSpriteAndTransform();
    }

    // Public method to check if the source renderer still exists
    public bool IsSourceRendererValid()
    {
        // Unity overloads null check for destroyed objects
        if (sourcePlantPartRenderer == null)
            return false;
            
        // Additional check: is the gameObject actually active/valid
        if (!sourcePlantPartRenderer.gameObject.activeInHierarchy)
            return false;
            
        return true;
    }

    // Public method to update the source renderer if the original was destroyed
    public void UpdateSourceRenderer(SpriteRenderer newSource)
    {
        if (newSource != null)
        {
            sourcePlantPartRenderer = newSource;
            
            // Ensure visibility state is correct after source update
            SetVisibility(
                outlineRenderer != null && 
                sourcePlantPartRenderer.enabled && 
                sourcePlantPartRenderer.sprite != null
            );
            
            // Immediately sync sprite/transform after updating source
            SyncSpriteAndTransform();
            
            // Debug.Log($"Updated outline at {gridCoord} with new source renderer: {newSource.gameObject.name}");
        } 
        else 
        {
            Debug.LogWarning($"Attempted to update source renderer for outline at {gridCoord} with null.", gameObject);
            // If no valid new source, hide this outline
            SetVisibility(false);
        }
    }

    // Sync sprite and transform data
    public void SyncSpriteAndTransform()
    {
        // Safety checks
        if (!IsSourceRendererValid() || outlineRenderer == null) 
            return;

        // Sync sprite
        if (outlineRenderer.sprite != sourcePlantPartRenderer.sprite)
        {
            outlineRenderer.sprite = sourcePlantPartRenderer.sprite;
        }
        
        // Sync other visual properties
        transform.localScale = sourcePlantPartRenderer.transform.localScale;
        outlineRenderer.flipX = sourcePlantPartRenderer.flipX;
        outlineRenderer.flipY = sourcePlantPartRenderer.flipY;
        
        // Note: Position is set in Initialize and doesn't need to track source renderer's parent offset
    }

    public void SetVisibility(bool isVisible)
    {
        if (outlineRenderer != null && outlineRenderer.enabled != isVisible)
        {
            outlineRenderer.enabled = isVisible;
        }
    }

    public void DestroyOutlinePart()
    {
        if (this != null && gameObject != null)
        {
            if (Application.isPlaying)
            {
                Destroy(gameObject);
            }
            else
            {
                DestroyImmediate(gameObject);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\PixelPerfectSetup.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Core/PixelPerfectSetup.cs
using UnityEngine;
using UnityEngine.U2D;

[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(PixelPerfectCamera))]
public class PixelPerfectSetup : MonoBehaviour
{
    [Header("Game Resolution")]
    [SerializeField] private int referenceResolutionX = 320; // Your base game width
    [SerializeField] private int referenceResolutionY = 180; // Your base game height
    
    [Header("Pixel Settings")]
    [SerializeField] private int pixelsPerUnit = 6; // Since 1 game pixel = 6x6 real pixels
    
    private PixelPerfectCamera pixelPerfectCamera;
    private Camera cam;
    
    void Awake()
    {
        cam = GetComponent<Camera>();
        pixelPerfectCamera = GetComponent<PixelPerfectCamera>();
        
        SetupPixelPerfectCamera();
    }
    
    void SetupPixelPerfectCamera()
    {
        // Configure Pixel Perfect Camera
        pixelPerfectCamera.assetsPPU = pixelsPerUnit;
        pixelPerfectCamera.refResolutionX = referenceResolutionX;
        pixelPerfectCamera.refResolutionY = referenceResolutionY;
        pixelPerfectCamera.upscaleRT = true;
        pixelPerfectCamera.pixelSnapping = true;
        pixelPerfectCamera.cropFrameX = false;
        pixelPerfectCamera.cropFrameY = false;
        pixelPerfectCamera.stretchFill = false;
        
        Debug.Log($"[PixelPerfectSetup] Configured for {referenceResolutionX}x{referenceResolutionY} at {pixelsPerUnit} PPU");
    }
    
    void Start()
    {
        // Verify the setup
        float expectedCameraSize = (float)referenceResolutionY / (2f * pixelsPerUnit);
        Debug.Log($"[PixelPerfectSetup] Expected camera orthographic size: {expectedCameraSize}");
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\PlantOutlineController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/PlantOutlineController.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[RequireComponent(typeof(RectTransform))]
public class PlantOutlineController : MonoBehaviour
{
    // --- Fields ---
    [Header("Outline Settings")]
    [SerializeField] private Color outlineColor = Color.black;
    [SerializeField] private bool excludeOuterCorners = false;
    [SerializeField] private bool excludeBaseCell = true;
    [SerializeField] private GameObject outlinePartPrefab;
    
    [Header("Sorting")]
    [SerializeField] private string outlineSortingLayerName = "Default";
    [SerializeField] private int outlineSortingOrder = -1;

    [Header("Debugging")]
    [SerializeField] private bool debugLogging = false;

    // Public accessors
    public Color OutlineColor => outlineColor;
    public int OutlineSortingLayer => outlineSortingLayerID;
    public int OutlineSortingOrder => outlineSortingOrder;

    // Internal State
    private int outlineSortingLayerID;
    private PlantGrowth parentPlantGrowth;
    private Dictionary<Vector2Int, OutlinePartController> outlinePartMap = new Dictionary<Vector2Int, OutlinePartController>();
    private HashSet<Vector2Int> plantCellCoords = new HashSet<Vector2Int>();
    
    // Neighbor offsets - 8 directions around a cell
    private static readonly Vector2Int[] neighborOffsets = new Vector2Int[]
    {
        new Vector2Int(-1, -1), // Down-Left
        new Vector2Int(0, -1),  // Down
        new Vector2Int(1, -1),  // Down-Right
        new Vector2Int(-1, 0),  // Left
        new Vector2Int(1, 0),   // Right
        new Vector2Int(-1, 1),  // Up-Left
        new Vector2Int(0, 1),   // Up
        new Vector2Int(1, 1),   // Up-Right
    };

    // Just the cardinal directions (for certain operations)
    private static readonly Vector2Int[] cardinalOffsets = new Vector2Int[]
    {
        new Vector2Int(0, -1),  // Down
        new Vector2Int(-1, 0),  // Left
        new Vector2Int(1, 0),   // Right
        new Vector2Int(0, 1),   // Up
    };

    void Awake()
    {
        parentPlantGrowth = GetComponentInParent<PlantGrowth>();
        if (parentPlantGrowth == null)
        {
            Debug.LogError($"[{gameObject.name} Awake] Missing PlantGrowth parent!", gameObject);
            enabled = false;
            return;
        }
        
        if (outlinePartPrefab == null)
        {
            Debug.LogError($"[{gameObject.name} Awake] Outline Part Prefab not assigned!", gameObject);
            enabled = false;
            return;
        }
        
        // Get the proper sorting layer ID from the name
        outlineSortingLayerID = SortingLayer.NameToID(outlineSortingLayerName);
        if (outlineSortingLayerID == 0 && outlineSortingLayerName != "Default")
        {
            Debug.LogWarning($"[{gameObject.name} Awake] Sorting Layer '{outlineSortingLayerName}' not found, using 'Default'.");
            outlineSortingLayerID = SortingLayer.NameToID("Default");
        }
        
        // Zero out local transform values to avoid unexpected visual glitches
        transform.localPosition = Vector3.zero;
        transform.localRotation = Quaternion.identity;
        transform.localScale = Vector3.one;
        
        if (debugLogging)
            Debug.Log($"[{gameObject.name} Awake] Initialized outline controller for {parentPlantGrowth.gameObject.name}");
    }

    // --- Methods Called by PlantGrowth ---

    // OnPlantCellAdded - Called when a new plant cell is added
    public void OnPlantCellAdded(Vector2Int plantCoord, GameObject plantCellGO)
    {
        if (plantCellGO == null)
        {
            if (debugLogging)
                Debug.LogWarning($"[{gameObject.name}] OnPlantCellAdded: Null GameObject at {plantCoord}");
            return;
        }
        
        // Add to our plant cells set
        plantCellCoords.Add(plantCoord);
        
        // Remove any existing outline at the plant location (should be clear already, but safety)
        RemoveOutlinePartIfExists(plantCoord);
        
        // Get the SpriteRenderer from the plant cell
        SpriteRenderer plantRenderer = plantCellGO.GetComponentInChildren<SpriteRenderer>();
        if (plantRenderer == null)
        {
            Debug.LogWarning($"Plant cell added at {plantCoord} missing SpriteRenderer.", plantCellGO);
            return;
        }
        
        // Check all neighboring coordinates around this plant cell
        foreach (Vector2Int offset in neighborOffsets)
        {
            Vector2Int neighborCoord = plantCoord + offset;
            
            // Only create outline parts where:
            // 1. There's no plant cell
            // 2. There's no outline part already
            // 3. It passes any exclusion rules
            if (!plantCellCoords.Contains(neighborCoord) && 
                !outlinePartMap.ContainsKey(neighborCoord))
            {
                if (ShouldExcludeOutlineAt(neighborCoord))
                    continue;
                    
                CreateOutlinePart(neighborCoord, plantRenderer);
            }
        }
        
        if (debugLogging)
            Debug.Log($"[{gameObject.name}] Added cell at {plantCoord}, now tracking {plantCellCoords.Count} cells and {outlinePartMap.Count} outline parts");
    }

    // OnPlantCellRemoved - Called when a plant cell is removed
    public void OnPlantCellRemoved(Vector2Int plantCoord)
    {
        if (!plantCellCoords.Contains(plantCoord))
        {
            if (debugLogging)
                Debug.LogWarning($"[{gameObject.name}] OnPlantCellRemoved: Coordinate {plantCoord} not found in plant cells!");
            return;
        }
        
        // Remove the coordinate from our internal tracking
        plantCellCoords.Remove(plantCoord);
        
        if (debugLogging)
            Debug.Log($"[{gameObject.name}] Removed cell at {plantCoord}, now have {plantCellCoords.Count} cells");
        
        // 1. Check if outline should appear *at the removed location*
        if (!outlinePartMap.ContainsKey(plantCoord))
        {
            if (HasPlantNeighbor(plantCoord))
            {
                SpriteRenderer sourceRenderer = FindValidNeighborRenderer(plantCoord);
                if (sourceRenderer != null && !ShouldExcludeOutlineAt(plantCoord))
                {
                    CreateOutlinePart(plantCoord, sourceRenderer);
                    if (debugLogging)
                        Debug.Log($"[{gameObject.name}] Created new outline at removed cell position {plantCoord}");
                }
            }
        }
        
        // 2. Re-evaluate all neighboring coordinates
        foreach (Vector2Int offset in neighborOffsets)
        {
            Vector2Int neighborCoord = plantCoord + offset;
            
            // Check if an outline exists at this neighbor
            if (outlinePartMap.TryGetValue(neighborCoord, out OutlinePartController outlinePart))
            {
                // Safety check for destroyed outline part
                if (outlinePart == null)
                {
                    outlinePartMap.Remove(neighborCoord);
                    if (debugLogging)
                        Debug.Log($"[{gameObject.name}] Removed null outline at {neighborCoord} from dictionary");
                    continue;
                }
                
                // Check if this neighbor still needs an outline
                bool neighborStillHasPlantNeighbor = HasPlantNeighbor(neighborCoord);
                
                if (!neighborStillHasPlantNeighbor)
                {
                    // No longer has any plant neighbors, remove it
                    RemoveOutlinePartIfExists(neighborCoord);
                    if (debugLogging)
                        Debug.Log($"[{gameObject.name}] Removed orphaned outline at {neighborCoord}");
                }
                else if (!outlinePart.IsSourceRendererValid())
                {
                    // Outline's source was likely the removed cell, update it
                    SpriteRenderer newSource = FindValidNeighborRenderer(neighborCoord);
                    if (newSource != null)
                    {
                        outlinePart.UpdateSourceRenderer(newSource);
                        outlinePart.SyncSpriteAndTransform();
                        if (debugLogging)
                            Debug.Log($"[{gameObject.name}] Updated source for outline at {neighborCoord}");
                    }
                    else
                    {
                        // This case is unlikely but could happen in complex removals
                        if (debugLogging)
                            Debug.LogWarning($"[{gameObject.name}] Outline at {neighborCoord} lost source but HasPlantNeighbor=true. Removing.");
                        RemoveOutlinePartIfExists(neighborCoord);
                    }
                }
            }
            // If no outline at this neighbor, but there should be one (e.g., it was excluded before)
            else if (!plantCellCoords.Contains(neighborCoord) && HasPlantNeighbor(neighborCoord))
            {
                if (!ShouldExcludeOutlineAt(neighborCoord))
                {
                    SpriteRenderer sourceRenderer = FindValidNeighborRenderer(neighborCoord);
                    if (sourceRenderer != null)
                    {
                        CreateOutlinePart(neighborCoord, sourceRenderer);
                        if (debugLogging)
                            Debug.Log($"[{gameObject.name}] Created new outline at neighbor {neighborCoord} after cell removal");
                    }
                }
            }
        }
    }

    // --- Internal Helper Methods ---

    // CreateOutlinePart - Creates an outline part at the specified coordinates
    private void CreateOutlinePart(Vector2Int coord, SpriteRenderer sourceRenderer)
    {
        if (outlinePartPrefab == null)
        {
            Debug.LogError($"[{gameObject.name}] CreateOutlinePart: outlinePartPrefab is null!");
            return;
        }
        
        if (sourceRenderer == null)
        {
            Debug.LogWarning($"[{gameObject.name}] CreateOutlinePart: sourceRenderer is null for coord {coord}");
            return;
        }
        
        // Check if already exists (safety)
        if (outlinePartMap.ContainsKey(coord))
        {
            if (debugLogging)
                Debug.LogWarning($"[{gameObject.name}] CreateOutlinePart: Outline already exists at {coord}");
            return;
        }
        
        // Instantiate the outline part
        GameObject outlineInstance = Instantiate(outlinePartPrefab, transform);
        if (outlineInstance == null)
        {
            Debug.LogError($"[{gameObject.name}] CreateOutlinePart: Failed to instantiate outline prefab!");
            return;
        }
        
        // Set position using PlantGrowth's cell spacing
        float spacing = parentPlantGrowth.GetCellSpacing();
        outlineInstance.transform.localPosition = (Vector2)coord * spacing;
        
        // Get the controller and initialize it
        OutlinePartController outlineController = outlineInstance.GetComponent<OutlinePartController>();
        if (outlineController != null)
        {
            outlineController.Initialize(sourceRenderer, coord, this);
            outlineController.SetVisibility(true);
            outlinePartMap.Add(coord, outlineController);
            
            if (debugLogging)
                Debug.Log($"[{gameObject.name}] Created outline part at {coord} using source {sourceRenderer.gameObject.name}");
        }
        else
        {
            Debug.LogError($"[{gameObject.name}] Outline Part Prefab missing OutlinePartController script!", outlinePartPrefab);
            Destroy(outlineInstance);
        }
    }

    // RemoveOutlinePartIfExists - Removes an outline part if it exists at the specified coordinates
    private void RemoveOutlinePartIfExists(Vector2Int coord)
    {
        if (outlinePartMap.TryGetValue(coord, out OutlinePartController outlinePart))
        {
            if (outlinePart != null)
            {
                outlinePart.DestroyOutlinePart();
                if (debugLogging)
                    Debug.Log($"[{gameObject.name}] Destroyed outline part at {coord}");
            }
            outlinePartMap.Remove(coord);
        }
    }

    // HasPlantNeighbor - Checks if the specified coordinates have any plant neighbors
    private bool HasPlantNeighbor(Vector2Int coord)
    {
        foreach (Vector2Int offset in neighborOffsets)
        {
            if (plantCellCoords.Contains(coord + offset))
            {
                return true;
            }
        }
        return false;
    }

    // FindValidNeighborRenderer - Finds a valid SpriteRenderer from a neighboring plant cell
    private SpriteRenderer FindValidNeighborRenderer(Vector2Int coord)
    {
        foreach (Vector2Int offset in neighborOffsets)
        {
            Vector2Int neighborCoord = coord + offset;
            
            // Check if there's a plant cell at this coordinate
            if (plantCellCoords.Contains(neighborCoord))
            {
                // Get the GameObject from PlantGrowth
                GameObject plantGO = parentPlantGrowth.GetCellGameObjectAt(neighborCoord);
                if (plantGO != null)
                {
                    SpriteRenderer renderer = plantGO.GetComponentInChildren<SpriteRenderer>();
                    if (renderer != null)
                    {
                        if (debugLogging)
                            Debug.Log($"[{gameObject.name}] Found valid renderer at {neighborCoord} for outline at {coord}");
                        return renderer;
                    }
                }
            }
        }
        
        if (debugLogging)
            Debug.LogWarning($"[{gameObject.name}] Could not find any valid neighbor renderer for {coord}");
        return null;
    }

    // ShouldExcludeOutlineAt - Checks if an outline should be excluded at the specified coordinates
    private bool ShouldExcludeOutlineAt(Vector2Int coord)
    {
        // Exclude base cell (e.g., under the seed) if enabled
        if (excludeBaseCell && coord == Vector2Int.down && plantCellCoords.Contains(Vector2Int.zero))
        {
            return true;
        }
        
        // Exclude outer corners if enabled
        if (excludeOuterCorners && IsOuterCornerCandidate(coord))
        {
            return true;
        }
        
        return false;
    }

    // IsOuterCornerCandidate - Checks if the coordinate is a potential outer corner
    private bool IsOuterCornerCandidate(Vector2Int coord)
    {
        // If it's a plant cell, it's not an outer corner
        if (plantCellCoords.Contains(coord))
            return false;
            
        // Count the number of plant neighbors
        int plantNeighborCount = 0;
        foreach (Vector2Int offset in neighborOffsets)
        {
            if (plantCellCoords.Contains(coord + offset)) {
                plantNeighborCount++;
            }
        }
        
        // In typical 2D grid outline detection, an outer corner has 3 neighbors
        return plantNeighborCount == 3;
    }

    void OnDestroy()
    {
        // Clean up resources when destroyed
        foreach (var kvp in outlinePartMap)
        {
            if (kvp.Value != null)
            {
                kvp.Value.DestroyOutlinePart();
            }
        }
        outlinePartMap.Clear();
        plantCellCoords.Clear();
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\PlantShadowController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/PlantShadowController.cs
using UnityEngine;
using System.Collections.Generic;

public class PlantShadowController : MonoBehaviour
{
    [Header("Global Shadow Settings")]
    [SerializeField] private Color shadowColor = new Color(0f, 0f, 0f, 0.5f);
    [SerializeField] [Range(0.1f, 2f)] [Tooltip("Vertical squash factor (1 = none, <1 = flatter, >1 = taller)")]
    private float squashFactor = 0.6f;
    [SerializeField] [Range(0f, 360f)] [Tooltip("Rotation angle of the shadow around the plant's base (0 = right, 90 = up, 180 = left, 270 = down)")]
    private float shadowAngleDegrees = 270f; // Default to directly downwards
    [SerializeField] [Tooltip("Flip the shadow horizontally?")]
    private bool flipShadow = false;
    // Removed: lightSourceDirection
    // Removed: shadowDistance
    // Removed: skewAngleDegrees (replaced by shadowAngleDegrees for direction)
    
    [Header("Distance Fade")]
    [Tooltip("Enable fading parts based on distance from the root.")]
    [SerializeField] private bool enableDistanceFade = true;
    [Tooltip("Distance from the root where the shadow part starts fading.")]
    [SerializeField] private float fadeStartDistance = 1.5f;
    [Tooltip("Distance from the root where the shadow part is fully faded (alpha 0).")]
    [SerializeField] private float fadeEndDistance = 3.0f;
    [Tooltip("Minimum alpha value even when fully faded (e.g., 0.1 for slight visibility).")]
    [SerializeField] [Range(0f, 1f)] private float minFadeAlpha = 0.0f;

    [Header("Sorting")]
    [SerializeField] [Tooltip("Name of the Sorting Layer for shadows (e.g., 'Shadows')")]
    private string shadowSortingLayerName = "Default";
    [SerializeField] [Tooltip("Sorting Order within the layer (lower values are rendered first)")]
    private int shadowSortingOrder = -1;

    // --- Internal ID ---
    private int shadowSortingLayerID;

    // Public accessors for ShadowPartController
    public Color ShadowColor => shadowColor;
    public int ShadowSortingLayer => shadowSortingLayerID;
    public int ShadowSortingOrder => shadowSortingOrder;

    // <<< NEW ACCESSORS for Fade >>>
    public bool EnableDistanceFade => enableDistanceFade;
    public float FadeStartDistance => fadeStartDistance;
    public float FadeEndDistance => fadeEndDistance;
    public float MinFadeAlpha => minFadeAlpha;
    
    // Cached base transform values
    private Vector3 baseLocalScale;
    private Quaternion baseLocalRotation;
    private Vector3 baseLocalPosition;

    // Dictionary to manage shadow parts (unchanged)
    private Dictionary<SpriteRenderer, ShadowPartController> shadowPartMap = new Dictionary<SpriteRenderer, ShadowPartController>();

    void Awake()
    {
        // Convert layer name to ID (unchanged)
        shadowSortingLayerID = SortingLayer.NameToID(shadowSortingLayerName);
        if (shadowSortingLayerID == 0 && shadowSortingLayerName != "Default")
        {
            Debug.LogWarning($"Sorting Layer '{shadowSortingLayerName}' not found. Shadow will use 'Default'.", this);
            shadowSortingLayerID = SortingLayer.NameToID("Default");
        }

        // Cache initial transform state (unchanged)
        baseLocalScale = transform.localScale;
        baseLocalRotation = transform.localRotation;
        // --- IMPORTANT: Ensure _ShadowRoot starts at local position (0,0,0) relative to the Plant root ---
        baseLocalPosition = transform.localPosition;
        if (baseLocalPosition != Vector3.zero) {
             Debug.LogWarning($"'{gameObject.name}' initial localPosition is not zero ({baseLocalPosition}). Shadow origin might be slightly offset from plant root.", gameObject);
        }
    }

    void LateUpdate()
    {
        // 1. Set Position: Keep the shadow root at the plant's origin (relative to parent)
        // We don't apply any offset anymore.
        transform.localPosition = baseLocalPosition; // Should typically be Vector3.zero

        // 2. Set Rotation based on the angle slider
        // Apply the rotation relative to the initial orientation
        Quaternion angleRotation = Quaternion.Euler(0, 0, shadowAngleDegrees);
        transform.localRotation = baseLocalRotation * angleRotation;

        // 3. Calculate and Apply Scale (Squash + Flip)
        Vector3 finalScale = baseLocalScale; // Start with original scale
        // Apply squash factor (typically affects the Y-axis before rotation)
        // To apply squash along the *rotated* Y-axis is more complex.
        // Let's keep the simpler approach: squash the local Y scale.
        finalScale.y *= squashFactor;

        // Apply horizontal flip if checked (affects the X-axis)
        if (flipShadow)
        {
            finalScale.x *= -1f;
        }
        // Apply the calculated scale
        transform.localScale = finalScale;

    }

    // --- Methods for PlantGrowth Integration (Unchanged) ---

    public void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject shadowPartPrefab)
    {
        if (plantPartRenderer == null || shadowPartPrefab == null) return;
        if (shadowPartMap.ContainsKey(plantPartRenderer)) return;
        GameObject shadowInstance = Instantiate(shadowPartPrefab, transform);
        ShadowPartController shadowController = shadowInstance.GetComponent<ShadowPartController>();
        if (shadowController != null) { shadowController.Initialize(plantPartRenderer, this); shadowPartMap.Add(plantPartRenderer, shadowController); }
        else { Debug.LogError($"Shadow Part Prefab '{shadowPartPrefab.name}' missing ShadowPartController.", shadowPartPrefab); Destroy(shadowInstance); }
    }

    public void UnregisterPlantPart(SpriteRenderer plantPartRenderer)
    {
        if (plantPartRenderer != null && shadowPartMap.TryGetValue(plantPartRenderer, out ShadowPartController shadowController)) {
            if (shadowController != null) { shadowController.OnPlantPartDestroyed(); }
            shadowPartMap.Remove(plantPartRenderer);
        }
    }

    void OnDestroy()
    {
        shadowPartMap.Clear(); // Prevent memory leaks
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\RuntimeCircleDrawer.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/RuntimeCircleDrawer.cs

using UnityEngine;

/// <summary>
/// Draws a circle outline using a LineRenderer attached to the same GameObject.
/// Requires a LineRenderer component.
/// </summary>
[RequireComponent(typeof(LineRenderer))]
public class RuntimeCircleDrawer : MonoBehaviour
{
    [Range(3, 60)]
    public int segments = 30; // Number of line segments to approximate the circle
    public float radius = 1.0f;
    public float lineWidth = 0.02f;
    public Color color = Color.yellow;
    public Material lineMaterial; // Assign the same material used for firefly lines, or a specific one

    private LineRenderer lineRenderer;
    private bool needsRedraw = true; // Flag to force redraw on first UpdateCircle call or when params change
    private float currentRadius = -1f; // Store current values to detect changes
    private Color currentColor = Color.clear;

    void Awake()
    {
        lineRenderer = GetComponent<LineRenderer>();
        if (lineRenderer == null) { // Should not happen with RequireComponent
            Debug.LogError($"[{gameObject.name}] RuntimeCircleDrawer: Missing required LineRenderer component!");
            enabled = false; // Disable script if component missing
            return;
        }
        ConfigureLineRendererDefaults();
        lineRenderer.enabled = false; // Start hidden
    }

    // Sets initial parameters that don't change often
    void ConfigureLineRendererDefaults()
    {
        lineRenderer.useWorldSpace = false; // Draw relative to this object's transform
        lineRenderer.loop = true; // Connect the last point to the first
        lineRenderer.startWidth = lineWidth;
        lineRenderer.endWidth = lineWidth;
        
        // Only set material if one was provided and lineRenderer doesn't have one
        if (lineMaterial != null && lineRenderer.material == null)
        {
            lineRenderer.material = lineMaterial;
        }
        
        // Don't set color here - UpdateCircle will handle that

        // Attempt to match sorting with parent sprite
        SpriteRenderer parentSprite = GetComponentInParent<SpriteRenderer>();
        if (parentSprite != null) {
            lineRenderer.sortingLayerName = parentSprite.sortingLayerName;
            lineRenderer.sortingOrder = parentSprite.sortingOrder + 1; // Draw slightly in front
        } else {
            // Default sorting if no parent sprite found
            lineRenderer.sortingLayerName = "Default";
            lineRenderer.sortingOrder = 1;
        }
    }

    // Call this method to update the circle's appearance and make it visible
    public void UpdateCircle(float newRadius, Color newColor)
    {
        // Check if parameters have actually changed
        bool radiusChanged = !Mathf.Approximately(currentRadius, newRadius);
        bool colorChanged = currentColor != newColor;
        
        if (!needsRedraw && !radiusChanged && !colorChanged)
        {
            // Ensure it's enabled if it wasn't already
            if (!lineRenderer.enabled) lineRenderer.enabled = true;
            return; // No change needed
        }

        // Update stored values
        currentRadius = newRadius;
        radius = newRadius; // Update public field for potential inspector viewing
        currentColor = newColor;
        color = newColor; // Update public field

        // IMPORTANT: Update LineRenderer colors
        lineRenderer.startColor = currentColor;
        lineRenderer.endColor = currentColor;
        
        // Log color change for debugging
        if (colorChanged && Debug.isDebugBuild)
        {
            Debug.Log($"[RuntimeCircleDrawer] Updated color to: {newColor}", gameObject);
        }
        
        // Update width if you add properties for it too
        // lineRenderer.startWidth = newWidth;
        // lineRenderer.endWidth = newWidth;

        DrawCircle(); // Recalculate points
        lineRenderer.enabled = true; // Ensure it's visible
        needsRedraw = false; // Mark as drawn
    }

    // Call this to hide the circle
    public void HideCircle()
    {
        if (lineRenderer != null && lineRenderer.enabled)
        {
            lineRenderer.enabled = false;
            needsRedraw = true; // Needs redraw next time it's shown
        }
    }

    void DrawCircle()
    {
        if (lineRenderer == null || segments <= 2 || radius <= 0f) {
            lineRenderer.positionCount = 0; // Clear points if invalid params
            return;
        };

        // Only resize array if segment count changes (optimization)
        if (lineRenderer.positionCount != segments + 1) {
            lineRenderer.positionCount = segments + 1;
        }

        float angleStep = 360f / segments;
        Vector3[] points = new Vector3[segments + 1];

        for (int i = 0; i <= segments; i++)
        {
            float currentAngle = Mathf.Deg2Rad * (i * angleStep);
            float x = Mathf.Cos(currentAngle) * radius;
            float y = Mathf.Sin(currentAngle) * radius;
            points[i] = new Vector3(x, y, 0); // Z is 0 for local space relative to transform
        }

        lineRenderer.SetPositions(points);
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\ShadowPartController.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/ShadowPartController.cs
using UnityEngine;
// using UnityEngine.Rendering; // Not needed for this simple fade

[RequireComponent(typeof(SpriteRenderer))]
public class ShadowPartController : MonoBehaviour
{
    private SpriteRenderer shadowRenderer;
    private SpriteRenderer plantPartRenderer;
    private Transform plantPartTransform;
    private Transform shadowRootTransform;
    private PlantShadowController mainShadowController;
    // Removed: initialLocalPosition - not needed for distance calc

    void Awake()
    {
        shadowRenderer = GetComponent<SpriteRenderer>();
        shadowRenderer.drawMode = SpriteDrawMode.Simple;
        shadowRenderer.enabled = false;
    }

    public void Initialize(SpriteRenderer targetPlantPartRenderer, PlantShadowController controller)
    {
        if (targetPlantPartRenderer == null || controller == null) { Destroy(gameObject); return; }
        plantPartRenderer = targetPlantPartRenderer;
        plantPartTransform = targetPlantPartRenderer.transform;
        mainShadowController = controller;
        shadowRootTransform = controller.transform;

        shadowRenderer.sortingLayerID = mainShadowController.ShadowSortingLayer;
        shadowRenderer.sortingOrder = mainShadowController.ShadowSortingOrder;
        // Color is now set in LateUpdate to include fade alpha

        transform.SetParent(shadowRootTransform, true); // Parent first

        shadowRenderer.enabled = plantPartRenderer.enabled && plantPartRenderer.sprite != null;
        // Initialize color with potentially full alpha
        UpdateColorAndFade();
    }

    void LateUpdate()
    {
        if (plantPartRenderer == null || !plantPartRenderer.enabled || plantPartRenderer.sprite == null || shadowRenderer == null || mainShadowController == null)
        {
            if (shadowRenderer != null) shadowRenderer.enabled = false;
            return;
        }

        shadowRenderer.enabled = true;

        // 1. Sync Sprite
        shadowRenderer.sprite = plantPartRenderer.sprite;

        // 2. Sync Position & Rotation (Relative to Shadow Root) - Unchanged
        Vector3 plantPartPosRelativeToPlantRoot = plantPartTransform.parent.InverseTransformPoint(plantPartTransform.position);
        transform.localPosition = plantPartPosRelativeToPlantRoot;
        transform.localRotation = plantPartTransform.localRotation;

        // 3. Sync Flip - Unchanged
        shadowRenderer.flipX = plantPartRenderer.flipX;
        shadowRenderer.flipY = plantPartRenderer.flipY;

        // 4. Sync Scale (relative to parent) - Unchanged
        transform.localScale = plantPartTransform.localScale;

        // 5. Update Color & Apply Distance Fade
        UpdateColorAndFade();
    }

    // <<< NEW METHOD >>>
    private void UpdateColorAndFade()
    {
        if(mainShadowController == null || shadowRenderer == null) return;

        Color baseShadowColor = mainShadowController.ShadowColor;
        float finalAlpha = baseShadowColor.a; // Start with the controller's base alpha

        // Apply distance fade if enabled
        if (mainShadowController.EnableDistanceFade)
        {
            float distance = Vector3.Distance(transform.position, shadowRootTransform.position); // Distance from shadow part to shadow root

            float fadeStart = mainShadowController.FadeStartDistance;
            float fadeEnd = mainShadowController.FadeEndDistance;
            float minAlpha = mainShadowController.MinFadeAlpha;

            if (distance >= fadeEnd)
            {
                finalAlpha *= minAlpha; // Apply min alpha
            }
            else if (distance > fadeStart)
            {
                // Calculate interpolation factor (0 at start, 1 at end)
                float t = Mathf.InverseLerp(fadeStart, fadeEnd, distance);
                // Lerp between 1 (full alpha multiplier) and minAlpha
                float distanceAlphaMultiplier = Mathf.Lerp(1f, minAlpha, t);
                finalAlpha *= distanceAlphaMultiplier; // Modulate base alpha
            }
            // Else (distance <= fadeStart), finalAlpha remains baseShadowColor.a
        }

        // Set the final color with calculated alpha
        shadowRenderer.color = new Color(baseShadowColor.r, baseShadowColor.g, baseShadowColor.b, finalAlpha);
    }
    // <<< END NEW METHOD >>>


    public void OnPlantPartDestroyed() // Unchanged
    {
         if (this != null && gameObject != null) { if (Application.isPlaying) { Destroy(gameObject); } else { DestroyImmediate(gameObject); } }
    }
}


////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\WaterReflection.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/WaterReflection.cs
using UnityEngine;
using UnityEngine.Tilemaps;
using System.Collections.Generic; // Keep for potential future extensions, not strictly needed now

public class WaterReflection : MonoBehaviour
{
    // --- SECTION: Override Toggles ---
    [System.Serializable]
    public class OverrideSettings
    {
        [Tooltip("If checked, the local 'Reflection Opacity' value will be used instead of the global manager's default.")]
        public bool reflectionOpacity = false;
        [Tooltip("If checked, the local 'Reflection Tint' value will be used instead of the global manager's default.")]
        public bool reflectionTint = false;
        [Tooltip("If checked, the local 'Gradient Fade Base Material' will be used. Otherwise, manager's default is used.")]
        public bool gradientFadeBaseMaterial = false;
        [Tooltip("If checked, the local 'Sorting Order Offset' value will be used instead of the global manager's default.")]
        public bool sortingOrderOffset = false;
        [Tooltip("If checked, the local 'Use Water Masking' value will be used instead of the global manager's default.")]
        public bool useWaterMasking = false;
        [Tooltip("If checked, the local 'Water Tilemap Tag' value will be used instead of the global manager's default.")]
        public bool waterTilemapTag = false;
        [Tooltip("If checked, the local 'Show Debug Info' value will be used instead of the global manager's default.")]
        public bool showDebugInfo = false;
    }
    [Header("Overrides (Global Defaults from WaterReflectionManager)")]
    [SerializeField] private OverrideSettings overrides;


    // --- SECTION: Local Settings (Used if Overridden) ---
    [Header("Reflection Source")]
    [Tooltip("If true, Y Offset and Distance Fade calculations will be relative to this GameObject's parent. If false (default), relative to this GameObject.")]
    [SerializeField] private bool useParentAsReference = false; // This remains a local setting

    [Header("Local Reflection Settings (If Overridden)")]
    [Tooltip("Vertical offset of the reflection. Interpretation depends on 'Use Parent As Reference'.")]
    [SerializeField] private float yOffset = -1f; // This remains a local setting

    [Tooltip("Local opacity of the reflection (0 = invisible, 1 = fully opaque)")]
    [SerializeField] [Range(0f, 1f)] private float localReflectionOpacity = 0.5f;

    [Tooltip("Local additional tint color for the reflection")]
    [SerializeField] private Color localReflectionTint = Color.white;

    [Header("Local Distance Fade (If Overridden)")]
    [Tooltip("Enable fading reflection. Requires 'Gradient Fade Base Material' (local or global) to be assigned.")]
    [SerializeField] private bool enableDistanceFade = true; // This remains local as it depends on material
    [Tooltip("Vertical distance from the reference Y where fade starts.")]
    [SerializeField] private float fadeStartDistance = 0.0f; // Local
    [Tooltip("Vertical distance from the reference Y where reflection becomes min alpha.")]
    [SerializeField] private float fadeEndDistance = 1.0f; // Local
    [Tooltip("Minimum alpha when fully faded.")]
    [SerializeField] [Range(0f, 1f)] private float minFadeAlpha = 0.0f; // Local
    [Tooltip("Local override for the gradient fade material. If unassigned and override is false, uses manager's default.")]
    [SerializeField] private Material localGradientFadeBaseMaterial;

    [Header("Local Sorting (If Overridden)")]
    [Tooltip("Local sorting order offset for the reflection")]
    [SerializeField] private int localSortingOrderOffset = -1;

    [Header("Local Water Masking (If Overridden)")]
    [Tooltip("Local override for using water masking")]
    [SerializeField] private bool localUseWaterMasking = true;
    [Tooltip("Local override for the water tilemap tag")]
    [SerializeField] private string localWaterTilemapTag = "Water";

    [Header("Local Debug (If Overridden)")]
    [SerializeField] private bool localShowDebugInfo = false;


    // --- Internal References ---
    private SpriteRenderer originalRenderer;
    private Animator originalAnimator;
    private GameObject reflectionObject;
    private SpriteRenderer reflectionRenderer;
    private Animator reflectionAnimator;
    private Material reflectionMaterialInstance; // Instanced material for this reflection

    // --- Resolved Settings (from Manager or Local) ---
    private float _actualReflectionOpacity;
    private Color _actualReflectionTint;
    private Material _actualGradientFadeBaseMaterial;
    private int _actualSortingOrderOffset;
    private bool _actualUseWaterMasking;
    private string _actualWaterTilemapTag;
    private bool _actualShowDebugInfo;


    // --- Cached Values for Optimization ---
    private Sprite lastSprite;
    private Color lastOriginalColor;
    private bool lastFlipX, lastFlipY;
    private bool lastEnabled;
    private Vector3 lastScale;
    private Vector3 lastPosition;
    private float lastParentY;

    void Awake()
    {
        // Initialize with local settings first, will be updated in Start if manager exists
        _actualReflectionOpacity = localReflectionOpacity;
        _actualReflectionTint = localReflectionTint;
        _actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
        _actualSortingOrderOffset = localSortingOrderOffset;
        _actualUseWaterMasking = localUseWaterMasking;
        _actualWaterTilemapTag = localWaterTilemapTag;
        _actualShowDebugInfo = localShowDebugInfo;

        originalRenderer = GetComponent<SpriteRenderer>();
        originalAnimator = GetComponent<Animator>();

        if (originalRenderer == null)
        {
            if (_actualShowDebugInfo) Debug.LogError($"[WaterReflection] No SpriteRenderer found on {gameObject.name}! Component disabled.", this);
            enabled = false;
            return;
        }

        if (useParentAsReference && transform.parent == null)
        {
            if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] 'Use Parent As Reference' is true on {gameObject.name}, but it has no parent. Will use self as reference.", this);
            useParentAsReference = false;
        }

        if (Application.isPlaying)
        {
            if (enableDistanceFade && _actualGradientFadeBaseMaterial == null)
            {
                 if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection Awake] '{gameObject.name}': 'Enable Distance Fade' is true, but no 'Gradient Fade Base Material' (local or global) is assigned/found. Distance fade will not use the custom shader.", this);
            }
        }

        CreateReflectionObject();

        if (_actualUseWaterMasking)
        {
            SetupWaterMaskingInteraction();
        }
    }
    
    void ResolveSettings()
    {
        if (WaterReflectionManager.Instance != null)
        {
            _actualReflectionOpacity = overrides.reflectionOpacity ? localReflectionOpacity : WaterReflectionManager.Instance.defaultReflectionOpacity;
            _actualReflectionTint = overrides.reflectionTint ? localReflectionTint : WaterReflectionManager.Instance.defaultReflectionTint;
            _actualGradientFadeBaseMaterial = overrides.gradientFadeBaseMaterial ? localGradientFadeBaseMaterial : WaterReflectionManager.Instance.defaultGradientFadeMaterial;
            _actualSortingOrderOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : WaterReflectionManager.Instance.defaultSortingOrderOffset;
            _actualUseWaterMasking = overrides.useWaterMasking ? localUseWaterMasking : WaterReflectionManager.Instance.defaultUseWaterMasking;
            _actualWaterTilemapTag = overrides.waterTilemapTag && !string.IsNullOrEmpty(localWaterTilemapTag) ? localWaterTilemapTag : WaterReflectionManager.Instance.defaultWaterTilemapTag;
            _actualShowDebugInfo = overrides.showDebugInfo ? localShowDebugInfo : WaterReflectionManager.Instance.globalShowDebugInfo;
        }
        else // Fallback if no manager in scene
        {
            _actualReflectionOpacity = localReflectionOpacity;
            _actualReflectionTint = localReflectionTint;
            _actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
            _actualSortingOrderOffset = localSortingOrderOffset;
            _actualUseWaterMasking = localUseWaterMasking;
            _actualWaterTilemapTag = localWaterTilemapTag;
            _actualShowDebugInfo = localShowDebugInfo;
            if (Application.isPlaying) Debug.LogWarning("[WaterReflection] WaterReflectionManager not found in scene. Using local settings for all reflections.", this);
        }
    }


    void Start()
    {
        ResolveSettings(); // Now resolve settings after all Awake() calls are completed
        UpdateReflectionVisuals();
        UpdateReflectionTransform();
        CacheCurrentState();
    }

    void LateUpdate()
    {
        if (originalRenderer == null || reflectionObject == null)
        {
            if (reflectionObject != null) reflectionObject.SetActive(false);
            return;
        }
        UpdateReflectionTransform();
        if (HasVisualStateChanged())
        {
            UpdateReflectionVisuals();
            CacheCurrentState();
        }
    }

    private void CreateReflectionObject()
    {
        reflectionObject = new GameObject($"{gameObject.name}_Reflection");
        reflectionObject.transform.SetParent(transform.parent, false);
        reflectionObject.transform.SetSiblingIndex(transform.GetSiblingIndex() + 1);

        reflectionRenderer = reflectionObject.AddComponent<SpriteRenderer>();
        reflectionRenderer.sortingLayerName = originalRenderer.sortingLayerName;
        reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + _actualSortingOrderOffset; // Use resolved
        reflectionRenderer.drawMode = originalRenderer.drawMode;

        if (enableDistanceFade && _actualGradientFadeBaseMaterial != null) // Use resolved
        {
            reflectionMaterialInstance = new Material(_actualGradientFadeBaseMaterial);
            reflectionRenderer.material = reflectionMaterialInstance;
            if (_actualShowDebugInfo && Application.isPlaying) Debug.Log($"[{gameObject.name}] Instantiated gradient material for reflection using '{_actualGradientFadeBaseMaterial.name}'.", this);
        }
        else
        {
            reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
            if (enableDistanceFade && _actualGradientFadeBaseMaterial == null && _actualShowDebugInfo && Application.isPlaying)
            {
                 Debug.Log($"[{gameObject.name}] Using sharedMaterial for reflection as no gradientFadeBaseMaterial (local or global) was resolved during CreateReflectionObject.", this);
            }
        }

        if (originalAnimator != null)
        {
            reflectionAnimator = reflectionObject.AddComponent<Animator>();
            reflectionAnimator.runtimeAnimatorController = originalAnimator.runtimeAnimatorController;
        }
        SortableEntity originalSortable = GetComponent<SortableEntity>();
        if (originalSortable != null)
        {
            reflectionObject.AddComponent<SortableEntity>();
        }
        if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Created reflection for {gameObject.name}", this);
    }

    private void UpdateReflectionTransform()
    {
        if (reflectionObject == null || originalRenderer == null) return;
        Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
        Vector3 originalWorldPos = transform.position;
        Vector3 reflectionWorldPos = originalWorldPos;
        float referenceYForOffset = referenceTransform.position.y;
        reflectionWorldPos.y = referenceYForOffset + yOffset - (originalWorldPos.y - referenceYForOffset);
        reflectionObject.transform.position = reflectionWorldPos;
        reflectionObject.transform.rotation = transform.rotation;
        reflectionObject.transform.localScale = transform.localScale;
        Vector3 currentLocalScale = reflectionObject.transform.localScale;
        currentLocalScale.y *= -1;
        reflectionObject.transform.localScale = currentLocalScale;
    }

    private void UpdateReflectionVisuals()
    {
        if (reflectionRenderer == null || originalRenderer == null) return;

        reflectionRenderer.sprite = originalRenderer.sprite;
        reflectionRenderer.flipX = originalRenderer.flipX;
        reflectionRenderer.flipY = originalRenderer.flipY;

        Color baseOriginalSpriteColor = originalRenderer.color;
        Color finalReflectionTintedColor = baseOriginalSpriteColor * _actualReflectionTint; // Use resolved
        float finalCombinedAlpha = baseOriginalSpriteColor.a * _actualReflectionOpacity; // Use resolved
        reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);

        if (enableDistanceFade && reflectionMaterialInstance != null)
        {
            Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
            float waterSurfaceY = referenceTransform.position.y;
            reflectionMaterialInstance.SetFloat("_FadeStart", fadeStartDistance);
            reflectionMaterialInstance.SetFloat("_FadeEnd", fadeEndDistance);
            reflectionMaterialInstance.SetFloat("_MinAlpha", minFadeAlpha);
            reflectionMaterialInstance.SetFloat("_OriginalY", waterSurfaceY);
            Color materialBaseColor = _actualReflectionTint; // Use resolved
            materialBaseColor.a = _actualReflectionOpacity * baseOriginalSpriteColor.a; // Use resolved
            reflectionMaterialInstance.SetColor("_Color", materialBaseColor);
        }
        else if (!enableDistanceFade && reflectionMaterialInstance != null)
        {
            reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
            Destroy(reflectionMaterialInstance);
            reflectionMaterialInstance = null;
        }

        reflectionRenderer.enabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;

        if (reflectionAnimator != null && originalAnimator != null)
        {
            reflectionAnimator.enabled = originalAnimator.enabled;
            if (originalAnimator.runtimeAnimatorController != null && originalAnimator.parameterCount > 0)
            {
                foreach (AnimatorControllerParameter param in originalAnimator.parameters)
                {
                    try {
                        switch (param.type)
                        {
                            case AnimatorControllerParameterType.Bool:
                                reflectionAnimator.SetBool(param.name, originalAnimator.GetBool(param.name));
                                break;
                            case AnimatorControllerParameterType.Float:
                                reflectionAnimator.SetFloat(param.name, originalAnimator.GetFloat(param.name));
                                break;
                            case AnimatorControllerParameterType.Int:
                                reflectionAnimator.SetInteger(param.name, originalAnimator.GetInteger(param.name));
                                break;
                        }
                    } catch (System.Exception e) {
                        if(_actualShowDebugInfo) Debug.LogWarning($"Failed to sync animator param '{param.name}': {e.Message}", reflectionAnimator);
                    }
                }
            }
        }
    }

    private bool HasVisualStateChanged()
    {
        if (originalRenderer == null) return false;
        bool parentYChanged = false;
        if (useParentAsReference && transform.parent != null)
        {
            parentYChanged = !Mathf.Approximately(lastParentY, transform.parent.position.y);
        }
        return lastSprite != originalRenderer.sprite ||
               !ColorsApproximatelyEqual(lastOriginalColor, originalRenderer.color) ||
               lastFlipX != originalRenderer.flipX ||
               lastFlipY != originalRenderer.flipY ||
               lastEnabled != (originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy) ||
               lastScale != transform.localScale ||
               lastPosition != transform.position ||
               parentYChanged;
    }

    private void CacheCurrentState()
    {
        if (originalRenderer == null) return;
        lastSprite = originalRenderer.sprite;
        lastOriginalColor = originalRenderer.color;
        lastFlipX = originalRenderer.flipX;
        lastFlipY = originalRenderer.flipY;
        lastEnabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;
        lastScale = transform.localScale;
        lastPosition = transform.position;
        if (useParentAsReference && transform.parent != null)
        {
            lastParentY = transform.parent.position.y;
        }
    }

    private bool ColorsApproximatelyEqual(Color c1, Color c2, float tolerance = 0.001f)
    {
        return Mathf.Abs(c1.r - c2.r) < tolerance &&
               Mathf.Abs(c1.g - c2.g) < tolerance &&
               Mathf.Abs(c1.b - c2.b) < tolerance &&
               Mathf.Abs(c1.a - c2.a) < tolerance;
    }

    private void SetupWaterMaskingInteraction()
    {
        if (!_actualUseWaterMasking || reflectionRenderer == null) return; // Use resolved
        GameObject waterTilemapGO = FindWaterTilemapByTag(); // FindWaterTilemapByTag will use resolved tag
        if (waterTilemapGO == null)
        {
            if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Water tilemap for masking not found on {gameObject.name} using tag '{_actualWaterTilemapTag}'. Masking disabled.", this);
            // _actualUseWaterMasking = false; // Don't change resolved setting here, just don't apply mask
            return;
        }
        SpriteMask maskComponent = waterTilemapGO.GetComponent<SpriteMask>();
        if (maskComponent == null)
        {
            maskComponent = waterTilemapGO.AddComponent<SpriteMask>();
            maskComponent.sprite = null;
            if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Added SpriteMask to water tilemap '{waterTilemapGO.name}' for object '{gameObject.name}'.", waterTilemapGO);
        }
        reflectionRenderer.maskInteraction = SpriteMaskInteraction.VisibleInsideMask;
        if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Reflection of '{gameObject.name}' will be masked by '{waterTilemapGO.name}'.", this);
    }

    private GameObject FindWaterTilemapByTag()
    {
        // Uses _actualWaterTilemapTag which is resolved in Awake
        if (string.IsNullOrEmpty(_actualWaterTilemapTag)) return FindWaterTilemapFallback();
        GameObject taggedWater = GameObject.FindGameObjectWithTag(_actualWaterTilemapTag);
        if (taggedWater != null && taggedWater.GetComponent<Tilemap>() != null)
        {
            if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Found water tilemap by tag '{_actualWaterTilemapTag}': {taggedWater.name} for {gameObject.name}", this);
            return taggedWater;
        }
        if (taggedWater != null && taggedWater.GetComponent<Tilemap>() == null && _actualShowDebugInfo)
        {
            Debug.LogWarning($"[WaterReflection] GameObject '{taggedWater.name}' (tag '{_actualWaterTilemapTag}') has no Tilemap component!", this);
        }
        return FindWaterTilemapFallback();
    }

    private GameObject FindWaterTilemapFallback()
    {
        if (TileInteractionManager.Instance != null)
        {
            var mappings = TileInteractionManager.Instance.tileDefinitionMappings;
            if (mappings != null)
            {
                foreach (var mapping in mappings)
                {
                    if (mapping?.tileDef != null && mapping.tilemapModule != null && mapping.tileDef.isWaterTile)
                    {
                        Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                        if (renderTilemapTransform != null && renderTilemapTransform.GetComponent<Tilemap>() != null)
                        {
                            if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Auto-detected water tilemap via TIM: {renderTilemapTransform.name} for {gameObject.name}", this);
                            return renderTilemapTransform.gameObject;
                        }
                    }
                }
            }
        }
        if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Could not auto-detect water tilemap via TileInteractionManager for {gameObject.name}.", this);
        return null;
    }

    void OnDestroy()
    {
        if (reflectionObject != null)
        {
            if (Application.isPlaying) Destroy(reflectionObject);
            else DestroyImmediate(reflectionObject);
        }
        if (reflectionMaterialInstance != null)
        {
            if (Application.isPlaying) Destroy(reflectionMaterialInstance);
            else DestroyImmediate(reflectionMaterialInstance);
        }
    }

    void OnValidate()
    {
        // In OnValidate, we don't have access to the Manager's instance easily,
        // so we'll primarily validate local settings.
        // The ResolveSettings() call in Awake will handle combining with manager settings at runtime.
        if (Application.isEditor && !Application.isPlaying)
        {
            // Check if local material is needed but missing
            bool localMaterialNeeded = enableDistanceFade && (!overrides.gradientFadeBaseMaterial || localGradientFadeBaseMaterial == null);
            bool globalMaterialMightBeUsed = enableDistanceFade && !overrides.gradientFadeBaseMaterial && localGradientFadeBaseMaterial == null;

            if (localMaterialNeeded && !globalMaterialMightBeUsed) // Warn if local override is on but local material missing
            {
                 Debug.LogWarning($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true and 'Override Gradient Material' is true, but 'Local Gradient Fade Base Material' is not assigned. Assign local material or uncheck override.", this);
            }
            else if (globalMaterialMightBeUsed) // Inform that global will be used if local isn't set
            {
                 Debug.Log($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true. If 'Local Gradient Fade Base Material' remains unassigned and override is false, the global default from WaterReflectionManager will be used in Play mode.", this);
            }


            // Basic visual update for editor preview if possible
            if (reflectionRenderer != null && originalRenderer != null)
            {
                // Determine settings as best as possible for editor preview (without manager)
                Color previewTint = overrides.reflectionTint ? localReflectionTint : Color.white; // Default to white if no manager
                float previewOpacity = overrides.reflectionOpacity ? localReflectionOpacity : 0.5f;
                int previewSortOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : -1;

                reflectionRenderer.sprite = originalRenderer.sprite;
                reflectionRenderer.flipX = originalRenderer.flipX;
                reflectionRenderer.flipY = originalRenderer.flipY;
                reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + previewSortOffset;
                Color baseOriginalSpriteColor = originalRenderer.color;
                Color finalReflectionTintedColor = baseOriginalSpriteColor * previewTint;
                float finalCombinedAlpha = baseOriginalSpriteColor.a * previewOpacity;
                reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);
                UpdateReflectionTransform(); // Keep transform updated
            }
        }
    }


    // --- Public Methods for Runtime Control (Could be removed if not needed, or kept for dynamic changes) ---
    public void SetLocalReflectionOpacity(float opacity) // Example of changing a local-only value
    {
        localReflectionOpacity = Mathf.Clamp01(opacity);
        if (overrides.reflectionOpacity) // Only re-resolve and update if this local value is being used
        {
            ResolveSettings();
            if (Application.isPlaying && originalRenderer != null) UpdateReflectionVisuals();
        }
    }
    // Add more setters if you need to programmatically change local override values and have them take effect.
}



////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\WaterReflectionManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Visuals/Managers/WaterReflectionManager.cs
using UnityEngine;

public class WaterReflectionManager : MonoBehaviour
{
    public static WaterReflectionManager Instance { get; private set; }

    [Header("Global Default Reflection Settings")]
    [Tooltip("Default material to use for reflections if 'Enable Distance Fade' is true and no specific material is assigned on the WaterReflection component. Assign your 'Custom/WaterReflectionGradient' material asset here.")]
    public Material defaultGradientFadeMaterial;

    [Tooltip("Default opacity for all reflections (0 = invisible, 1 = fully opaque). Can be overridden per instance.")]
    [Range(0f, 1f)] public float defaultReflectionOpacity = 0.5f;

    [Tooltip("Default additional tint color for all reflections. Can be overridden per instance.")]
    public Color defaultReflectionTint = Color.white;

    [Tooltip("Default sorting order offset for reflections (usually negative). Can be overridden per instance.")]
    public int defaultSortingOrderOffset = -1;

    [Header("Global Default Water Masking Settings")]
    [Tooltip("Default setting for whether to use water masking. Can be overridden per instance.")]
    public bool defaultUseWaterMasking = true;

    [Tooltip("Default tag used to identify the water tilemap. Can be overridden per instance.")]
    public string defaultWaterTilemapTag = "Water";

    [Header("Global Debug Settings")]
    [Tooltip("Enable debug logs for all WaterReflection instances that don't override this.")]
    public bool globalShowDebugInfo = false;


    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Debug.LogWarning($"[WaterReflectionManager] Duplicate instance found on {gameObject.name}. Destroying self.", gameObject);
            Destroy(gameObject);
            return;
        }
        Instance = this;

        if (defaultGradientFadeMaterial == null)
        {
            Debug.LogWarning("[WaterReflectionManager] Default Gradient Fade Material is not assigned. Distance fade may not work correctly for reflections that don't have their own material specified.", this);
        }
    }
}

