UNITY PROJECT SCRIPTS - COMPRESSED FORMAT
Compression Stats: 581,981 → 399,298 chars (31.4% reduction)
Estimated tokens saved: ~45,670

This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my Unity game project.

 When you're tasked with editing: return each changed method in full; if edits touch ≤3 methods list those blocks only, else output the entire script—always copy-paste ready.

 This file is optimized for AI/LLM token efficiency. The following compression is applied:
- Removed: excess whitespace, common using statements, XML docs, attributes
- Preserved: code structure, important comments, logic flow

IMPORTANT FOR AI: When editing/creating scripts from this reference:
1. Re-add standard Unity using statements (System, UnityEngine, etc.)
2. Format with proper indentation and spacing
3. Add back regions and documentation as needed
4. Ensure proper C# code style

Common using statements (add these back when needed):
using System;

[Unknown]
  PixelPerfectSetup (Assets\Scripts\Core/) L29
  RunManager (Assets\Scripts\Core/) L70
  SortableEntity (Assets\Scripts\Core/) L213
  UIManager (Assets\Scripts\Core/) L280
  WeatherManager (Assets\Scripts\Core/) L542
  AnimalBehavior (Assets\Scripts\Ecosystem\Animals/) L741
  AnimalController (Assets\Scripts\Ecosystem\Animals/) L925
  AnimalDefinition (Assets\Scripts\Ecosystem\Animals/) L1198
  AnimalLibrary (Assets\Scripts\Ecosystem\Animals/) L1284
  AnimalMovement (Assets\Scripts\Ecosystem\Animals/) L1293
  AnimalNeeds (Assets\Scripts\Ecosystem\Animals/) L1681
  AnimalSpawnData (Assets\Scripts\Ecosystem\Animals/) L1828
  AnimalThoughtLibrary (Assets\Scripts\Ecosystem\Animals/) L1841
  FireflyController (Assets\Scripts\Ecosystem\Effects/) L1878
  FireflyDefinition (Assets\Scripts\Ecosystem\Effects/) L2186
  FireflyManager (Assets\Scripts\Ecosystem\Effects/) L2217
  PoopController (Assets\Scripts\Ecosystem\Environment/) L2480
  ScentDefinition (Assets\Scripts\Ecosystem\Environment/) L2573
  ScentLibrary (Assets\Scripts\Ecosystem\Environment/) L2588
  ScentSource (Assets\Scripts\Ecosystem\Environment/) L2607
  DietPreferenceSimplified (Assets\Scripts\Ecosystem\Food/) L2691
  FoodItem (Assets\Scripts\Ecosystem\Food/) L2767
  FoodType (Assets\Scripts\Ecosystem\Food/) L2833
  EcosystemManager (Assets\Scripts\Ecosystem\Management/) L2846
  FaunaManager (Assets\Scripts\Ecosystem\Management/) L2875
  FloraManager (Assets\Scripts\Ecosystem\Management/) L3097
  WaveManager (Assets\Scripts\Ecosystem\Management/) L3283
  WaveSpawnEntry (Assets\Scripts\Ecosystem\Spawning/) L3573
  EnvironmentalStatusEffectSystem (Assets\Scripts\Ecosystem\Status Effects/) L3602
  IStatusEffectable (Assets\Scripts\Ecosystem\Status Effects/) L3738
  StatusEffect (Assets\Scripts\Ecosystem\Status Effects/) L3756
  StatusEffectIconUI (Assets\Scripts\Ecosystem\Status Effects/) L3794
  StatusEffectInstance (Assets\Scripts\Ecosystem\Status Effects/) L3842
  StatusEffectManager (Assets\Scripts\Ecosystem\Status Effects/) L3860
  StatusEffectUIManager (Assets\Scripts\Ecosystem\Status Effects/) L3986
  ThoughtBubbleController (Assets\Scripts\Ecosystem\UI/) L4096
  ThoughtTrigger (Assets\Scripts\Ecosystem\UI/) L4132
  NodeDefinitionAutoAdder (Assets\Scripts\Editor/) L4145
  NodeDefinitionCreator (Assets\Scripts\Editor/) L4173
  NodeDefinitionEditor (Assets\Scripts\Editor/) L4234
  NodeDefinitionLibraryEditor (Assets\Scripts\Editor/) L4279
  NodeDefinitionPostprocessor (Assets\Scripts\Editor/) L4330
  NodeEffectDrawer (Assets\Scripts\Editor/) L4364
  RadiusPatternTesterEditor (Assets\Scripts\Editor/) L4490
  TileDefinitionEditor (Assets\Scripts\Editor/) L4551
  TileInteractionManagerEditor (Assets\Scripts\Editor/) L4571
  WaveDefinitionEditor (Assets\Scripts\Editor/) L4606
  WaveManagerEditor (Assets\Scripts\Editor/) L4743
  LeafData (Assets\Scripts\PlantSystem\Data/) L4918
  NodeData (Assets\Scripts\PlantSystem\Data/) L4933
  NodeDefinition (Assets\Scripts\PlantSystem\Data/) L5021
  InitialNodeConfig (Assets\Scripts\PlantSystem\Data/) L5307
  NodeEffectData (Assets\Scripts\PlantSystem\Data/) L5330
  NodeEffectType (Assets\Scripts\PlantSystem\Data/) L5356
  NodeGraph (Assets\Scripts\PlantSystem\Data/) L5387
  SeedSpawnData (Assets\Scripts\PlantSystem\Data/) L5397
  NodeExecutor (Assets\Scripts\PlantSystem\Execution/) L5424
  OutputNodeEffect (Assets\Scripts\PlantSystem\Growth/) L5664
  PlantCell (Assets\Scripts\PlantSystem\Growth/) L5703
  PlantCellManager (Assets\Scripts\PlantSystem\Growth/) L5727
  PlantEnergySystem (Assets\Scripts\PlantSystem\Growth/) L5972
  PlantGrowth (Assets\Scripts\PlantSystem\Growth/) L6066
  PlantGrowthLogic (Assets\Scripts\PlantSystem\Growth/) L6359
  PlantNodeExecutor (Assets\Scripts\PlantSystem\Growth/) L6687
  PlantVisualManager (Assets\Scripts\PlantSystem\Growth/) L7024
  InventoryBarController (Assets\Scripts\PlantSystem\UI/) L7162
  InventoryBarItem (Assets\Scripts\PlantSystem\UI/) L7479
  InventoryColorManager (Assets\Scripts\PlantSystem\UI/) L7546
  InventoryGridController (Assets\Scripts\PlantSystem\UI/) L7617
  ItemView (Assets\Scripts\PlantSystem\UI/) L7938
  NodeCell (Assets\Scripts\PlantSystem\UI/) L8063
  NodeDraggable (Assets\Scripts\PlantSystem\UI/) L8298
  NodeEditorGridController (Assets\Scripts\PlantSystem\UI/) L8432
  OutlinePartController (Assets\Scripts\PlantSystem\Visual/) L8798
  PlantOutlineController (Assets\Scripts\PlantSystem\Visual/) L8934
  PlantShadowController (Assets\Scripts\PlantSystem\Visual/) L9243
  ShadowPartController (Assets\Scripts\PlantSystem\Visual/) L9331
  GridDebugVisualizer (Assets\Scripts\Ticks/) L9432
  GridSnapStartup (Assets\Scripts\Ticks/) L9670
  TickDebugMonitor (Assets\Scripts\Ticks/) L9736
  TooltipTrigger (Assets\Scripts\UI\Tooltips/) L9908
  ITooltipDataProvider (Assets\Scripts\UI\Tooltips/) L9977
  ColorExtensions (Assets\Scripts\UI\Utilities/) L10208
  PrefabOrigin (Assets\Scripts\UI\Utilities/) L10219
  NightColorPostProcess (Assets\Scripts\Visual\Effects/) L10248
  RuntimeCircleDrawer (Assets\Scripts\Visual\Effects/) L10344
  WaterReflection (Assets\Scripts\Visual\Effects/) L10449
  WaterReflectionManager (Assets\Scripts\Visual\Effects/) L10844
  PlantGrowthModifierManager (Assets\Scripts\WorldInteraction\Placement/) L10880
  PlantPlacementManager (Assets\Scripts\WorldInteraction\Placement/) L11044
  PlayerTileInteractor (Assets\Scripts\WorldInteraction\Placement/) L11186
  GardenerController (Assets\Scripts\WorldInteraction\Player/) L11304
  HarvestableTag (Assets\Scripts\WorldInteraction\Player/) L11514
  HarvestedItem (Assets\Scripts\WorldInteraction\Player/) L11523
  HungerUI (Assets\Scripts\WorldInteraction\Player/) L11544
  PlayerActionManager (Assets\Scripts\WorldInteraction\Player/) L11591
  PlayerHungerSystem (Assets\Scripts\WorldInteraction\Player/) L11794
  TileDefinition (Assets\Scripts\WorldInteraction\Tiles/) L11855
  TileHoverColorManager (Assets\Scripts\WorldInteraction\Tiles/) L11895
  ToolRefillRule (Assets\Scripts\WorldInteraction\Tiles/) L11919
  TileInteractionManager (Assets\Scripts\WorldInteraction\Tiles/) L11939
  TileInteractionRule (Assets\Scripts\WorldInteraction\Tiles/) L12244
  ToolDefinition (Assets\Scripts\WorldInteraction\Tools/) L12256
  ToolSwitcher (Assets\Scripts\WorldInteraction\Tools/) L12291
  ToolType (Assets\Scripts\WorldInteraction\Tools/) L12466

[WegoSystem]
  GridEntity (Assets\Scripts\Ticks/) L12477
  GridPosition (Assets\Scripts\Ticks/) L12631
  GridPositionManager (Assets\Scripts\Ticks/) L12732
  GridRadiusUtility (Assets\Scripts\Ticks/) L13088
  TickConfiguration (Assets\Scripts\Ticks/) L13232
  ITickUpdateable (Assets\Scripts\Ticks/) L13315

================================================================================
SCRIPTS
================================================================================

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\PixelPerfectSetup.cs

﻿using UnityEngine;
using UnityEngine.U2D;

pub cls PixelPerfectSetup : MonoBehaviour {
[SerializeField] int referenceResolutionX = 320; // Your base game width
[SerializeField] int referenceResolutionY = 180; // Your base game height

[SerializeField] int pixelsPerUnit = 6; // Since 1 game pixel = 6x6 real pixels

PixelPerfectCamera pixelPerfectCamera;
Camera cam;

void Awake() {
cam = GetComponent<Camera>();
pixelPerfectCamera = GetComponent<PixelPerfectCamera>();

SetupPixelPerfectCamera();
}

void SetupPixelPerfectCamera() {
pixelPerfectCamera.assetsPPU = pixelsPerUnit;
pixelPerfectCamera.refResolutionX = referenceResolutionX;
pixelPerfectCamera.refResolutionY = referenceResolutionY;
pixelPerfectCamera.upscaleRT = true;
pixelPerfectCamera.pixelSnapping = true;
pixelPerfectCamera.cropFrameX = false;
pixelPerfectCamera.cropFrameY = false;
pixelPerfectCamera.stretchFill = false;

Debug.Log($"[PixelPerfectSetup] Configured for {referenceResolutionX}x{referenceResolutionY} at {pixelsPerUnit} PPU");
}

void Start() {
float expectedCameraSize = (float)referenceResolutionY / (2f * pixelsPerUnit);
Debug.Log($"[PixelPerfectSetup] Expected camera orthographic size: {expectedCameraSize}");
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\RunManager.cs

﻿using System;
using UnityEngine.Serialization;
using WegoSystem;

pub enum RunState {
Planning,
GrowthAndThreat
}

pub enum GamePhase {
Planning,      // Players place nodes/plan strategy
Execution      // Game executes actions/waves
}

pub cls RunManager : MonoBehaviour {
pub stat RunManager Instance { get; set; }

[SerializeField] WeatherManager weatherManager;
[SerializeField] WaveManager waveManager;

[SerializeField] RunState currentState = RunState.Planning;
[SerializeField] GamePhase currentPhase = GamePhase.Planning;
[SerializeField] int currentRoundNumber = 1;
[SerializeField] int currentPhaseTicks = 0;

pub RunState CurrentState => currentState;
pub GamePhase CurrentPhase => currentPhase;
pub int CurrentRoundNumber => currentRoundNumber;
pub int CurrentPhaseTicks => currentPhaseTicks;

pub event Action<RunState> OnRunStateChanged;
pub event Action<GamePhase, GamePhase> OnPhaseChanged;
pub event Action<int> OnRoundChanged;

void Awake() {
if (Instance != null && Instance != this) {
Debug.LogWarning($"[RunManager] Another instance already exists. Destroying this one.", gameObject);
Destroy(gameObject);
return;
}
Instance = this;

SetState(RunState.Planning, true);
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(new PhaseTickHandler(this));
}
}

void SetState(RunState newState, bool force = false) {
if (currentState == newState && !force) return;

currentState = newState;
Debug.Log($"[RunManager] State changed to: {currentState}");

switch (currentState) {
case RunState.Planning:
weatherManager?.PauseCycleAtDay();
SetPhase(GamePhase.Planning);
break;

case RunState.GrowthAndThreat:
weatherManager?.ResumeCycle();
waveManager?.StartWaveForRound(currentRoundNumber);
SetPhase(GamePhase.Execution);
break;
}

OnRunStateChanged?.Invoke(currentState);
}

void SetPhase(GamePhase newPhase) {
if (currentPhase == newPhase) return;

GamePhase oldPhase = currentPhase;
currentPhase = newPhase;
currentPhaseTicks = 0;

Debug.Log($"[RunManager] Phase changed: {oldPhase} -> {newPhase}");
OnPhaseChanged?.Invoke(oldPhase, newPhase);
}

pub void StartGrowthAndThreatPhase() {
if (currentState == RunState.Planning) {
Debug.Log($"[RunManager] Starting Growth & Threat for Round {currentRoundNumber}");
SetState(RunState.GrowthAndThreat);
}
}

pub void EndPlanningPhase() {
if (currentState == RunState.Planning && currentPhase == GamePhase.Planning) {
SetPhase(GamePhase.Execution);
StartGrowthAndThreatPhase();
}
}

pub void StartNewPlanningPhase() {
Debug.Log("[RunManager] Starting new planning phase");

if (currentState != RunState.Planning) {
if (waveManager != null && waveManager.IsCurrentWaveDefeated()) {
StartNewRound();
}
else {
SetState(RunState.Planning);
}
}
}

void StartNewRound() {
currentRoundNumber++;
Debug.Log($"[RunManager] Starting new round: {currentRoundNumber}");

waveManager?.ResetForNewRound();
SetState(RunState.Planning);

OnRoundChanged?.Invoke(currentRoundNumber);
}

cls PhaseTickHandler : ITickUpdateable {
RunManager manager;

pub PhaseTickHandler(RunManager manager) {
this.manager = manager;
}

pub void OnTickUpdate(int currentTick) {
manager.currentPhaseTicks++;
}
}

pub void ForcePhase(GamePhase phase) {
if (Application.isEditor || Debug.isDebugBuild) {
SetPhase(phase);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\SortableEntity.cs

﻿using UnityEngine;

pub cls SortableEntity : MonoBehaviour {
[SerializeField] float sortingLayerYOffset = 0f;

[SerializeField] bool useParentYCoordinate = false;

pub bool debugSorting = false;

SpriteRenderer spriteRenderer;

void Awake() {
spriteRenderer = GetComponent<SpriteRenderer>();

if (spriteRenderer == null)
spriteRenderer = GetComponentInChildren<SpriteRenderer>();

if (spriteRenderer == null) {
Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
}
}

void Start() {
UpdateSortingOrder();
}

void LateUpdate() {
UpdateSortingOrder();
}

pub void UpdateSortingOrder() {
if (spriteRenderer == null) return;

float yPositionForSorting = useParentYCoordinate && transform.parent != null
? transform.parent.position.y
: transform.position.y;

int sortOrder = CalculateSortOrder(yPositionForSorting);
spriteRenderer.sortingOrder = sortOrder;

if (debugSorting) {
Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
}
}

int CalculateSortOrder(float yPosition) {
ret Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
}

pub int GetCurrentSortOrder() {
if (spriteRenderer == null) ret 0;
ret spriteRenderer.sortingOrder;
}

pub void SetSortingOrder(int order) {
if (spriteRenderer != null)
spriteRenderer.sortingOrder = order;
}

pub void SetUseParentYCoordinate(bool value) {
useParentYCoordinate = value;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\UIManager.cs

﻿using System.Collections;
using TMPro;
using WegoSystem;

pub cls UIManager : MonoBehaviour {
pub stat UIManager Instance { get; set; }

[SerializeField] GameObject planningPanel;
[SerializeField] GameObject growthAndThreatPanel;
[SerializeField] GameObject nodeEditorPanel;

[SerializeField] Button startGrowthPhaseButton;
[SerializeField] Button startNewPlanningPhaseButton;
[SerializeField] Button endPlanningPhaseButton;
[SerializeField] Button advanceTickButton;

[SerializeField] GameObject wegoControlPanel;
[SerializeField] TextMeshProUGUI currentPhaseText;
[SerializeField] TextMeshProUGUI tickCounterText;
[SerializeField] TextMeshProUGUI persistentTickCounterText;
[SerializeField] TextMeshProUGUI phaseProgressText;

RunManager runManager;
TickManager tickManager;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void Start() {
runManager = RunManager.Instance;
tickManager = TickManager.Instance;

if (runManager == null) {
Debug.LogError("[UIManager] RunManager.Instance not found! UI will not fn correctly.");
return;
}

runManager.OnRunStateChanged += HandleRunStateChanged;
runManager.OnPhaseChanged += HandlePhaseChanged;
runManager.OnRoundChanged += HandleRoundChanged;

if (tickManager != null) {
tickManager.OnTickAdvanced += HandleTickAdvanced;
}

SetupButtons();

HandleRunStateChanged(runManager.CurrentState);
UpdatePhaseDisplay();
UpdateTickDisplay();
}

void OnDestroy() {
if (runManager != null) {
runManager.OnRunStateChanged -= HandleRunStateChanged;
runManager.OnPhaseChanged -= HandlePhaseChanged;
runManager.OnRoundChanged -= HandleRoundChanged;
}

if (tickManager != null) {
tickManager.OnTickAdvanced -= HandleTickAdvanced;
}
}

void SetupButtons() {
startGrowthPhaseButton?.onClick.AddListener(OnStartGrowthPhaseClicked);
startNewPlanningPhaseButton?.onClick.AddListener(OnStartNewPlanningPhaseClicked);
endPlanningPhaseButton?.onClick.AddListener(OnEndPlanningPhaseClicked);
advanceTickButton?.onClick.AddListener(OnAdvanceTickClicked);
}

void HandleRunStateChanged(RunState newState) {
if (planningPanel != null)
planningPanel.SetActive(newState == RunState.Planning);

if (growthAndThreatPanel != null)
growthAndThreatPanel.SetActive(newState == RunState.GrowthAndThreat);

if (nodeEditorPanel != null)
nodeEditorPanel.SetActive(newState == RunState.Planning);

if (InventoryGridController.Instance != null) {
InventoryGridController.Instance.gameObject.SetActive(newState == RunState.Planning);
}

if (newState == RunState.GrowthAndThreat) {
if (InventoryBarController.Instance != null)
StartCoroutine(ShowInventoryBarDelayed());
}
else {
InventoryBarController.Instance?.HideBar();
}

UpdateButtonStates(newState);
}

void HandlePhaseChanged(GamePhase oldPhase, GamePhase newPhase) {
UpdatePhaseDisplay();
UpdateButtonStates(runManager.CurrentState);
}

void HandleRoundChanged(int newRound) {
}

void HandleTickAdvanced(int currentTick) {
UpdateTickDisplay();
UpdatePhaseProgressDisplay();
}

void UpdatePhaseDisplay() {
if (currentPhaseText != null && runManager != null) {
currentPhaseText.text = $"Phase: {runManager.CurrentPhase}";
}
}

void UpdateTickDisplay() {
if (tickManager == null) return;

string tickInfo = $"Tick: {tickManager.CurrentTick}";

if (tickCounterText != null)
tickCounterText.text = tickInfo;

if (persistentTickCounterText != null)
persistentTickCounterText.text = tickInfo;
}

void UpdatePhaseProgressDisplay() {
if (phaseProgressText != null && runManager != null) {
phaseProgressText.text = $"Phase Ticks: {runManager.CurrentPhaseTicks}";
}
}

void UpdateButtonStates(RunState state) {
bool isPlanning = (state == RunState.Planning);
bool isPlanningPhase = (runManager?.CurrentPhase == GamePhase.Planning);

if (startGrowthPhaseButton != null)
startGrowthPhaseButton.interactable = isPlanning && isPlanningPhase;

if (startNewPlanningPhaseButton != null)
startNewPlanningPhaseButton.interactable = !isPlanning;

if (endPlanningPhaseButton != null)
endPlanningPhaseButton.interactable = isPlanning && isPlanningPhase;

if (advanceTickButton != null)
advanceTickButton.interactable = !isPlanningPhase;
}

void OnStartGrowthPhaseClicked() {
AutoReturnSeedFromEditorSlot();
runManager?.StartGrowthAndThreatPhase();
}

void OnStartNewPlanningPhaseClicked() {
runManager?.StartNewPlanningPhase();
}

void OnEndPlanningPhaseClicked() {
AutoReturnSeedFromEditorSlot();
runManager?.EndPlanningPhase();
}

void OnAdvanceTickClicked() {
tickManager?.DebugAdvanceTick();
}

IEnumerator ShowInventoryBarDelayed() {
yield ret null; // Wait one frame
InventoryBarController.Instance?.ShowBar();
}

void AutoReturnSeedFromEditorSlot() {
if (NodeEditorGridController.Instance == null || InventoryGridController.Instance == null) return;

var editor = NodeEditorGridController.Instance;
var seedCell = editor.SeedSlotCell;

if (seedCell == null || !seedCell.HasItem()) return;

editor.RefreshGraphAndUpdateSeed();

ItemView seedView = seedCell.GetItemView();
NodeData seedData = seedCell.GetNodeData();
if (seedView == null || seedData == null) return;

editor.UnloadSeedFromSlot();

InventoryGridController.Instance.ReturnGeneToInventory(seedView, seedData);

seedCell.ClearNodeReference();
Debug.Log($"[UIManager] Auto-returned seed \"{seedData.nodeDisplayName}\" to inventory.");
}

pub void ShowNotification(string message, float duration = 3f) {
StartCoroutine(ShowNotificationCoroutine(message, duration));
}

IEnumerator ShowNotificationCoroutine(string message, float duration) {
GameObject notification = new GameObject("Notification");
notification.transform.SetParent(transform, false);

var canvasGroup = notification.AddComponent<CanvasGroup>();
var rectTransform = notification.AddComponent<RectTransform>();
var image = notification.AddComponent<Image>();
var text = notification.AddComponent<TextMeshProUGUI>();

rectTransform.anchorMin = new Vector2(0.5f, 0.8f);
rectTransform.anchorMax = new Vector2(0.5f, 0.8f);
rectTransform.sizeDelta = new Vector2(300, 60);

image.color = new Color(0, 0, 0, 0.8f);
text.text = message;
text.color = Color.white;
text.alignment = TextAlignmentOptions.Center;
text.fontSize = 16;

float elapsedTime = 0f;
while (elapsedTime < 0.5f) {
canvasGroup.alpha = elapsedTime / 0.5f;
elapsedTime += Time.deltaTime;
yield ret null;
}
canvasGroup.alpha = 1f;

yield ret new WaitForSeconds(duration - 1f);

elapsedTime = 0f;
while (elapsedTime < 0.5f) {
canvasGroup.alpha = 1f - (elapsedTime / 0.5f);
elapsedTime += Time.deltaTime;
yield ret null;
}

Destroy(notification);
}

void Update() {
if (Input.GetKeyDown(KeyCode.Space)) {
if (runManager?.CurrentPhase == GamePhase.Planning) {
OnEndPlanningPhaseClicked();
}
else {
Debug.Log("[UIManager] Time only advances through player actions!");
}
}

if (Input.GetKeyDown(KeyCode.R) && (Application.isEditor || Debug.isDebugBuild)) {
runManager?.ForcePhase(GamePhase.Planning);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\WeatherManager.cs

﻿using System;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using WegoSystem;

pub cls WeatherManager : MonoBehaviour, ITickUpdateable {
pub stat WeatherManager Instance { get; set; }

pub enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }

pub bool dayNightCycleEnabled = true;
pub AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);
pub float sunIntensity = 1f;

pub float fixedSunIntensity = 1f;
pub SpriteRenderer fadeSprite;
pub float minAlpha = 0f;
pub float maxAlpha = 1f;

pub bool IsPaused { get; set; } = false;

int currentPhaseTicks = 0;
int totalPhaseTicksTarget = 0;

pub CyclePhase CurrentPhase => currentPhase;
pub event Action<CyclePhase> OnPhaseChanged;

CyclePhase currentPhase = CyclePhase.Day;

pub float CurrentTotalPhaseTime => totalPhaseTicksTarget * (TickManager.Instance?.Config?.GetRealSecondsPerTick() ?? 0.5f);
pub float CurrentPhaseTimer => (totalPhaseTicksTarget - currentPhaseTicks) * (TickManager.Instance?.Config?.GetRealSecondsPerTick() ?? 0.5f);

pub float GetPhaseProgress() {
if (totalPhaseTicksTarget <= 0) ret 0f;
ret (float)currentPhaseTicks / totalPhaseTicksTarget;
}

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}

EnterPhase(CyclePhase.Day, true);
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
if (!dayNightCycleEnabled || IsPaused) return;

currentPhaseTicks++;

if (currentPhaseTicks >= totalPhaseTicksTarget) {
AdvanceToNextPhase();
}

UpdateSunIntensity();
}

void Update() {
UpdateFadeSprite();
}

void UpdateSunIntensity() {
if (TickManager.Instance?.Config != null) {
float dayProgress = TickManager.Instance.Config.GetDayProgressNormalized(TickManager.Instance.CurrentTick);

CyclePhase newPhase = currentPhase;

if (dayProgress < 0.4f) {
newPhase = CyclePhase.Day;
sunIntensity = 1f;
}
else if (dayProgress < 0.5f) {
newPhase = CyclePhase.TransitionToNight;
float transitionProgress = (dayProgress - 0.4f) / 0.1f;
sunIntensity = Mathf.Lerp(1f, 0f, transitionCurve.Evaluate(transitionProgress));
}
else if (dayProgress < 0.9f) {
newPhase = CyclePhase.Night;
sunIntensity = 0f;
}
else {
newPhase = CyclePhase.TransitionToDay;
float transitionProgress = (dayProgress - 0.9f) / 0.1f;
sunIntensity = Mathf.Lerp(0f, 1f, transitionCurve.Evaluate(transitionProgress));
}

if (newPhase != currentPhase) {
EnterPhase(newPhase, true);
}
}
}

void AdvanceToNextPhase() {
CyclePhase nextPhase = currentPhase;
switch (currentPhase) {
case CyclePhase.Day: nextPhase = CyclePhase.TransitionToNight; break;
case CyclePhase.TransitionToNight: nextPhase = CyclePhase.Night; break;
case CyclePhase.Night: nextPhase = CyclePhase.TransitionToDay; break;
case CyclePhase.TransitionToDay: nextPhase = CyclePhase.Day; break;
}
EnterPhase(nextPhase);
}

void EnterPhase(CyclePhase nextPhase, bool forceEvent = false) {
CyclePhase previousPhase = currentPhase;
currentPhase = nextPhase;

if (TickManager.Instance?.Config != null) {
var config = TickManager.Instance.Config;
switch (nextPhase) {
case CyclePhase.Day:
totalPhaseTicksTarget = config.dayPhaseTicks;
break;
case CyclePhase.Night:
totalPhaseTicksTarget = config.nightPhaseTicks;
break;
case CyclePhase.TransitionToNight:
case CyclePhase.TransitionToDay:
totalPhaseTicksTarget = config.transitionTicks;
break;
}
currentPhaseTicks = 0;
}

if (previousPhase != currentPhase || forceEvent) {
if (Debug.isDebugBuild) Debug.Log($"[WeatherManager] Phase Changed To: {currentPhase}");
OnPhaseChanged?.Invoke(currentPhase);
}
}

void UpdateFadeSprite() {
if (fadeSprite != null) {
float alpha = Mathf.Lerp(maxAlpha, minAlpha, sunIntensity);
Color c = fadeSprite.color;
c.a = alpha;
fadeSprite.color = c;
}
}

pub void PauseCycleAtDay() {
Debug.Log("[WeatherManager] PauseCycleAtDay called.");
IsPaused = true;
currentPhase = CyclePhase.Day;
currentPhaseTicks = 0;
totalPhaseTicksTarget = TickManager.Instance?.Config?.dayPhaseTicks ?? 60;
sunIntensity = 1.0f;
UpdateFadeSprite();
OnPhaseChanged?.Invoke(CyclePhase.Day);
}

pub void ResumeCycle() {
Debug.Log("[WeatherManager] ResumeCycle called.");
IsPaused = false;

currentPhaseTicks = 0;
EnterPhase(CyclePhase.Day, true);
}

pub void PauseCycle() {
Debug.Log("[WeatherManager] PauseCycle called.");
IsPaused = true;
}

pub int GetCurrentPhaseTicks() {
ret currentPhaseTicks;
}

pub int GetTotalPhaseTicksTarget() {
ret totalPhaseTicksTarget;
}

pub void ForcePhase(CyclePhase phase) {
if (Application.isEditor || Debug.isDebugBuild) {
EnterPhase(phase, true);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalBehavior.cs

﻿using UnityEngine;
using WegoSystem;

pub cls AnimalBehavior : MonoBehaviour {
[SerializeField] Transform poopSpawnPoint;
[SerializeField] List<GameObject> poopPrefabs;

AnimalController controller;
AnimalDefinition definition;

bool isEating = false;
bool isPooping = false;
bool hasPooped = true;
GameObject currentEatingTarget = null;

int eatRemainingTicks = 0;
int poopDelayTick = 0;
int currentPoopCooldownTick = 0;

pub bool IsEating => isEating;
pub bool IsPooping => isPooping;
pub bool CanAct => !isEating && !isPooping && !controller.IsDying;

pub void Initialize(AnimalController controller, AnimalDefinition definition) {
this.controller = controller;
this.definition = definition;

hasPooped = true;
poopDelayTick = 0;
currentPoopCooldownTick = 0;

Debug.Log($"[AnimalBehavior] Initialized for {controller.SpeciesName}. Poop delay range: {definition.minPoopDelayTicks}-{definition.maxPoopDelayTicks} ticks");
}

pub void OnTickUpdate(int currentTick) {
if (isEating) {
eatRemainingTicks--;
if (eatRemainingTicks <= 0) {
FinishEating();
}
}

if (poopDelayTick > 0) {
poopDelayTick--;
if (poopDelayTick == 0) {
Debug.Log($"[AnimalBehavior] {controller.SpeciesName} poop delay timer reached 0");
}
}

if (currentPoopCooldownTick > 0) {
currentPoopCooldownTick--;
}

if (!hasPooped && poopDelayTick <= 0 && currentPoopCooldownTick <= 0 && CanAct) {
Debug.Log($"[AnimalBehavior] {controller.SpeciesName} ready to poop! hasPooped={hasPooped}, delay={poopDelayTick}, cooldown={currentPoopCooldownTick}, canAct={CanAct}");
TryPoop();
}
}

pub void StartEating(GameObject food) {
if (food == null || !CanAct) return;

FoodItem foodItem = food.GetComponent<FoodItem>();
if (foodItem == null || foodItem.foodType == null || !definition.diet.CanEat(foodItem.foodType)) {
Debug.LogWarning($"[AnimalBehavior] {controller.SpeciesName} cannot eat this food!");
return;
}

controller.Movement.ClearMovementPlan();

isEating = true;
currentEatingTarget = food;
eatRemainingTicks = definition.eatDurationTicks;

if (controller.CanShowThought()) {
controller.ShowThought(ThoughtTrigger.Eating);
}

Debug.Log($"[AnimalBehavior] {controller.SpeciesName} started eating {foodItem.foodType.foodName}");
}

void FinishEating() {
isEating = false;

if (currentEatingTarget == null) {
return;
}

FoodItem foodItem = currentEatingTarget.GetComponent<FoodItem>();
if (foodItem != null) {
controller.Needs.Eat(foodItem);

PlantCell plantCell = currentEatingTarget.GetComponent<PlantCell>();
if (plantCell != null && plantCell.ParentPlantGrowth != null) {
if (Debug.isDebugBuild) {
Debug.Log($"[AnimalBehavior] Eating a plant cell. Manually reporting destruction of cell at {plantCell.GridCoord} to plant '{plantCell.ParentPlantGrowth.name}' before Destroy() is called.");
}
plantCell.ParentPlantGrowth.ReportCellDestroyed(plantCell.GridCoord);
}

Destroy(currentEatingTarget);

hasPooped = false;
poopDelayTick = Random.Range(definition.minPoopDelayTicks, definition.maxPoopDelayTicks);

Debug.Log($"[AnimalBehavior] {controller.SpeciesName} finished eating. Will poop in {poopDelayTick} ticks");
}

currentEatingTarget = null;
}

void TryPoop() {
if (!CanAct) return;

isPooping = true;
currentPoopCooldownTick = definition.poopCooldownTicks;

SpawnPoop();

hasPooped = true;
isPooping = false;

if (controller.CanShowThought()) {
controller.ShowThought(ThoughtTrigger.Pooping);
}

Debug.Log($"[AnimalBehavior] {controller.SpeciesName} pooped!");
}

void SpawnPoop() {
if (poopPrefabs == null || poopPrefabs.Count == 0) {
Debug.LogWarning($"[AnimalBehavior] No poop prefabs assigned for {controller.SpeciesName}");
return;
}

int index = Random.Range(0, poopPrefabs.Count);
GameObject prefab = poopPrefabs[index];
if (prefab == null) return;

Transform spawnTransform = poopSpawnPoint != null ? poopSpawnPoint : transform;
GameObject poopObj = Instantiate(prefab, spawnTransform.position, Quaternion.identity);

SpriteRenderer sr = poopObj.GetComponent<SpriteRenderer>();
if (sr != null) {
sr.flipX = Random.value > 0.5f;

Color c = sr.color;
float v = definition.poopColorVariation;
sr.color = new Color(
Mathf.Clamp01(c.r + Random.Range(-v, v)),
Mathf.Clamp01(c.g + Random.Range(-v, v)),
Mathf.Clamp01(c.b + Random.Range(-v, v)),
c.a
);
}

PoopController pc = poopObj.GetComponent<PoopController>();
if (pc == null) {
pc = poopObj.AddComponent<PoopController>();
}

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(poopObj);
}

Debug.Log($"[AnimalBehavior] {controller.SpeciesName} pooped at {poopObj.transform.position}");
}

pub void CancelCurrentAction() {
if (isEating) {
isEating = false;
eatRemainingTicks = 0;
currentEatingTarget = null;
}

if (isPooping) {
isPooping = false;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalController.cs

﻿// Assets/Scripts/Ecosystem/Animals/AnimalController.cs
using TMPro;
using WegoSystem;

pub cls AnimalController : MonoBehaviour, ITickUpdateable, IStatusEffectable {
[SerializeField] pub AnimalDefinition definition;

[SerializeField] GameObject thoughtBubblePrefab;
[SerializeField] Transform bubbleSpawnTransform;
[SerializeField] Animator animator;

[SerializeField] TextMeshProUGUI hpText;
[SerializeField] TextMeshProUGUI hungerText;
[SerializeField] KeyCode showStatsKey = KeyCode.LeftAlt;

AnimalMovement movement;
AnimalNeeds needs;
AnimalBehavior behavior;
GridEntity gridEntity;
SpriteRenderer spriteRenderer;
StatusEffectManager statusManager;
StatusEffectUIManager statusEffectUI;

bool isDying = false;
float deathFadeTimer = 0f;
float deathFadeDuration = 1f;
int thoughtCooldownTick = 0;

pub GridEntity GridEntity => gridEntity;
pub StatusEffectManager StatusManager => statusManager;
pub AnimalDefinition Definition => definition;
pub AnimalMovement Movement => movement;
pub AnimalNeeds Needs => needs;
pub AnimalBehavior Behavior => behavior;
pub bool IsDying => isDying;
pub string SpeciesName => definition != null ? definition.animalName : "Uninitialized";

void Awake() {
CacheComponents();
ValidateComponents();
}

void Start() {
InitializeAnimal();

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}

if (gridEntity != null) {
gridEntity.OnPositionChanged += OnGridPositionChanged;
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
if (gridEntity != null) {
gridEntity.OnPositionChanged -= OnGridPositionChanged;
}
}

void Update() {
if (!enabled) return;
if (isDying && deathFadeTimer > 0) {
deathFadeTimer -= Time.deltaTime;
UpdateDeathFade();
if (deathFadeTimer <= 0) Destroy(gameObject);
return;
}
bool showStats = Input.GetKey(showStatsKey);
SetStatsTextVisibility(showStats);
UpdateSpriteFlipping();
movement.UpdateVisuals();
}

pub void OnTickUpdate(int currentTick) {
if (!enabled || definition == null) return;
if (!isDying && needs != null && needs.CurrentHealth <= 0) {
StartDying();
return;
}
if (isDying) return;

needs.OnTickUpdate(currentTick);
behavior.OnTickUpdate(currentTick);
movement.OnTickUpdate(currentTick);
statusManager.OnTickUpdate(currentTick);

if (gridEntity != null && statusManager != null) {
gridEntity.SetSpeedMultiplier(statusManager.VisualSpeedMultiplier); // <<< RENAMED
}

if (thoughtCooldownTick > 0) thoughtCooldownTick--;
UpdateAnimations();
}

void OnGridPositionChanged(GridPosition oldPos, GridPosition newPos) {
}

pub string GetDisplayName() { ret SpeciesName; }
pub void Heal(float amount) { if (needs != null) needs.Heal(amount); }
pub void ModifyHunger(float amount) { if (needs != null) needs.ModifyHunger(amount); }

pub void TakeDamage(float amount) {
if (isDying) return;
float finalDamage = amount;
if (statusManager != null) {
finalDamage *= statusManager.DamageResistanceMultiplier;
}
needs.TakeDamage(finalDamage);
}

void CacheComponents() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) gridEntity = gameObject.AddComponent<GridEntity>();
movement = GetComponent<AnimalMovement>();
if (movement == null) movement = gameObject.AddComponent<AnimalMovement>();
needs = GetComponent<AnimalNeeds>();
if (needs == null) needs = gameObject.AddComponent<AnimalNeeds>();
behavior = GetComponent<AnimalBehavior>();
if (behavior == null) behavior = gameObject.AddComponent<AnimalBehavior>();
spriteRenderer = GetComponentInChildren<SpriteRenderer>();
statusManager = GetComponent<StatusEffectManager>();
if (statusManager == null) statusManager = gameObject.AddComponent<StatusEffectManager>();
statusEffectUI = GetComponentInChildren<StatusEffectUIManager>(true);
if (statusEffectUI == null) Debug.LogWarning($"StatusEffectUIManager not found on a child of {gameObject.name}. Icons will not display.", this);
}

void ValidateComponents() {
if (definition == null) { Debug.LogError($"[{gameObject.name}] Missing AnimalDefinition!", this); enabled = false; return; }
if (definition.diet == null) { Debug.LogError($"[{gameObject.name}] AnimalDefinition missing diet!", this); enabled = false; return; }
}

void InitializeAnimal() {
movement.Initialize(this, definition);
needs.Initialize(this, definition);
behavior.Initialize(this, definition);
statusManager.Initialize(this);
if (statusEffectUI != null) {
statusEffectUI.Initialize(statusManager);
}
if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
Debug.Log($"[AnimalController] {gameObject.name} snapped to grid position {gridEntity.Position}");
}
}

void StartDying() {
if (isDying) return;
isDying = true;

if (TickManager.Instance?.Config != null) {
deathFadeDuration = definition.deathFadeTicks / TickManager.Instance.Config.ticksPerRealSecond;
}
else {
deathFadeDuration = definition.deathFadeTicks * 0.5f;
}
deathFadeTimer = deathFadeDuration;

Debug.Log($"[AnimalController] {SpeciesName} is dying! Duration: {deathFadeDuration}s");

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
movement.StopAllMovement();
behavior.CancelCurrentAction();

if (movement != null) movement.enabled = false;
if (behavior != null) behavior.enabled = false;
if (needs != null) needs.enabled = false;
}

void UpdateDeathFade() {
if (spriteRenderer == null) return;

float fadeProgress = 1f - (deathFadeTimer / deathFadeDuration);
Color color = spriteRenderer.color;
color.a = Mathf.Lerp(1f, 0f, fadeProgress);
spriteRenderer.color = color;
}

pub void ShowThought(ThoughtTrigger trigger) {
if (!CanShowThought()) return;

thoughtCooldownTick = definition.thoughtCooldownTicks;
if (definition.thoughtLibrary == null || thoughtBubblePrefab == null) return;

string message = "";
switch (trigger) {
case ThoughtTrigger.Hungry:
message = definition.thoughtLibrary?.hungryThoughts?.Length > 0 ? definition.thoughtLibrary.hungryThoughts[Random.Range(0, definition.thoughtLibrary.hungryThoughts.Length)] : "";
break;
case ThoughtTrigger.Eating:
message = definition.thoughtLibrary?.eatingThoughts?.Length > 0 ? definition.thoughtLibrary.eatingThoughts[Random.Range(0, definition.thoughtLibrary.eatingThoughts.Length)] : "";
break;
case ThoughtTrigger.HealthLow:
message = definition.thoughtLibrary?.healthLowThoughts?.Length > 0 ? definition.thoughtLibrary.healthLowThoughts[Random.Range(0, definition.thoughtLibrary.healthLowThoughts.Length)] : "";
break;
case ThoughtTrigger.Fleeing:
message = definition.thoughtLibrary?.fleeingThoughts?.Length > 0 ? definition.thoughtLibrary.fleeingThoughts[Random.Range(0, definition.thoughtLibrary.fleeingThoughts.Length)] : "";
break;
case ThoughtTrigger.Pooping:
message = definition.thoughtLibrary?.poopingThoughts?.Length > 0 ? definition.thoughtLibrary.poopingThoughts[Random.Range(0, definition.thoughtLibrary.poopingThoughts.Length)] : "";
break;
}

if (!string.IsNullOrEmpty(message)) {
Transform spawnT = bubbleSpawnTransform != null ? bubbleSpawnTransform : transform;
GameObject bubble = Instantiate(thoughtBubblePrefab, spawnT.position, Quaternion.identity);
ThoughtBubbleController controller = bubble.GetComponent<ThoughtBubbleController>();
if (controller != null) {
controller.Initialize(message, spawnT, 3f);
}
}
}

pub bool CanShowThought() {
ret thoughtCooldownTick <= 0 && !isDying;
}

void UpdateAnimations() {
if (animator == null) return;

bool isMoving = gridEntity != null && gridEntity.IsMoving;
bool isEating = behavior != null && behavior.IsEating;

animator.SetBool("isMoving", isMoving);
animator.SetBool("isEating", isEating);
animator.SetBool("isDying", isDying);
}

void UpdateSpriteFlipping() {
if (spriteRenderer == null || movement == null) return;

Vector2 moveDirection = movement.GetLastMoveDirection();
if (Mathf.Abs(moveDirection.x) > 0.01f) {
spriteRenderer.flipX = moveDirection.x < 0;
}
}

void SetStatsTextVisibility(bool visible) {
if (hpText != null) hpText.gameObject.SetActive(visible);
if (hungerText != null) hungerText.gameObject.SetActive(visible);

if (visible) {
UpdateUI();
}
}

pub void UpdateUI() {
if (needs == null) return;

if (hpText != null) {
hpText.text = $"{Mathf.CeilToInt(needs.CurrentHealth)}/{Mathf.CeilToInt(definition.maxHealth)}";
}
if (hungerText != null) {
hungerText.text = $"{Mathf.CeilToInt(needs.CurrentHunger)}/{Mathf.CeilToInt(definition.diet.maxHunger)}";
}
}

pub void SetSeekingScreenCenter(Vector2 target, Vector2 minBounds, Vector2 maxBounds) {
movement.SetSeekingScreenCenter(target, minBounds, maxBounds);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs

﻿using System.Collections.Generic;

pub cls AnimalDefinition : ScriptableObject {
pub string animalName = "DefaultAnimal";
pub GameObject prefab;

pub float maxHealth = 10f;

pub float movementSpeed = 2f;

pub AnimalDiet diet;

pub int thinkingTickInterval = 3;

pub int searchRadiusTiles = 5;

pub int eatDistanceTiles = 1;

pub int eatDurationTicks = 3;

pub int wanderPauseTickChance = 30;

pub int minWanderMoveTicks = 2;

pub int maxWanderMoveTicks = 6;

pub int minWanderPauseTicks = 1;

pub int maxWanderPauseTicks = 4;

pub int starvationDamageTickInterval = 4;

pub float damagePerStarvationTick = 2f;

pub Color damageFlashColor = Color.red;

pub int damageFlashTicks = 1;

pub int deathFadeTicks = 3;

pub int minPoopDelayTicks = 10;

pub int maxPoopDelayTicks = 20;

pub int poopCooldownTicks = 2;

pub float poopColorVariation = 0.1f;

pub AnimalThoughtLibrary thoughtLibrary;

pub int thoughtCooldownTicks = 10;

pub List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();

pub List<ScentDefinition> repellentScentDefinitions = new List<ScentDefinition>();

void OnValidate() {
maxHealth = Mathf.Max(1f, maxHealth);
movementSpeed = Mathf.Max(0.1f, movementSpeed);

thinkingTickInterval = Mathf.Max(1, thinkingTickInterval);
searchRadiusTiles = Mathf.Max(1, searchRadiusTiles);
eatDistanceTiles = Mathf.Max(1, eatDistanceTiles);
eatDurationTicks = Mathf.Max(1, eatDurationTicks);

minWanderMoveTicks = Mathf.Max(1, minWanderMoveTicks);
maxWanderMoveTicks = Mathf.Max(minWanderMoveTicks, maxWanderMoveTicks);
minWanderPauseTicks = Mathf.Max(1, minWanderPauseTicks);
maxWanderPauseTicks = Mathf.Max(minWanderPauseTicks, maxWanderPauseTicks);

starvationDamageTickInterval = Mathf.Max(1, starvationDamageTickInterval);
damagePerStarvationTick = Mathf.Max(0.1f, damagePerStarvationTick);
deathFadeTicks = Mathf.Max(1, deathFadeTicks);
damageFlashTicks = Mathf.Max(1, damageFlashTicks);

minPoopDelayTicks = Mathf.Max(1, minPoopDelayTicks);
maxPoopDelayTicks = Mathf.Max(minPoopDelayTicks, maxPoopDelayTicks);
poopCooldownTicks = Mathf.Max(1, poopCooldownTicks);

thoughtCooldownTicks = Mathf.Max(1, thoughtCooldownTicks);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs

﻿using UnityEngine;

pub cls AnimalLibrary : ScriptableObject {
pub List<AnimalDefinition> animals;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalMovement.cs

﻿using System.Collections.Generic;
using WegoSystem;

pub cls AnimalMovement : MonoBehaviour {
[SerializeField] bool showPathfindingDebugLine = false;

AnimalController controller;
AnimalDefinition definition;
GridEntity gridEntity;
LineRenderer pathDebugLine;

List<GridPosition> currentPath = new List<GridPosition>();
int currentPathIndex = 0;
GameObject currentTargetFood = null;
bool hasPlannedAction = false;
int wanderPauseTicks = 0;
int lastThinkTick = 0;

bool isSeekingScreenCenter = false;
Vector2 screenCenterTarget;
Vector2 minBounds;
Vector2 maxBounds;

Vector2 lastMoveDirection;

pub bool HasTarget => currentTargetFood != null || hasPlannedAction;
pub GameObject CurrentTargetFood => currentTargetFood;

pub void Initialize(AnimalController controller, AnimalDefinition definition) {
this.controller = controller;
this.definition = definition;
this.gridEntity = controller.GridEntity;

SetupDebugLineRenderer();
}

pub void OnTickUpdate(int currentTick) {
if (!enabled || controller.IsDying || controller.Behavior.IsEating || controller.Behavior.IsPooping) return;

if (wanderPauseTicks > 0) {
wanderPauseTicks--;
return;
}

if (currentTick - lastThinkTick >= definition.thinkingTickInterval) {
MakeMovementDecision();
lastThinkTick = currentTick;
}

if (hasPlannedAction && !gridEntity.IsMoving) {
ExecutePlannedMovement();
}
}

pub void UpdateVisuals() {
UpdatePathDebugLine();
}

void MakeMovementDecision() {
if (gridEntity.IsMoving) return;

if (isSeekingScreenCenter) {
HandleScreenCenterSeeking();
return;
}

if (controller.Needs.IsHungry) {
PlanFoodSeeking();
}
else {
PlanWandering();
}
}

void PlanFoodSeeking() {
if (GridDebugVisualizer.Instance != null && Debug.isDebugBuild) {
GridDebugVisualizer.Instance.VisualizeAnimalSearchRadius(controller, gridEntity.Position, definition.searchRadiusTiles);
}

if (controller.CanShowThought()) {
controller.ShowThought(ThoughtTrigger.Hungry);
}

GameObject nearestFood = FindNearestFood();
if (nearestFood != null) {
SetTargetFood(nearestFood);
}
else {
PlanWandering();
}
}

GameObject FindNearestFood() {
if (definition.diet == null) ret null;

GameObject foodFromGrid = FindFoodInGrid();
if (foodFromGrid != null) ret foodFromGrid;

ret FindFoodByCollider();
}

GameObject FindFoodInGrid() {
var entitiesInRadius = GridPositionManager.Instance.GetEntitiesInRadius(
gridEntity.Position,
definition.searchRadiusTiles,
true
);

GameObject bestFood = null;
float bestScore = -1f;

foreach (var entity in entitiesInRadius) {
if (entity == null || entity.gameObject == this.gameObject) continue;

FoodItem foodItem = entity.GetComponent<FoodItem>();
if (foodItem != null && foodItem.foodType != null && definition.diet.CanEat(foodItem.foodType)) {
var pref = definition.diet.GetPreference(foodItem.foodType);
if (pref == null) continue;

GridPosition foodGroundPos = GetFoodGroundPosition(entity.gameObject);
float distance = gridEntity.Position.ManhattanDistance(foodGroundPos);

float score = pref.preferencePriority / (1f + distance);

if (score > bestScore) {
bestScore = score;
bestFood = entity.gameObject;
}
}
}

ret bestFood;
}

GameObject FindFoodByCollider() {
Vector3 worldPos = transform.position;
float tileSize = GridPositionManager.Instance.GetTilemapGrid()?.cellSize.x ?? 1f;
float searchRadius = definition.searchRadiusTiles * tileSize;

Collider2D[] colliders = Physics2D.OverlapCircleAll(worldPos, searchRadius);

GameObject bestFood = null;
float bestScore = -1f;

foreach (var collider in colliders) {
if (collider.gameObject == this.gameObject) continue;

FoodItem foodItem = collider.GetComponent<FoodItem>();
if (foodItem != null && foodItem.foodType != null && definition.diet.CanEat(foodItem.foodType)) {
var pref = definition.diet.GetPreference(foodItem.foodType);
if (pref == null) continue;

float distance = Vector3.Distance(worldPos, collider.transform.position);
float score = pref.preferencePriority / (1f + distance);

if (score > bestScore) {
bestScore = score;
bestFood = collider.gameObject;
}
}
}

ret bestFood;
}

GridPosition GetFoodGroundPosition(GameObject food) {
GridEntity foodEntity = food.GetComponent<GridEntity>();
if (foodEntity != null) {
ret foodEntity.Position;
}

Vector3 foodWorldPos = food.transform.position;
ret GridPositionManager.Instance.WorldToGrid(foodWorldPos);
}

void SetTargetFood(GameObject food) {
currentTargetFood = food;
GridPosition foodGroundPos = GetFoodGroundPosition(food);

List<GridPosition> path = GridPositionManager.Instance.GetPath(gridEntity.Position, foodGroundPos, false);
if (path != null && path.Count > 0) {
currentPath = path;
currentPathIndex = 0;
hasPlannedAction = true;
}
else {
currentTargetFood = null;
}
}

void PlanWandering() {
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(controller);
}
ClearPathDebugLine();

currentPath.Clear();
currentTargetFood = null;

if (Random.Range(0, 100) < definition.wanderPauseTickChance) {
wanderPauseTicks = Random.Range(definition.minWanderPauseTicks, definition.maxWanderPauseTicks);
hasPlannedAction = false;
return;
}

GridPosition currentPos = gridEntity.Position;
GridPosition[] directions = {
GridPosition.Up, GridPosition.Down,
GridPosition.Left, GridPosition.Right
};

for (int i = 0; i < directions.Length; i++) {
int randomIndex = Random.Range(i, directions.Length);
GridPosition temp = directions[i];
directions[i] = directions[randomIndex];
directions[randomIndex] = temp;
}

foreach (var dir in directions) {
GridPosition targetPos = currentPos + dir;
if (IsValidMove(targetPos)) {
currentPath.Clear();
currentPath.Add(targetPos);
currentPathIndex = 0;
hasPlannedAction = true;
return;
}
}

hasPlannedAction = false;
}

void ExecutePlannedMovement() {
if (!hasPlannedAction || gridEntity.IsMoving) return;

if (currentTargetFood != null) {
GridPosition foodPos = GetFoodGroundPosition(currentTargetFood);
int distance = gridEntity.Position.ManhattanDistance(foodPos);

if (distance <= definition.eatDistanceTiles) {
controller.Behavior.StartEating(currentTargetFood);
ClearMovementPlan();
return;
}
}

if (currentPath != null && currentPath.Count > 0 && currentPathIndex < currentPath.Count) {
GridPosition nextPosition = currentPath[currentPathIndex];

if (TryMoveTo(nextPosition)) {
currentPathIndex++;

if (currentPathIndex >= currentPath.Count) {
ClearMovementPlan();
}
}
else {
if (currentTargetFood != null) {
SetTargetFood(currentTargetFood); // Re-path to the same food
}
else {
ClearMovementPlan(); // Or just clear if it was a wander
}
}
}
else {
hasPlannedAction = false;
}
}

bool TryMoveTo(GridPosition targetPos) {
if (!IsValidMove(targetPos))
ret false;

Vector3 currentWorld = transform.position;
Vector3 targetWorld = GridPositionManager.Instance.GridToWorld(targetPos);
lastMoveDirection = (targetWorld - currentWorld).normalized;

gridEntity.SetPosition(targetPos);
ret true;
}

bool IsValidMove(GridPosition pos) {
if (GridPositionManager.Instance == null) ret false;

if (!GridPositionManager.Instance.IsPositionValid(pos)) ret false;

if (GridPositionManager.Instance.IsPositionOccupied(pos)) {
if (currentTargetFood != null) {
GridPosition foodPos = GetFoodGroundPosition(currentTargetFood);
if (pos == foodPos) ret true;
}
ret false;
}

ret true;
}

void HandleScreenCenterSeeking() {
Vector2 currentPos = transform.position;
bool centerWithinBounds = currentPos.x >= minBounds.x && currentPos.x <= maxBounds.x &&
currentPos.y >= minBounds.y && currentPos.y <= maxBounds.y;

if (centerWithinBounds) {
isSeekingScreenCenter = false;
hasPlannedAction = false;
}
else {
GridPosition targetGridPos = GridPositionManager.Instance.WorldToGrid(screenCenterTarget);
currentPath = GridPositionManager.Instance.GetPath(gridEntity.Position, targetGridPos, false);
currentPathIndex = 0;
hasPlannedAction = currentPath.Count > 0;
}
}

pub void SetSeekingScreenCenter(Vector2 target, Vector2 minBounds, Vector2 maxBounds) {
isSeekingScreenCenter = true;
screenCenterTarget = target;
this.minBounds = minBounds;
this.maxBounds = maxBounds;
}

pub void StopAllMovement() {
ClearMovementPlan();
wanderPauseTicks = 0;
isSeekingScreenCenter = false;
}

pub void ClearMovementPlan() {
currentPath.Clear();
currentPathIndex = 0;
currentTargetFood = null;
hasPlannedAction = false;
ClearPathDebugLine();

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(controller);
}
}

pub Vector2 GetLastMoveDirection() {
ret lastMoveDirection;
}

void SetupDebugLineRenderer() {
if (!showPathfindingDebugLine) return;

GameObject lineObj = new GameObject("PathDebugLine");
lineObj.transform.SetParent(transform);
pathDebugLine = lineObj.AddComponent<LineRenderer>();
pathDebugLine.startWidth = 0.05f;
pathDebugLine.endWidth = 0.05f;
pathDebugLine.material = new Material(Shader.Find("Sprites/Default"));
pathDebugLine.startColor = Color.yellow;
pathDebugLine.endColor = Color.red;
pathDebugLine.sortingOrder = 100;
}

void UpdatePathDebugLine() {
if (!showPathfindingDebugLine || pathDebugLine == null || currentPath == null || currentPath.Count == 0) {
if (pathDebugLine != null) pathDebugLine.positionCount = 0;
return;
}

List<Vector3> positions = new List<Vector3>();

Vector3 groundPosition = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
positions.Add(groundPosition);

for (int i = currentPathIndex; i < currentPath.Count; i++) {
Vector3 worldPos = GridPositionManager.Instance.GridToWorld(currentPath[i]);
positions.Add(worldPos);
}

pathDebugLine.positionCount = positions.Count;
pathDebugLine.SetPositions(positions.ToArray());
}

void ClearPathDebugLine() {
if (pathDebugLine != null) {
pathDebugLine.positionCount = 0;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalNeeds.cs

﻿// Assets/Scripts/Ecosystem/Animals/AnimalNeeds.cs
using WegoSystem;

pub cls AnimalNeeds : MonoBehaviour {
AnimalController controller;
AnimalDefinition definition;
AnimalDiet diet;
SpriteRenderer spriteRenderer;

float currentHealth;
float currentHunger;

int hungerTick = 0;
int starvationTick = 0;

float flashRemainingTime = 0f;
float flashDurationSeconds = 0.2f;
bool isFlashing = false;
Color originalColor;

pub float CurrentHealth => currentHealth;
pub float CurrentHunger => currentHunger;
pub bool IsHungry => currentHunger >= diet.hungerThreshold;
pub bool IsStarving => currentHunger >= diet.maxHunger;

pub void Initialize(AnimalController controller, AnimalDefinition definition) {
this.controller = controller;
this.definition = definition;
this.diet = definition.diet;

spriteRenderer = GetComponentInChildren<SpriteRenderer>();
if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}

if (TickManager.Instance?.Config != null) {
flashDurationSeconds = definition.damageFlashTicks / TickManager.Instance.Config.ticksPerRealSecond;
}

currentHealth = definition.maxHealth;
currentHunger = 0f;
}

pub void OnTickUpdate(int currentTick) {
UpdateHunger();
UpdateStarvation();
}

void UpdateHunger() {
if (TickManager.Instance?.Config == null || diet == null) return;

hungerTick++;
if (hungerTick >= TickManager.Instance.Config.animalHungerTickInterval) {
hungerTick = 0;

currentHunger += diet.hungerIncreaseRate;
currentHunger = Mathf.Min(currentHunger, diet.maxHunger);

controller.UpdateUI();
}
}

void UpdateStarvation() {
if (!IsStarving) {
starvationTick = 0;
return;
}

starvationTick++;
if (starvationTick >= definition.starvationDamageTickInterval) {
starvationTick = 0;
ApplyStarvationDamage();
}
}

void Update() {
if (!isFlashing || spriteRenderer == null) return;

flashRemainingTime -= Time.deltaTime;

if (flashRemainingTime <= 0) {
spriteRenderer.color = originalColor;
isFlashing = false;
}
else {
float t = (flashRemainingTime / flashDurationSeconds);
spriteRenderer.color = Color.Lerp(originalColor, definition.damageFlashColor, t);
}
}

pub void TakeDamage(float amount) {
currentHealth -= amount;
currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);

StartDamageFlash();
controller.UpdateUI();

if (currentHealth <= definition.maxHealth * 0.3f && controller.CanShowThought()) {
controller.ShowThought(ThoughtTrigger.HealthLow);
}
}

void ApplyStarvationDamage() {
currentHealth -= definition.damagePerStarvationTick;
currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);

StartDamageFlash();
controller.UpdateUI();

Debug.Log($"[AnimalNeeds] {controller.SpeciesName} taking starvation damage. Health: {currentHealth}");
}

pub void Eat(FoodItem foodItem) {
if (foodItem == null || foodItem.foodType == null || diet == null) return;

float satiationGain = diet.GetSatiationValue(foodItem.foodType);
currentHunger -= satiationGain;
currentHunger = Mathf.Max(0f, currentHunger);

controller.UpdateUI();

Debug.Log($"[AnimalNeeds] {controller.SpeciesName} ate {foodItem.foodType.foodName}. Hunger: {currentHunger}/{diet.maxHunger}");
}

pub void Heal(float amount) {
currentHealth += amount;
currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);
controller.UpdateUI();
}

pub void ModifyHunger(float amount) {
currentHunger += amount;
currentHunger = Mathf.Clamp(currentHunger, 0f, diet.maxHunger);
controller.UpdateUI();
}

void StartDamageFlash() {
if (spriteRenderer == null) return;

isFlashing = true;
flashRemainingTime = flashDurationSeconds;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalSpawnData.cs

﻿using UnityEngine;

pub cls AnimalSpawnData {
pub AnimalDefinition animalDefinition;
pub float spawnRateMultiplier = 1f;
pub int maximumSpawned = 0;

pub float spawnTimer = 0f;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalThoughtLibrary.cs

﻿using UnityEngine;

pub cls AnimalThoughtLibrary : ScriptableObject {
pub string[] hungryThoughts = new string[] {
"I'm hungry!",
"Need food...",
"Where's the food?"
};

pub string[] eatingThoughts = new string[] {
"Yum!",
"Delicious!",
"Nom nom nom"
};

pub string[] healthLowThoughts = new string[] {
"I don't feel good...",
"Help me!",
"Ouch!"
};

pub string[] fleeingThoughts = new string[] {
"Run away!",
"Scary!",
"Help!"
};

pub string[] poopingThoughts = new string[] {
"Nature calls!",
"Gotta go!",
"..."
};
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyController.cs

﻿using System.Collections.Generic;
using UnityEngine.Rendering.Universal;
using WegoSystem;

pub cls FireflyController : MonoBehaviour, ITickUpdateable {
[SerializeField] FireflyDefinition definition;

[SerializeField] Light2D glowLight;
[SerializeField] Light2D groundLight;
[SerializeField] SpriteRenderer spriteRenderer;
[SerializeField] TrailRenderer trailRenderer;
[SerializeField] ParticleSystem glowParticles;

[SerializeField] float groundLightRadiusMultiplier = 2.5f;

GridEntity gridEntity;

int lifetimeTicks;
int lastMovementTick = 0;

float currentLifetimeSeconds = 0f;
float maxLifetimeSeconds = 0f;

Vector3 currentTileCenter;
Vector3 localTargetPosition;
float currentLocalSpeed;

float baseGlowIntensity;
float currentGlowIntensity;
float baseGroundLightIntensity;
float baseGroundLightOuterRadius;
float glowFlickerTime;
Color originalColor;

pub bool IsAlive { get; set; } = true;
pub Transform AttractionTarget { get; set; }

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
Debug.LogError($"[FireflyController] Firefly prefab is missing the required GridEntity component!", this);
enabled = false;
return;
}

if (glowLight != null) {
baseGlowIntensity = glowLight.intensity;
currentGlowIntensity = glowLight.intensity;
}

if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}

if (groundLight != null) {
baseGroundLightIntensity = groundLight.intensity;
baseGroundLightOuterRadius = groundLight.pointLightOuterRadius;
}
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}

pub void Initialize() {
if (FireflyManager.Instance?.defaultFireflyDefinition == null || gridEntity == null) {
Debug.LogError("[FireflyController] Initialization failed: Missing definition or GridEntity!", this);
enabled = false;
return;
}

definition = FireflyManager.Instance.defaultFireflyDefinition;

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
currentTileCenter = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
}

lifetimeTicks = Random.Range(definition.minLifetimeTicks, definition.maxLifetimeTicks + 1);
currentLocalSpeed = Random.Range(definition.minLocalSpeed, definition.maxLocalSpeed);

SetRandomLocalTarget();

if (glowParticles != null) {
glowParticles.Play();
}

if (TickManager.Instance?.Config != null) {
maxLifetimeSeconds = lifetimeTicks / TickManager.Instance.Config.ticksPerRealSecond;
}
else {
maxLifetimeSeconds = lifetimeTicks * 0.5f;
}
}

pub void OnTickUpdate(int currentTick) {
if (!IsAlive) return;

currentLifetimeSeconds += Time.deltaTime;
if (currentLifetimeSeconds >= maxLifetimeSeconds) {
Die();
return;
}

if (currentTick - lastMovementTick >= definition.movementTickInterval) {
UpdateMovement();
lastMovementTick = currentTick;
}

UpdatePhotosynthesisVisualization();
}

void Update() {
if (!IsAlive) return;

UpdateLocalMovement();
UpdateGlowEffect();
UpdateGroundLight();
}

void UpdateMovement() {
FindAttractionTarget();

if (AttractionTarget != null) {
Vector3 attractionDirection = (AttractionTarget.position - currentTileCenter).normalized;
localTargetPosition = currentTileCenter + attractionDirection * Random.Range(0.1f, 0.3f);
}
else {
SetRandomLocalTarget();
}
}

void UpdatePhotosynthesisVisualization() {
if (GridDebugVisualizer.Instance != null && FireflyManager.Instance != null && gridEntity != null) {
int photosynthesisRadius = Mathf.RoundToInt(FireflyManager.Instance.photosynthesisRadius);
if (photosynthesisRadius > 0) {
GridDebugVisualizer.Instance.VisualizeFireflyPhotosynthesisRadius(this, gridEntity.Position, photosynthesisRadius);
}
}
}

void FindAttractionTarget() {
if (definition == null || gridEntity == null) return;

float bestScore = 0f;
Transform bestTarget = null;

GridPosition currentPos = gridEntity.Position;
int searchRadius = definition.tileSearchRadius;

for (int x = currentPos.x - searchRadius; x <= currentPos.x + searchRadius; x++) {
for (int y = currentPos.y - searchRadius; y <= currentPos.y + searchRadius; y++) {
GridPosition checkPos = new GridPosition(x, y);
if (!GridPositionManager.Instance.IsPositionValid(checkPos)) continue;

float distance = Vector2.Distance(currentPos.ToVector2Int(), checkPos.ToVector2Int());
if (distance > searchRadius) continue;

var entitiesAtPosition = GridPositionManager.Instance.GetEntitiesAt(checkPos);
foreach (var entity in entitiesAtPosition) {
var scentSources = entity.GetComponentsInChildren<ScentSource>();
foreach (var source in scentSources) {
if (definition.attractiveScentDefinitions.Contains(source.Definition)) {
float score = definition.scentAttractionWeight / (distance + 1f);
if (score > bestScore) {
bestScore = score;
bestTarget = entity.transform;
}
}
}

var plantGrowth = entity.GetComponent<PlantGrowth>();
if (plantGrowth != null && plantGrowth.CurrentState == PlantState.Growing) {
float score = definition.growingPlantAttraction / (distance + 1f);
if (score > bestScore) {
bestScore = score;
bestTarget = entity.transform;
}
}
}
}
}

AttractionTarget = bestTarget;
}

void SetRandomLocalTarget() {
if (definition == null) return;

Vector2 randomOffset = new Vector2(
Random.Range(-definition.flightBounds.x * 0.5f, definition.flightBounds.x * 0.5f),
Random.Range(definition.flightHeightOffset, definition.flightHeightOffset + definition.flightBounds.y)
);

localTargetPosition = currentTileCenter + (Vector3)randomOffset;
}

void UpdateLocalMovement() {
if (definition == null) return;

transform.position = Vector3.MoveTowards(transform.position, localTargetPosition, currentLocalSpeed * Time.deltaTime);

Vector3 direction = (localTargetPosition - transform.position).normalized;
if (direction.magnitude > 0.1f) {
float targetAngle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
float currentAngle = transform.eulerAngles.z;
float newAngle = Mathf.MoveTowardsAngle(currentAngle, targetAngle, definition.localMovementTurnSpeed * Time.deltaTime);
transform.rotation = Quaternion.AngleAxis(newAngle, Vector3.forward);
}
}

void UpdateGlowEffect() {
if (glowParticles == null) return;

glowFlickerTime += Time.deltaTime * definition.glowFlickerSpeed;
float flicker = Mathf.Sin(glowFlickerTime) * definition.glowFlickerAmount;
currentGlowIntensity = Mathf.Clamp01(baseGlowIntensity + flicker);

var emission = glowParticles.emission;
emission.rateOverTime = currentGlowIntensity * 10f;
}

void UpdateGroundLight() {
if (groundLight == null) return;

groundLight.transform.position = currentTileCenter;

float height = Mathf.Max(0, transform.position.y - currentTileCenter.y);
float maxFlightHeight = definition.flightBounds.y + definition.flightHeightOffset;
float heightT = (maxFlightHeight > 0) ? Mathf.Clamp01(height / maxFlightHeight) : 0f;

float heightBasedIntensity = Mathf.Lerp(baseGroundLightIntensity, baseGroundLightIntensity * 0.5f, heightT); // Dims to 50% at max height
float heightBasedRadiusMultiplier = Mathf.Lerp(1f, groundLightRadiusMultiplier, heightT); // Scales from 1x to the max multiplier
float finalRadius = baseGroundLightOuterRadius * heightBasedRadiusMultiplier;

glowFlickerTime += Time.deltaTime * definition.glowFlickerSpeed;
float flicker = Mathf.Sin(glowFlickerTime) * definition.glowFlickerAmount;

groundLight.intensity = Mathf.Clamp(heightBasedIntensity + flicker, definition.groundLightMinIntensity, 1f);
groundLight.pointLightOuterRadius = finalRadius;
}

void Die() {
IsAlive = false;

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}

if (FireflyManager.Instance != null) {
FireflyManager.Instance.ReportFireflyDespawned(this);
}

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}

if (glowParticles != null) {
glowParticles.Stop();
Destroy(gameObject, glowParticles.main.duration);
}
else {
Destroy(gameObject);
}
}

void OnDrawGizmosSelected() {
if (definition == null) return;

float tileSize = 1f;
if (Application.isPlaying && GridPositionManager.Instance?.GetTilemapGrid() != null) {
tileSize = GridPositionManager.Instance.GetTilemapGrid().cellSize.x;
}

Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
Gizmos.DrawWireSphere(transform.position, definition.tileSearchRadius * tileSize);

if (Application.isPlaying && FireflyManager.Instance != null) {
Gizmos.color = new Color(0f, 1f, 0.5f, 0.3f);
Gizmos.DrawWireSphere(transform.position, FireflyManager.Instance.photosynthesisRadius * tileSize);
}

if (Application.isPlaying) {
Vector3 flightBoxCenter = currentTileCenter + new Vector3(0, definition.flightHeightOffset + definition.flightBounds.y / 2f, 0);
Gizmos.color = new Color(0f, 1f, 1f, 0.5f);
Gizmos.DrawWireCube(flightBoxCenter, new Vector3(definition.flightBounds.x, definition.flightBounds.y, 0.1f));

Gizmos.color = Color.yellow;
Gizmos.DrawLine(transform.position, localTargetPosition);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyDefinition.cs

﻿using System.Collections.Generic;

pub cls FireflyDefinition : ScriptableObject {
pub int movementTickInterval = 5;
pub int tileSearchRadius = 3;

pub Vector2 flightBounds = new Vector2(0.4f, 0.4f);
pub float flightHeightOffset = 0.2f;
pub float localMovementTurnSpeed = 90f;
pub float minLocalSpeed = 0.5f;
pub float maxLocalSpeed = 1.0f;

pub int minLifetimeTicks = 40;
pub int maxLifetimeTicks = 90;
pub float fadeInSeconds = 1.5f;
pub float fadeOutSeconds = 2.5f;
pub float glowFlickerAmount = 0.2f;
pub float glowFlickerSpeed = 5.0f;
[Range(0f, 1f)] pub float groundLightMinIntensity = 0.1f;

pub List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();
pub float scentAttractionWeight = 2.0f;
pub float growingPlantAttraction = 1.0f;

[HideInInspector] pub bool useSpawnEffect = true;
[HideInInspector] pub int spawnEffectTicks = 3;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyManager.cs

﻿using System.Collections.Generic;
using WegoSystem;

pub cls FireflyManager : MonoBehaviour, ITickUpdateable {
pub stat FireflyManager Instance { get; set; }

[SerializeField] WeatherManager weatherManager;
[SerializeField] GameObject fireflyPrefab;
[SerializeField] pub FireflyDefinition defaultFireflyDefinition; // Made pub to fix access issue
[SerializeField] Transform fireflyParent;

[SerializeField] int maxFireflies = 50;
[SerializeField] int spawnIntervalTicks = 3;
[SerializeField] [Range(0f, 1f)] float nightThreshold = 0.25f;

[SerializeField] Vector2 spawnCenter = Vector2.zero;
[SerializeField] Vector2 spawnAreaSize = new Vector2(20f, 10f);

pub float photosynthesisRadius = 3f;
pub float photosynthesisIntensityPerFly = 0.05f;
pub float maxPhotosynthesisBonus = 0.5f;

[SerializeField] bool showAttractionLinesRuntime = false;
[SerializeField] Color attractionLineColorRuntime = Color.magenta;
[SerializeField] GameObject lineVisualizerPrefab;
[SerializeField] Transform lineContainer;

List<FireflyController> activeFireflies = new List<FireflyController>();
Dictionary<FireflyController, LineRenderer> activeLineVisualizers = new Dictionary<FireflyController, LineRenderer>();

int spawnTickCounter = 0;
bool isNight = false;

pub bool ShowAttractionLinesRuntime => showAttractionLinesRuntime;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

ValidateReferences();
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void OnDestroy() {
if (Instance == this) Instance = null;

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}

CleanupVisualizers();
}

void ValidateReferences() {
if (weatherManager == null) {
Debug.LogError($"[{nameof(FireflyManager)}] WeatherManager not assigned!", this);
enabled = false;
return;
}

if (fireflyPrefab == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab not assigned!", this);
enabled = false;
return;
}

if (defaultFireflyDefinition == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Default Firefly Definition not assigned!", this);
enabled = false;
return;
}

FireflyController controller = fireflyPrefab.GetComponent<FireflyController>();
if (controller == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing FireflyController script!", this);
enabled = false;
return;
}

if (fireflyParent == null) {
fireflyParent = transform;
}
}

pub void OnTickUpdate(int currentTick) {
isNight = weatherManager.sunIntensity <= nightThreshold;

if (isNight) {
spawnTickCounter++;
if (spawnTickCounter >= spawnIntervalTicks) {
TrySpawnFirefly();
spawnTickCounter = 0;
}
}
else {
spawnTickCounter = 0;
}

activeFireflies.RemoveAll(f => f == null || !f.IsAlive);
}

void Update() {
UpdateRuntimeLineVisualizers();
}

void TrySpawnFirefly() {
if (activeFireflies.Count >= maxFireflies) return;

GridPosition spawnGridPos = FindValidSpawnPosition();
if (spawnGridPos == GridPosition.Zero) return;

Vector3 spawnWorldPos = GridPositionManager.Instance.GridToWorld(spawnGridPos);

GameObject fireflyGO = Instantiate(fireflyPrefab, spawnWorldPos, Quaternion.identity, fireflyParent);
FireflyController controller = fireflyGO.GetComponent<FireflyController>();

if (controller != null) {
controller.Initialize();
activeFireflies.Add(controller);
}
}

GridPosition FindValidSpawnPosition() {
Vector2 minBounds = spawnCenter - spawnAreaSize * 0.5f;
Vector2 maxBounds = spawnCenter + spawnAreaSize * 0.5f;

GridPosition minGrid = GridPositionManager.Instance.WorldToGrid(minBounds);
GridPosition maxGrid = GridPositionManager.Instance.WorldToGrid(maxBounds);

for (int i = 0; i < 10; i++) // Try 10 times to find a spot {
int x = Random.Range(minGrid.x, maxGrid.x + 1);
int y = Random.Range(minGrid.y, maxGrid.y + 1);
GridPosition pos = new GridPosition(x, y);

if (GridPositionManager.Instance.IsPositionValid(pos) &&
!GridPositionManager.Instance.IsPositionOccupied(pos)) {
ret pos;
}
}

ret GridPosition.Zero; // Failed to find a spot
}

pub void ReportFireflyDespawned(FireflyController firefly) {
activeFireflies.Remove(firefly);

if (activeLineVisualizers.TryGetValue(firefly, out LineRenderer line)) {
if (line != null) Destroy(line.gameObject);
activeLineVisualizers.Remove(firefly);
}
}

pub int GetNearbyFireflyCount(Vector3 position, float radius) {
int count = 0;
float radiusSq = radius * radius;

for (int i = activeFireflies.Count - 1; i >= 0; i--) {
if (activeFireflies[i] == null) {
activeFireflies.RemoveAt(i);
continue;
}

if ((activeFireflies[i].transform.position - position).sqrMagnitude <= radiusSq) {
count++;
}
}

ret count;
}

void UpdateRuntimeLineVisualizers() {
if (!Application.isPlaying || !showAttractionLinesRuntime) {
CleanupVisualizers();
return;
}

var toRemove = new List<FireflyController>();
foreach (var kvp in activeLineVisualizers) {
if (kvp.Key == null || kvp.Value == null) {
toRemove.Add(kvp.Key);
continue;
}

Transform target = kvp.Key.AttractionTarget;
if (target != null) {
kvp.Value.enabled = true;
kvp.Value.SetPosition(0, kvp.Key.transform.position);
kvp.Value.SetPosition(1, target.position);
kvp.Value.startColor = attractionLineColorRuntime;
kvp.Value.endColor = attractionLineColorRuntime;
}
else {
kvp.Value.enabled = false;
}
}

foreach (var firefly in toRemove) {
if (activeLineVisualizers.TryGetValue(firefly, out var line) && line != null) {
Destroy(line.gameObject);
}
activeLineVisualizers.Remove(firefly);
}

if (lineVisualizerPrefab != null && lineContainer != null) {
foreach (var firefly in activeFireflies) {
if (firefly == null || activeLineVisualizers.ContainsKey(firefly)) continue;

if (firefly.AttractionTarget != null) {
GameObject lineGO = Instantiate(lineVisualizerPrefab, lineContainer);
LineRenderer newLine = lineGO.GetComponent<LineRenderer>();

if (newLine != null) {
newLine.SetPosition(0, firefly.transform.position);
newLine.SetPosition(1, firefly.AttractionTarget.position);
newLine.startColor = attractionLineColorRuntime;
newLine.endColor = attractionLineColorRuntime;
newLine.enabled = true;
activeLineVisualizers.Add(firefly, newLine);
}
else {
Debug.LogError($"Line Visualizer Prefab missing LineRenderer!", lineVisualizerPrefab);
Destroy(lineGO);
}
}
}
}
}

void CleanupVisualizers() {
foreach (var kvp in activeLineVisualizers) {
if (kvp.Value != null) {
Destroy(kvp.Value.gameObject);
}
}
activeLineVisualizers.Clear();
}

void OnDrawGizmosSelected() {
Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
Gizmos.DrawWireCube(spawnCenter, spawnAreaSize);

if (Application.isPlaying) {
Gizmos.color = new Color(0f, 1f, 0.5f, 0.2f);
foreach (var firefly in activeFireflies) {
if (firefly != null) {
Gizmos.DrawWireSphere(firefly.transform.position, photosynthesisRadius);
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\PoopController.cs

﻿using UnityEngine;
using WegoSystem;

pub cls PoopController : MonoBehaviour, ITickUpdateable {
[SerializeField] int lifetimeTicks = 20;

[SerializeField] float fadeRealTimeDuration = 1f;

GridEntity gridEntity;
SpriteRenderer spriteRenderer;
int currentLifetimeTicks;
bool isFading = false;
float fadeTimer = 0f;
Color originalColor;

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}
gridEntity.isTileOccupant = false;

spriteRenderer = GetComponent<SpriteRenderer>();
if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
}
else {
Debug.LogError($"[{gameObject.name}] GridPositionManager not found on Awake! Poop will not be registered correctly.");
}
}

void Start() {
currentLifetimeTicks = lifetimeTicks;

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}

}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

void Update() {
if (isFading && fadeTimer > 0) {
fadeTimer -= Time.deltaTime;
UpdateFade();

if (fadeTimer <= 0) {
Destroy(gameObject);
}
}
}

pub void OnTickUpdate(int currentTick) {
if (isFading) return;

currentLifetimeTicks--;

if (currentLifetimeTicks <= 0) {
StartFading();
}
}

void StartFading() {
isFading = true;
fadeTimer = fadeRealTimeDuration;

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

void UpdateFade() {
if (spriteRenderer == null) return;

float fadeProgress = 1f - (fadeTimer / fadeRealTimeDuration);
Color color = originalColor;
color.a = Mathf.Lerp(1f, 0f, fadeProgress);
spriteRenderer.color = color;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentDefinition.cs

﻿using UnityEngine;

pub cls ScentDefinition : ScriptableObject {
pub string scentID = "default_scent"; // Still useful for debugging/lookup
pub string displayName = "Default Scent";

pub float baseRadius = 1f;
pub float baseStrength = 1f;

pub GameObject particleEffectPrefab;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentLibrary.cs

﻿using UnityEngine;

pub cls ScentLibrary : ScriptableObject {
pub List<ScentDefinition> scents;

pub ScentDefinition GetScentByID(string id) {
if (string.IsNullOrEmpty(id) || scents == null) ret null;
ret scents.FirstOrDefault(s => s != null && s.scentID == id);
}

pub List<ScentDefinition> GetAllDefinitions() {
ret scents?.Where(s => s != null).ToList() ?? new List<ScentDefinition>();
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentSource.cs

﻿using UnityEngine;
using WegoSystem;

pub cls ScentSource : MonoBehaviour {
[SerializeField] ScentDefinition definition;
[SerializeField] float radiusModifier = 0f;
[SerializeField] float strengthModifier = 0f;

pub ScentDefinition Definition => definition;
pub float EffectiveRadius => definition != null ? Mathf.Max(0f, definition.baseRadius + radiusModifier) : 0f;
pub float EffectiveStrength => definition != null ? Mathf.Max(0f, definition.baseStrength + strengthModifier) : 0f;

GridEntity gridEntity;

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}
}

void Start() {
if (GetComponentInParent<PlantGrowth>() == null) {
if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
}
}
}

void Update() {
UpdateRadiusVisualization();
}

void UpdateRadiusVisualization() {
if (GridDebugVisualizer.Instance != null && definition != null && gridEntity != null) {
float effectiveRadius = EffectiveRadius;
if (effectiveRadius > 0.01f) {
int radiusTiles = Mathf.RoundToInt(effectiveRadius);
GridDebugVisualizer.Instance.VisualizeScentRadius(this, gridEntity.Position, radiusTiles);
}
else {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}
}

pub void SetDefinition(ScentDefinition newDefinition) {
definition = newDefinition;
UpdateRadiusVisualization(); // Update visualization when definition changes
}

pub void SetRadiusModifier(float modifier) {
radiusModifier = modifier;
}

pub void SetStrengthModifier(float modifier) {
strengthModifier = modifier;
}

pub void ApplyModifiers(float radiusMod, float strengthMod) {
radiusModifier += radiusMod;
strengthModifier += strengthMod;
}

void OnDestroy() {
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}

void OnDisable() {
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}

void OnEnable() {
UpdateRadiusVisualization();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\AnimalDiet.cs

﻿using System.Collections.Generic;

pub cls DietPreferenceSimplified {
pub FoodType foodType;
pub float satiationAmount = 5f;
pub float preferencePriority = 1f;
}

pub cls AnimalDiet : ScriptableObject {
pub List<DietPreferenceSimplified> acceptableFoods = new List<DietPreferenceSimplified>();

pub float maxHunger = 20f;

pub float hungerIncreaseRate = 0.5f;

pub float hungerThreshold = 10f;

pub bool CanEat(FoodType food) {
if (food == null) ret false;
ret acceptableFoods.Any(pref => pref.foodType == food);
}

pub DietPreferenceSimplified GetPreference(FoodType food) {
if (food == null) ret null;
ret acceptableFoods.FirstOrDefault(p => p.foodType == food);
}

pub float GetSatiationValue(FoodType food) {
var pref = GetPreference(food);
ret pref != null ? pref.satiationAmount : 0f;
}

pub GameObject FindBestFood(Collider2D[] nearbyColliders, Vector3 animalPosition) {
GameObject bestTarget = null;
float highestScore = -1f;

foreach (var collider in nearbyColliders) {
if (collider == null) continue;

PoopController poopController = collider.GetComponent<PoopController>();
if (poopController != null) continue;

FoodItem foodItem = collider.GetComponent<FoodItem>();
if (foodItem != null && foodItem.foodType != null && CanEat(foodItem.foodType)) {
DietPreferenceSimplified pref = GetPreference(foodItem.foodType);
if (pref == null) continue;

float distance = Vector3.Distance(animalPosition, collider.transform.position);
float score = pref.preferencePriority / (1f + distance); // Inverse distance weighting

if (score > highestScore) {
highestScore = score;
bestTarget = collider.gameObject;
}
}
}
ret bestTarget;
}

void OnValidate() {
maxHunger = Mathf.Max(1f, maxHunger);
hungerIncreaseRate = Mathf.Max(0.1f, hungerIncreaseRate);
hungerThreshold = Mathf.Clamp(hungerThreshold, 0f, maxHunger);

foreach (var pref in acceptableFoods) {
if (pref != null) {
pref.satiationAmount = Mathf.Max(0.1f, pref.satiationAmount);
pref.preferencePriority = Mathf.Max(0.1f, pref.preferencePriority);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\FoodItem.cs

﻿using UnityEngine;
using WegoSystem;

pub cls FoodItem : MonoBehaviour {
pub FoodType foodType;

bool snapToGridOnStart = true;

GridEntity gridEntity;

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}

gridEntity.isTileOccupant = false;
}

void Start() {
if (foodType == null) {
Debug.LogWarning($"FoodItem on GameObject '{gameObject.name}' is missing its FoodType reference!", gameObject);
enabled = false;
return;
}

PlantGrowth parentPlant = GetComponentInParent<PlantGrowth>();
if (parentPlant != null) {
if (gridEntity != null) {
gridEntity.enabled = false;
}
snapToGridOnStart = false;
}

if (snapToGridOnStart && GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
Debug.Log($"[FoodItem] Standalone food '{foodType.foodName}' snapped to grid position {gridEntity.Position}");
}

Collider2D col = GetComponent<Collider2D>();
if (col != null) {
col.isTrigger = true;
}
}

void OnDestroy() {
}

pub bool CanBeEatenBy(AnimalController animal) {
if (animal == null || animal.Definition == null || animal.Definition.diet == null)
ret false;

ret animal.Definition.diet.CanEat(foodType);
}

pub float GetSatiationValueFor(AnimalController animal) {
if (animal == null || animal.Definition == null || animal.Definition.diet == null)
ret 0f;

ret animal.Definition.diet.GetSatiationValue(foodType);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\FoodType.cs

﻿using UnityEngine;

pub cls FoodType : ScriptableObject {
pub string foodName = "Default Food";
pub Sprite icon;

pub enum FoodCategory { Plant_Leaf, Plant_Fruit, Plant_Stem, Plant_Seed, Other }
pub FoodCategory category = FoodCategory.Other;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\EcosystemManager.cs

﻿using UnityEngine;

pub cls EcosystemManager : MonoBehaviour {
pub stat EcosystemManager Instance { get; set; }

pub Transform animalParent;
pub Transform plantParent;

pub ScentLibrary scentLibrary; // <<< ADDED

pub bool sortAnimalsBySpecies = true;
pub bool sortPlantsBySpecies = true;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (scentLibrary == null) {
Debug.LogWarning($"[{nameof(EcosystemManager)}] Scent Library not assigned! Scent effects will not work.", this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\FaunaManager.cs

﻿using UnityEngine;

pub cls FaunaManager : MonoBehaviour {
[SerializeField] Vector2 spawnCenter = Vector2.zero;
[SerializeField] Vector2 spawnAreaSize = new Vector2(20f, 10f);

[SerializeField] Transform ecosystemParent;
[SerializeField][Min(0f)] float screenBoundsPadding = 0.5f;
[SerializeField][Min(0f)] float offscreenSpawnMargin = 2.0f;

[SerializeField] bool showBoundsGizmos = false;

[SerializeField][Range(-10f, 10f)] float boundsOffsetX = 0f;
[SerializeField][Range(-10f, 10f)] float boundsOffsetY = 0f;

List<Coroutine> activeSpawnCoroutines = new List<Coroutine>();
Camera mainCamera; // Ensure this is assigned or found

void Start() {
InitializeManager();
}

void InitializeManager() {
activeSpawnCoroutines.Clear();
if (WaveManager.Instance != null) mainCamera = WaveManager.Instance.GetMainCamera();
if (mainCamera == null) mainCamera = Camera.main;
if (mainCamera == null) Debug.LogError("[FaunaManager] Cannot find Main Camera!", this);

if (ecosystemParent == null) {
if (EcosystemManager.Instance != null && EcosystemManager.Instance.animalParent != null) {
ecosystemParent = EcosystemManager.Instance.animalParent;
Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned from EcosystemManager.animalParent.", this);
}
else {
ecosystemParent = transform;
Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned to self as fallback.", this);
}
}
}

pub void ExecuteSpawnWave(WaveDefinition waveDef) {
if (waveDef == null) { Debug.LogError("[FaunaManager] ExecuteSpawnWave called with null WaveDefinition!", this); return; }
if (waveDef.spawnEntries == null || waveDef.spawnEntries.Count == 0) { Debug.LogWarning($"[FaunaManager] Wave '{waveDef.waveName}' has no spawn entries.", this); return; }

Debug.Log($"[FaunaManager] Executing spawn for Wave: '{waveDef.waveName}'");
StopAllSpawnCoroutines(); // Ensures only one waveDef's entries are spawning at a time from this manager

foreach (WaveSpawnEntry entry in waveDef.spawnEntries) {
if (entry.animalDefinition == null) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', null AnimalDefinition for wave '{waveDef.waveName}'."); continue; }
if (entry.spawnCount <= 0) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', Spawn Count <= 0 for wave '{waveDef.waveName}'."); continue; }

if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat) {
Debug.Log($"[FaunaManager] Halting further spawn entry processing for wave '{waveDef.waveName}', RunManager not in GrowthAndThreat state.");
break; // Don't start new coroutines if not in the correct game state
}

WaveSpawnEntry currentEntry = entry; // Closure capture
Coroutine spawnCoroutine = StartCoroutine(SpawnWaveEntryCoroutine(currentEntry, waveDef.waveName));
activeSpawnCoroutines.Add(spawnCoroutine);
}
Debug.Log($"[FaunaManager] Started {activeSpawnCoroutines.Count} spawn entry coroutine(s) for '{waveDef.waveName}'.");
}

pub void StopAllSpawnCoroutines() {
if (activeSpawnCoroutines.Count > 0) {
Debug.Log($"[FaunaManager] Stopping all ({activeSpawnCoroutines.Count}) active spawn coroutines.");
foreach (Coroutine co in activeSpawnCoroutines) {
if (co != null) StopCoroutine(co);
}
activeSpawnCoroutines.Clear();
}
}

IEnumerator SpawnWaveEntryCoroutine(WaveSpawnEntry entry, string waveNameForDebug) {
if (entry.delayAfterSpawnTime > 0) {
yield ret new WaitForSeconds(entry.delayAfterSpawnTime);
}

for (int i = 0; i < entry.spawnCount; i++) {
if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat) {
Debug.Log($"[FaunaManager] Halting spawn for entry '{entry.description}' in wave '{waveNameForDebug}', RunManager no longer in GrowthAndThreat state.");
break; // Exit loop if game state changed
}

Vector2 spawnPos = CalculateSpawnPosition(entry.spawnLocationType, entry.spawnRadius);
bool isOffscreen = entry.spawnLocationType == WaveSpawnLocationType.Offscreen;
GameObject spawnedAnimal = SpawnAnimal(entry.animalDefinition, spawnPos, isOffscreen);

if (entry.spawnInterval > 0 && i < entry.spawnCount - 1) // Don't wait after the last one {
yield ret new WaitForSeconds(entry.spawnInterval);
}
}
}

Vector2 CalculateSpawnPosition(WaveSpawnLocationType locationType, float radius) {
if (mainCamera == null) { Debug.LogError("[FaunaManager] Missing Main Camera for CalculateSpawnPosition!"); ret spawnCenter; }

Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

Vector2 spawnPos = Vector2.zero;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;

switch (locationType) {
case WaveSpawnLocationType.Offscreen:
float marginMinX = effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin;
float marginMaxX = effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin;
float marginMinY = effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin;
float marginMaxY = effectiveCamPos.y + camHeight / 2f + offscreenSpawnMargin;
float extraOffset = 0.1f;
int edge = Random.Range(0, 4);
if (edge == 0) { spawnPos.x = marginMinX - extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
else if (edge == 1) { spawnPos.x = marginMaxX + extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
else if (edge == 2) { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMinY - extraOffset; }
else { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMaxY + extraOffset; }
break;

case WaveSpawnLocationType.RandomNearPlayer:
Transform playerT = FindPlayerTransform();
if (playerT != null) {
spawnPos = (Vector2)playerT.position + Random.insideUnitCircle * radius;
} else {
Debug.LogWarning("[FaunaManager] Player not found for RandomNearPlayer. Falling back to Global.");
goto case WaveSpawnLocationType.GlobalSpawnArea;
}
break;

case WaveSpawnLocationType.GlobalSpawnArea:
default:
spawnPos.x = effectiveCamPos.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
spawnPos.y = effectiveCamPos.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
break;
}
ret spawnPos;
}

Transform FindPlayerTransform() {
GameObject playerGO = GameObject.FindGameObjectWithTag("Player");
if (playerGO != null) ret playerGO.transform;

PlayerTileInteractor pti = FindAnyObjectByType<PlayerTileInteractor>();
if (pti != null) ret pti.transform;

GardenerController gc = FindAnyObjectByType<GardenerController>();
if (gc != null) ret gc.transform;

ret null;
}

GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position, bool isOffscreenSpawn) {
if (definition == null || definition.prefab == null) {
Debug.LogError("[FaunaManager] Cannot spawn animal: null definition or prefab.");
ret null;
}

if (mainCamera == null) {
Debug.LogError("[FaunaManager] Missing Main Camera for SpawnAnimal bounds calculation!");
ret null;
}

Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

Vector2 minPaddedBounds, maxPaddedBounds;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;

minPaddedBounds.x = effectiveCamPos.x - camWidth / 2f + screenBoundsPadding;
maxPaddedBounds.x = effectiveCamPos.x + camWidth / 2f - screenBoundsPadding;
minPaddedBounds.y = effectiveCamPos.y - camHeight / 2f + screenBoundsPadding;
maxPaddedBounds.y = effectiveCamPos.y + camHeight / 2f - screenBoundsPadding;

GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

if (ecosystemParent != null) {
Transform speciesParent = ecosystemParent;
if (EcosystemManager.Instance != null && EcosystemManager.Instance.sortAnimalsBySpecies && !string.IsNullOrEmpty(definition.animalName)) {
speciesParent = ecosystemParent.Find(definition.animalName);
if (speciesParent == null) {
GameObject subParentGO = new GameObject(definition.animalName);
subParentGO.transform.SetParent(ecosystemParent);
speciesParent = subParentGO.transform;
}
}
animalObj.transform.SetParent(speciesParent);
}

AnimalController controller = animalObj.GetComponent<AnimalController>();
if (controller != null) {
if (isOffscreenSpawn) {
Vector2 screenCenter = (minPaddedBounds + maxPaddedBounds) / 2f;
controller.SetSeekingScreenCenter(screenCenter, minPaddedBounds, maxPaddedBounds);
}
}
else {
Debug.LogError($"[FaunaManager] Spawned animal prefab '{definition.prefab.name}' missing AnimalController script!", animalObj);
}

ret animalObj;
}

void OnDrawGizmos() {
if (!showBoundsGizmos || mainCamera == null) return;
Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;
Vector2 paddedMin = new Vector2(effectiveCamPos.x - camWidth / 2f + screenBoundsPadding, effectiveCamPos.y - camHeight / 2f + screenBoundsPadding);
Vector2 paddedMax = new Vector2(effectiveCamPos.x + camWidth / 2f - screenBoundsPadding, effectiveCamPos.y + camHeight / 2f - screenBoundsPadding);
DrawWireRectangleGizmo(paddedMin, paddedMax, Color.green);
Vector2 marginMin = new Vector2(effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin, effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin);
Vector2 marginMax = new Vector2(effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin, effectiveCamPos.y + camHeight / 2f - offscreenSpawnMargin);
DrawWireRectangleGizmo(marginMin, marginMax, Color.red);
}

void DrawWireRectangleGizmo(Vector2 min, Vector2 max, Color color) { Gizmos.color = color; Gizmos.DrawLine(new Vector3(min.x, min.y, 0), new Vector3(max.x, min.y, 0)); Gizmos.DrawLine(new Vector3(max.x, min.y, 0), new Vector3(max.x, max.y, 0)); Gizmos.DrawLine(new Vector3(max.x, max.y, 0), new Vector3(min.x, max.y, 0)); Gizmos.DrawLine(new Vector3(min.x, max.y, 0), new Vector3(min.x, min.y, 0)); }
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\FloraManager.cs

﻿using UnityEngine;
using WegoSystem;

pub cls FloraManager : MonoBehaviour {
pub stat FloraManager Instance { get; set; }

[SerializeField] bool enableDebugLogging = false;

[SerializeField] pub float basePhotosynthesisRatePerLeaf = 0.1f;

ro HashSet<ScentSource> trackedScentSources = new HashSet<ScentSource>();
ro HashSet<PlantGrowth> trackedPlants = new HashSet<PlantGrowth>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (enableDebugLogging) {
Debug.Log($"[FloraManager] Initialized - all radius visualization controlled by GridDebugVisualizer only");
}
}

void OnDestroy() {
if (Instance == this) Instance = null;

CleanupAllVisualizations();
}

void Update() {
if (!Application.isPlaying || GridDebugVisualizer.Instance == null) return;

UpdateScentRadiusTracking();
UpdatePoopAbsorptionTracking();
}

pub float GetPlantPoopDetectionRadius(PlantGrowth plant) {
if (plant == null || plant.NodeExecutor == null) ret 0f;
ret plant.GetPoopDetectionRadius();
}

void UpdateScentRadiusTracking() {
bool shouldShow = GridDebugVisualizer.Instance.IsScentRadiusEnabled &&
GridDebugVisualizer.Instance.IsRadiusVisualizationEnabled;

if (!shouldShow) {
foreach (var source in trackedScentSources) {
if (source != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(source);
}
}
trackedScentSources.Clear();
return;
}

ScentSource[] currentSources = FindObjectsByType<ScentSource>(FindObjectsSortMode.None);
var currentSourcesSet = new HashSet<ScentSource>(currentSources);

var sourcesToRemove = new HashSet<ScentSource>();
foreach (var source in trackedScentSources) {
if (source == null || !source.enabled || !currentSourcesSet.Contains(source)) {
sourcesToRemove.Add(source);
if (source != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(source);
}
}
}

foreach (var source in sourcesToRemove) {
trackedScentSources.Remove(source);
}

foreach (ScentSource source in currentSources) {
if (source == null || !source.enabled || source.Definition == null) continue;

float radius = source.EffectiveRadius;
if (radius <= 0.01f) {
if (trackedScentSources.Contains(source)) {
GridDebugVisualizer.Instance.HideContinuousRadius(source);
trackedScentSources.Remove(source);
}
continue;
}

GridEntity gridEntity = source.GetComponent<GridEntity>();
if (gridEntity != null) {
int radiusTiles = Mathf.RoundToInt(radius);
GridDebugVisualizer.Instance.VisualizeScentRadius(source, gridEntity.Position, radiusTiles);
trackedScentSources.Add(source);
}
else if (GridPositionManager.Instance != null) {
GridPosition gridPos = GridPositionManager.Instance.WorldToGrid(source.transform.position);
int radiusTiles = Mathf.RoundToInt(radius);
GridDebugVisualizer.Instance.VisualizeScentRadius(source, gridPos, radiusTiles);
trackedScentSources.Add(source);
}
}
}

void UpdatePoopAbsorptionTracking() {
bool shouldShow = GridDebugVisualizer.Instance.IsPlantPoopRadiusEnabled &&
GridDebugVisualizer.Instance.IsRadiusVisualizationEnabled;

if (!shouldShow) {
foreach (var plant in trackedPlants) {
if (plant != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(plant);
}
}
trackedPlants.Clear();
return;
}

var currentPlantsSet = new HashSet<PlantGrowth>(PlantGrowth.AllActivePlants);

var plantsToRemove = new HashSet<PlantGrowth>();
foreach (var plant in trackedPlants) {
if (plant == null || !plant.gameObject.activeInHierarchy || !currentPlantsSet.Contains(plant)) {
plantsToRemove.Add(plant);
if (plant != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(plant);
}
}
}

foreach (var plant in plantsToRemove) {
trackedPlants.Remove(plant);
}

foreach (PlantGrowth plant in PlantGrowth.AllActivePlants) {
if (plant == null || !plant.gameObject.activeInHierarchy) continue;

float poopRadius = GetPlantPoopDetectionRadius(plant);
if (poopRadius <= 0.01f) {
if (trackedPlants.Contains(plant)) {
GridDebugVisualizer.Instance.HideContinuousRadius(plant);
trackedPlants.Remove(plant);
}
continue;
}

GridEntity gridEntity = plant.GetComponent<GridEntity>();
if (gridEntity != null) {
int radiusTiles = Mathf.RoundToInt(poopRadius);
GridDebugVisualizer.Instance.VisualizePlantPoopRadius(plant, gridEntity.Position, radiusTiles);
trackedPlants.Add(plant);
}
else if (GridPositionManager.Instance != null) {
GridPosition gridPos = GridPositionManager.Instance.WorldToGrid(plant.transform.position);
int radiusTiles = Mathf.RoundToInt(poopRadius);
GridDebugVisualizer.Instance.VisualizePlantPoopRadius(plant, gridPos, radiusTiles);
trackedPlants.Add(plant);
}
}
}

void CleanupAllVisualizations() {
if (GridDebugVisualizer.Instance == null) return;

foreach (var source in trackedScentSources) {
if (source != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(source);
}
}

foreach (var plant in trackedPlants) {
if (plant != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(plant);
}
}

trackedScentSources.Clear();
trackedPlants.Clear();
}

pub bool HasScentSourcesTracked => trackedScentSources.Count > 0;
pub bool HasPlantsTracked => trackedPlants.Count > 0;
pub int TrackedScentSourceCount => trackedScentSources.Count;
pub int TrackedPlantCount => trackedPlants.Count;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\WaveManager.cs

﻿using System.Collections;
using TMPro;
using WegoSystem;

pub enum WaveState {
Idle,           // No wave active
Active,         // Wave is currently running
Spawning        // Currently spawning enemies
}

pub cls WaveManager : MonoBehaviour {
pub stat WaveManager Instance { get; set; }

[SerializeField] Camera mainCamera;
[SerializeField] FaunaManager faunaManager;
[SerializeField] List<WaveDefinition> wavesSequence;

[SerializeField] int waveDurationInDays = 1; // Default: one wave per full day/night cycle
[SerializeField] float spawnTimeNormalized = 0.1f; // When in the wave to start spawning (0-1)
[SerializeField] bool continuousSpawning = false; // If true, spawns throughout the wave

[SerializeField] bool deletePreviousWaveAnimals = true;

[SerializeField] TextMeshProUGUI waveStatusText;
[SerializeField] TextMeshProUGUI timeTrackerText;

WaveState currentState = WaveState.Idle;
WaveDefinition currentWaveDef = null;
int currentWaveIndex = -1;

int waveStartTick = 0;
int waveEndTick = 0;
int waveSpawnTick = 0;
bool hasSpawnedThisWave = false;

Coroutine activeSpawnCoroutine = null;

pub bool IsWaveActive => currentState != WaveState.Idle;
pub bool IsCurrentWaveDefeated() => currentState == WaveState.Idle && currentWaveIndex >= 0;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

ValidateReferences();
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.OnTickAdvanced += OnTickAdvanced;
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.OnTickAdvanced -= OnTickAdvanced;
}
StopAllCoroutines();
}

void ValidateReferences() {
if (faunaManager == null) Debug.LogError("[WaveManager] FaunaManager missing!", this);
if (wavesSequence == null || wavesSequence.Count == 0)
Debug.LogWarning("[WaveManager] Wave Sequence empty. No waves will spawn.", this);
}

void OnTickAdvanced(int currentTick) {
if (currentState == WaveState.Active) {
if (currentTick >= waveEndTick) {
EndCurrentWave();
}
else if (!hasSpawnedThisWave && currentTick >= waveSpawnTick) {
StartSpawning();
}
else if (continuousSpawning && hasSpawnedThisWave) {
}
}
}

pub void StartWaveForRound(int roundNumber) {
if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat) {
Debug.LogWarning("[WaveManager] Cannot start wave - not in GrowthAndThreat state.");
return;
}

currentWaveIndex = roundNumber - 1;

if (!IsValidWaveIndex(currentWaveIndex)) {
Debug.LogWarning($"[WaveManager] No wave definition for round {roundNumber}");
currentState = WaveState.Idle;
return;
}

currentWaveDef = wavesSequence[currentWaveIndex];
if (currentWaveDef == null) {
Debug.LogError($"[WaveManager] Wave definition at index {currentWaveIndex} is null!");
currentState = WaveState.Idle;
return;
}

StartWave();
}

void StartWave() {
if (deletePreviousWaveAnimals) {
ClearAllActiveAnimals();
}

var config = TickManager.Instance?.Config;
if (config == null) {
Debug.LogError("[WaveManager] No TickConfiguration found!");
return;
}

waveStartTick = TickManager.Instance.CurrentTick;
int waveDurationTicks = config.ticksPerDay * waveDurationInDays;
waveEndTick = waveStartTick + waveDurationTicks;

waveSpawnTick = waveStartTick + Mathf.RoundToInt(waveDurationTicks * spawnTimeNormalized);

hasSpawnedThisWave = false;
currentState = WaveState.Active;

Debug.Log($"[WaveManager] Starting wave '{currentWaveDef.waveName}' " +
$"Duration: {waveDurationTicks} ticks ({waveDurationInDays} days) " +
$"Spawn at tick: {waveSpawnTick}");
}

void StartSpawning() {
if (currentWaveDef == null || faunaManager == null) return;

hasSpawnedThisWave = true;
currentState = WaveState.Spawning;

Debug.Log($"[WaveManager] Beginning spawn for wave '{currentWaveDef.waveName}'");

if (activeSpawnCoroutine != null) {
StopCoroutine(activeSpawnCoroutine);
}

activeSpawnCoroutine = StartCoroutine(ExecuteWaveSpawn());
}

IEnumerator ExecuteWaveSpawn() {
faunaManager.ExecuteSpawnWave(currentWaveDef);

yield ret new WaitForSeconds(1f);

if (currentState == WaveState.Spawning) {
currentState = WaveState.Active;
}

activeSpawnCoroutine = null;
}

void EndCurrentWave() {
Debug.Log($"[WaveManager] Ending wave '{currentWaveDef?.waveName}'");

StopCurrentWaveSpawning();
currentWaveDef = null;
currentState = WaveState.Idle;

if (RunManager.Instance != null) {
RunManager.Instance.StartNewPlanningPhase();
}
}

pub void StopCurrentWaveSpawning() {
if (activeSpawnCoroutine != null) {
StopCoroutine(activeSpawnCoroutine);
activeSpawnCoroutine = null;
}

faunaManager?.StopAllSpawnCoroutines();
}

pub void ResetForNewRound() {
Debug.Log("[WaveManager] Resetting for new round");

StopCurrentWaveSpawning();

if (deletePreviousWaveAnimals) {
ClearAllActiveAnimals();
}

currentWaveDef = null;
currentWaveIndex = -1;
currentState = WaveState.Idle;
hasSpawnedThisWave = false;
waveStartTick = 0;
waveEndTick = 0;
waveSpawnTick = 0;
}

void ClearAllActiveAnimals() {
AnimalController[] animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
int count = 0;

foreach (var animal in animals) {
if (animal != null) {
Destroy(animal.gameObject);
count++;
}
}

Debug.Log($"[WaveManager] Cleared {count} animals");
}

bool IsValidWaveIndex(int index) {
ret wavesSequence != null &&
index >= 0 &&
index < wavesSequence.Count;
}

void Update() {
UpdateUI();
}

void UpdateUI() {
UpdateTimeTracker();
UpdateWaveStatus();
}

void UpdateTimeTracker() {
if (timeTrackerText == null || TickManager.Instance == null) return;

var config = TickManager.Instance.Config;
if (config == null) return;

float dayProgress = config.GetDayProgressNormalized(TickManager.Instance.CurrentTick);
int dayNumber = TickManager.Instance.CurrentTick / config.ticksPerDay + 1;

timeTrackerText.text = $"Day {dayNumber} - {(dayProgress * 100):F0}%";

if (currentState != WaveState.Idle) {
int ticksIntoWave = TickManager.Instance.CurrentTick - waveStartTick;
int totalWaveTicks = waveEndTick - waveStartTick;
float waveProgress = totalWaveTicks > 0 ? (float)ticksIntoWave / totalWaveTicks : 0;
timeTrackerText.text += $" | Wave: {(waveProgress * 100):F0}%";
}
}

void UpdateWaveStatus() {
if (waveStatusText == null) return;

if (RunManager.Instance == null) {
waveStatusText.text = "System Offline";
return;
}

if (RunManager.Instance.CurrentState == RunState.Planning) {
waveStatusText.text = $"Prepare for Round {RunManager.Instance.CurrentRoundNumber}";
}
else if (RunManager.Instance.CurrentState == RunState.GrowthAndThreat) {
if (currentWaveDef != null) {
int ticksRemaining = Mathf.Max(0, waveEndTick - TickManager.Instance.CurrentTick);
string waveName = string.IsNullOrEmpty(currentWaveDef.waveName)
? $"Wave {currentWaveIndex + 1}"
: currentWaveDef.waveName;

string status = currentState == WaveState.Spawning ? " [SPAWNING]" : "";
waveStatusText.text = $"{waveName}{status} - {ticksRemaining} ticks left";
}
else {
waveStatusText.text = "No active wave";
}
}
}

pub Camera GetMainCamera() => mainCamera;

void Debug_ForceEndWave() {
if (Application.isEditor && currentState != WaveState.Idle) {
EndCurrentWave();
}
}

void Debug_ForceSpawn() {
if (Application.isEditor && currentState == WaveState.Active && !hasSpawnedThisWave) {
StartSpawning();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Spawning\WaveDefinition.cs

﻿using UnityEngine;

pub enum WaveSpawnLocationType {
GlobalSpawnArea,
RandomNearPlayer,
Offscreen
}

pub cls WaveSpawnEntry {
pub string description = "Spawn Group";
pub AnimalDefinition animalDefinition;
pub int spawnCount = 1;
[Tooltip("Delay (in seconds) AFTER the designated wave spawn time (e.g. Day 50%) before *this entry* begins spawning.")] // Clarified Tooltip
pub float delayAfterSpawnTime = 0f; // Renamed from delayAfterWaveStart
pub float spawnInterval = 0.5f;
pub WaveSpawnLocationType spawnLocationType = WaveSpawnLocationType.GlobalSpawnArea;
pub float spawnRadius = 5f;
}

pub cls WaveDefinition : ScriptableObject {
pub string waveName = "New Wave";

pub List<WaveSpawnEntry> spawnEntries = new List<WaveSpawnEntry>();

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\EnvironmentalStatusEffectSystem.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/EnvironmentalStatusEffectSystem.cs
using WegoSystem;

pub cls EnvironmentalStatusEffectSystem : MonoBehaviour, ITickUpdateable {
pub stat EnvironmentalStatusEffectSystem Instance { get; set; }

pub cls TileStatusRule {
pub TileDefinition tile;
pub List<StatusEffect> statusEffectsToApply;
}

pub cls ToolStatusRule {
pub ToolDefinition tool;
pub List<StatusEffect> statusEffectsToApply;
}

pub List<TileStatusRule> tileRules = new List<TileStatusRule>();

pub List<ToolStatusRule> toolRules = new List<ToolStatusRule>(); // <<< NEW

Dictionary<TileDefinition, List<StatusEffect>> tileRuleLookup = new Dictionary<TileDefinition, List<StatusEffect>>();
Dictionary<ToolDefinition, List<StatusEffect>> toolRuleLookup = new Dictionary<ToolDefinition, List<StatusEffect>>(); // <<< NEW
List<IStatusEffectable> allEffectableEntities = new List<IStatusEffectable>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
BuildLookups();
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
if (PlayerActionManager.Instance != null) {
PlayerActionManager.Instance.OnActionExecuted += HandlePlayerAction;
}
}

void OnDestroy() {
if (Instance == this) Instance = null;

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
if (PlayerActionManager.Instance != null) {
PlayerActionManager.Instance.OnActionExecuted -= HandlePlayerAction;
}
}

void BuildLookups() {
tileRuleLookup.Clear();
foreach (var rule in tileRules) {
if (rule.tile != null && rule.statusEffectsToApply != null && rule.statusEffectsToApply.Count > 0) {
tileRuleLookup[rule.tile] = rule.statusEffectsToApply;
}
}

toolRuleLookup.Clear();
foreach (var rule in toolRules) {
if (rule.tool != null && rule.statusEffectsToApply != null && rule.statusEffectsToApply.Count > 0) {
toolRuleLookup[rule.tool] = rule.statusEffectsToApply;
}
}
}

pub void OnTickUpdate(int currentTick) {
RefreshAllEntityTileEffects();
}

void HandlePlayerAction(PlayerActionType actionType, object actionData) {
if (actionType != PlayerActionType.UseTool) return;

var toolData = actionData as PlayerActionManager.ToolActionData;
if (toolData == null) return;

if (toolRuleLookup.TryGetValue(toolData.Tool, out List<StatusEffect> effectsToApply)) {
if (GridPositionManager.Instance == null) return;
GridPosition gridPos = new GridPosition(toolData.GridPosition);
HashSet<GridEntity> entitiesOnTile = GridPositionManager.Instance.GetEntitiesAt(gridPos);

foreach(var entity in entitiesOnTile) {
IStatusEffectable effectable = entity.GetComponent<IStatusEffectable>();
if (effectable != null) {
foreach(var effect in effectsToApply) {
effectable.StatusManager.ApplyStatusEffect(effect);
}
}
}
}
}

void RefreshAllEntityTileEffects() {
var animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
var players = FindObjectsByType<GardenerController>(FindObjectsSortMode.None);

allEffectableEntities.Clear();
foreach (var animal in animals) allEffectableEntities.Add(animal);
foreach (var player in players) allEffectableEntities.Add(player);

foreach(var entity in allEffectableEntities) {
CheckAndApplyTileEffects(entity);
}
}

pub void CheckAndApplyTileEffects(IStatusEffectable entity) {
if (entity == null || TileInteractionManager.Instance == null) return;

Component entityComponent = entity as Component;
if (entityComponent == null || !entityComponent.gameObject.activeInHierarchy) return;

GridPosition currentPos = entity.GridEntity.Position;
TileDefinition currentTile = TileInteractionManager.Instance.FindWhichTileDefinitionAt(currentPos.ToVector3Int());

if (currentTile == null) return;

if (tileRuleLookup.TryGetValue(currentTile, out List<StatusEffect> effectsToApply)) {
foreach (var effect in effectsToApply) {
if (effect != null) {
entity.StatusManager.ApplyStatusEffect(effect);
}
}
}
}

void OnValidate() {
BuildLookups();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\IStatusEffectable.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/IStatusEffectable.cs
using WegoSystem; // For GridEntity

pub ifc IStatusEffectable {
GridEntity GridEntity { get; }

StatusEffectManager StatusManager { get; }

string GetDisplayName();

void TakeDamage(float amount);
void Heal(float amount);
void ModifyHunger(float amount); // Can be left empty for player
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffect.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffect.cs

pub cls StatusEffect : ScriptableObject {
pub string effectID = "status_effect";
pub string displayName = "Status Effect";
pub Sprite icon;
pub string unicodeSymbol = "?";
pub Color effectColor = Color.white;

pub bool isPermanent = false;
pub int durationTicks = 10;

pub bool modifyAnimalColor = false;
pub Color animalTintColor = Color.white;
pub GameObject visualEffectPrefab;

pub bool damagePerTick = false;
pub float damageAmount = 0f;

pub bool healPerTick = false;
pub float healAmount = 0f;

pub bool modifyHunger = false;
pub float hungerModifier = 0f;

pub float visualSpeedMultiplier = 1f; // <<< RENAMED

pub float damageResistanceMultiplier = 1f;

pub int additionalMoveTicks = 0;

pub bool canStack = false;
pub int maxStacks = 1;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectIconUI.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffectIconUI.cs
using TMPro;

pub cls StatusEffectIconUI : MonoBehaviour {
Image iconImage;
TextMeshProUGUI iconText;
StatusEffect currentEffect;

pub void Initialize(StatusEffectInstance instance) {
currentEffect = instance.effect;

Transform iconTransform = transform.Find("Icon");
if (iconTransform != null) {
iconTransform.gameObject.SetActive(true);

iconImage = iconTransform.GetComponent<Image>();
iconText = iconTransform.GetComponentInChildren<TextMeshProUGUI>();

if (currentEffect.icon != null) {
if (iconImage != null) {
iconImage.sprite = currentEffect.icon;
iconImage.color = currentEffect.effectColor;
iconImage.enabled = true;
}
if (iconText != null) {
iconText.enabled = false;
}
}
else {
if (iconImage != null) {
iconImage.enabled = false;
}
if (iconText != null) {
iconText.text = currentEffect.unicodeSymbol;
iconText.color = currentEffect.effectColor;
iconText.enabled = true;
}
}
}
else {
Debug.LogError("Could not find child GameObject named 'Icon' in the StatusEffectIcon prefab!", this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectInstance.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffectInstance.cs

pub cls StatusEffectInstance {
pub StatusEffect effect;
pub int remainingTicks;
pub int stackCount = 1;
pub GameObject visualEffectInstance;

pub StatusEffectInstance(StatusEffect effect) {
this.effect = effect;
this.remainingTicks = effect.durationTicks;
this.stackCount = 1;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectManager.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffectManager.cs

pub cls StatusEffectManager : MonoBehaviour {
IStatusEffectable owner;
List<StatusEffectInstance> activeEffects = new List<StatusEffectInstance>();
Dictionary<string, StatusEffectInstance> effectLookup = new Dictionary<string, StatusEffectInstance>();

float cachedVisualSpeedMultiplier = 1f; // <<< RENAMED
float cachedDamageResistanceMultiplier = 1f;
int cachedAdditionalMoveTicks = 0;
Color originalColor;
SpriteRenderer spriteRenderer;

pub float VisualSpeedMultiplier => cachedVisualSpeedMultiplier; // <<< RENAMED
pub float DamageResistanceMultiplier => cachedDamageResistanceMultiplier;
pub int AdditionalMoveTicks => cachedAdditionalMoveTicks;

pub void Initialize(IStatusEffectable owner) {
this.owner = owner;

Component ownerComponent = owner as Component;
if (ownerComponent != null) {
spriteRenderer = ownerComponent.GetComponentInChildren<SpriteRenderer>();
if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}
}
}

pub void OnTickUpdate(int currentTick) {
if (owner == null || (owner as Component) == null) {
Destroy(this);
return;
}

ProcessStatusEffects();
UpdateCachedModifiers();
UpdateVisualEffects();
}

pub void ApplyStatusEffect(StatusEffect effect) {
if (effect == null) return;

if (effectLookup.ContainsKey(effect.effectID)) {
var existing = effectLookup[effect.effectID];
if (effect.canStack && existing.stackCount < effect.maxStacks) {
existing.stackCount++;
existing.remainingTicks = effect.durationTicks;
}
else if (!effect.canStack) {
existing.remainingTicks = effect.durationTicks;
}
}
else {
var instance = new StatusEffectInstance(effect);
activeEffects.Add(instance);
effectLookup[effect.effectID] = instance;

if (effect.visualEffectPrefab != null) {
instance.visualEffectInstance = Instantiate(
effect.visualEffectPrefab,
(owner as Component).transform.position,
Quaternion.identity,
(owner as Component).transform
);
}
Debug.Log($"[StatusEffect] Applied {effect.displayName} to {owner.GetDisplayName()}");
}

UpdateCachedModifiers();
}

pub void RemoveStatusEffect(string effectID) {
if (!effectLookup.ContainsKey(effectID)) return;
var instance = effectLookup[effectID];
if (instance.visualEffectInstance != null) {
Destroy(instance.visualEffectInstance);
}
activeEffects.Remove(instance);
effectLookup.Remove(effectID);
Debug.Log($"[StatusEffect] Removed {instance.effect.displayName} from {owner.GetDisplayName()}");
UpdateCachedModifiers();
}

void ProcessStatusEffects() {
for (int i = activeEffects.Count - 1; i >= 0; i--) {
var instance = activeEffects[i];
var effect = instance.effect;

if (effect.damagePerTick) owner.TakeDamage(effect.damageAmount * instance.stackCount);
if (effect.healPerTick) owner.Heal(effect.healAmount * instance.stackCount);
if (effect.modifyHunger) owner.ModifyHunger(effect.hungerModifier * instance.stackCount);

if (!effect.isPermanent) {
instance.remainingTicks--;
if (instance.remainingTicks <= 0) {
RemoveStatusEffect(effect.effectID);
}
}
}
}

void UpdateCachedModifiers() {
cachedVisualSpeedMultiplier = 1f; // <<< RENAMED
cachedDamageResistanceMultiplier = 1f;
cachedAdditionalMoveTicks = 0;

foreach (var instance in activeEffects) {
var effect = instance.effect;
cachedVisualSpeedMultiplier *= effect.visualSpeedMultiplier; // <<< RENAMED
cachedDamageResistanceMultiplier *= effect.damageResistanceMultiplier;
cachedAdditionalMoveTicks += effect.additionalMoveTicks * instance.stackCount;
}
}

pub bool HasStatusEffect(string effectID) { ret effectLookup.ContainsKey(effectID); }
void UpdateVisualEffects() { if(spriteRenderer==null)return;Color targetColor=originalColor;bool hasColorEffect=false;foreach(var instance in activeEffects){if(instance.effect.modifyAnimalColor){targetColor=instance.effect.animalTintColor;hasColorEffect=true;break;}}
spriteRenderer.color=hasColorEffect?targetColor:originalColor;}
pub List<StatusEffectInstance> GetActiveEffects() { ret new List<StatusEffectInstance>(activeEffects); }
pub void ClearAllEffects() { for(int i=activeEffects.Count-1;i>=0;i--){RemoveStatusEffect(activeEffects[i].effect.effectID);}}
void OnDestroy() { foreach(var instance in activeEffects){if(instance.visualEffectInstance!=null){Destroy(instance.visualEffectInstance);}}}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectUIManager.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffectUIManager.cs
using TMPro;

pub cls StatusEffectUIManager : MonoBehaviour {
[SerializeField] Transform effectIconContainer; // Set this in prefab
[SerializeField] GameObject effectIconPrefab; // Simple UI icon prefab

StatusEffectManager statusManager;
Dictionary<string, StatusEffectIconUI> activeIcons = new Dictionary<string, StatusEffectIconUI>();

pub void Initialize(StatusEffectManager manager) {
statusManager = manager;

if (effectIconPrefab == null) {
CreateDefaultIconPrefab();
}
}

void Update() {
if (statusManager == null || effectIconContainer == null) return;

UpdateStatusIcons();
}

void UpdateStatusIcons() {
var currentEffectInstances = statusManager.GetActiveEffects();
var currentEffectIDs = currentEffectInstances.Select(e => e.effect.effectID).ToList();
var displayedIconIDs = activeIcons.Keys.ToList();

foreach (var id in displayedIconIDs) {
if (!currentEffectIDs.Contains(id)) {
if (activeIcons.TryGetValue(id, out StatusEffectIconUI iconToDestroy)) {
if (iconToDestroy != null) Destroy(iconToDestroy.gameObject);
}
activeIcons.Remove(id);
}
}

foreach (var instance in currentEffectInstances) {
if (!activeIcons.ContainsKey(instance.effect.effectID)) {
CreateEffectIcon(instance);
}
}

for (int i = 0; i < currentEffectInstances.Count; i++) {
string effectID = currentEffectInstances[i].effect.effectID;
if (activeIcons.TryGetValue(effectID, out StatusEffectIconUI iconUI)) {
iconUI.transform.SetSiblingIndex(i);
}
}
}

void CreateEffectIcon(StatusEffectInstance instance) {
if (effectIconPrefab == null) {
Debug.LogError("Effect Icon Prefab is missing!", this);
return;
}

GameObject iconObj = Instantiate(effectIconPrefab, effectIconContainer);
iconObj.SetActive(true);
StatusEffectIconUI iconUI = iconObj.GetComponent<StatusEffectIconUI>();

if (iconUI == null) iconUI = iconObj.AddComponent<StatusEffectIconUI>();

iconUI.Initialize(instance);
activeIcons[instance.effect.effectID] = iconUI;
}

void CreateDefaultIconPrefab() {
float iconSize = 0.32f; // e.g., 0.32 world units
float iconPadding = 0.04f;
float fontSize = 0.2f;

GameObject prefab = new GameObject("StatusEffectIcon");
prefab.AddComponent<RectTransform>().sizeDelta = new Vector2(iconSize, iconSize);
prefab.AddComponent<LayoutElement>();

GameObject bg = new GameObject("Background");
bg.transform.SetParent(prefab.transform, false);
Image bgImage = bg.AddComponent<Image>();
bgImage.color = new Color(0, 0, 0, 0.5f);
bg.GetComponent<RectTransform>().sizeDelta = new Vector2(iconSize, iconSize);

GameObject icon = new GameObject("Icon");
icon.transform.SetParent(prefab.transform, false);
Image iconImage = icon.AddComponent<Image>();
iconImage.enabled = false;
icon.GetComponent<RectTransform>().sizeDelta = new Vector2(iconSize - iconPadding, iconSize - iconPadding);

GameObject unicodeTextGO = new GameObject("UnicodeText");
unicodeTextGO.transform.SetParent(icon.transform, false);
TextMeshProUGUI tmpText = unicodeTextGO.AddComponent<TextMeshProUGUI>();
tmpText.text = "?";
tmpText.fontSize = fontSize; // Use the smaller font size
tmpText.alignment = TextAlignmentOptions.Center;
tmpText.enabled = false;
RectTransform textRect = tmpText.GetComponent<RectTransform>();
textRect.anchorMin = Vector2.zero;
textRect.anchorMax = Vector2.one;
textRect.sizeDelta = Vector2.zero;
textRect.anchoredPosition = Vector2.zero;

effectIconPrefab = prefab;
effectIconPrefab.SetActive(false);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\UI\ThoughtBubbleController.cs

﻿using UnityEngine;
using TMPro;
using WegoSystem;

pub cls ThoughtBubbleController : MonoBehaviour {
pub TMP_Text messageText;

float lifetimeTicks;
Transform followTarget;

pub void Initialize(string message, Transform target, float durationInTicks) {
if (messageText != null)
messageText.text = message;
followTarget = target;
lifetimeTicks = durationInTicks;
}

void Update() {
if (TickManager.Instance?.Config != null) {
lifetimeTicks -= TickManager.Instance.Config.ticksPerRealSecond * Time.deltaTime;
} else {
lifetimeTicks -= 2f * Time.deltaTime;
}

if (lifetimeTicks <= 0f)
Destroy(gameObject);

if (followTarget != null) {
transform.position = followTarget.position;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\UI\ThoughtTrigger.cs

﻿using UnityEngine;

pub enum ThoughtTrigger {
Hungry,
Eating,
HealthLow,
Fleeing,
Pooping,
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeDefinitionAutoAdder.cs

﻿using UnityEngine;
using UnityEditor;
using System.IO;

pub cls NodeDefinitionAutoAdder : AssetPostprocessor {
stat void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths) {
foreach (string assetPath in importedAssets) {
NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
if (nodeDef != null) {
string folderPath = Path.GetDirectoryName(assetPath);
string[] libraryFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly)
.Where(f => f.Contains("NodeDefinitionLibrary")).ToArray();
if (libraryFiles.Length > 0) {
NodeDefinitionLibrary library = AssetDatabase.LoadAssetAtPath<NodeDefinitionLibrary>(libraryFiles[0]);
if (library != null && !library.definitions.Contains(nodeDef)) {
library.definitions.Add(nodeDef);
EditorUtility.SetDirty(library);
AssetDatabase.SaveAssets();
}
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeDefinitionCreator.cs

﻿using UnityEngine;
using UnityEditor;
using System.IO;

pub stat cls NodeDefinitionCreator {
c string MenuPath = "Assets/Create/Nodes/Node Definition (Auto-Named)";

pub stat void CreateNodeDefinition() {
string folder = GetSelectedPathOrFallback();

int nextNumber = GetNextNodeNumber(folder);

string newName = $"Node_{nextNumber:D3}_";
string newPath = Path.Combine(folder, newName + ".asset").Replace("\\", "/");

NodeDefinition nodeDef = ScriptableObject.CreateInstance<NodeDefinition>();
AssetDatabase.CreateAsset(nodeDef, newPath);

AssetDatabase.SaveAssets();
AssetDatabase.Refresh();

Debug.Log($"Created NodeDefinition at: {newPath}");
}

stat bool ValidateCreateNodeDefinition() {
ret !Application.isPlaying;
}

stat string GetSelectedPathOrFallback() {
string path = "Assets";
foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets)) {
path = AssetDatabase.GetAssetPath(obj);
if (!string.IsNullOrEmpty(path)) {
if (File.Exists(path)) {
path = Path.GetDirectoryName(path);
}
break;
}
}
ret path;
}

stat int GetNextNodeNumber(string folderPath) {
int nextNumber = 1;
string[] files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
foreach (var file in files) {
string fName = Path.GetFileNameWithoutExtension(file);
if (fName.StartsWith("Node_") && fName.Length >= 8) {
string numberPart = fName.Substring(5, 3);
if (int.TryParse(numberPart, out int num) && num >= nextNumber) {
nextNumber = num + 1;
}
}
}
ret nextNumber;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeDefinitionEditor.cs

﻿using UnityEditor;

pub cls NodeDefinitionEditor : Editor {
SerializedProperty displayName;
SerializedProperty description;
SerializedProperty thumbnail;
SerializedProperty thumbnailTintColor;
SerializedProperty backgroundColor;
SerializedProperty nodeViewPrefab;
SerializedProperty effects;

void OnEnable() {
displayName = serializedObject.FindProperty("displayName");
description = serializedObject.FindProperty("description");
thumbnail = serializedObject.FindProperty("thumbnail");
thumbnailTintColor = serializedObject.FindProperty("thumbnailTintColor");
backgroundColor = serializedObject.FindProperty("backgroundColor");
nodeViewPrefab = serializedObject.FindProperty("nodeViewPrefab");
effects = serializedObject.FindProperty("effects");
}

pub ovr void OnInspectorGUI() {
serializedObject.Update();

EditorGUILayout.LabelField("Display", EditorStyles.boldLabel);
EditorGUILayout.PropertyField(displayName);
EditorGUILayout.PropertyField(description);
EditorGUILayout.PropertyField(thumbnail);
EditorGUILayout.PropertyField(thumbnailTintColor);
EditorGUILayout.PropertyField(backgroundColor);

EditorGUILayout.Space();

EditorGUILayout.LabelField("Prefab & Effects", EditorStyles.boldLabel);
EditorGUILayout.PropertyField(nodeViewPrefab);

EditorGUILayout.PropertyField(effects, new GUIContent("Effects"), true, GUILayout.MinHeight(1300f));

serializedObject.ApplyModifiedProperties();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeDefinitionLibraryEditor.cs

﻿using UnityEngine;
using UnityEditor;
using System.IO;

pub cls NodeDefinitionLibraryEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

if (GUILayout.Button("UPDATE")) {
UpdateLibrary();
}
}

void UpdateLibrary() {
NodeDefinitionLibrary library = (NodeDefinitionLibrary)target;

string libraryPath = AssetDatabase.GetAssetPath(library);
string folderPath = Path.GetDirectoryName(libraryPath);

string[] assetFiles = Directory.GetFiles(folderPath, "*.asset", SearchOption.TopDirectoryOnly);

List<NodeDefinition> defs = new List<NodeDefinition>();
foreach (string file in assetFiles) {
if (file == libraryPath)
continue;

NodeDefinition def = AssetDatabase.LoadAssetAtPath<NodeDefinition>(file);
if (def != null)
defs.Add(def);
}

defs = defs.OrderBy(d => {
string name = d.name;
if (name.StartsWith("Node_") && name.Length >= 8) {
string numStr = name.Substring(5, 3);
if (int.TryParse(numStr, out int num))
ret num;
}
ret int.MaxValue; // if no number is found, sort last.
}).ToList();

library.definitions = defs;
EditorUtility.SetDirty(library);
AssetDatabase.SaveAssets();
Debug.Log("NodeDefinitionLibrary updated. Total definitions: " + library.definitions.Count);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeDefinitionPostprocessor.cs

﻿using UnityEngine;
using UnityEditor;
using System.IO;

pub cls NodeDefinitionPostprocessor : AssetPostprocessor {
stat void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths) {
foreach (string assetPath in importedAssets) {
NodeDefinition nodeDef = AssetDatabase.LoadAssetAtPath<NodeDefinition>(assetPath);
if (nodeDef != null) {
string fileName = Path.GetFileNameWithoutExtension(assetPath);
if (!fileName.StartsWith("Node_")) {
string folderPath = Path.GetDirectoryName(assetPath);
var files = Directory.GetFiles(folderPath, "Node_*", SearchOption.TopDirectoryOnly);
int nextNumber = 1;
foreach (var file in files) {
string fName = Path.GetFileNameWithoutExtension(file);
string[] parts = fName.Split('_');
if (parts.Length >= 2 && int.TryParse(parts[1], out int num)) {
if (num >= nextNumber)
nextNumber = num + 1;
}
}
string newName = $"Node_{nextNumber:D3}_";
AssetDatabase.RenameAsset(assetPath, newName);
AssetDatabase.SaveAssets();
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\NodeEffectDrawer.cs

﻿using UnityEditor;
using WegoSystem;

pub cls NodeEffectDrawer : PropertyDrawer {
c float BASE_PROPERTY_HEIGHT = 58f;

pub ovr void OnGUI(Rect position, SerializedProperty property, GUIContent label) {
EditorGUI.BeginProperty(position, label, property);

var effectTypeProp = property.FindPropertyRelative("effectType");
var isPassiveProp = property.FindPropertyRelative("isPassive");
var consumedOnTriggerProp = property.FindPropertyRelative("consumedOnTrigger");
var seedDataProp = property.FindPropertyRelative("seedData");

Rect currentRect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);
EditorGUI.PropertyField(currentRect, effectTypeProp);
currentRect.y += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;

EditorGUI.PropertyField(currentRect, isPassiveProp);
currentRect.y += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;

NodeEffectType currentType = (NodeEffectType)effectTypeProp.enumValueIndex;

if (IsCastType(currentType)) {
EditorGUI.PropertyField(currentRect, consumedOnTriggerProp, new GUIContent("Consumed on Trigger"));
currentRect.y += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;
}

if (currentType == NodeEffectType.SeedSpawn) {
EditorGUI.PropertyField(currentRect, seedDataProp, true);
}
else {
DrawStandardValueFields(currentRect, property, currentType);
}

EditorGUI.EndProperty();
}

pub ovr float GetPropertyHeight(SerializedProperty property, GUIContent label) {
float totalHeight = BASE_PROPERTY_HEIGHT;

NodeEffectType currentType = (NodeEffectType)property.FindPropertyRelative("effectType").enumValueIndex;

if (IsCastType(currentType)) {
totalHeight += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;
}

if (currentType == NodeEffectType.SeedSpawn) {
totalHeight += EditorGUI.GetPropertyHeight(property.FindPropertyRelative("seedData"), true);
}
else {
totalHeight += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing; // Primary value is always shown

switch (currentType) {
case NodeEffectType.StemLength:
case NodeEffectType.PoopAbsorption:
case NodeEffectType.ScentModifier:
totalHeight += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing; // For secondary value
break;
}

if (currentType == NodeEffectType.ScentModifier) {
totalHeight += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing; // For scent reference
}
}

ret totalHeight;
}

bool IsCastType(NodeEffectType type) {
ret type == NodeEffectType.TimerCast ||
type == NodeEffectType.ProximityCast ||
type == NodeEffectType.EatCast ||
type == NodeEffectType.LeafLossCast;
}

void DrawStandardValueFields(Rect startRect, SerializedProperty property, NodeEffectType currentType) {
var primaryValueProp = property.FindPropertyRelative("primaryValue");
var secondaryValueProp = property.FindPropertyRelative("secondaryValue");
var scentDefRefProp = property.FindPropertyRelative("scentDefinitionReference");

GUIContent primaryLabel = new GUIContent("Primary Value");
GUIContent secondaryLabel = new GUIContent("Secondary Value");
bool showSecondary = false;
bool showScentField = false;

switch (currentType) {
case NodeEffectType.EnergyStorage: primaryLabel.text = "Max Energy Increase"; break;
case NodeEffectType.EnergyPerTick: primaryLabel.text = "Energy Per Tick"; break;
case NodeEffectType.EnergyCost: primaryLabel.text = "Energy Cost"; break;
case NodeEffectType.StemLength: primaryLabel.text = "Min Segments Add"; secondaryLabel.text = "Max Segments Add"; showSecondary = true; break;
case NodeEffectType.GrowthSpeed: primaryLabel.text = "Ticks Per Stage"; break;
case NodeEffectType.LeafGap: primaryLabel.text = "Segments Between Leaves"; break;
case NodeEffectType.LeafPattern: primaryLabel.text = "Pattern Type"; break;
case NodeEffectType.StemRandomness: primaryLabel.text = "Wobble Chance (0-1)"; break;
case NodeEffectType.Cooldown: primaryLabel.text = "Cooldown Ticks"; break;
case NodeEffectType.CastDelay: primaryLabel.text = "Delay Ticks"; break;
case NodeEffectType.PoopAbsorption: primaryLabel.text = "Detection Radius"; secondaryLabel.text = "Energy Per Poop"; showSecondary = true; break;
case NodeEffectType.Damage: primaryLabel.text = "Damage Multiplier Add"; break;
case NodeEffectType.GrowBerry: primaryLabel.text = "Enabled"; break;
case NodeEffectType.ScentModifier: primaryLabel.text = "Radius Modifier"; secondaryLabel.text = "Strength Modifier"; showSecondary = true; showScentField = true; break;

case NodeEffectType.TimerCast: primaryLabel.text = "Tick Interval"; break;
case NodeEffectType.ProximityCast: primaryLabel.text = "Detection Range (Tiles)"; break;
case NodeEffectType.Nutritious: primaryLabel.text = "Hunger Restored"; break; // <<< NEW
}

Rect currentRect = startRect;

EditorGUI.PropertyField(currentRect, primaryValueProp, primaryLabel);
currentRect.y += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;

if (showSecondary) {
EditorGUI.PropertyField(currentRect, secondaryValueProp, secondaryLabel);
currentRect.y += EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;
}

if (showScentField) {
EditorGUI.PropertyField(currentRect, scentDefRefProp, new GUIContent("Scent Definition"));
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\RadiusPatternTester.cs

﻿using UnityEngine;
using WegoSystem;

#if UNITY_EDITOR
using UnityEditor;

pub cls RadiusPatternTesterEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

RadiusPatternTester tester = (RadiusPatternTester)target;

if (GUILayout.Button("Test Radius Pattern")) {
tester.TestRadiusPattern();
}

if (GUILayout.Button("Compare All Patterns")) {
tester.CompareAllPatterns();
}
}
}
#endif

pub cls RadiusPatternTester : MonoBehaviour {
pub int testRadius = 3;

pub void TestRadiusPattern() {
GridRadiusUtility.DebugPrintRadius(GridPosition.Zero, testRadius);
}

pub void CompareAllPatterns() {
Debug.Log("=== RADIUS PATTERN COMPARISON ===");

for (int r = 1; r <= 5; r++) {
Debug.Log($"\n--- Radius {r} ---");

var circleTiles = GridRadiusUtility.GetTilesInCircle(GridPosition.Zero, r);
Debug.Log($"Circle tiles: {circleTiles.Count}");

GridRadiusUtility.DebugPrintRadius(GridPosition.Zero, r);

int manhattanCount = 0;
int chebyshevCount = 0;

for (int x = -r; x <= r; x++) {
for (int y = -r; y <= r; y++) {
if (Mathf.Abs(x) + Mathf.Abs(y) <= r) manhattanCount++;
if (Mathf.Max(Mathf.Abs(x), Mathf.Abs(y)) <= r) chebyshevCount++;
}
}

Debug.Log($"Manhattan (diamond): {manhattanCount} tiles");
Debug.Log($"Chebyshev (square): {chebyshevCount} tiles");
Debug.Log($"Circle (ours): {circleTiles.Count} tiles");
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\TileDefinitionEditor.cs

﻿#if UNITY_EDITOR
using UnityEditor;

pub cls TileDefinitionEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

TileDefinition tileDefinition = (TileDefinition)target;

EditorGUILayout.Space();
if (GUILayout.Button("UPDATE COLOR IN SCENE", GUILayout.Height(30))) {
tileDefinition.UpdateColor();
}
}
}
#endif

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\TileInteractionManagerEditor.cs

﻿#if UNITY_EDITOR
using UnityEditor;

pub cls TileInteractionManagerEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

TileInteractionManager manager = (TileInteractionManager)target;

EditorGUILayout.Space();
EditorGUILayout.BeginHorizontal();

if (GUILayout.Button("UPDATE SORTING ORDER", GUILayout.Height(30))) {
manager.UpdateSortingOrder();
EditorUtility.SetDirty(manager);
}

if (GUILayout.Button("UPDATE ALL COLORS", GUILayout.Height(30))) {
manager.UpdateAllColors();
EditorUtility.SetDirty(manager);
}

EditorGUILayout.EndHorizontal();

EditorGUILayout.HelpBox("Order: First item in list gets highest sorting order value (" +
manager.baseSortingOrder + "). Each subsequent item is " +
(manager.baseSortingOrder - 1) + ", " +
(manager.baseSortingOrder - 2) + ", etc.", MessageType.Info);
}
}
#endif

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\WaveDefinitionEditor.cs

﻿using UnityEngine;
using UnityEditor;
using UnityEditorInternal;

pub cls WaveDefinitionEditor : Editor {
ReorderableList spawnList;
SerializedProperty spawnEntries;

void OnEnable() {
spawnEntries = serializedObject.FindProperty("spawnEntries");

spawnList = new ReorderableList(serializedObject, spawnEntries, true, true, true, true);

spawnList.drawHeaderCallback = (Rect rect) => {
EditorGUI.LabelField(rect, "Spawn Entries");
};

spawnList.elementHeightCallback = (int index) => {
ret EditorGUIUtility.singleLineHeight * 4 + 10;
};

spawnList.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) => {
var element = spawnEntries.GetArrayElementAtIndex(index);
rect.y += 2;

float lineHeight = EditorGUIUtility.singleLineHeight;
float spacing = 2;

Rect descRect = new Rect(rect.x, rect.y, rect.width * 0.4f, lineHeight);
Rect animalRect = new Rect(rect.x + rect.width * 0.42f, rect.y, rect.width * 0.58f, lineHeight);

EditorGUI.PropertyField(descRect, element.FindPropertyRelative("description"), GUIContent.none);
EditorGUI.PropertyField(animalRect, element.FindPropertyRelative("animalDefinition"), GUIContent.none);

rect.y += lineHeight + spacing;

Rect countRect = new Rect(rect.x, rect.y, rect.width * 0.3f, lineHeight);
Rect delayRect = new Rect(rect.x + rect.width * 0.32f, rect.y, rect.width * 0.3f, lineHeight);
Rect intervalRect = new Rect(rect.x + rect.width * 0.64f, rect.y, rect.width * 0.36f, lineHeight);

EditorGUI.LabelField(countRect, "Count:");
countRect.x += 40;
countRect.width -= 40;
EditorGUI.PropertyField(countRect, element.FindPropertyRelative("spawnCount"), GUIContent.none);

EditorGUI.LabelField(delayRect, "Delay:");
delayRect.x += 35;
delayRect.width -= 35;
EditorGUI.PropertyField(delayRect, element.FindPropertyRelative("delayAfterSpawnTime"), GUIContent.none);

EditorGUI.LabelField(intervalRect, "Interval:");
intervalRect.x += 45;
intervalRect.width -= 45;
EditorGUI.PropertyField(intervalRect, element.FindPropertyRelative("spawnInterval"), GUIContent.none);

rect.y += lineHeight + spacing;

Rect locTypeRect = new Rect(rect.x, rect.y, rect.width * 0.6f, lineHeight);
Rect radiusRect = new Rect(rect.x + rect.width * 0.62f, rect.y, rect.width * 0.38f, lineHeight);

EditorGUI.PropertyField(locTypeRect, element.FindPropertyRelative("spawnLocationType"), GUIContent.none);

EditorGUI.LabelField(radiusRect, "Radius:");
radiusRect.x += 45;
radiusRect.width -= 45;
EditorGUI.PropertyField(radiusRect, element.FindPropertyRelative("spawnRadius"), GUIContent.none);
};

spawnList.onAddCallback = (ReorderableList list) => {
var index = list.serializedProperty.arraySize;
list.serializedProperty.arraySize++;
list.index = index;

var element = list.serializedProperty.GetArrayElementAtIndex(index);
element.FindPropertyRelative("description").stringValue = "New Spawn Entry";
element.FindPropertyRelative("spawnCount").intValue = 1;
element.FindPropertyRelative("delayAfterSpawnTime").floatValue = 0f;
element.FindPropertyRelative("spawnInterval").floatValue = 0.5f;
element.FindPropertyRelative("spawnRadius").floatValue = 5f;
};
}

pub ovr void OnInspectorGUI() {
serializedObject.Update();

WaveDefinition waveDef = (WaveDefinition)target;

EditorGUILayout.LabelField("Wave Definition", EditorStyles.boldLabel);
EditorGUILayout.Space();

EditorGUILayout.BeginHorizontal();
EditorGUILayout.LabelField("Wave Name:", GUILayout.Width(80));
SerializedProperty waveNameProp = serializedObject.FindProperty("waveName");
waveNameProp.stringValue = EditorGUILayout.TextField(waveNameProp.stringValue);
EditorGUILayout.EndHorizontal();

EditorGUILayout.Space();

int totalEnemies = 0;
float totalDuration = 0;

foreach (WaveSpawnEntry entry in waveDef.spawnEntries) {
if (entry != null) {
totalEnemies += entry.spawnCount;
totalDuration = Mathf.Max(totalDuration,
entry.delayAfterSpawnTime + (entry.spawnCount - 1) * entry.spawnInterval);
}
}

EditorGUILayout.HelpBox(
$"Total Enemies: {totalEnemies}\n" +
$"Spawn Duration: ~{totalDuration:F1} seconds",
MessageType.Info
);

EditorGUILayout.Space();

spawnList.DoLayoutList();

serializedObject.ApplyModifiedProperties();

EditorGUILayout.Space();

if (GUILayout.Button("Clear All Entries")) {
if (EditorUtility.DisplayDialog("Clear All Entries",
"Are you sure you want to remove all spawn entries?",
"Clear", "Cancel")) {
waveDef.spawnEntries.Clear();
EditorUtility.SetDirty(waveDef);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\WaveManagerEditor.cs

﻿using UnityEngine;
using UnityEditor;
using WegoSystem;

pub cls WaveManagerEditor : Editor {
SerializedProperty waveDurationInDays;
SerializedProperty spawnTimeNormalized;
SerializedProperty continuousSpawning;
SerializedProperty deletePreviousWaveAnimals;
SerializedProperty wavesSequence;

bool showTimingSettings = true;
bool showWaveSequence = true;
bool showDebugInfo = false;

void OnEnable() {
waveDurationInDays = serializedObject.FindProperty("waveDurationInDays");
spawnTimeNormalized = serializedObject.FindProperty("spawnTimeNormalized");
continuousSpawning = serializedObject.FindProperty("continuousSpawning");
deletePreviousWaveAnimals = serializedObject.FindProperty("deletePreviousWaveAnimals");
wavesSequence = serializedObject.FindProperty("wavesSequence");
}

pub ovr void OnInspectorGUI() {
serializedObject.Update();

WaveManager waveManager = (WaveManager)target;

EditorGUILayout.LabelField("Wave Manager", EditorStyles.boldLabel);
EditorGUILayout.Space();

DrawPropertiesExcluding(serializedObject,
"waveDurationInDays",
"spawnTimeNormalized",
"continuousSpawning",
"deletePreviousWaveAnimals",
"wavesSequence"
);

EditorGUILayout.Space();

showTimingSettings = EditorGUILayout.BeginFoldoutHeaderGroup(showTimingSettings, "Wave Timing Settings");
if (showTimingSettings) {
EditorGUI.indentLevel++;

EditorGUILayout.BeginHorizontal();
EditorGUILayout.PropertyField(waveDurationInDays, new GUIContent("Wave Duration (Days)"));
EditorGUILayout.EndHorizontal();

if (Application.isPlaying && TickManager.Instance?.Config != null) {
var config = TickManager.Instance.Config;
int totalTicks = config.ticksPerDay * waveDurationInDays.intValue;
EditorGUILayout.HelpBox($"Wave will last {totalTicks} ticks", MessageType.Info);
}

EditorGUILayout.Space();

float spawnPercent = spawnTimeNormalized.floatValue * 100f;
EditorGUILayout.LabelField($"Spawn Start: {spawnPercent:F0}% into wave");
spawnTimeNormalized.floatValue = EditorGUILayout.Slider("Spawn Time", spawnTimeNormalized.floatValue, 0f, 1f);

DrawTimingBar(spawnTimeNormalized.floatValue);

EditorGUILayout.Space();

EditorGUILayout.PropertyField(continuousSpawning, new GUIContent("Continuous Spawning", "If enabled, enemies spawn throughout the wave"));

EditorGUI.indentLevel--;
}
EditorGUILayout.EndFoldoutHeaderGroup();

EditorGUILayout.Space();

EditorGUILayout.PropertyField(deletePreviousWaveAnimals, new GUIContent("Clear Previous Wave", "Delete all animals when starting a new wave"));

EditorGUILayout.Space();

showWaveSequence = EditorGUILayout.BeginFoldoutHeaderGroup(showWaveSequence, "Wave Sequence");
if (showWaveSequence) {
EditorGUI.indentLevel++;

if (wavesSequence.arraySize == 0) {
EditorGUILayout.HelpBox("No waves defined! Add wave definitions to the sequence.", MessageType.Warning);
}

for (int i = 0; i < wavesSequence.arraySize; i++) {
EditorGUILayout.BeginHorizontal();

var element = wavesSequence.GetArrayElementAtIndex(i);
var waveDef = element.objectReferenceValue as WaveDefinition;

string label = $"Round {i + 1}";
if (waveDef != null && !string.IsNullOrEmpty(waveDef.waveName)) {
label += $": {waveDef.waveName}";
}

EditorGUILayout.PropertyField(element, new GUIContent(label));

if (GUILayout.Button("X", GUILayout.Width(20))) {
wavesSequence.DeleteArrayElementAtIndex(i);
break;
}

EditorGUILayout.EndHorizontal();
}

EditorGUILayout.BeginHorizontal();
GUILayout.FlexibleSpace();
if (GUILayout.Button("Add Wave", GUILayout.Width(100))) {
wavesSequence.InsertArrayElementAtIndex(wavesSequence.arraySize);
}
EditorGUILayout.EndHorizontal();

EditorGUI.indentLevel--;
}
EditorGUILayout.EndFoldoutHeaderGroup();

EditorGUILayout.Space();

if (Application.isPlaying) {
showDebugInfo = EditorGUILayout.BeginFoldoutHeaderGroup(showDebugInfo, "Runtime Debug");
if (showDebugInfo) {
EditorGUI.indentLevel++;

EditorGUILayout.LabelField("Status", waveManager.IsWaveActive ? "Wave Active" : "Idle");

if (waveManager.IsWaveActive && TickManager.Instance != null) {
EditorGUILayout.Space();
DrawRuntimeWaveProgress(waveManager);
}

EditorGUILayout.Space();

EditorGUILayout.BeginHorizontal();
if (GUILayout.Button("Force End Wave")) {
waveManager.SendMessage("Debug_ForceEndWave", SendMessageOptions.DontRequireReceiver);
}
if (GUILayout.Button("Force Spawn")) {
waveManager.SendMessage("Debug_ForceSpawn", SendMessageOptions.DontRequireReceiver);
}
EditorGUILayout.EndHorizontal();

EditorGUI.indentLevel--;
}
EditorGUILayout.EndFoldoutHeaderGroup();
}

serializedObject.ApplyModifiedProperties();
}

void DrawTimingBar(float spawnTime) {
Rect rect = GUILayoutUtility.GetRect(0, 20, GUILayout.ExpandWidth(true));

EditorGUI.DrawRect(rect, new Color(0.2f, 0.2f, 0.2f));

Rect waveRect = new Rect(rect.x, rect.y, rect.width, rect.height);
EditorGUI.DrawRect(waveRect, new Color(0.3f, 0.5f, 0.3f));

float spawnX = rect.x + (rect.width * spawnTime);
Rect spawnRect = new Rect(spawnX - 2, rect.y, 4, rect.height);
EditorGUI.DrawRect(spawnRect, Color.yellow);

GUI.Label(new Rect(rect.x, rect.y, 50, rect.height), "Start", EditorStyles.miniLabel);
GUI.Label(new Rect(rect.x + rect.width - 30, rect.y, 30, rect.height), "End", EditorStyles.miniLabel);
GUI.Label(new Rect(spawnX - 25, rect.y - 20, 50, 20), "Spawn", EditorStyles.centeredGreyMiniLabel);
}

void DrawRuntimeWaveProgress(WaveManager waveManager) {
EditorGUILayout.HelpBox("Wave progress visualization requires exposing runtime data", MessageType.Info);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\LeafData.cs

﻿using UnityEngine;

pub struct LeafData {
pub Vector2Int GridCoord;
pub bool IsActive; // True if the leaf exists, false if it was eaten

pub LeafData(Vector2Int coord, bool isActive = true) {
GridCoord = coord;
IsActive = isActive;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeData.cs

﻿using System;

pub cls NodeData : ISerializationCallbackReceiver {
pub string nodeId;
pub string nodeDisplayName;
pub List<NodeEffectData> effects = new List<NodeEffectData>();
pub int orderIndex;

pub bool canBeDeleted = true;

NodeGraph _storedSequence;

bool _isPartOfSequence = false;

pub NodeData() {
nodeId = Guid.NewGuid().ToString();
_storedSequence = null;
_isPartOfSequence = false;
}

pub bool HasSeedEffect() {
ret effects != null &&
effects.Any(e => e != null &&
e.effectType == NodeEffectType.SeedSpawn &&
e.isPassive);
}

pub bool IsSeed() {
ret HasSeedEffect() && !_isPartOfSequence;
}

pub NodeGraph storedSequence {
get {
ret IsSeed() ? _storedSequence : null;
}
set {
if (!HasSeedEffect() || _isPartOfSequence) {
_storedSequence = null;
return;
}

_storedSequence = value;

if (_storedSequence?.nodes != null) {
foreach (var node in _storedSequence.nodes.Where(n => n != null)) {
node._isPartOfSequence = true;
node._storedSequence = null; // Nested sequences not allowed
}
}
}
}

pub void SetPartOfSequence(bool isPartOfSequence) {
_isPartOfSequence = isPartOfSequence;

if (isPartOfSequence) {
_storedSequence = null;
}
}

pub void EnsureSeedSequenceInitialized() {
if (IsSeed() && _storedSequence == null) {
_storedSequence = new NodeGraph { nodes = new List<NodeData>() };
}
}

pub void ClearStoredSequence() {
_storedSequence = null;
}

pub void OnBeforeSerialize() {
if (_isPartOfSequence) {
_storedSequence = null;
}
}

pub void OnAfterDeserialize() {
_isPartOfSequence = false;

if (!HasSeedEffect()) {
_storedSequence = null;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeDefinition.cs

﻿using System.Collections.Generic;
using System.Text;
using WegoSystem;

pub cls NodeDefinition : ScriptableObject, ITooltipDataProvider {

pub string displayName;

pub string description;

pub Sprite thumbnail;
pub Color thumbnailTintColor = Color.white;
pub Color backgroundColor = Color.gray;

pub GameObject nodeViewPrefab;
pub List<NodeEffectData> effects;

pub List<NodeEffectData> CloneEffects() {
var copy = new List<NodeEffectData>();

if (effects == null) {
Debug.LogWarning($"[NodeDefinition '{this.name}'] No effects to clone");
ret copy;
}

Debug.Log($"[NodeDefinition '{this.name}'] Cloning {effects.Count} effects:");

foreach (var originalEffect in effects) {
if (originalEffect == null) {
Debug.LogWarning($"[NodeDefinition '{this.name}'] Contains a null effect in its list.");
continue;
}

var newEffect = new NodeEffectData() {
effectType = originalEffect.effectType,
primaryValue = originalEffect.primaryValue,
secondaryValue = originalEffect.secondaryValue,
isPassive = originalEffect.isPassive,
consumedOnTrigger = originalEffect.consumedOnTrigger, // <<< NEW
scentDefinitionReference = originalEffect.scentDefinitionReference
};

if (originalEffect.effectType == NodeEffectType.SeedSpawn && originalEffect.seedData != null) {
newEffect.seedData = new SeedSpawnData {
growthSpeed = originalEffect.seedData.growthSpeed,
stemLengthMin = originalEffect.seedData.stemLengthMin,
stemLengthMax = originalEffect.seedData.stemLengthMax,
leafGap = originalEffect.seedData.leafGap,
leafPattern = originalEffect.seedData.leafPattern,
stemRandomness = originalEffect.seedData.stemRandomness,
energyStorage = originalEffect.seedData.energyStorage,
cooldown = originalEffect.seedData.cooldown,
castDelay = originalEffect.seedData.castDelay,
maxBerries = originalEffect.seedData.maxBerries
};
}

Debug.Log($"  - Cloned: {newEffect.effectType} (passive: {newEffect.isPassive}, primary: {newEffect.primaryValue}, secondary: {newEffect.secondaryValue})");

copy.Add(newEffect);
}

Debug.Log($"[NodeDefinition '{this.name}'] Successfully cloned {copy.Count} effects");
ret copy;
}

pub string GetTooltipTitle() {
ret displayName ?? "Unknown Node";
}

pub string GetTooltipDescription() {
ret description ?? string.Empty;
}

pub string GetTooltipDetails(object source = null) {
var nodeData = source as NodeData;
if (nodeData == null) ret string.Empty;

var sb = new StringBuilder();

if (nodeData.effects != null && nodeData.effects.Any()) {
sb.Append("<b>Effects:</b>\n");
var passiveEffectColor = new Color(0.6f, 0.8f, 1f, 1f); // Light Blue
var activeEffectColor = new Color(1f, 0.8f, 0.6f, 1f);  // Light Orange
c string effectPrefix = "• ";
c string seedDetailPrefix = "    └ ";

foreach (var effect in nodeData.effects) {
if (effect == null) continue;
Color effectColor = effect.isPassive ? passiveEffectColor : activeEffectColor;
string hexColor = ColorUtility.ToHtmlStringRGB(effectColor);

sb.Append($"<color=#{hexColor}>{effectPrefix}{GetEffectDisplayName(effect.effectType)}: ");
sb.Append(GetEffectDescription(effect));
sb.Append("</color>\n");

if (effect.effectType == NodeEffectType.SeedSpawn && effect.seedData != null && effect.isPassive) {
var energyStorageEffect = new NodeEffectData { effectType = NodeEffectType.EnergyStorage, primaryValue = effect.seedData.energyStorage };
sb.Append($"<color=#{hexColor}>{seedDetailPrefix}{GetEffectDisplayName(energyStorageEffect.effectType)}: {GetEffectDescription(energyStorageEffect)}</color>\n");

var growthSpeedEffect = new NodeEffectData { effectType = NodeEffectType.GrowthSpeed, primaryValue = effect.seedData.growthSpeed };
sb.Append($"<color=#{hexColor}>{seedDetailPrefix}{GetEffectDisplayName(growthSpeedEffect.effectType)}: {GetEffectDescription(growthSpeedEffect)}</color>\n");

var stemLengthEffect = new NodeEffectData { effectType = NodeEffectType.StemLength, primaryValue = effect.seedData.stemLengthMin, secondaryValue = effect.seedData.stemLengthMax };
sb.Append($"<color=#{hexColor}>{seedDetailPrefix}{GetEffectDisplayName(stemLengthEffect.effectType)}: {GetEffectDescription(stemLengthEffect)}</color>\n");

var leafGapEffect = new NodeEffectData { effectType = NodeEffectType.LeafGap, primaryValue = effect.seedData.leafGap };
sb.Append($"<color=#{hexColor}>{seedDetailPrefix}{GetEffectDisplayName(leafGapEffect.effectType)}: {GetEffectDescription(leafGapEffect)}</color>\n");

var leafPatternEffect = new NodeEffectData { effectType = NodeEffectType.LeafPattern, primaryValue = effect.seedData.leafPattern };
sb.Append($"<color=#{hexColor}>{seedDetailPrefix}{GetEffectDisplayName(leafPatternEffect.effectType)}: {GetEffectDescription(leafPatternEffect)}</color>\n");

var stemRandomnessEffect = new NodeEffectData { effectType = NodeEffectType.StemRandomness, primaryValue = effect.seedData.stemRandomness };
sb.Append($"<color=#{hexColor}>{seedDetailPrefix}{GetEffectDisplayName(stemRandomnessEffect.effectType)}: {GetEffectDescription(stemRandomnessEffect)}</color>\n");

var cooldownEffect = new NodeEffectData { effectType = NodeEffectType.Cooldown, primaryValue = effect.seedData.cooldown };
sb.Append($"<color=#{hexColor}>{seedDetailPrefix}{GetEffectDisplayName(cooldownEffect.effectType)}: {GetEffectDescription(cooldownEffect)}</color>\n");

var castDelayEffect = new NodeEffectData { effectType = NodeEffectType.CastDelay, primaryValue = effect.seedData.castDelay };
sb.Append($"<color=#{hexColor}>{seedDetailPrefix}{GetEffectDisplayName(castDelayEffect.effectType)}: {GetEffectDescription(castDelayEffect)}</color>\n");
}
}
}

if (nodeData.IsSeed()) {
if (sb.Length > 0 && sb[sb.Length - 1] != '\n') sb.Append("\n");
sb.Append("<b>Seed Sequence:</b> ");
if (nodeData.storedSequence?.nodes != null && nodeData.storedSequence.nodes.Any()) {
sb.Append($"{nodeData.storedSequence.nodes.Count} nodes");
}
else {
sb.Append("Empty");
}
}

ret sb.ToString().TrimEnd();
}

string GetEffectDisplayName(NodeEffectType type) {
switch (type) {
case NodeEffectType.EnergyStorage: ret "Energy Storage";
case NodeEffectType.EnergyPerTick: ret "Energy/Tick";
case NodeEffectType.EnergyCost: ret "Energy Cost";
case NodeEffectType.StemLength: ret "Stem Length";
case NodeEffectType.GrowthSpeed: ret "Growth Speed";
case NodeEffectType.LeafGap: ret "Leaf Gap";
case NodeEffectType.LeafPattern: ret "Leaf Pattern";
case NodeEffectType.StemRandomness: ret "Stem Wobble";
case NodeEffectType.Cooldown: ret "Cooldown";
case NodeEffectType.CastDelay: ret "Cast Delay";
case NodeEffectType.PoopAbsorption: ret "Poop Absorption";
case NodeEffectType.Damage: ret "Damage";
case NodeEffectType.GrowBerry: ret "Berry Growth";
case NodeEffectType.SeedSpawn: ret "Seed";
case NodeEffectType.ScentModifier: ret "Scent";
case NodeEffectType.TimerCast: ret "Timer Cast";
case NodeEffectType.ProximityCast: ret "Proximity Cast";
case NodeEffectType.EatCast: ret "Eat Cast";
case NodeEffectType.LeafLossCast: ret "Leaf Loss Cast";
case NodeEffectType.Nutritious: ret "Nutritious"; // <<< NEW
default: ret type.ToString();
}
}

string GetEffectDescription(NodeEffectData effect) {
switch (effect.effectType) {
case NodeEffectType.EnergyStorage:
ret $"+{effect.primaryValue:F0} max energy";

case NodeEffectType.EnergyPerTick:
ret $"+{effect.primaryValue:F2} energy/tick";

case NodeEffectType.EnergyCost:
ret $"{effect.primaryValue:F0} energy to activate";

case NodeEffectType.StemLength:
if (effect.secondaryValue > 0 && effect.secondaryValue != effect.primaryValue) {
ret $"+{effect.primaryValue:F0} to +{effect.secondaryValue:F0} segments";
}
else {
ret $"+{effect.primaryValue:F0} segments";
}

case NodeEffectType.GrowthSpeed:
ret effect.primaryValue <= 1
? "Instant growth"
: $"{effect.primaryValue:F0} ticks/stage";

case NodeEffectType.LeafGap:
ret effect.primaryValue == 0
? "Leaves every segment"
: $"Leaves every {effect.primaryValue + 1:F0} segments";

case NodeEffectType.LeafPattern:
string patternName = GetLeafPatternName((int)effect.primaryValue);
ret $"Pattern: {patternName}";

case NodeEffectType.StemRandomness:
ret $"{effect.primaryValue * 100:F0}% chance to wobble";

case NodeEffectType.Cooldown:
ret $"{effect.primaryValue:F0} tick cooldown";

case NodeEffectType.CastDelay:
ret effect.primaryValue > 0
? $"{effect.primaryValue:F0} tick delay"
: "No delay";

case NodeEffectType.PoopAbsorption:
string result = "";
if (effect.primaryValue > 0) result += $"{effect.primaryValue:F0} tile radius";
if (effect.secondaryValue > 0) {
if (result.Length > 0) result += ", ";
result += $"+{effect.secondaryValue:F0} energy";
}
ret result;

case NodeEffectType.Damage:
ret $"+{effect.primaryValue * 100:F0}% damage";

case NodeEffectType.GrowBerry:
ret "Grows berries";

case NodeEffectType.SeedSpawn:
ret effect.isPassive ? "Contains seed" : "Active seed";

case NodeEffectType.ScentModifier:
string scentResult = "";
if (effect.primaryValue != 0) scentResult += $"Radius {(effect.primaryValue >= 0 ? "+" : "")}{effect.primaryValue:F0}";
if (effect.secondaryValue != 0) {
if (scentResult.Length > 0) scentResult += ", ";
scentResult += $"Strength {(effect.secondaryValue >= 0 ? "+" : "")}{effect.secondaryValue:F0}";
}
if (effect.scentDefinitionReference != null) {
scentResult += $" ({effect.scentDefinitionReference.displayName})";
}
ret scentResult;

case NodeEffectType.TimerCast:
ret $"Triggers every {effect.primaryValue:F0} ticks";
case NodeEffectType.ProximityCast:
ret $"Triggers within {effect.primaryValue:F0} tiles";
case NodeEffectType.EatCast:
ret "Triggers when eaten";
case NodeEffectType.LeafLossCast:
ret "Triggers when a leaf is lost";
case NodeEffectType.Nutritious:
ret $"Restores {effect.primaryValue:F0} hunger"; // <<< NEW

default:
string defaultResult = $"{effect.primaryValue:F1}";
if (effect.secondaryValue != 0) {
defaultResult += $" / {effect.secondaryValue:F1}";
}
ret defaultResult;
}
}

string GetLeafPatternName(int pattern) {
switch (pattern) {
case 0: ret "Symmetrical";
case 1: ret "Offset";
case 2: ret "Alternating";
case 3: ret "Spiral";
case 4: ret "Dense";
default: ret $"Pattern {pattern}";
}
}

pub string GetStatsAsString() {
if (effects == null || effects.Count == 0) ret "No effects";

var result = new System.Text.StringBuilder();

foreach (var effect in effects) {
result.AppendLine($"{GetEffectDisplayName(effect.effectType)}: {GetEffectDescription(effect)}");
}

ret result.ToString();
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeDefinitionLibrary.cs

﻿using UnityEngine;
using System; // Needed for [Serializable]

[Serializable] // Make it visible and editable in the Inspector
pub struct InitialNodeConfig {
pub NodeDefinition nodeDefinition;

pub int cellIndex;

pub bool canMove;

pub bool canDelete;
}

pub cls NodeDefinitionLibrary : ScriptableObject {
pub List<NodeDefinition> definitions; // Your existing list

pub List<InitialNodeConfig> initialNodes; // <<< NEW LIST ADDED
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeEffectData.cs

﻿using System;
using WegoSystem;

pub cls NodeEffectData {
pub NodeEffectType effectType;
pub float primaryValue;
pub float secondaryValue;
pub bool isPassive = false;
pub bool consumedOnTrigger = false; // <<< NEW: Determines if a trigger is single-use
pub ScentDefinition scentDefinitionReference;
pub SeedSpawnData seedData;

pub int GetPrimaryValueAsInt() => Mathf.RoundToInt(primaryValue);
pub int GetSecondaryValueAsInt() => Mathf.RoundToInt(secondaryValue);

pub void ValidateForTicks() {
if (effectType == NodeEffectType.EnergyPerTick && TickManager.Instance?.Config != null) {
float ticksPerSecond = TickManager.Instance.Config.ticksPerRealSecond;
primaryValue /= ticksPerSecond;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeEffectType.cs

﻿using System;

pub enum NodeEffectType {
EnergyStorage = 0,
EnergyPerTick = 1,
EnergyCost = 2,
StemLength = 3,
GrowthSpeed = 4,
LeafGap = 5,
LeafPattern = 6,
StemRandomness = 7,
Cooldown = 8,
CastDelay = 9,
PoopAbsorption = 10,
ScentModifier = 14,
SeedSpawn = 13,

TimerCast = 15,
ProximityCast = 16,
EatCast = 17,
LeafLossCast = 18,

GrowBerry = 12,
Damage = 11,
Nutritious = 19,
Harvestable = 20 // <<< NEW
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\NodeGraph.cs

﻿using System;

[Serializable]  // Add this!
pub cls NodeGraph {
pub List<NodeData> nodes = new List<NodeData>();
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\SeedSpawnData.cs

﻿using System;

pub cls SeedSpawnData {
pub int growthSpeed = 5;

pub int stemLengthMin = 3;

pub int stemLengthMax = 5;

pub int leafGap = 1;

pub int leafPattern = 0;

pub float stemRandomness = 0.1f;

pub float energyStorage = 10f;

pub int cooldown = 20;

pub int castDelay = 0;

pub int maxBerries = 3; // 0 = no limit (only space limit)
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Execution\NodeExecutor.cs

﻿using System;
using TMPro;
using WegoSystem;

pub cls NodeExecutor : MonoBehaviour {
[SerializeField] GameObject plantPrefab;
[SerializeField] TMP_Text debugOutput;

pub stat List<NodeEffectData> CloneEffectsList(List<NodeEffectData> originalEffects) {
if (originalEffects == null) ret new List<NodeEffectData>();

var clonedList = new List<NodeEffectData>();

foreach (var effect in originalEffects) {
if (effect == null) continue;

var clonedEffect = new NodeEffectData {
effectType = effect.effectType,
primaryValue = effect.primaryValue,
secondaryValue = effect.secondaryValue,
isPassive = effect.isPassive,
consumedOnTrigger = effect.consumedOnTrigger, // <<< NEW
scentDefinitionReference = effect.scentDefinitionReference
};

if (effect.effectType == NodeEffectType.SeedSpawn && effect.seedData != null) {
clonedEffect.seedData = new SeedSpawnData {
growthSpeed = effect.seedData.growthSpeed,
stemLengthMin = effect.seedData.stemLengthMin,
stemLengthMax = effect.seedData.stemLengthMax,
leafGap = effect.seedData.leafGap,
leafPattern = effect.seedData.leafPattern,
stemRandomness = effect.seedData.stemRandomness,
energyStorage = effect.seedData.energyStorage,
cooldown = effect.seedData.cooldown,
castDelay = effect.seedData.castDelay
};
}

clonedList.Add(clonedEffect);
}

ret clonedList;
}

pub stat NodeData CloneNode(NodeData original) {
if (original == null) ret null;

var clone = new NodeData {
nodeId = Guid.NewGuid().ToString(),
nodeDisplayName = original.nodeDisplayName,
effects = CloneEffectsList(original.effects),
orderIndex = original.orderIndex,
canBeDeleted = original.canBeDeleted
};

if (original.IsSeed() && original.storedSequence != null) {
clone.EnsureSeedSequenceInitialized();

foreach (var nodeInSequence in original.storedSequence.nodes) {
if (nodeInSequence == null) continue;

var sequenceNodeClone = CloneNodeWithoutSequence(nodeInSequence);
sequenceNodeClone.SetPartOfSequence(true);
clone.storedSequence.nodes.Add(sequenceNodeClone);
}
}

ret clone;
}

pub stat NodeData CloneNodeWithoutSequence(NodeData original) {
if (original == null) ret null;

var clone = new NodeData {
nodeId = Guid.NewGuid().ToString(),
nodeDisplayName = original.nodeDisplayName,
effects = CloneEffectsList(original.effects),
orderIndex = original.orderIndex,
canBeDeleted = original.canBeDeleted
};

if (Debug.isDebugBuild) {
Debug.Log($"[NodeExecutor] CloneNodeWithoutSequence: '{original.nodeDisplayName}' - Original effects: {original.effects?.Count ?? 0}, Clone effects: {clone.effects?.Count ?? 0}");
}

ret clone;
}

pub GameObject SpawnPlantFromSeedInSlot(Vector3 plantingPosition, Transform parentTransform) {
if (NodeEditorGridController.Instance == null) {
Debug.LogError("[NodeExecutor] Node Editor Grid Controller not found!");
ret null;
}

if (plantPrefab == null) {
Debug.LogError("[NodeExecutor] Plant prefab not assigned!");
ret null;
}

NodeData seedInSlot = NodeEditorGridController.Instance.GetCurrentSeedInSlot();

if (seedInSlot == null) {
Debug.Log("[NodeExecutor] No seed in slot to plant.");
ret null;
}

if (!seedInSlot.IsSeed()) {
Debug.LogError($"[NodeExecutor] Item '{seedInSlot.nodeDisplayName}' in seed slot is not a valid seed!");
ret null;
}

Debug.Log($"[NodeExecutor] Seed '{seedInSlot.nodeDisplayName}' has {seedInSlot.effects?.Count ?? 0} effects:");
if (seedInSlot.effects != null) {
foreach (var effect in seedInSlot.effects) {
Debug.Log($"  - {effect.effectType} (passive: {effect.isPassive})");
}
}

NodeGraph editorSequence = NodeEditorGridController.Instance.GetCurrentGraphInEditorForSpawning();
Debug.Log($"[NodeExecutor] Editor sequence has {editorSequence.nodes.Count} nodes");

NodeGraph plantGraph = new NodeGraph { nodes = new List<NodeData>() };

NodeData seedClone = CloneNodeWithoutSequence(seedInSlot);
seedClone.orderIndex = 0;
seedClone.canBeDeleted = false;
plantGraph.nodes.Add(seedClone);

Debug.Log($"[NodeExecutor] Seed clone has {seedClone.effects?.Count ?? 0} effects");

int orderIndex = 1;
foreach (NodeData editorNode in editorSequence.nodes.OrderBy(n => n.orderIndex)) {
if (editorNode == null) continue;

Debug.Log($"[NodeExecutor] Editor node '{editorNode.nodeDisplayName}' has {editorNode.effects?.Count ?? 0} effects:");
if (editorNode.effects != null) {
foreach (var effect in editorNode.effects) {
Debug.Log($"  - {effect.effectType} (passive: {effect.isPassive}, primary: {effect.primaryValue}, secondary: {effect.secondaryValue})");
}
}

NodeData nodeClone = CloneNodeWithoutSequence(editorNode);
nodeClone.orderIndex = orderIndex++;
nodeClone.canBeDeleted = false;
plantGraph.nodes.Add(nodeClone);

Debug.Log($"[NodeExecutor] Node clone has {nodeClone.effects?.Count ?? 0} effects");
}

Debug.Log($"[NodeExecutor] Final plant graph has {plantGraph.nodes.Count} nodes:");
foreach (var node in plantGraph.nodes) {
Debug.Log($"  - {node.nodeDisplayName} (order: {node.orderIndex}) with {node.effects?.Count ?? 0} effects");
if (node.effects != null) {
foreach (var effect in node.effects) {
Debug.Log($"    - {effect.effectType} (passive: {effect.isPassive}, primary: {effect.primaryValue})");
}
}
}

GameObject plantObj = Instantiate(plantPrefab, plantingPosition, Quaternion.identity, parentTransform);

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(plantObj);
}

PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
if (growthComponent != null) {
growthComponent.InitializeAndGrow(plantGraph);
Debug.Log($"[NodeExecutor] Plant spawned with seed '{seedInSlot.nodeDisplayName}'");
ret plantObj;
}
else {
Debug.LogError($"[NodeExecutor] Plant prefab missing PlantGrowth component!");
Destroy(plantObj);
ret null;
}
}

pub GameObject SpawnPlantFromInventorySeed(NodeData seedData, Vector3 spawnPos, Transform parent) {
if (seedData == null || !seedData.IsSeed()) {
Debug.LogError("[NodeExecutor] Invalid seed data provided!");
ret null;
}

if (plantPrefab == null) {
Debug.LogError("[NodeExecutor] Plant prefab not assigned!");
ret null;
}

NodeGraph plantGraph = new NodeGraph { nodes = new List<NodeData>() };

NodeData seedClone = CloneNodeWithoutSequence(seedData);
seedClone.orderIndex = 0;
seedClone.canBeDeleted = false;
plantGraph.nodes.Add(seedClone);

if (seedData.storedSequence?.nodes != null) {
int orderIndex = 1;
foreach (NodeData sequenceNode in seedData.storedSequence.nodes.OrderBy(n => n.orderIndex)) {
if (sequenceNode == null) continue;

NodeData nodeClone = CloneNodeWithoutSequence(sequenceNode);
nodeClone.orderIndex = orderIndex++;
nodeClone.canBeDeleted = false;
plantGraph.nodes.Add(nodeClone);
}
}

GameObject plantObj = Instantiate(plantPrefab, spawnPos, Quaternion.identity, parent);

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(plantObj);
}

PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
if (growthComponent != null) {
growthComponent.InitializeAndGrow(plantGraph);
ret plantObj;
}
else {
Debug.LogError("[NodeExecutor] Plant prefab missing PlantGrowth component!");
Destroy(plantObj);
ret null;
}
}

void DebugLog(string msg) {
if (debugOutput != null) debugOutput.text += msg + "\n";
}

void DebugLogError(string msg) {
Debug.LogError($"[NodeExecutor] {msg}");
if (debugOutput != null) debugOutput.text += $"ERROR: {msg}\n";
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\OutputNodeEffect.cs

﻿using UnityEngine;

pub cls OutputNodeEffect : MonoBehaviour {
pub GameObject projectilePrefab;

pub Vector2 spawnOffset = Vector2.up;

PlantGrowth parentPlantGrowth;

void Awake() {
parentPlantGrowth = GetComponentInParent<PlantGrowth>();
if (parentPlantGrowth == null) {
Debug.LogError($"[{nameof(OutputNodeEffect)}] Could not find parent PlantGrowth component! Scent application will fail.", gameObject);
}
}

pub void Activate(float damageMultiplier, Dictionary<ScentDefinition, float> scentRadiusBonuses, // <<< UPDATED TYPE Dictionary<ScentDefinition, float> scentStrengthBonuses) // <<< UPDATED TYPE {
if (projectilePrefab == null) {
Debug.LogError($"[{nameof(OutputNodeEffect)}] Projectile Prefab not assigned!", gameObject);
return;
}

if (parentPlantGrowth == null) { // Check again in case Awake failed silently
Debug.LogError($"[{nameof(OutputNodeEffect)}] Cannot activate, parent PlantGrowth reference is missing. Scent application will fail.", gameObject);
}

Vector2 spawnPos = (Vector2)transform.position + spawnOffset;
GameObject projGO = Instantiate(projectilePrefab, spawnPos, transform.rotation); // Use plant's rotation or aim logic

if (parentPlantGrowth != null) // Check if reference exists before calling {

parentPlantGrowth.ApplyScentDataToObject(projGO, scentRadiusBonuses, scentStrengthBonuses);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantCell.cs

﻿using UnityEngine;

pub enum PlantCellType { Seed, Stem, Leaf, Flower, Fruit }

pub cls PlantCell : MonoBehaviour {
[HideInInspector] pub PlantGrowth ParentPlantGrowth;
[HideInInspector] pub Vector2Int GridCoord;
[HideInInspector] pub PlantCellType CellType;

void OnDestroy() {
if (ParentPlantGrowth != null) {
if (CellType == PlantCellType.Leaf) {
if (Debug.isDebugBuild)
Debug.Log($"[PlantCell OnDestroy] Leaf at {GridCoord} is being destroyed - notifying parent plant", gameObject);
}

ParentPlantGrowth.ReportCellDestroyed(GridCoord);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantCellManager.cs

﻿using UnityEngine;
using WegoSystem;

pub cls PlantCellManager {
ro PlantGrowth plant;
ro GameObject seedCellPrefab;
ro GameObject stemCellPrefab;
ro GameObject leafCellPrefab;
ro GameObject berryCellPrefab;
ro float cellSpacing;

ro Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
ro List<GameObject> activeCellGameObjects = new List<GameObject>();

pub List<LeafData> LeafDataList { get; } = new List<LeafData>();
pub GameObject RootCellInstance { get; set; }

bool? offsetRightForPattern1 = null;

pub PlantCellManager(PlantGrowth plant, GameObject seedPrefab, GameObject stemPrefab, GameObject leafPrefab, GameObject berryPrefab, float spacing) {
this.plant = plant;
seedCellPrefab = seedPrefab;
stemCellPrefab = stemPrefab;
leafCellPrefab = leafPrefab;
berryCellPrefab = berryPrefab;
cellSpacing = spacing;
}

pub GameObject CreateSeedCell(Vector2Int coords) {
ret SpawnCellVisual(PlantCellType.Seed, coords);
}

pub void ReportCellDestroyed(Vector2Int coord) {
if (cells.ContainsKey(coord)) {
PlantCellType cellType = cells[coord];

if (cellType == PlantCellType.Leaf) {
for (int i = 0; i < LeafDataList.Count; i++) {
if (LeafDataList[i].GridCoord == coord) {
LeafData updatedData = LeafDataList[i];
updatedData.IsActive = false;
LeafDataList[i] = updatedData;

}
}
}

cells.Remove(coord);
activeCellGameObjects.RemoveAll(go => go == null || (go.GetComponent<PlantCell>()?.GridCoord == coord));

if (plant.IsOutlineEnabled() && plant.VisualManager.OutlineController != null) {
plant.VisualManager.OutlineController.OnPlantCellRemoved(coord);
}
}
}

pub void ClearAllVisuals() {
List<GameObject> cellsToClear = new List<GameObject>(activeCellGameObjects);
foreach (GameObject cellGO in cellsToClear) {
if (cellGO != null) {
Object.Destroy(cellGO);
}
}
activeCellGameObjects.Clear();
cells.Clear();
RootCellInstance = null;
}

pub GameObject SpawnCellVisual(PlantCellType cellType, Vector2Int coords, Dictionary<ScentDefinition, float> accumulatedScentRadiusBonus = null, Dictionary<ScentDefinition, float> accumulatedScentStrengthBonus = null) {
if (cells.ContainsKey(coords)) {
Debug.LogWarning($"[{plant.gameObject.name}] Trying to spawn {cellType} at occupied coord {coords}. This can lead to data mismatches.");
}

GameObject prefab = null;
switch (cellType) {
case PlantCellType.Seed: prefab = seedCellPrefab; break;
case PlantCellType.Stem: prefab = stemCellPrefab; break;
case PlantCellType.Leaf: prefab = leafCellPrefab; break;
case PlantCellType.Fruit: prefab = berryCellPrefab; break;
}

if (prefab == null) {
Debug.LogError($"[{plant.gameObject.name}] Prefab for PlantCellType.{cellType} is null!");
ret null;
}

Vector2 worldPos = (Vector2)plant.transform.position + ((Vector2)coords * cellSpacing);
GameObject instance = Object.Instantiate(prefab, worldPos, Quaternion.identity, plant.transform);
instance.name = $"{plant.gameObject.name}_{cellType}_{coords.x}_{coords.y}";

if (cellType != PlantCellType.Seed) {
GridEntity partGridEntity = instance.GetComponent<GridEntity>();
if (partGridEntity != null) {
Object.Destroy(partGridEntity);
}
}

PlantCell cellComp = instance.GetComponent<PlantCell>() ?? instance.AddComponent<PlantCell>();
cellComp.ParentPlantGrowth = plant;
cellComp.GridCoord = coords;
cellComp.CellType = cellType;

cells[coords] = cellType;
activeCellGameObjects.Add(instance);

SortableEntity sorter = instance.GetComponent<SortableEntity>() ?? instance.AddComponent<SortableEntity>();

if (cellType == PlantCellType.Leaf) {
LeafDataList.Add(new LeafData(coords, true));
}

plant.VisualManager.RegisterShadowForCell(instance, cellType.ToString());

if (plant.IsOutlineEnabled() && plant.VisualManager.OutlineController != null) {
plant.VisualManager.RegisterOutlineForCell(instance, cellType.ToString());
}

if (accumulatedScentRadiusBonus != null && accumulatedScentStrengthBonus != null) {
plant.ApplyScentDataToObject(instance, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
}

ret instance;
}

pub GameObject CreateStemSegment(int stemIndex, Dictionary<ScentDefinition, float> accumulatedScentRadiusBonus = null, Dictionary<ScentDefinition, float> accumulatedScentStrengthBonus = null) {
Vector2Int stemCoord = new Vector2Int(0, stemIndex + 1);
ret SpawnCellVisual(PlantCellType.Stem, stemCoord, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
}

pub List<GameObject> CreateLeavesForStemSegment(int stemIndex, int leafGap, int leafPattern, Dictionary<ScentDefinition, float> accumulatedScentRadiusBonus = null, Dictionary<ScentDefinition, float> accumulatedScentStrengthBonus = null) {
List<GameObject> newLeaves = new List<GameObject>();

if (leafGap == 0 || (stemIndex % (leafGap + 1)) == 0) {
Vector2Int stemCoord = new Vector2Int(0, stemIndex + 1);
List<Vector2Int> leafPositions = CalculateLeafPositions(stemCoord, leafPattern, stemIndex);

foreach (Vector2Int leafCoord in leafPositions) {
GameObject leafInstance = SpawnCellVisual(PlantCellType.Leaf, leafCoord, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
if (leafInstance != null) {
newLeaves.Add(leafInstance);
}
}
}

ret newLeaves;
}

pub List<Vector2Int> CalculateLeafPositions(Vector2Int stemPos, int leafPattern, int stageCounter) {
List<Vector2Int> leafPositions = new List<Vector2Int>();
Vector2Int leftBase = stemPos + Vector2Int.left;
Vector2Int rightBase = stemPos + Vector2Int.right;

switch (leafPattern) {
case 0: // Symmetrical
leafPositions.Add(leftBase);
leafPositions.Add(rightBase);
break;
case 1: // Offset
if (offsetRightForPattern1 == null) offsetRightForPattern1 = Random.value < 0.5f;
if (offsetRightForPattern1.Value) {
leafPositions.Add(leftBase);
leafPositions.Add(rightBase + Vector2Int.up);
}
else {
leafPositions.Add(leftBase + Vector2Int.up);
leafPositions.Add(rightBase);
}
break;
case 2: // Alternating
switch (stageCounter % 4) {
case 0:
case 2:
leafPositions.Add(leftBase);
leafPositions.Add(rightBase);
break;
case 1:
leafPositions.Add(leftBase + Vector2Int.up);
leafPositions.Add(rightBase);
break;
case 3:
leafPositions.Add(leftBase);
leafPositions.Add(rightBase + Vector2Int.up);
break;
}
break;
case 3: // Spiral
int spiralDir = (stageCounter % 2 == 0) ? 1 : -1;
if (spiralDir > 0) {
leafPositions.Add(rightBase);
}
else {
leafPositions.Add(leftBase);
}
break;
case 4: // Dense
leafPositions.Add(leftBase);
leafPositions.Add(leftBase + Vector2Int.up);
leafPositions.Add(rightBase);
leafPositions.Add(rightBase + Vector2Int.up);
break;
default: // Fallback to symmetrical
leafPositions.Add(leftBase);
leafPositions.Add(rightBase);
break;
}

ret leafPositions;
}

pub bool TryRegrowLeaf() {
int missingLeafIndex = -1;
for (int i = 0; i < LeafDataList.Count; i++) {
if (!LeafDataList[i].IsActive) {
missingLeafIndex = i;
break;
}
}
if (missingLeafIndex == -1) ret false; // No missing leaves to regrow

Vector2Int leafCoord = LeafDataList[missingLeafIndex].GridCoord;
if (cells.ContainsKey(leafCoord)) ret false;

GameObject newLeaf = SpawnCellVisual(PlantCellType.Leaf, leafCoord);
if (newLeaf != null) {
LeafDataList[missingLeafIndex] = new LeafData(leafCoord, true);
ret true;
}
ret false;
}

pub bool DoesCellExistAt(Vector2Int coord) => cells.ContainsKey(coord);
pub GameObject GetCellGameObjectAt(Vector2Int coord) { ret activeCellGameObjects.FirstOrDefault(go => go != null && go.GetComponent<PlantCell>()?.GridCoord == coord); }
pub Dictionary<Vector2Int, PlantCellType> GetCells() => cells;
pub bool HasCellAt(Vector2Int coord) { ret cells.ContainsKey(coord); }
pub PlantCellType? GetCellTypeAt(Vector2Int coord) { if (cells.TryGetValue(coord, out PlantCellType cellType)) { ret cellType; } ret null; }
pub int GetActiveLeafCount() { int count = 0; foreach (var leafData in LeafDataList) { if (leafData.IsActive) { count++; } } ret count; }
pub List<GameObject> ActiveCellGameObjects => activeCellGameObjects;
pub Dictionary<Vector2Int, PlantCellType> Cells => cells;
pub int GetBerryCount() { int count = 0; foreach (var kvp in cells) { if (kvp.Value == PlantCellType.Fruit) { count++; } } ret count; }
pub List<Vector2Int> GetBerryPositions() { List<Vector2Int> berryPositions = new List<Vector2Int>(); foreach (var kvp in cells) { if (kvp.Value == PlantCellType.Fruit) { berryPositions.Add(kvp.Key); } } ret berryPositions; }
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantEnergySystem.cs

﻿using UnityEngine;
using WegoSystem;

pub cls PlantEnergySystem {
ro PlantGrowth plant;

pub float CurrentEnergy { get; set; } = 0f;
pub float MaxEnergy { get; set; } = 10f;
pub float PhotosynthesisRate { get; set; }

FireflyManager fireflyManagerInstance;

pub PlantEnergySystem(PlantGrowth plant) {
this.plant = plant;
fireflyManagerInstance = FireflyManager.Instance;
}

pub void AccumulateEnergyTick() {
if (plant.GrowthLogic == null || MaxEnergy <= 0) return;

int leafCount = plant.CellManager.GetActiveLeafCount();

if (leafCount <= 0) {
return;
}

float sunlight = 1f; // Default to full sunlight

if (WeatherManager.Instance != null) {
if (WeatherManager.Instance.dayNightCycleEnabled &&
!WeatherManager.Instance.IsPaused) {
sunlight = WeatherManager.Instance.sunIntensity;
}
}

float tileMultiplier = (PlantGrowthModifierManager.Instance != null) ?
PlantGrowthModifierManager.Instance.GetEnergyRechargeMultiplier(plant) : 1.0f;
float ticksPerSecond = TickManager.Instance?.Config?.ticksPerRealSecond ?? 2f;

float efficiencyPerLeaf = plant.GrowthLogic.PhotosynthesisEfficiencyPerLeaf;

float fireflyBonusRate = 0f;
if (fireflyManagerInstance != null) {
GridEntity plantGrid = plant.GetComponent<GridEntity>();
if (plantGrid != null) {
int radiusTiles = Mathf.CeilToInt(fireflyManagerInstance.photosynthesisRadius);
int nearbyFlyCount = 0;
var fireflies = Object.FindObjectsByType<FireflyController>(FindObjectsSortMode.None);
foreach (var firefly in fireflies) {
GridEntity fireflyGrid = firefly.GetComponent<GridEntity>();
if (fireflyGrid != null &&
GridRadiusUtility.IsWithinCircleRadius(fireflyGrid.Position, plantGrid.Position, radiusTiles)) {
nearbyFlyCount++;
}
}
fireflyBonusRate = Mathf.Min(
nearbyFlyCount * fireflyManagerInstance.photosynthesisIntensityPerFly,
fireflyManagerInstance.maxPhotosynthesisBonus
);
}
}

float totalPhotosynthesisRatePerLeaf = (efficiencyPerLeaf * sunlight) + fireflyBonusRate;
float energyThisTick = (totalPhotosynthesisRatePerLeaf * leafCount) / ticksPerSecond;
float totalGain = energyThisTick * tileMultiplier;

if (Debug.isDebugBuild && Time.frameCount % 60 == 0) { // Log every 60 frames
Debug.Log($"[{plant.gameObject.name}] Photosynthesis: " +
$"Sunlight={sunlight:F2}, " +
$"Leaves={leafCount}, " +
$"FireflyBonus={fireflyBonusRate:F2}, " +
$"EnergyGain={totalGain:F2}/tick, " +
$"Current={CurrentEnergy:F1}/{MaxEnergy:F0}");
}

CurrentEnergy = Mathf.Clamp(CurrentEnergy + totalGain, 0f, MaxEnergy);
}

pub void SpendEnergy(float amount) {
CurrentEnergy = Mathf.Max(0f, CurrentEnergy - amount);
}

pub void AddEnergy(float amount) {
CurrentEnergy = Mathf.Clamp(CurrentEnergy + amount, 0f, MaxEnergy);
}

pub bool HasEnergy(float amount) {
ret CurrentEnergy >= amount;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantGrowth.cs

﻿using System.Collections.Generic;
using WegoSystem;

pub enum PlantState { Initializing, Growing, GrowthComplete, Mature_Idle, Mature_Executing }

pub cls PlantGrowth : MonoBehaviour, ITickUpdateable {
pub stat ro List<PlantGrowth> AllActivePlants = new List<PlantGrowth>();

pub PlantCellManager CellManager { get; set; }
pub PlantNodeExecutor NodeExecutor { get; set; }
pub PlantGrowthLogic GrowthLogic { get; set; }
pub PlantEnergySystem EnergySystem { get; set; }
pub PlantVisualManager VisualManager { get; set; }
pub NodeGraph NodeGraph { get; set; }
pub PlantState CurrentState { get; set; } = PlantState.Initializing;

[SerializeField] GameObject seedCellPrefab;
[SerializeField] GameObject stemCellPrefab;
[SerializeField] GameObject leafCellPrefab;
[SerializeField] GameObject berryCellPrefab;
[SerializeField] float cellSpacing = 0.08f;

[SerializeField] PlantShadowController shadowController;
[SerializeField] GameObject shadowPartPrefab;
[SerializeField] bool enableOutline = true;
[SerializeField] PlantOutlineController outlineController;
[SerializeField] GameObject outlinePartPrefab;

[SerializeField] pub NodeDefinition berryNodeDefinition; // This is what the plant produces when harvested

[SerializeField] pub bool showGrowthPercentage = true;
[SerializeField] pub bool allowPhotosynthesisDuringGrowth = false;

void Awake() {
InitializeComponents();
ValidateReferences();
AllActivePlants.Add(this);
}

void InitializeComponents() {
CellManager = new PlantCellManager(this, seedCellPrefab, stemCellPrefab, leafCellPrefab, berryCellPrefab, cellSpacing);
NodeExecutor = new PlantNodeExecutor(this);
GrowthLogic = new PlantGrowthLogic(this);
EnergySystem = new PlantEnergySystem(this);

GameObject outlinePrefabToUse = null;
if (outlineController != null && outlineController.outlinePartPrefab != null) {
outlinePrefabToUse = outlineController.outlinePartPrefab;
}
else {
outlinePrefabToUse = outlinePartPrefab;
}

VisualManager = new PlantVisualManager(this, shadowController, shadowPartPrefab, outlineController, outlinePrefabToUse, enableOutline);
}

void ValidateReferences() {
bool setupValid = true;

if (shadowController == null) {
shadowController = GetComponentInChildren<PlantShadowController>(true);
if (shadowController == null) {
Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': PlantShadowController ref missing!", this);
setupValid = false;
}
}

if (shadowPartPrefab == null) {
Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Shadow Part Prefab missing!", this);
setupValid = false;
}

if (enableOutline) {
if (outlineController == null) {
outlineController = GetComponentInChildren<PlantOutlineController>(true);
if (outlineController == null) {
Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': PlantOutlineController ref missing but outline is enabled!", this);
setupValid = false;
}
}

GameObject availableOutlinePrefab = GetOutlinePartPrefab();
if (availableOutlinePrefab == null) {
Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Outline Part Prefab missing but outline is enabled!", this);
setupValid = false;
}
}

if (seedCellPrefab == null) {
Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Seed Cell Prefab missing!", this);
setupValid = false;
}

if (!setupValid) {
enabled = false;
return;
}

if (!enableOutline && outlineController != null) {
outlineController.gameObject.SetActive(false);
}
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
VisualManager.UpdateUI();
}

void OnDestroy() {
AllActivePlants.Remove(this);

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}

if (PlantGrowthModifierManager.Instance != null) {
PlantGrowthModifierManager.Instance.UnregisterPlant(this);
}

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}

CellManager?.ClearAllVisuals();
}

pub void OnTickUpdate(int currentTick) {
if (!enabled) return;

switch (CurrentState) {
case PlantState.Initializing:
break;

case PlantState.Growing:
GrowthLogic.OnTickUpdate(currentTick);
if (allowPhotosynthesisDuringGrowth) {
EnergySystem.AccumulateEnergyTick();
}
break;

case PlantState.GrowthComplete:
TransitionToMature();
break;

case PlantState.Mature_Idle:
EnergySystem.AccumulateEnergyTick();
GrowthLogic.OnTickUpdate(currentTick);
UpdateRadiusVisualizations();
break;

case PlantState.Mature_Executing:
EnergySystem.AccumulateEnergyTick();
GrowthLogic.OnTickUpdate(currentTick);
break;
}

VisualManager.UpdateWegoUI();
}

void UpdateRadiusVisualizations() {
if (GridDebugVisualizer.Instance != null) {
GridEntity gridEntity = GetComponent<GridEntity>();
if (gridEntity != null) {
float poopRadius = GetPoopDetectionRadius();
if (poopRadius > 0.01f) {
int radiusTiles = Mathf.RoundToInt(poopRadius);
GridDebugVisualizer.Instance.VisualizePlantPoopRadius(this, gridEntity.Position, radiusTiles);
}
else {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}
}
}

pub void InitializeAndGrow(NodeGraph graph) {
if (graph == null || graph.nodes == null || graph.nodes.Count == 0) {
Debug.LogError($"[{gameObject.name}] Null/empty NodeGraph provided. Aborting growth.", gameObject);
CurrentState = PlantState.Mature_Idle;
Destroy(gameObject, 0.1f);
return;
}

CellManager.ClearAllVisuals();
VisualManager.ResetDisplayState();

NodeGraph = graph;
CurrentState = PlantState.Initializing;
EnergySystem.CurrentEnergy = 0f;
CellManager.LeafDataList.Clear();

GrowthLogic.CalculateAndApplyStats();

GameObject spawnedSeed = CellManager.CreateSeedCell(Vector2Int.zero);
if (spawnedSeed != null) {
CellManager.RootCellInstance = spawnedSeed;
RegisterWithManagers();

if (GrowthLogic.TargetStemLength > 0) {
CurrentState = PlantState.Growing;
VisualManager.UpdateGrowthPercentageUI();
}
else {
Debug.LogWarning($"[{gameObject.name}] Target stem length is {GrowthLogic.TargetStemLength}. Skipping visual growth phase.", gameObject);
GrowthLogic.CompleteGrowth();
}

VisualManager.UpdateShadow();
VisualManager.UpdateOutline();
}
else {
Debug.LogError($"[{gameObject.name}] Failed to spawn initial seed! Aborting growth.", gameObject);
CurrentState = PlantState.Mature_Idle;
Destroy(gameObject, 0.1f);
}
}

void TransitionToMature() {
CurrentState = PlantState.Mature_Idle;

if (GrowthLogic.GrowthTicksPerStage <= 1) {
Debug.Log($"[{gameObject.name}] Growth completed instantly. Skipping visual growth phase.", gameObject);
GrowthLogic.CompleteGrowth();
}
else {
Debug.Log($"[{gameObject.name}] Growth completed! Transitioning to mature state.");
}
}

void RegisterWithManagers() {
if (PlantGrowthModifierManager.Instance != null && TileInteractionManager.Instance != null) {
Vector3Int gridPos = TileInteractionManager.Instance.WorldToCell(transform.position);
TileDefinition currentTile = TileInteractionManager.Instance.FindWhichTileDefinitionAt(gridPos);
PlantGrowthModifierManager.Instance.RegisterPlantTile(this, currentTile);
}
}

pub List<NodeDefinition> Harvest() {
var harvestedDefs = new List<NodeDefinition>();
var harvestableBerries = new List<GameObject>();

var tags = GetComponentsInChildren<HarvestableTag>();
foreach (var tag in tags) {
if (tag.HarvestedItemDefinition == null) {
Debug.LogWarning($"Found a harvestable berry on '{gameObject.name}' but its HarvestedItemDefinition was null. It will not be harvested. Check Plant an Berry Node Definition assignment.", tag.gameObject);
continue;
}

var cell = tag.GetComponent<PlantCell>();
if (cell != null && cell.CellType == PlantCellType.Fruit) {
harvestableBerries.Add(tag.gameObject);
}
else if (cell == null) // Also harvest items that might not be on the plant's grid system {
harvestableBerries.Add(tag.gameObject);
}
}

if (harvestableBerries.Count == 0) {
Debug.LogWarning($"[PlantGrowth] Harvest called on '{gameObject.name}', but no GameObjects with a valid 'HarvestableTag' component were found as children. Ensure the berry-producing gene has a PASSIVE 'Harvestable' effect.", gameObject);
ret harvestedDefs;
}

foreach (var berryGO in harvestableBerries) {
var tag = berryGO.GetComponent<HarvestableTag>();
var cell = berryGO.GetComponent<PlantCell>();

harvestedDefs.Add(tag.HarvestedItemDefinition);

if (cell != null) {
ReportCellDestroyed(cell.GridCoord);
}
Destroy(berryGO);
}

Debug.Log($"[PlantGrowth] Harvested {harvestedDefs.Count} berries from {gameObject.name}");
ret harvestedDefs;
}

pub float GetCellSpacing() => cellSpacing;
pub bool IsOutlineEnabled() => enableOutline;
pub GameObject GetCellGameObjectAt(Vector2Int coord) => CellManager.GetCellGameObjectAt(coord);
pub GameObject GetOutlinePartPrefab() { if (outlineController != null && outlineController.outlinePartPrefab != null) { ret outlineController.outlinePartPrefab; } ret outlinePartPrefab; }
pub float GetPoopDetectionRadius() { if (NodeGraph?.nodes == null) ret 0f; foreach (var node in NodeGraph.nodes) { if (node?.effects == null) continue; var poopEffect = node.effects.FirstOrDefault(e => e.effectType == NodeEffectType.PoopAbsorption); if (poopEffect != null) { ret poopEffect.primaryValue; } } ret 0f; }
pub bool DoesCellExistAt(Vector2Int coord) => CellManager.DoesCellExistAt(coord);
pub void ReportCellDestroyed(Vector2Int coord) => CellManager.ReportCellDestroyed(coord);
pub void ApplyScentDataToObject(GameObject targetObject, Dictionary<ScentDefinition, float> scentRadiusBonuses, Dictionary<ScentDefinition, float> scentStrengthBonuses) => NodeExecutor.ApplyScentDataToObject(targetObject, scentRadiusBonuses, scentStrengthBonuses);
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantGrowthLogic.cs

﻿using UnityEngine;
using WegoSystem;

pub cls PlantGrowthLogic {
ro PlantGrowth plant;

pub int TargetStemLength { get; set; }
pub int GrowthTicksPerStage { get; set; }
pub int LeafGap { get; set; }
pub int LeafPattern { get; set; }
pub float GrowthRandomness { get; set; }
pub int MaturityCycleTicks { get; set; }
pub int NodeCastDelayTicks { get; set; }
pub float PhotosynthesisEfficiencyPerLeaf { get; set; }
pub float EnergyCostPerCycle { get; set; }
pub int MaxBerries { get; set; }

pub float PoopDetectionRadius { get; set; }
pub float EnergyPerPoop { get; set; }

float growthProgressTicks = 0f;
int maturityCycleTick = 0;
int currentStemStage = 0;
List<PoopController> _poopsToAbsorbNextTick = new List<PoopController>();
int _poopScanCooldownTicks = 0;
c int POOP_ABSORB_COOLDOWN = 5;

pub PlantGrowthLogic(PlantGrowth plant) {
this.plant = plant;
}

pub void CalculateAndApplyStats() {
if (plant.NodeGraph == null) {
Debug.LogError($"[{plant.gameObject.name}] CalculateAndApplyStats called with null NodeGraph!");
return;
}

float basePhotosynthesisEfficiency = FloraManager.Instance != null
? FloraManager.Instance.basePhotosynthesisRatePerLeaf
: 0.1f;

float baseEnergyStorage = 10f;
int baseStemMin = 3;
int baseStemMax = 5;
int baseGrowthTicksPerStage = 5;
int baseLeafGap = 1;
int baseLeafPattern = 0;
float baseGrowthRandomness = 0.1f;
int baseCooldownTicks = 20;
int baseCastDelayTicks = 0;
bool seedFound = false;
int baseMaxBerries = 3;

NodeData firstNode = plant.NodeGraph.nodes.FirstOrDefault();
if (firstNode != null) {
var seedEffect = firstNode.effects?.FirstOrDefault(e => e != null && e.effectType == NodeEffectType.SeedSpawn);
if (seedEffect != null && seedEffect.seedData != null) {
seedFound = true;
baseEnergyStorage = seedEffect.seedData.energyStorage;
baseGrowthTicksPerStage = seedEffect.seedData.growthSpeed;
baseStemMin = seedEffect.seedData.stemLengthMin;
baseStemMax = seedEffect.seedData.stemLengthMax;
baseLeafGap = seedEffect.seedData.leafGap;
baseLeafPattern = seedEffect.seedData.leafPattern;
baseGrowthRandomness = seedEffect.seedData.stemRandomness;
baseCooldownTicks = seedEffect.seedData.cooldown;
baseCastDelayTicks = seedEffect.seedData.castDelay;
baseMaxBerries = seedEffect.seedData.maxBerries;
}
}

float accumulatedEnergyStorage = 0f;
float accumulatedPhotosynthesisEfficiency = 0f;
int stemLengthMinModifier = 0;
int stemLengthMaxModifier = 0;
int growthTicksModifier = 0;
int leafGapModifier = 0;
int currentLeafPattern = baseLeafPattern;
float growthRandomnessModifier = 0f;
int cooldownTicksModifier = 0;
int castDelayTicksModifier = 0;
PoopDetectionRadius = 0f;
EnergyPerPoop = 0f;

foreach (NodeData node in plant.NodeGraph.nodes.OrderBy(n => n.orderIndex)) {
if (node?.effects == null) continue;

foreach (var effect in node.effects) {
if (effect == null || !effect.isPassive) continue;
if (effect.effectType == NodeEffectType.SeedSpawn) {
seedFound = true;
continue;
}
effect.ValidateForTicks();

switch (effect.effectType) {
case NodeEffectType.EnergyStorage: accumulatedEnergyStorage += effect.primaryValue; break;
case NodeEffectType.EnergyPerTick: accumulatedPhotosynthesisEfficiency += effect.primaryValue; break;
case NodeEffectType.StemLength:
stemLengthMinModifier += effect.GetPrimaryValueAsInt();
stemLengthMaxModifier += effect.GetSecondaryValueAsInt(); break;
case NodeEffectType.GrowthSpeed: growthTicksModifier += effect.GetPrimaryValueAsInt(); break;
case NodeEffectType.LeafGap: leafGapModifier += effect.GetPrimaryValueAsInt(); break;
case NodeEffectType.LeafPattern: currentLeafPattern = Mathf.Clamp(effect.GetPrimaryValueAsInt(), 0, 4); break;
case NodeEffectType.StemRandomness: growthRandomnessModifier += effect.primaryValue; break;
case NodeEffectType.Cooldown: cooldownTicksModifier += effect.GetPrimaryValueAsInt(); break;
case NodeEffectType.CastDelay: castDelayTicksModifier += effect.GetPrimaryValueAsInt(); break;
case NodeEffectType.PoopAbsorption:
PoopDetectionRadius = Mathf.Max(PoopDetectionRadius, effect.primaryValue);
EnergyPerPoop = Mathf.Max(EnergyPerPoop, effect.secondaryValue);
break;
}
}
}

plant.EnergySystem.MaxEnergy = Mathf.Max(1f, baseEnergyStorage + accumulatedEnergyStorage);
PhotosynthesisEfficiencyPerLeaf = Mathf.Max(0f, basePhotosynthesisEfficiency + accumulatedPhotosynthesisEfficiency);

int finalStemMin = Mathf.Max(1, baseStemMin + stemLengthMinModifier);
int finalStemMax = Mathf.Max(finalStemMin, baseStemMax + stemLengthMaxModifier);
TargetStemLength = seedFound ? Random.Range(finalStemMin, finalStemMax + 1) : 0;

GrowthTicksPerStage = Mathf.Max(1, baseGrowthTicksPerStage + growthTicksModifier);
LeafGap = Mathf.Max(0, baseLeafGap + leafGapModifier);
LeafPattern = currentLeafPattern;
GrowthRandomness = Mathf.Clamp01(baseGrowthRandomness + growthRandomnessModifier);
MaturityCycleTicks = Mathf.Max(1, baseCooldownTicks + cooldownTicksModifier);
NodeCastDelayTicks = Mathf.Max(0, baseCastDelayTicks + castDelayTicksModifier);
MaxBerries = baseMaxBerries;

if (!seedFound) {
Debug.LogWarning($"[{plant.gameObject.name}] NodeGraph lacks a SeedSpawn effect. Growth aborted.", plant.gameObject);
}
}

pub void OnTickUpdate(int currentTick) {
AbsorbPendingPoops();
if (_poopScanCooldownTicks > 0) {
_poopScanCooldownTicks--;
}
ScanForPoop();

switch (plant.CurrentState) {
case PlantState.Growing:
float growthMultiplier = 1.0f;
if (PlantGrowthModifierManager.Instance != null) {
growthMultiplier = PlantGrowthModifierManager.Instance.GetGrowthSpeedMultiplier(plant);
}
growthProgressTicks += growthMultiplier;

if (growthProgressTicks >= GrowthTicksPerStage) {
growthProgressTicks = 0f;
GrowNextStemStage();

if (currentStemStage >= TargetStemLength) {
CompleteGrowth();
}
}
break;
case PlantState.Mature_Idle:
maturityCycleTick++;
if (maturityCycleTick >= MaturityCycleTicks && plant.EnergySystem.CurrentEnergy >= 1f) {
plant.CurrentState = PlantState.Mature_Executing;
plant.NodeExecutor.ExecuteMatureCycleTick();
maturityCycleTick = 0;
}
break;
case PlantState.Mature_Executing:
plant.CurrentState = PlantState.Mature_Idle;
break;
}
}

void AbsorbPendingPoops() {
if (_poopsToAbsorbNextTick.Count == 0) return;

foreach (var poop in _poopsToAbsorbNextTick) {
if (poop != null && poop.gameObject != null) {
if (EnergyPerPoop > 0) {
plant.EnergySystem.AddEnergy(EnergyPerPoop);
}
Object.Destroy(poop.gameObject);
if (Debug.isDebugBuild)
Debug.Log($"[{plant.gameObject.name}] Absorbed poop, gained {EnergyPerPoop} energy.");
_poopScanCooldownTicks = POOP_ABSORB_COOLDOWN;
}
}
_poopsToAbsorbNextTick.Clear();
}

void ScanForPoop() {
if (PoopDetectionRadius <= 0 || _poopsToAbsorbNextTick.Count > 0 || _poopScanCooldownTicks > 0) return;

GridEntity plantGrid = plant.GetComponent<GridEntity>();
if (plantGrid == null) return;

int radiusTiles = Mathf.RoundToInt(PoopDetectionRadius);

if (Debug.isDebugBuild && Time.frameCount % 60 == 0) {
Debug.Log($"[{plant.gameObject.name}] Scanning for poop with radius {radiusTiles} at position {plantGrid.Position}");
}

var tilesInRadius = GridRadiusUtility.GetTilesInCircle(plantGrid.Position, radiusTiles);

foreach (var tile in tilesInRadius) {
var entitiesAtTile = GridPositionManager.Instance.GetEntitiesAt(tile);
if (entitiesAtTile.Count > 0) {
foreach (var entity in entitiesAtTile) {
if (entity == null) continue;
PoopController poop = entity.GetComponent<PoopController>();
if (poop != null) {
_poopsToAbsorbNextTick.Add(poop);
if (Debug.isDebugBuild)
Debug.Log($"[{plant.gameObject.name}] <color=green>SUCCESS:</color> Detected poop at {poop.GetComponent<GridEntity>().Position}. Will absorb next tick.");
return;
}
}
}
}
}

void GrowNextStemStage() {
if (currentStemStage >= TargetStemLength) return;
currentStemStage++;

Vector2Int stemPos;
if (currentStemStage == 1) {
stemPos = Vector2Int.up;
}
else {
Vector2Int previousStemPos = Vector2Int.zero;
bool foundPreviousStem = false;

for (int i = currentStemStage - 1; i >= 1; i--) {
var cells = plant.CellManager.GetCells();
foreach (var kvp in cells) {
if (kvp.Value == PlantCellType.Stem && kvp.Key.y == i) {
previousStemPos = kvp.Key;
foundPreviousStem = true;
break;
}
}
if (foundPreviousStem) break;
}

if (!foundPreviousStem) {
Debug.LogError($"[{plant.gameObject.name}] Could not find previous stem at stage {currentStemStage - 1}! Using default position.");
previousStemPos = Vector2Int.up * (currentStemStage - 1);
}

stemPos = previousStemPos + Vector2Int.up;

if (Random.value < GrowthRandomness) {
int wobbleDirection = (Random.value < 0.5f) ? -1 : 1;
stemPos.x = previousStemPos.x + wobbleDirection;
}
else {
stemPos.x = previousStemPos.x;
}

int attempts = 0;
while (plant.CellManager.HasCellAt(stemPos) && attempts < 5) {
attempts++;
switch (attempts) {
case 1: stemPos = previousStemPos + Vector2Int.up; break;
case 2: stemPos = previousStemPos + Vector2Int.up + Vector2Int.left; break;
case 3: stemPos = previousStemPos + Vector2Int.up + Vector2Int.right; break;
case 4: stemPos = previousStemPos + Vector2Int.up + new Vector2Int(0, 1); break;
default: stemPos = previousStemPos + Vector2Int.up; break;
}
}
if (plant.CellManager.HasCellAt(stemPos)) {
var existingCellType = plant.CellManager.GetCellTypeAt(stemPos);
Debug.LogError($"[{plant.gameObject.name}] Cannot spawn stem at stage {currentStemStage} - position {stemPos} occupied by {existingCellType}! Previous stem was at {previousStemPos}");
return;
}
}

GameObject stemCell = plant.CellManager.SpawnCellVisual(PlantCellType.Stem, stemPos, null, null);
if (stemCell == null) {
Debug.LogError($"[{plant.gameObject.name}] Failed to spawn stem at stage {currentStemStage} at position {stemPos}");
return;
}

if (LeafGap >= 0 && (currentStemStage % (LeafGap + 1)) == 0) {
var leafPositions = plant.CellManager.CalculateLeafPositions(stemPos, LeafPattern, currentStemStage);
foreach (Vector2Int leafPos in leafPositions) {
if (!plant.CellManager.HasCellAt(leafPos)) {
GameObject leafCell = plant.CellManager.SpawnCellVisual(PlantCellType.Leaf, leafPos, null, null);
if (leafCell != null) {
plant.CellManager.LeafDataList.Add(new LeafData(leafPos, true));
}
}
else {
if (Debug.isDebugBuild)
Debug.LogWarning($"[{plant.gameObject.name}] Skipping leaf at {leafPos} - position occupied");
}
}
}
}

pub void CompleteGrowth() {
if (plant.CurrentState == PlantState.GrowthComplete) return;

plant.CurrentState = PlantState.Mature_Idle;
maturityCycleTick = 0;

if (Debug.isDebugBuild) {
Debug.Log($"[{plant.gameObject.name}] Growth completed! Transitioning to mature state.");
}
}

pub float GetGrowthProgressNormalized() {
if (GrowthTicksPerStage <= 0) ret 1f;
ret growthProgressTicks / GrowthTicksPerStage;
}

pub int GetCurrentStemStage() => currentStemStage;
pub void HandleGrowthComplete() => CompleteGrowth();
pub int GetStepsCompleted() => currentStemStage;
pub float GetGrowthProgress() => TargetStemLength > 0 ? (float)currentStemStage / TargetStemLength : 0f;
pub float GetActualGrowthProgress() => GrowthTicksPerStage > 0 ? growthProgressTicks / GrowthTicksPerStage : 0f;
pub int GetCurrentStemCount() => currentStemStage;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantNodeExecutor.cs

﻿using System.Collections.Generic;
using WegoSystem;

pub cls PlantNodeExecutor {
ro PlantGrowth plant;

stat ro HashSet<NodeEffectType> EnergyFreeEffectTypes = new HashSet<NodeEffectType> {
};

pub PlantNodeExecutor(PlantGrowth plant) {
this.plant = plant;
}

pub void ExecuteMatureCycleTick() {
if (plant.NodeGraph?.nodes == null || plant.NodeGraph.nodes.Count == 0) {
Debug.LogError($"[{plant.gameObject.name}] NodeGraph missing or empty!");
return;
}

Debug.Log($"[{plant.gameObject.name}] Executing mature cycle tick. Current energy: {plant.EnergySystem.CurrentEnergy:F1}/{plant.EnergySystem.MaxEnergy:F0}");

var energyFreeEffects = new List<NodeEffectData>();
var energyRequiringEffects = new List<NodeEffectData>();
var accumulatedScentRadiusBonus = new Dictionary<ScentDefinition, float>();
var accumulatedScentStrengthBonus = new Dictionary<ScentDefinition, float>();
float totalEnergyCostForCycle = 0f;

foreach (var node in plant.NodeGraph.nodes.OrderBy(n => n.orderIndex)) {
if (node?.effects == null) continue;

Debug.Log($"[{plant.gameObject.name}] Processing node '{node.nodeDisplayName}' with {node.effects.Count} effects");

foreach (var effect in node.effects) {
if (effect == null) continue;

if (effect.isPassive) {
Debug.Log($"[{plant.gameObject.name}] Skipping passive effect: {effect.effectType}");
continue;
}

if (IsEnergyFreeEffect(effect.effectType)) {
energyFreeEffects.Add(effect);
}
else {
energyRequiringEffects.Add(effect);

if (effect.effectType == NodeEffectType.EnergyCost) {
totalEnergyCostForCycle += Mathf.Max(0f, effect.primaryValue);
}
}

Debug.Log($"[{plant.gameObject.name}] Found active effect: {effect.effectType} (energy-free: {IsEnergyFreeEffect(effect.effectType)})");
}
}

if (energyFreeEffects.Count > 0) {
Debug.Log($"[{plant.gameObject.name}] Executing {energyFreeEffects.Count} energy-free effects");
foreach (var effect in energyFreeEffects) {
ExecuteEffect(effect, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
}
}

float totalCostForAbilities = totalEnergyCostForCycle;

foreach (var effect in energyRequiringEffects) {
if (effect.effectType != NodeEffectType.EnergyCost && effect.effectType == NodeEffectType.GrowBerry) {
totalCostForAbilities += 1f;
}
}

Debug.Log($"[{plant.gameObject.name}] Total energy cost for abilities: {totalCostForAbilities}");

if (totalCostForAbilities > 0 && plant.EnergySystem.CurrentEnergy < totalCostForAbilities) {
Debug.Log($"[{plant.gameObject.name}] Not enough energy ({plant.EnergySystem.CurrentEnergy:F1}/{totalCostForAbilities:F1}) for abilities. Skipping.");

if (accumulatedScentRadiusBonus.Count > 0 || accumulatedScentStrengthBonus.Count > 0) {
ApplyScentDataToObject(plant.gameObject, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
}
return;
}

if (totalCostForAbilities > 0) {
plant.EnergySystem.SpendEnergy(totalCostForAbilities);
Debug.Log($"[{plant.gameObject.name}] Spent {totalCostForAbilities} energy. Remaining: {plant.EnergySystem.CurrentEnergy:F1}");
}

if (energyRequiringEffects.Count > 0) {
Debug.Log($"[{plant.gameObject.name}] Executing {energyRequiringEffects.Count} energy-requiring effects");
foreach (var effect in energyRequiringEffects) {
ExecuteEffect(effect, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
}
}

if (accumulatedScentRadiusBonus.Count > 0 || accumulatedScentStrengthBonus.Count > 0) {
ApplyScentDataToObject(plant.gameObject, accumulatedScentRadiusBonus, accumulatedScentStrengthBonus);
}
}

bool IsEnergyFreeEffect(NodeEffectType effectType) {
ret EnergyFreeEffectTypes.Contains(effectType);
}

void ExecuteEffect(NodeEffectData effect, Dictionary<ScentDefinition, float> accumulatedScentRadiusBonus, Dictionary<ScentDefinition, float> accumulatedScentStrengthBonus) {
switch (effect.effectType) {
case NodeEffectType.PoopAbsorption:
Debug.LogWarning($"[{plant.gameObject.name}] Tried to execute PoopAbsorption as an ACTIVE effect. It should be PASSIVE. Please check the 'Is Passive' box on its NodeDefinition in the Inspector.");
break;

case NodeEffectType.GrowBerry:
SpawnBerry();
break;

case NodeEffectType.ScentModifier:
if (effect.scentDefinitionReference != null) {
ScentDefinition key = effect.scentDefinitionReference;
if (!accumulatedScentRadiusBonus.ContainsKey(key))
accumulatedScentRadiusBonus[key] = 0f;
accumulatedScentRadiusBonus[key] += effect.primaryValue;

if (!accumulatedScentStrengthBonus.ContainsKey(key))
accumulatedScentStrengthBonus[key] = 0f;
accumulatedScentStrengthBonus[key] += effect.secondaryValue;
}
break;
}
}

pub void ExecutePassiveAbilities(List<NodeEffectData> passiveEffects = null) {
if (plant.NodeGraph?.nodes == null || plant.NodeGraph.nodes.Count == 0) return;

if (passiveEffects == null) {
passiveEffects = new List<NodeEffectData>();
foreach (var node in plant.NodeGraph.nodes) {
if (node?.effects == null) continue;
foreach (var effect in node.effects) {
if (effect != null && effect.isPassive) {
passiveEffects.Add(effect);
}
}
}
}

foreach (var effect in passiveEffects) {
}
}

void SpawnBerry() {
Debug.Log($"[{plant.gameObject.name}] SpawnBerry called!");

if (plant.CellManager == null) {
Debug.LogError($"[{plant.gameObject.name}] CellManager is null!");
return;
}

var cells = plant.CellManager.GetCells();
if (cells.Count == 0) {
Debug.LogWarning($"[{plant.gameObject.name}] No cells in plant!");
return;
}

int maxBerriesAllowed = plant.GrowthLogic.MaxBerries;
bool hasLimit = maxBerriesAllowed > 0;

int currentBerryCount = plant.CellManager.GetBerryCount();

if (hasLimit && currentBerryCount >= maxBerriesAllowed) {
Debug.Log($"[{plant.gameObject.name}] Already has {currentBerryCount} berries (max: {maxBerriesAllowed}). Skipping berry spawn.");
return;
}

HashSet<Vector2Int> availablePositions = new HashSet<Vector2Int>();

foreach (var kvp in cells) {
if (kvp.Value == PlantCellType.Stem || kvp.Value == PlantCellType.Leaf) {
Vector2Int cellPos = kvp.Key;
Vector2Int[] surroundingPositions = new Vector2Int[] {
cellPos + Vector2Int.up,
cellPos + Vector2Int.down,
cellPos + Vector2Int.left,
cellPos + Vector2Int.right,
cellPos + Vector2Int.up + Vector2Int.left,
cellPos + Vector2Int.up + Vector2Int.right,
cellPos + Vector2Int.down + Vector2Int.left,
cellPos + Vector2Int.down + Vector2Int.right
};

foreach (Vector2Int pos in surroundingPositions) {
if (!plant.CellManager.HasCellAt(pos)) {
availablePositions.Add(pos);
}
}
}
}

Debug.Log($"[{plant.gameObject.name}] Found {availablePositions.Count} potential berry positions");

availablePositions.RemoveWhere(pos => pos.y <= 0);

Debug.Log($"[{plant.gameObject.name}] After filtering ground level: {availablePositions.Count} positions");

List<Vector2Int> candidatePositions = availablePositions.ToList();

if (candidatePositions.Count == 0) {
Debug.LogWarning($"[{plant.gameObject.name}] No available space to spawn berry!");
return;
}

List<Vector2Int> existingBerryPositions = plant.CellManager.GetBerryPositions();
List<Vector2Int> preferredPositions = new List<Vector2Int>();
List<Vector2Int> otherPositions = new List<Vector2Int>();

if (existingBerryPositions.Count > 0) {
foreach (var candidate in candidatePositions) {
if (IsAdjacentToExistingBerries(candidate, existingBerryPositions)) {
otherPositions.Add(candidate);
}
else {
preferredPositions.Add(candidate);
}
}
}
else {
preferredPositions.AddRange(candidatePositions);
}

List<Vector2Int> finalCandidates = preferredPositions.Count > 0 ? preferredPositions : otherPositions;

if (finalCandidates.Count == 0) {
Debug.LogWarning($"[{plant.gameObject.name}] No final candidates to spawn berry.");
return;
}

int randomIndex = Random.Range(0, finalCandidates.Count);
Vector2Int chosenPosition = finalCandidates[randomIndex];

Debug.Log($"[{plant.gameObject.name}] Attempting to spawn berry at position {chosenPosition}");

GameObject berry = plant.CellManager.SpawnCellVisual(PlantCellType.Fruit, chosenPosition, null, null);

if (berry != null) {
string limitInfo = hasLimit ? $"#{currentBerryCount + 1}/{maxBerriesAllowed}" : $"#{currentBerryCount + 1} (no limit)";
Debug.Log($"[{plant.gameObject.name}] SUCCESS: Spawned berry {limitInfo} at {chosenPosition}");
AddFoodComponentToBerry(berry);
}
else {
Debug.LogError($"[{plant.gameObject.name}] FAILED to spawn berry at {chosenPosition} - SpawnCellVisual returned null!");
}
}

bool IsAdjacentToExistingBerries(Vector2Int position, List<Vector2Int> existingBerries) {
foreach(var berryPos in existingBerries) {
if (Mathf.Max(Mathf.Abs(position.x - berryPos.x), Mathf.Abs(position.y - berryPos.y)) == 1) {
ret true;
}
}
ret false;
}

void AddFoodComponentToBerry(GameObject berry) {
if (berry == null) return;

FoodItem foodItem = berry.GetComponent<FoodItem>();
if (foodItem != null) return; // Already has one

FoodType berryFoodType = GetBerryFoodType();
if (berryFoodType != null) {
foodItem = berry.AddComponent<FoodItem>();
foodItem.foodType = berryFoodType;
}

bool isHarvestable = plant.NodeGraph.nodes.Any(node => node.effects.Any(eff => eff.isPassive && eff.effectType == NodeEffectType.Harvestable));

if (isHarvestable) {
HarvestableTag tag = berry.AddComponent<HarvestableTag>();

NodeDefinition berryDef = berry.GetComponentInParent<PlantGrowth>()?.GetComponent<PlantGrowth>().berryNodeDefinition;

if (berryDef != null) {
tag.HarvestedItemDefinition = berryDef;
Debug.Log($"[PlantNodeExecutor] Added HarvestableTag to berry and assigned '{berryDef.displayName}' as its item definition.", berry);
}
else {
Debug.LogError($"[PlantNodeExecutor] Plant '{plant.name}' created a harvestable berry, but the plant's 'Berry Node Definition' is not assigned in the Inspector. The harvested item will be null.", plant.gameObject);
}
}
}

FoodType GetBerryFoodType() {
FoodType berryType = Resources.Load<FoodType>("FoodTypes/Berry");
if (berryType != null) ret berryType;

FoodType[] allFoodTypes = Resources.LoadAll<FoodType>("");
foreach(FoodType foodType in allFoodTypes) {
if (foodType.category == FoodType.FoodCategory.Plant_Fruit) {
ret foodType;
}
}

Debug.LogWarning($"[{plant.gameObject.name}] No berry FoodType found. Berry won't be edible by animals.");
ret null;
}

pub void ApplyScentDataToObject(GameObject targetObject, Dictionary<ScentDefinition, float> scentRadiusBonuses, Dictionary<ScentDefinition, float> scentStrengthBonuses) {
if (targetObject == null) return;

foreach (var kvp in scentRadiusBonuses) {
ScentDefinition scentDef = kvp.Key;
float radiusBonus = kvp.Value;
float strengthBonus = scentStrengthBonuses.ContainsKey(scentDef) ? scentStrengthBonuses[scentDef] : 0f;

ScentSource existingSource = targetObject.GetComponentsInChildren<ScentSource>()
.FirstOrDefault(s => s.Definition == scentDef);

if (existingSource != null) {
existingSource.ApplyModifiers(radiusBonus, strengthBonus);
}
else {
GameObject scentSourceObj = new GameObject($"ScentSource_{scentDef.displayName}");
scentSourceObj.transform.SetParent(targetObject.transform);
scentSourceObj.transform.localPosition = Vector3.zero;

ScentSource newSource = scentSourceObj.AddComponent<ScentSource>();
SetScentSourceDefinition(newSource, scentDef);
newSource.SetRadiusModifier(radiusBonus);
newSource.SetStrengthModifier(strengthBonus);
}
}
}

void SetScentSourceDefinition(ScentSource source, ScentDefinition definition) {
source.SetDefinition(definition);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantVisualManager.cs

﻿using UnityEngine;
using TMPro;
using WegoSystem;

pub cls PlantVisualManager {
ro PlantGrowth plant;
ro PlantShadowController shadowController;
ro GameObject shadowPartPrefab;
ro bool enableOutline;

pub PlantOutlineController OutlineController { get; set; }
ro GameObject outlinePartPrefab;

TMP_Text energyText;
bool showGrowthPercentage;
int displayedGrowthPercentage = -1;

pub PlantVisualManager(PlantGrowth plant, PlantShadowController shadowController, GameObject shadowPartPrefab, PlantOutlineController outlineController, GameObject outlinePartPrefab, bool enableOutline) {
this.plant = plant;
this.shadowController = shadowController;
this.shadowPartPrefab = shadowPartPrefab;
this.OutlineController = outlineController;
this.outlinePartPrefab = outlinePartPrefab;
this.enableOutline = enableOutline;

EnsureUIReferences();
}

void EnsureUIReferences() {
if (energyText) return;

energyText = plant.GetComponentInChildren<TMP_Text>(true);
if (!energyText) {
Debug.LogWarning($"[{plant.gameObject.name}] Energy Text (TMP_Text) UI reference not assigned and not found in children.", plant.gameObject);
}

showGrowthPercentage = plant.showGrowthPercentage;
}

pub void RegisterShadowForCell(GameObject cellInstance, string cellTypeName) {
if (shadowController == null || shadowPartPrefab == null || cellInstance == null) return;

SpriteRenderer partRenderer = cellInstance.GetComponentInChildren<SpriteRenderer>();
if (partRenderer != null) {
shadowController.RegisterPlantPart(partRenderer, shadowPartPrefab);
}
else {
Debug.LogWarning($"Plant '{plant.gameObject.name}': {cellTypeName} missing SpriteRenderer. No shadow.", cellInstance);
}
}

pub void RegisterOutlineForCell(GameObject cellInstance, string cellTypeName) {
if (!enableOutline || OutlineController == null || cellInstance == null) return;

SpriteRenderer partRenderer = cellInstance.GetComponentInChildren<SpriteRenderer>();
if (partRenderer != null) {
OutlineController.RegisterPlantPart(partRenderer, OutlineController.outlinePartPrefab);
}
else {
Debug.LogWarning($"Plant '{plant.gameObject.name}': {cellTypeName} missing SpriteRenderer. No outline.", cellInstance);
}
}

pub void UpdateUI() {
if (energyText == null) return;

if (showGrowthPercentage && (plant.CurrentState == PlantState.Growing || plant.CurrentState == PlantState.Initializing)) {
UpdateGrowthPercentageUI();
}
else // State is Mature_Idle, Mature_Executing, GrowthComplete, etc. {
UpdateEnergyUI();
}
}

pub void UpdateGrowthPercentageUI() {
if (energyText == null || !showGrowthPercentage) return;

int currentPercentage = 0;
if (plant.GrowthLogic != null) {
currentPercentage = Mathf.RoundToInt(plant.GrowthLogic.GetGrowthProgress() * 100f);
}

if (currentPercentage != displayedGrowthPercentage) {
displayedGrowthPercentage = currentPercentage;
energyText.text = $"{displayedGrowthPercentage}%";
}
}

pub void UpdateEnergyUI() {
if (energyText == null) return;

float currentEnergy = plant.EnergySystem.CurrentEnergy;
float maxEnergy = plant.EnergySystem.MaxEnergy;
energyText.text = $"{currentEnergy:F1}/{maxEnergy:F0}";
}

pub void UpdateWegoUI() {
UpdateUI();  // Simply delegate to the main update method
}

pub void ResetDisplayState() {
displayedGrowthPercentage = -1;
}

pub void UpdateShadow() {
if (shadowController == null) return;
}

pub void UpdateOutline() {
if (!enableOutline || OutlineController == null) return;
}

pub void SetEnergyTextVisibility(bool visible) {
if (energyText != null) {
energyText.gameObject.SetActive(visible);
}
}

pub void SetGrowthPercentageDisplay(bool enabled) {
showGrowthPercentage = enabled;
if (!enabled) {
displayedGrowthPercentage = -1;
}
}

pub bool IsEnergyTextVisible() {
ret energyText != null && energyText.gameObject.activeInHierarchy;
}

pub void ForceUIUpdate() {
displayedGrowthPercentage = -1; // Force refresh
UpdateUI();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryBarController.cs

﻿using UnityEngine;

pub cls InventoryBarController : MonoBehaviour {
pub stat InventoryBarController Instance { get; set; }

[SerializeField] int slotsPerRow = 10;
[SerializeField] Vector2 cellSize = new Vector2(64f, 64f);
[SerializeField] float cellMargin = 10f;

[SerializeField] Transform cellContainer;
[SerializeField] Button upArrowButton;
[SerializeField] Button downArrowButton;
[SerializeField] GameObject selectionHighlight;

[SerializeField] Sprite emptyCellSprite;
[SerializeField] Color emptyCellColor = Color.white;

[SerializeField] InventoryGridController inventoryGridController;

ro List<NodeCell> barCells = new List<NodeCell>();
int currentRow = 0;
int selectedSlot = 0;
int totalRows = 0;

pub InventoryBarItem SelectedItem { get; set; }
pub event System.Action<InventoryBarItem> OnSelectionChanged;

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;
selectedSlot = 0;
}

void Start() {
if (upArrowButton != null) upArrowButton.onClick.AddListener(() => ChangeRow(-1));
if (downArrowButton != null) downArrowButton.onClick.AddListener(() => ChangeRow(1));

SetupBarCells();
gameObject.SetActive(false); // Start hidden
}

void OnDestroy() {
if (upArrowButton != null) upArrowButton.onClick.RemoveAllListeners();
if (downArrowButton != null) downArrowButton.onClick.RemoveAllListeners();
}

void Update() {
if (!gameObject.activeInHierarchy) return;
HandleNumberKeyInput();
HandleArrowKeyInput();
}

pub void ShowBar() {
if (inventoryGridController == null) return;
if (selectedSlot < 0 && slotsPerRow > 0) selectedSlot = 0;
RefreshFromInventory();
gameObject.SetActive(true);
UpdateBarDisplay();
UpdateSelection();
}

pub void HideBar() {
gameObject.SetActive(false);
if (selectionHighlight != null) selectionHighlight.SetActive(false);
UniversalTooltipManager.Instance?.HideTooltip();
}

void SetupBarCells() {
foreach (Transform child in cellContainer) Destroy(child.gameObject);
barCells.Clear();

GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
gridLayout.cellSize = cellSize;
gridLayout.spacing = new Vector2(cellMargin, cellMargin);
gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
gridLayout.constraintCount = slotsPerRow;

for (int i = 0; i < slotsPerRow; i++) {
GameObject cellGO = new GameObject($"BarCell_{i}", typeof(RectTransform));
cellGO.transform.SetParent(cellContainer, false);
Image cellImage = cellGO.AddComponent<Image>();
cellImage.sprite = emptyCellSprite;

if (inventoryGridController != null) {
cellImage.color = inventoryGridController.EmptyCellColor;
} else {
cellImage.color = emptyCellColor;
}

NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
cellLogic.Init(i, inventoryGridController, cellImage);
barCells.Add(cellLogic);
}
}

void RefreshFromInventory() {
if (inventoryGridController == null) return;
totalRows = Mathf.Max(1, Mathf.CeilToInt((float)inventoryGridController.TotalSlots / inventoryGridController.inventoryColumns));
currentRow = Mathf.Clamp(currentRow, 0, totalRows - 1);
}

void UpdateBarDisplay() {
if (inventoryGridController == null || barCells == null) return;

foreach (var cell in barCells) {
cell.RemoveNode();

Image cellImage = cell.GetComponent<Image>();
if (cellImage != null && inventoryGridController != null) {
cellImage.color = inventoryGridController.EmptyCellColor;
}
}

int startIndexInMainInventory = currentRow * inventoryGridController.inventoryColumns;

for (int i = 0; i < slotsPerRow; i++) {
if (i >= inventoryGridController.inventoryColumns) break;
int inventoryIndexToDisplay = startIndexInMainInventory + i;
if (inventoryIndexToDisplay >= inventoryGridController.TotalSlots) continue;

NodeCell inventoryCell = inventoryGridController.GetInventoryCellAtIndex(inventoryIndexToDisplay);
if (inventoryCell != null && inventoryCell.HasItem()) {
CopyInventoryItemToBarCell(inventoryCell, barCells[i]);
}
}

if (upArrowButton != null) upArrowButton.interactable = currentRow > 0;
if (downArrowButton != null) downArrowButton.interactable = currentRow < totalRows - 1;
}

void CopyInventoryItemToBarCell(NodeCell inventoryCell, NodeCell barCell) {
NodeData nodeData = inventoryCell.GetNodeData();
ToolDefinition toolDef = inventoryCell.GetToolDefinition();
NodeDefinition nodeDef = inventoryCell.GetNodeDefinition();

GameObject display = new GameObject("DisplayItem", typeof(RectTransform), typeof(Image));
display.transform.SetParent(barCell.transform, false);
Image displayImage = display.GetComponent<Image>();
displayImage.raycastTarget = false;

if (toolDef != null) {
displayImage.sprite = toolDef.icon;
displayImage.color = toolDef.iconTint;
}
else if (nodeDef != null) {
displayImage.sprite = nodeDef.thumbnail;
displayImage.color = nodeDef.thumbnailTintColor;
}

display.transform.localScale = Vector3.one * InventoryGridController.Instance.NodeGlobalImageScale;
display.GetComponent<RectTransform>().sizeDelta = cellSize * 0.8f;

if (barCell.GetComponent<Image>() != null && InventoryColorManager.Instance != null) {
Color cellColor = InventoryColorManager.Instance.GetCellColorForItem(nodeData, nodeDef, toolDef);
barCell.GetComponent<Image>().color = cellColor;
}

barCell.AssignDisplayOnly(display, nodeData, toolDef);
}

void CreateToolCopyInBarCell(ToolDefinition toolDef, NodeData toolWrapperNodeData, NodeCell barCell) {
GameObject toolDisplay = new GameObject($"ToolDisplay_{toolDef.displayName}", typeof(RectTransform), typeof(Image));
toolDisplay.transform.SetParent(barCell.transform, false);

Image toolImage = toolDisplay.GetComponent<Image>();
toolImage.sprite = toolDef.icon;
toolImage.color = toolDef.iconTint;
toolImage.raycastTarget = false;

float globalScale = 1f;
if (InventoryGridController.Instance != null) {
globalScale = InventoryGridController.Instance.NodeGlobalImageScale;
}
toolDisplay.transform.localScale = new Vector3(globalScale, globalScale, 1f);

RectTransform toolRect = toolDisplay.GetComponent<RectTransform>();
toolRect.anchoredPosition = Vector2.zero;
toolRect.sizeDelta = cellSize * 0.8f;

barCell.AssignDisplayOnly(toolDisplay, toolWrapperNodeData, toolDef);
}

void CreateNodeCopyInBarCell(NodeDefinition nodeDef, NodeData originalNodeData, NodeCell barCell) {
GameObject nodeDisplay = new GameObject($"NodeDisplay_{nodeDef.displayName}", typeof(RectTransform), typeof(Image));
nodeDisplay.transform.SetParent(barCell.transform, false);

Image nodeImage = nodeDisplay.GetComponent<Image>();
nodeImage.sprite = nodeDef.thumbnail;
nodeImage.color = nodeDef.thumbnailTintColor;
nodeImage.raycastTarget = false;

float globalScale = 1f;
if (InventoryGridController.Instance != null) {
globalScale = InventoryGridController.Instance.NodeGlobalImageScale;
}
nodeDisplay.transform.localScale = new Vector3(globalScale, globalScale, 1f);

RectTransform nodeRect = nodeDisplay.GetComponent<RectTransform>();
nodeRect.anchoredPosition = Vector2.zero;
nodeRect.sizeDelta = cellSize * 0.8f;

barCell.AssignDisplayOnly(nodeDisplay, originalNodeData, null);
}

void HandleNumberKeyInput() {
for (int i = 1; i <= 9; i++) {
KeyCode key = (KeyCode)((int)KeyCode.Alpha1 + (i - 1));
if (Input.GetKeyDown(key)) {
int targetSlotIndexInBar = i - 1; // 1-9 maps to slots 0-8
if (targetSlotIndexInBar < slotsPerRow) {
SelectSlot(targetSlotIndexInBar);
}
return;
}
}

if (Input.GetKeyDown(KeyCode.Alpha0)) {
int targetSlotIndexInBar = 9; // 0 maps to slot 9
if (targetSlotIndexInBar < slotsPerRow) {
SelectSlot(targetSlotIndexInBar);
}
}
}

void HandleArrowKeyInput() {
if (Input.GetKeyDown(KeyCode.UpArrow)) {
ChangeRow(-1);
}
else if (Input.GetKeyDown(KeyCode.DownArrow)) {
ChangeRow(1);
}
}

void ChangeRow(int direction) {
int newRow = currentRow + direction;
if (newRow >= 0 && newRow < totalRows) {
currentRow = newRow;
UpdateBarDisplay();
UpdateSelection();
}
}

void SelectSlot(int slotIndexInBar) {
if (this.selectedSlot == slotIndexInBar && this.SelectedItem != null) {
this.selectedSlot = -1; // Mark as deselected
}
else {
this.selectedSlot = Mathf.Clamp(slotIndexInBar, 0, slotsPerRow - 1);
}
UpdateSelection();
}

void UpdateSelection() {
SelectedItem = null; // Reset

if (selectedSlot == -1) // Explicitly deselected {
}
else if (selectedSlot >= 0 && selectedSlot < barCells.Count && inventoryGridController != null) {
int mainInventoryColumns = inventoryGridController.inventoryColumns;
if (mainInventoryColumns > 0) {
int inventoryIndex = currentRow * mainInventoryColumns + selectedSlot;
if (inventoryIndex >= 0 && inventoryIndex < inventoryGridController.TotalSlots) {
InventoryBarItem itemFromMainInventory = inventoryGridController.GetItemAtIndex(inventoryIndex);
if (itemFromMainInventory != null && itemFromMainInventory.IsValid()) {
SelectedItem = itemFromMainInventory;
}
}
}
}

if (selectionHighlight != null) {
if (SelectedItem != null && SelectedItem.IsValid() && selectedSlot >= 0 && selectedSlot < barCells.Count) {
if (gameObject.activeInHierarchy) {
NodeCell targetBarCellForHighlight = barCells[selectedSlot];
RectTransform cellRect = targetBarCellForHighlight.GetComponent<RectTransform>();

if (cellRect != null) {
selectionHighlight.SetActive(true);
selectionHighlight.transform.SetParent(cellRect.transform, false);
RectTransform highlightRect = selectionHighlight.GetComponent<RectTransform>();
if (highlightRect != null) {
highlightRect.anchoredPosition = Vector2.zero;
highlightRect.sizeDelta = cellRect.sizeDelta;
}
}
else { selectionHighlight.SetActive(false); }
}
else { selectionHighlight.SetActive(false); }
}
else // No valid item selected or slot is -1 {
selectionHighlight.SetActive(false);
}
}

if (gameObject.activeInHierarchy && SelectedItem != null && SelectedItem.IsValid() && UniversalTooltipManager.Instance != null && selectedSlot >= 0 && selectedSlot < barCells.Count) {
ITooltipDataProvider provider = (SelectedItem.Type == InventoryBarItem.ItemType.Node)
? (ITooltipDataProvider)SelectedItem.NodeDefinition
: SelectedItem.ToolDefinition;

object sourceData = (SelectedItem.Type == InventoryBarItem.ItemType.Node)
? SelectedItem.NodeData
: null;

UniversalTooltipManager.Instance.ShowTooltip(provider, barCells[selectedSlot].transform, sourceData);
}
else if (UniversalTooltipManager.Instance != null) {
UniversalTooltipManager.Instance.HideTooltip();
}

OnSelectionChanged?.Invoke(SelectedItem);
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryBarItem.cs

﻿using UnityEngine;

pub cls InventoryBarItem {
pub enum ItemType { Node, Tool }

[SerializeField] ItemType itemType;
[SerializeField] NodeData nodeData;
[SerializeField] NodeDefinition nodeDefinition;
[SerializeField] ToolDefinition toolDefinition;
[SerializeField] GameObject viewGameObject;

pub ItemType Type => itemType;
pub NodeData NodeData => nodeData;
pub NodeDefinition NodeDefinition => nodeDefinition;
pub ToolDefinition ToolDefinition => toolDefinition;
pub GameObject ViewGameObject => viewGameObject;

pub stat InventoryBarItem FromNode(NodeData data, NodeDefinition def, GameObject viewObj = null) {
ret new InventoryBarItem {
itemType = ItemType.Node,
nodeData = data,
nodeDefinition = def,
toolDefinition = null,
viewGameObject = viewObj
};
}

pub stat InventoryBarItem FromTool(ToolDefinition tool, GameObject viewObj = null) {
ret new InventoryBarItem {
itemType = ItemType.Tool,
nodeData = null,
nodeDefinition = null,
toolDefinition = tool,
viewGameObject = viewObj
};
}

pub string GetDisplayName() {
ret itemType == ItemType.Node ?
(nodeDefinition?.displayName ?? nodeData?.nodeDisplayName ?? "Unknown Node") :
(toolDefinition?.displayName ?? "Unknown Tool");
}

pub Sprite GetIcon() {
ret itemType == ItemType.Node ? nodeDefinition?.thumbnail : toolDefinition?.icon;
}

pub Color GetIconTint() {
ret itemType == ItemType.Node ?
(nodeDefinition?.thumbnailTintColor ?? Color.white) :
(toolDefinition?.iconTint ?? Color.white);
}

pub bool IsValid() {
ret itemType == ItemType.Node ?
(nodeData != null && nodeDefinition != null) :
(toolDefinition != null);
}

pub bool IsSeed() {
ret itemType == ItemType.Node && nodeData != null && nodeData.IsSeed();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryColorManager.cs

﻿using System.Linq;

pub cls InventoryColorManager : MonoBehaviour {
pub stat InventoryColorManager Instance { get; set; }

[SerializeField] Color toolCellColor = new Color(0.5f, 0.5f, 0.5f, 1f); // Gray
[SerializeField] Color seedCellColor = new Color(0.8f, 1f, 0.8f, 1f); // Light Green
[SerializeField] Color passiveGeneCellColor = new Color(0.8f, 0.8f, 1f, 1f); // Light Blue
[SerializeField] Color activeGeneCellColor = new Color(1f, 0.8f, 0.8f, 1f); // Light Red
[SerializeField] Color defaultCellColor = new Color(0.9f, 0.9f, 0.9f, 1f); // Light Gray

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

pub Color GetCellColorForItem(NodeData nodeData, NodeDefinition nodeDefinition, ToolDefinition toolDefinition) {
if (toolDefinition != null) {
ret toolCellColor;
}

if (nodeData != null && nodeDefinition != null) {
if (nodeData.IsSeed()) {
ret seedCellColor;
}

if (nodeData.effects != null && nodeData.effects.Count > 0) {
bool hasActiveEffects = nodeData.effects.Any(e => e != null && !e.isPassive);

if (hasActiveEffects) {
ret activeGeneCellColor;
}
else {
ret passiveGeneCellColor;
}
}
}

ret defaultCellColor;
}

pub enum ItemCategory {
Tool,
Seed,
PassiveGene,
ActiveGene,
Default
}

pub ItemCategory GetItemCategory(NodeData nodeData, NodeDefinition nodeDefinition, ToolDefinition toolDefinition) {
if (toolDefinition != null) ret ItemCategory.Tool;

if (nodeData != null && nodeDefinition != null) {
if (nodeData.IsSeed()) ret ItemCategory.Seed;

if (nodeData.effects != null && nodeData.effects.Count > 0) {
bool hasActiveEffects = nodeData.effects.Any(e => e != null && !e.isPassive);
ret hasActiveEffects ? ItemCategory.ActiveGene : ItemCategory.PassiveGene;
}
}

ret ItemCategory.Default;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryGridController.cs

﻿using System;
using UnityEngine.EventSystems;

pub cls InventoryGridController : MonoBehaviour {
pub stat InventoryGridController Instance { get; set; }

[SerializeField][Min(1)] pub int inventoryRows = 2;
[SerializeField][Min(1)] pub int inventoryColumns = 8;
[SerializeField] Vector2 cellSize = new Vector2(64f, 64f);
[SerializeField] float cellMargin = 10f;

[SerializeField] Sprite emptyCellSprite;
[SerializeField] Color emptyCellColor = Color.white;
[SerializeField] GameObject inventoryItemPrefab;
[SerializeField] float nodeGlobalImageScale = 1f;
[SerializeField] float nodeImageRaycastPadding = 0f;

[SerializeField] ToolDefinition[] availableTools;

[SerializeField] Transform cellContainer;
[SerializeField] Canvas _rootCanvas;

[SerializeField] bool logInventoryChanges = true;

ro List<NodeCell> inventoryCells = new List<NodeCell>();

pub GameObject InventoryItemPrefab => inventoryItemPrefab;
pub Color EmptyCellColor => emptyCellColor;
pub float NodeGlobalImageScale => nodeGlobalImageScale;
pub float NodeImageRaycastPadding => nodeImageRaycastPadding;
pub int TotalSlots => inventoryRows * inventoryColumns;
pub int ActualCellCount => inventoryCells?.Count ?? 0;

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;

if (cellContainer == null) Debug.LogError("[InventoryGridController] Cell Container not assigned!", gameObject);
if (inventoryItemPrefab == null) Debug.LogError("[InventoryGridController] Inventory Item Prefab not assigned!", gameObject);
if (_rootCanvas == null) Debug.LogError("[InventoryGridController] Root Canvas not assigned!", gameObject);
}

void Start() {
if (cellContainer != null) {
CreateInventoryCells();
PopulateInitialGenesFromLibrary();
}
}

void CreateInventoryCells() {
foreach (Transform child in cellContainer) Destroy(child.gameObject);
inventoryCells.Clear();

GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
if (gridLayout == null) {
Debug.LogError("[InventoryGridController] Cell Container MUST have a GridLayoutGroup.", cellContainer.gameObject);
return;
}

gridLayout.cellSize = cellSize;
gridLayout.spacing = new Vector2(cellMargin, cellMargin);
gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
gridLayout.constraintCount = inventoryColumns;

int totalCells = inventoryRows * inventoryColumns;
for (int i = 0; i < totalCells; i++) {
GameObject cellGO = new GameObject($"InventoryCell_{i}", typeof(RectTransform));
cellGO.transform.SetParent(cellContainer, false);
Image cellImage = cellGO.AddComponent<Image>();
cellImage.sprite = emptyCellSprite;
cellImage.color = emptyCellColor;
cellImage.raycastTarget = true;
NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
cellLogic.Init(i, this, cellImage);
inventoryCells.Add(cellLogic);
}
}

void PopulateInitialGenesFromLibrary() {
if (NodeEditorGridController.Instance?.DefinitionLibrary == null) {
Debug.LogWarning("[InventoryGridController] Cannot populate: NodeEditorGridController or DefinitionLibrary not ready.");
return;
}

if (availableTools != null) {
foreach (var tool in availableTools) {
if (tool != null && tool.autoAddToInventory) {
AddToolToInventory(tool);
}
}
}

NodeDefinitionLibrary lib = NodeEditorGridController.Instance.DefinitionLibrary;
if (lib.definitions != null) {
int remainingSlots = TotalSlots - GetUsedSlotCount();
var definitionsToAdd = lib.definitions.Where(d => d != null).Take(remainingSlots).ToList();
foreach (var def in definitionsToAdd) {
AddGeneToInventoryFromDefinition(def, null);
}
}
}

bool AddToolToInventory(ToolDefinition tool) {
NodeCell emptyCell = inventoryCells.FirstOrDefault(cell => !cell.HasItem());
if (emptyCell == null) ret false;

NodeData toolNodeData = new NodeData {
nodeId = tool.name + "_tool_" + System.Guid.NewGuid().ToString(),
nodeDisplayName = tool.displayName,
effects = new List<NodeEffectData>(),
orderIndex = -1,
canBeDeleted = false,
storedSequence = null
};

GameObject itemViewGO = Instantiate(inventoryItemPrefab, emptyCell.transform);
ItemView itemView = itemViewGO.GetComponent<ItemView>();

if (itemView != null) {
itemView.Initialize(toolNodeData, tool);

NodeDraggable draggable = itemViewGO.GetComponent<NodeDraggable>() ?? itemViewGO.AddComponent<NodeDraggable>();
draggable.Initialize(this, emptyCell);
emptyCell.AssignItemView(itemView, toolNodeData, tool);
if (logInventoryChanges) Debug.Log($"[Inventory] Added tool '{tool.displayName}' to cell {emptyCell.CellIndex}.");
ret true;
}

Destroy(itemViewGO);
ret false;
}

pub bool AddGeneToInventoryFromDefinition(NodeDefinition geneDef, NodeCell targetCellHint = null) {
if (geneDef == null) ret false;

NodeCell cellToUse = (targetCellHint != null && targetCellHint.IsInventoryCell && !targetCellHint.HasItem())
? targetCellHint
: inventoryCells.FirstOrDefault(cell => !cell.HasItem());

if (cellToUse == null) ret false;

NodeData inventoryNode = new NodeData {
nodeId = geneDef.name + "_inventory_" + Guid.NewGuid().ToString(),
nodeDisplayName = geneDef.displayName,
effects = geneDef.CloneEffects(),
orderIndex = -1,
canBeDeleted = false
};

if (inventoryNode.IsSeed()) {
inventoryNode.EnsureSeedSequenceInitialized();
}

GameObject itemViewGO = Instantiate(inventoryItemPrefab, cellToUse.transform);
ItemView view = itemViewGO.GetComponent<ItemView>();
if (view == null) {
Destroy(itemViewGO);
ret false;
}

view.Initialize(inventoryNode, geneDef, null);

NodeDraggable draggable = view.GetComponent<NodeDraggable>();
if (draggable == null) {
draggable = view.gameObject.AddComponent<NodeDraggable>();
}
draggable.Initialize(this, cellToUse);

cellToUse.AssignItemView(view, inventoryNode, null);

if (logInventoryChanges) {
Debug.Log($"[Inventory] Added gene '{geneDef.displayName}' (seed: {inventoryNode.IsSeed()}) to cell {cellToUse.CellIndex}");
}

ret true;
}

pub void ReturnGeneToInventory(ItemView itemViewToReturn, NodeData geneDataToReturn) {
if (itemViewToReturn == null || geneDataToReturn == null) {
if (itemViewToReturn != null) Destroy(itemViewToReturn.gameObject);
return;
}

NodeCell emptyCell = inventoryCells.FirstOrDefault(cell => !cell.HasItem());
if (emptyCell == null) {
if (logInventoryChanges) {
Debug.LogWarning($"[Inventory] No empty cell to ret '{geneDataToReturn.nodeDisplayName}' to. Item destroyed.");
}
Destroy(itemViewToReturn.gameObject);
return;
}

geneDataToReturn.orderIndex = -1;
geneDataToReturn.canBeDeleted = false;

if (geneDataToReturn.IsSeed()) {
geneDataToReturn.EnsureSeedSequenceInitialized();
}

emptyCell.AssignItemView(itemViewToReturn, geneDataToReturn, null);

NodeDraggable draggable = itemViewToReturn.GetComponent<NodeDraggable>();
if (draggable == null) {
draggable = itemViewToReturn.gameObject.AddComponent<NodeDraggable>();
}
draggable.Initialize(this, emptyCell);
draggable.SnapToCell(emptyCell);

if (logInventoryChanges) {
Debug.Log($"[Inventory] Returned gene '{geneDataToReturn.nodeDisplayName}' to cell {emptyCell.CellIndex}");
}
}

pub void HandleDropOnInventoryCell(NodeDraggable draggedDraggable, NodeCell originalCell, NodeCell targetInventoryCell) {
if (draggedDraggable == null || originalCell == null || targetInventoryCell == null || !targetInventoryCell.IsInventoryCell) {
draggedDraggable?.ResetPosition();
return;
}

ItemView draggedItemView = draggedDraggable.GetComponent<ItemView>();
if (draggedItemView == null) {
draggedDraggable.ResetPosition();
return;
}

NodeData draggedData = draggedItemView.GetNodeData();
NodeDefinition draggedNodeDef = draggedItemView.GetNodeDefinition();
ToolDefinition draggedToolDef = draggedItemView.GetToolDefinition();

if (originalCell.IsInventoryCell) {
if (targetInventoryCell == originalCell) { draggedDraggable.ResetPosition(); return; }

if (targetInventoryCell.HasItem()) {
ItemView viewInTargetCell = targetInventoryCell.GetItemView();
NodeData dataInTargetCell = targetInventoryCell.GetNodeData();
ToolDefinition toolInTargetCell = targetInventoryCell.GetToolDefinition();

if (logInventoryChanges) Debug.Log($"[Inventory] Swapped item '{draggedData.nodeDisplayName}' from cell {originalCell.CellIndex} with item '{dataInTargetCell.nodeDisplayName}' from cell {targetInventoryCell.CellIndex}.");

originalCell.ClearNodeReference();
originalCell.AssignItemView(viewInTargetCell, dataInTargetCell, toolInTargetCell);
viewInTargetCell.GetComponent<NodeDraggable>()?.SnapToCell(originalCell);
targetInventoryCell.ClearNodeReference();
}
else {
if (logInventoryChanges) Debug.Log($"[Inventory] Moved item '{draggedData.nodeDisplayName}' from cell {originalCell.CellIndex} to empty cell {targetInventoryCell.CellIndex}.");
originalCell.ClearNodeReference();
}

targetInventoryCell.AssignItemView(draggedItemView, draggedData, draggedToolDef);
draggedDraggable.SnapToCell(targetInventoryCell);
}
else {
NodeCell actualTargetInvCell = targetInventoryCell.HasItem()
? inventoryCells.FirstOrDefault(c => !c.HasItem())
: targetInventoryCell;

if (actualTargetInvCell == null) { draggedDraggable.ResetPosition(); return; }

if (originalCell.IsSeedSlot) {
if (logInventoryChanges) Debug.Log($"[Inventory] Moved seed '{draggedData.nodeDisplayName}' from Seed Slot to inventory cell {actualTargetInvCell.CellIndex}.");
NodeEditorGridController.Instance.UnloadSeedFromSlot();
originalCell.ClearNodeReference();
actualTargetInvCell.AssignItemView(draggedItemView, draggedData, null);
draggedDraggable.SnapToCell(actualTargetInvCell);
}
else {
if (logInventoryChanges) Debug.Log($"[Inventory] Returned node '{draggedNodeDef.displayName}' from sequence to inventory cell {actualTargetInvCell.CellIndex}.");
NodeEditorGridController.Instance?.GetCellAtIndex(originalCell.CellIndex)?.RemoveNode();
NodeEditorGridController.Instance?.RefreshGraphAndUpdateSeed();
AddGeneToInventoryFromDefinition(draggedNodeDef, actualTargetInvCell);
Destroy(draggedDraggable.gameObject);
}
}
}

pub int GetUsedSlotCount() => inventoryCells.Count(cell => cell.HasItem());

pub void RemoveGeneFromInventory(NodeCell inventoryCell) {
if (inventoryCell != null && inventoryCell.HasItem() && inventoryCell.IsInventoryCell) {
if (logInventoryChanges) Debug.Log($"[Inventory] Removing item '{inventoryCell.GetNodeData()?.nodeDisplayName ?? "Unknown"}' from cell {inventoryCell.CellIndex}.");
inventoryCell.ClearNodeReference();
}
}

pub NodeCell GetInventoryCellAtIndex(int index) => (index >= 0 && index < inventoryCells.Count) ? inventoryCells[index] : null;

pub NodeCell FindInventoryCellAtScreenPosition(Vector2 screenPosition) {
if (_rootCanvas == null) ret null;
foreach (NodeCell cell in inventoryCells) {
if (RectTransformUtility.RectangleContainsScreenPoint(cell.GetComponent<RectTransform>(), screenPosition, _rootCanvas.worldCamera)) {
ret cell;
}
}
ret null;
}

pub InventoryBarItem GetItemAtIndex(int index) {
if (index < 0 || index >= inventoryCells.Count) ret null;

var cell = inventoryCells[index];
if (cell.HasItem()) {
var itemView = cell.GetItemView();
var toolDef = cell.GetToolDefinition();
var nodeDef = cell.GetNodeDefinition();
var nodeData = cell.GetNodeData();

if (toolDef != null) {
ret InventoryBarItem.FromTool(toolDef, itemView?.gameObject);
}
if (nodeDef != null && nodeData != null) {
ret InventoryBarItem.FromNode(nodeData, nodeDef, itemView?.gameObject);
}
}
ret null;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\ItemView.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;

pub cls ItemView : MonoBehaviour, IPointerDownHandler {
[SerializeField] Image thumbnailImage;
[SerializeField] Image backgroundImage;

NodeData _nodeData;
NodeDefinition _nodeDefinition;
ToolDefinition _toolDefinition;

NodeEditorGridController _sequenceGridControllerRef;
NodeCell _parentCell;
Color _originalBackgroundColor;
TooltipTrigger _tooltipTrigger;
DisplayType _displayType;

pub enum DisplayType { None, Node, Tool }

pub void Initialize(NodeData data, NodeDefinition definition, NodeEditorGridController sequenceController) {
_displayType = DisplayType.Node;
_nodeData = data;
_nodeDefinition = definition;
_sequenceGridControllerRef = sequenceController;

if (_nodeData == null || _nodeDefinition == null) {
Debug.LogError($"[ItemView Initialize Node] NodeData or NodeDefinition is null for {gameObject.name}. Disabling.", gameObject);
gameObject.SetActive(false);
return;
}

if (!_nodeData.IsSeed()) {
_nodeData.ClearStoredSequence();
}

SetupVisuals();
}

pub void Initialize(NodeData data, ToolDefinition toolDef) {
_displayType = DisplayType.Tool;
_nodeData = data; // This is the wrapper NodeData for the tool
_toolDefinition = toolDef;

if (_toolDefinition == null) {
Debug.LogError($"[ItemView Initialize Tool] ToolDefinition is null for {gameObject.name}. Disabling.", gameObject);
gameObject.SetActive(false);
return;
}

SetupVisuals();
}

void SetupVisuals() {
UpdateParentCellReference();
_tooltipTrigger = GetComponent<TooltipTrigger>() ?? gameObject.AddComponent<TooltipTrigger>();

float globalScaleFactor = 1f;
float raycastPaddingValue = 0f;
if (InventoryGridController.Instance != null) {
globalScaleFactor = InventoryGridController.Instance.NodeGlobalImageScale;
raycastPaddingValue = InventoryGridController.Instance.NodeImageRaycastPadding;
}

Vector4 raycastPaddingVector = new Vector4(raycastPaddingValue, raycastPaddingValue, raycastPaddingValue, raycastPaddingValue);

if (thumbnailImage != null) {
thumbnailImage.sprite = (_displayType == DisplayType.Node) ? _nodeDefinition.thumbnail : _toolDefinition.icon;
thumbnailImage.color = (_displayType == DisplayType.Node) ? _nodeDefinition.thumbnailTintColor : _toolDefinition.iconTint;
thumbnailImage.rectTransform.localScale = new Vector3(globalScaleFactor, globalScaleFactor, 1f);
thumbnailImage.enabled = (thumbnailImage.sprite != null);
thumbnailImage.raycastTarget = true;
thumbnailImage.raycastPadding = raycastPaddingVector;
}

if (backgroundImage != null) {
if (InventoryColorManager.Instance != null) {
_originalBackgroundColor = InventoryColorManager.Instance.GetCellColorForItem(_nodeData, _nodeDefinition, _toolDefinition);
}
else {
_originalBackgroundColor = (_displayType == DisplayType.Node) ? _nodeDefinition.backgroundColor : new Color(0.5f, 0.5f, 0.5f, 1f);
}

backgroundImage.color = _originalBackgroundColor;
backgroundImage.enabled = true;
backgroundImage.raycastTarget = true;
backgroundImage.raycastPadding = raycastPaddingVector;
}
}

pub NodeData GetNodeData() => _nodeData;
pub NodeDefinition GetNodeDefinition() => _nodeDefinition;
pub ToolDefinition GetToolDefinition() => _toolDefinition;
pub NodeCell GetParentCell() => _parentCell;
pub DisplayType GetDisplayType() => _displayType;

pub void UpdateParentCellReference() {
_parentCell = GetComponentInParent<NodeCell>();
}

pub void Highlight() {
if (backgroundImage != null && _sequenceGridControllerRef != null && _parentCell != null && !_parentCell.IsInventoryCell && _displayType == DisplayType.Node) {
backgroundImage.color = _sequenceGridControllerRef.SelectedNodeBackgroundColor;
}
}

pub void Unhighlight() {
if (backgroundImage != null) {
backgroundImage.color = _originalBackgroundColor;
}
}

pub void OnPointerDown(PointerEventData eventData) {
if (_parentCell == null) UpdateParentCellReference();

if (_parentCell != null && eventData.button == PointerEventData.InputButton.Left) {
if (!_parentCell.IsInventoryCell && !_parentCell.IsSeedSlot && _displayType == DisplayType.Node) {
NodeCell.SelectCell(_parentCell);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\NodeCell.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;

pub cls NodeCell : MonoBehaviour, IPointerClickHandler, IDropHandler {
pub stat NodeCell CurrentlySelectedCell { get; set; }

pub int CellIndex { get; set; }
pub bool IsInventoryCell { get; set; }
pub bool IsSeedSlot { get; set; }

NodeEditorGridController _sequenceController;
InventoryGridController _inventoryController;

ItemView _itemView;
NodeData _nodeData;
NodeDefinition _nodeDefinition;
ToolDefinition _toolDefinition;

Image _backgroundImage;
GameObject _displayObject; // For inventory bar display-only items

pub void Init(int index, NodeEditorGridController sequenceController, InventoryGridController inventoryController, Image bgImage) {
CellIndex = index;
_sequenceController = sequenceController;
_inventoryController = inventoryController;
_backgroundImage = bgImage;
IsInventoryCell = (_inventoryController != null);
IsSeedSlot = false;

if (_backgroundImage != null) {
Color emptyColor = Color.gray;
if (IsInventoryCell && _inventoryController != null) emptyColor = _inventoryController.EmptyCellColor;
else if (!IsInventoryCell && _sequenceController != null) emptyColor = _sequenceController.EmptyCellColor;
_backgroundImage.color = emptyColor;
}
}
pub void Init(int index, NodeEditorGridController sequenceController, Image bgImage) => Init(index, sequenceController, null, bgImage);
pub void Init(int index, InventoryGridController inventoryController, Image bgImage) => Init(index, null, inventoryController, bgImage);
pub void InitAsSeedSlot(NodeEditorGridController sequenceController, Image bgImage) {
CellIndex = -1;
_sequenceController = sequenceController;
_inventoryController = null;
_backgroundImage = bgImage;
IsInventoryCell = false;
IsSeedSlot = true;
if (_backgroundImage != null) {
_backgroundImage.color = _sequenceController != null ? _sequenceController.EmptyCellColor : Color.magenta;
}
}

pub void UpdateCellBackgroundColor() {
if (_backgroundImage != null && HasItem() && InventoryColorManager.Instance != null) {
Color cellColor = InventoryColorManager.Instance.GetCellColorForItem(_nodeData, _nodeDefinition, _toolDefinition);
_backgroundImage.color = cellColor;
}
}

pub bool HasItem() => _itemView != null || _displayObject != null;
pub NodeData GetNodeData() => _nodeData;
pub NodeDefinition GetNodeDefinition() => _nodeDefinition;
pub ToolDefinition GetToolDefinition() => _toolDefinition;
pub ItemView GetItemView() => _itemView;

pub void AssignItemView(ItemView view, NodeData data, ToolDefinition toolDef) {
RemoveNode();

_itemView = view;
_nodeData = data;
_toolDefinition = toolDef;
_nodeDefinition = view?.GetNodeDefinition();

if (_itemView != null) {
_itemView.transform.SetParent(transform, false);
_itemView.GetComponent<RectTransform>().anchoredPosition = Vector2.zero;

if (_nodeData != null && !IsInventoryCell && !IsSeedSlot && _sequenceController != null) {
_nodeData.orderIndex = this.CellIndex;
}

if (_backgroundImage != null) _backgroundImage.raycastTarget = false;
}
}

pub void AssignNode(NodeDefinition def) {
if (def == null || IsInventoryCell || IsSeedSlot || _sequenceController == null) return;
if (def.effects.Any(e => e != null && e.effectType == NodeEffectType.SeedSpawn)) return;

RemoveNode();

Debug.Log($"[NodeCell] AssignNode '{def.displayName}' - Definition has {def.effects?.Count ?? 0} effects:");
if (def.effects != null) {
foreach (var effect in def.effects) {
Debug.Log($"  - {effect.effectType} (passive: {effect.isPassive}, primary: {effect.primaryValue}, secondary: {effect.secondaryValue})");
}
}

var clonedEffects = def.CloneEffects();
Debug.Log($"[NodeCell] Cloned {clonedEffects?.Count ?? 0} effects");

_nodeData = new NodeData {
nodeId = System.Guid.NewGuid().ToString(),
nodeDisplayName = def.displayName,
effects = clonedEffects,
orderIndex = this.CellIndex,
canBeDeleted = true
};

_nodeData.ClearStoredSequence();

Debug.Log($"[NodeCell] Created NodeData with {_nodeData.effects?.Count ?? 0} effects");

_nodeDefinition = def;
_toolDefinition = null;

GameObject prefabToInstantiate = _sequenceController.InventoryItemPrefab;
if (prefabToInstantiate == null) {
Debug.LogError($"[NodeCell {CellIndex}] Sequence controller is missing its InventoryItemPrefab!", gameObject);
return;
}

GameObject itemViewGO = Instantiate(prefabToInstantiate, transform);
_itemView = itemViewGO.GetComponent<ItemView>();

if (_itemView == null) {
Destroy(itemViewGO);
return;
}

_itemView.Initialize(_nodeData, def, _sequenceController);

NodeDraggable draggable = _itemView.GetComponent<NodeDraggable>();
if (draggable == null) {
draggable = itemViewGO.AddComponent<NodeDraggable>();
}
draggable.Initialize(_sequenceController, this);

if (_backgroundImage != null) {
_backgroundImage.raycastTarget = false;
}

UpdateCellBackgroundColor();
}

pub void RemoveNode() {
if (CurrentlySelectedCell == this) NodeCell.ClearSelection();
if (_itemView != null) Destroy(_itemView.gameObject);
if (_displayObject != null) Destroy(_displayObject);

_itemView = null;
_nodeData = null;
_nodeDefinition = null;
_toolDefinition = null;
_displayObject = null;

if (_backgroundImage != null) _backgroundImage.raycastTarget = true;
}

pub void ClearNodeReference() {
_itemView = null;
_nodeData = null;
_nodeDefinition = null;
_toolDefinition = null;
if (_backgroundImage != null) _backgroundImage.raycastTarget = true;
}

pub stat void SelectCell(NodeCell cellToSelect) {
if (cellToSelect == null || !cellToSelect.HasItem() || cellToSelect.IsInventoryCell || cellToSelect.IsSeedSlot) {
ClearSelection();
return;
}
if (CurrentlySelectedCell == cellToSelect) return;

ClearSelection();
CurrentlySelectedCell = cellToSelect;
CurrentlySelectedCell?.GetItemView()?.Highlight();
}

pub stat void ClearSelection() {
CurrentlySelectedCell?.GetItemView()?.Unhighlight();
CurrentlySelectedCell = null;
}

pub void OnPointerClick(PointerEventData eventData) {
if (eventData.button == PointerEventData.InputButton.Right) {
if (!HasItem() && !IsInventoryCell && !IsSeedSlot && _sequenceController != null) {
ClearSelection();
_sequenceController.OnEmptyCellRightClicked(this, eventData);
}
}
else if (eventData.button == PointerEventData.InputButton.Left) {
if (HasItem() && !IsInventoryCell && !IsSeedSlot) SelectCell(this);
else if (!HasItem()) ClearSelection();
}
}

pub void OnDrop(PointerEventData eventData) {
GameObject draggedObject = eventData.pointerDrag;
if (draggedObject == null) return;

NodeDraggable draggedDraggable = draggedObject.GetComponent<NodeDraggable>();
if (draggedDraggable == null) return;

NodeCell originalCell = draggedDraggable.OriginalCell;
if (originalCell == null || draggedDraggable.GetComponent<ItemView>() == null) {
draggedDraggable.ResetPosition();
return;
}

if (this.IsSeedSlot && _sequenceController != null)
_sequenceController.HandleDropOnSeedSlot(draggedDraggable, originalCell, this);
else if (!this.IsInventoryCell && _sequenceController != null)
_sequenceController.HandleDropOnSequenceCell(draggedDraggable, originalCell, this);
else if (this.IsInventoryCell && _inventoryController != null)
_inventoryController.HandleDropOnInventoryCell(draggedDraggable, originalCell, this);
else
draggedDraggable.ResetPosition();
}

pub void AssignDisplayOnly(GameObject displayObject, NodeData data, ToolDefinition toolDef) {
RemoveNode();
_nodeData = data;
_toolDefinition = toolDef;
_displayObject = displayObject;

if (_displayObject != null) {
_displayObject.transform.SetParent(transform, false);
_displayObject.GetComponent<RectTransform>().anchoredPosition = Vector2.zero;
if (_backgroundImage != null) _backgroundImage.raycastTarget = false;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\NodeDraggable.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;

[RequireComponent(typeof(ItemView))] // Ensures an ItemView is always present
pub cls NodeDraggable : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler {
RectTransform _rectTransform;
CanvasGroup _canvasGroup;
Vector2 _originalAnchoredPosition;
Transform _originalParent;
NodeCell _originalCell;
NodeEditorGridController _gridController;
InventoryGridController _inventoryController;
Canvas _rootCanvas;
ItemView _itemView; // Reference to the unified view

pub NodeCell OriginalCell => _originalCell;

void Awake() {
_rectTransform = GetComponent<RectTransform>();
_canvasGroup = GetComponent<CanvasGroup>() ?? gameObject.AddComponent<CanvasGroup>();
_itemView = GetComponent<ItemView>(); // Get the unified ItemView component
}

pub void Initialize(NodeEditorGridController gridCtrl, NodeCell startingCell) => Initialize(gridCtrl, null, startingCell);
pub void Initialize(InventoryGridController invCtrl, NodeCell startingCell) => Initialize(null, invCtrl, startingCell);

void Initialize(NodeEditorGridController gridCtrl, InventoryGridController invCtrl, NodeCell startingCell) {
_gridController = gridCtrl;
_inventoryController = invCtrl;
_originalCell = startingCell;

_rootCanvas = GetComponentInParent<Canvas>()?.rootCanvas ?? FindFirstObjectByType<Canvas>();
if (_rootCanvas == null) Debug.LogError("[NodeDraggable] Could not find root Canvas!", gameObject);
}

pub void OnBeginDrag(PointerEventData eventData) {
if (eventData.button != PointerEventData.InputButton.Left) return;
if (_originalCell == null || _itemView == null) return;

NodeData data = _itemView.GetNodeData();
if (data == null) return;

bool isInSequenceEditorCell = _gridController != null && !_originalCell.IsInventoryCell && !_originalCell.IsSeedSlot;
if (isInSequenceEditorCell && !data.canBeDeleted) {
eventData.pointerDrag = null; // Prevent drag from starting
return;
}

if (_rootCanvas == null) return;

_originalParent = transform.parent;
_originalAnchoredPosition = _rectTransform.anchoredPosition;

_canvasGroup.alpha = 0.6f;
_canvasGroup.blocksRaycasts = false;

transform.SetParent(_rootCanvas.transform, true);
transform.SetAsLastSibling();

Vector2 mouseLocalPosInCanvas;
RectTransformUtility.ScreenPointToLocalPointInRectangle(_rootCanvas.transform as RectTransform, eventData.position, _rootCanvas.worldCamera, out mouseLocalPosInCanvas);
_rectTransform.localPosition = mouseLocalPosInCanvas;
}

pub void OnDrag(PointerEventData eventData) {
if (eventData.button != PointerEventData.InputButton.Left || _canvasGroup.blocksRaycasts) return;
if (_rootCanvas == null || _rectTransform == null) return;

Vector2 mouseLocalPosInCanvas;
if (RectTransformUtility.ScreenPointToLocalPointInRectangle(_rootCanvas.transform as RectTransform, eventData.position, _rootCanvas.worldCamera, out mouseLocalPosInCanvas)) {
_rectTransform.localPosition = mouseLocalPosInCanvas;
}
}

pub void OnEndDrag(PointerEventData eventData) {
_canvasGroup.alpha = 1f;
_canvasGroup.blocksRaycasts = true;

if (eventData.button != PointerEventData.InputButton.Left) {
if (transform.parent == _rootCanvas.transform) ResetPosition();
return;
}

if (eventData.pointerEnter == null || eventData.pointerEnter.GetComponent<IDropHandler>() == null) {
ResetPosition();
}
}

pub void ResetPosition() {
if (_originalParent == null || _originalCell == null) {
Destroy(gameObject);
return;
}

transform.SetParent(_originalParent, false);
_rectTransform.anchoredPosition = _originalAnchoredPosition;
}

pub void SnapToCell(NodeCell targetCell) {
if (targetCell == null) {
ResetPosition();
return;
}

transform.SetParent(targetCell.transform, false);
_rectTransform.anchoredPosition = Vector2.zero;

_originalParent = targetCell.transform;
_originalCell = targetCell;
_originalAnchoredPosition = Vector2.zero;

_itemView?.UpdateParentCellReference();

if (targetCell.IsInventoryCell) {
_inventoryController = InventoryGridController.Instance;
_gridController = null;
}
else // Sequence or Seed Slot {
_inventoryController = null;
_gridController = NodeEditorGridController.Instance;
}
}

void OnDisable() {
if (_canvasGroup != null && !_canvasGroup.blocksRaycasts) {
_canvasGroup.alpha = 1f;
_canvasGroup.blocksRaycasts = true;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\NodeEditorGridController.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;
using TMPro;

pub cls NodeEditorGridController : MonoBehaviour {
pub stat NodeEditorGridController Instance { get; set; }

[SerializeField][Min(1)] int emptyCellsCount = 8;
[SerializeField] Vector2 cellSize = new Vector2(64f, 64f);
[SerializeField] float cellMargin = 10f;

[SerializeField] Sprite emptyCellSprite;
[SerializeField] Color emptyCellColor = Color.white;
[SerializeField] Vector3 emptyCellScale = Vector3.one;
[SerializeField] GameObject inventoryItemPrefab;
[SerializeField] Color selectedNodeBackgroundColor = new Color(0.9f, 0.9f, 0.7f, 1f);

[SerializeField] NodeDefinitionLibrary definitionLibrary;
[SerializeField] TMP_Dropdown nodeDropdown;
[SerializeField] pub GameObject gridUIParent;
[SerializeField] Transform cellContainer;
[SerializeField] Transform seedSlotContainer;

ro List<NodeCell> nodeCells = new List<NodeCell>();
NodeCell _actualSeedSlotCell;
Canvas _rootCanvas;
ro NodeGraph _currentlyEditedSequence = new NodeGraph();

pub GameObject InventoryItemPrefab => inventoryItemPrefab;
pub NodeDefinitionLibrary DefinitionLibrary => definitionLibrary;
pub Color SelectedNodeBackgroundColor => selectedNodeBackgroundColor;
pub Color EmptyCellColor => emptyCellColor;
pub NodeData GetCurrentSeedInSlot() => _actualSeedSlotCell?.GetNodeData();
pub NodeCell SeedSlotCell => _actualSeedSlotCell;

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;

_rootCanvas = GetComponentInParent<Canvas>()?.rootCanvas ?? FindFirstObjectByType<Canvas>();
if (_rootCanvas == null) Debug.LogError("[NodeEditorGridController] Root Canvas not found!", gameObject);
if (inventoryItemPrefab == null) Debug.LogError("[NodeEditorGridController] Inventory Item Prefab is not assigned!", gameObject);
}

void OnDestroy() {
if (Instance == this) Instance = null;
}

void Start() {
if (nodeDropdown != null) nodeDropdown.gameObject.SetActive(false);
if (seedSlotContainer != null) CreateSeedSlot();
if (cellContainer != null && definitionLibrary != null) {
CreateSequenceCells();
HideNodeEditorPanel();
}
}

pub NodeGraph GetCurrentGraphInEditorForSpawning() {
NodeGraph clone = new NodeGraph { nodes = new List<NodeData>() };

Debug.Log($"[NodeEditor] GetCurrentGraphInEditorForSpawning - Editor has {_currentlyEditedSequence?.nodes?.Count ?? 0} nodes");

if (_currentlyEditedSequence?.nodes != null) {
foreach (var nodeData in _currentlyEditedSequence.nodes) {
if (nodeData == null) continue;

Debug.Log($"[NodeEditor] Processing node '{nodeData.nodeDisplayName}' with {nodeData.effects?.Count ?? 0} effects:");
if (nodeData.effects != null) {
foreach (var effect in nodeData.effects) {
Debug.Log($"  - {effect.effectType} (passive: {effect.isPassive}, primary: {effect.primaryValue})");
}
}

NodeData clonedNode = new NodeData {
nodeId = nodeData.nodeId,
nodeDisplayName = nodeData.nodeDisplayName,
effects = NodeExecutor.CloneEffectsList(nodeData.effects),
orderIndex = nodeData.orderIndex,
canBeDeleted = nodeData.canBeDeleted,
};

Debug.Log($"[NodeEditor] Cloned node has {clonedNode.effects?.Count ?? 0} effects");

clone.nodes.Add(clonedNode);
}
}

Debug.Log($"[NodeEditor] Returning graph with {clone.nodes.Count} nodes");
ret clone;
}

void CreateSeedSlot() {
foreach (Transform child in seedSlotContainer) Destroy(child.gameObject);

GameObject seedCellGO = new GameObject("SeedSlot_Cell", typeof(RectTransform));
seedCellGO.transform.SetParent(seedSlotContainer, false);
seedCellGO.GetComponent<RectTransform>().sizeDelta = cellSize;
Image cellImage = seedCellGO.AddComponent<Image>();
cellImage.sprite = emptyCellSprite;
cellImage.color = emptyCellColor;
NodeCell cellLogic = seedCellGO.AddComponent<NodeCell>();
cellLogic.InitAsSeedSlot(this, cellImage);
_actualSeedSlotCell = cellLogic;
}

void CreateSequenceCells() {
foreach (Transform child in cellContainer) Destroy(child.gameObject);
nodeCells.Clear();
NodeCell.ClearSelection();

GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
gridLayout.cellSize = cellSize;
gridLayout.spacing = new Vector2(cellMargin, cellMargin);

for (int i = 0; i < emptyCellsCount; i++) {
GameObject cellGO = new GameObject($"SequenceCell_{i}", typeof(RectTransform));
cellGO.transform.SetParent(cellContainer, false);
Image cellImage = cellGO.AddComponent<Image>();
cellImage.sprite = emptyCellSprite;
cellImage.color = emptyCellColor;
NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
cellLogic.Init(i, this, cellImage);
nodeCells.Add(cellLogic);
}
}

void Update() {
if (gridUIParent != null && gridUIParent.activeInHierarchy) {
if (Input.GetKeyDown(KeyCode.Delete) && NodeCell.CurrentlySelectedCell != null) {
NodeCell selected = NodeCell.CurrentlySelectedCell;
NodeData data = selected.GetNodeData();
if (data != null && data.canBeDeleted) {
selected.RemoveNode();
RefreshGraphAndUpdateSeed();
}
}
if (Input.GetKeyDown(KeyCode.Escape)) {
if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) HideDropdown();
else if (NodeCell.CurrentlySelectedCell != null) NodeCell.ClearSelection();
}
}
}

pub void LoadSequenceFromSeed(NodeData seedData) {
if (_actualSeedSlotCell == null || seedData == null || !seedData.IsSeed()) {
HideNodeEditorPanel();
_currentlyEditedSequence.nodes.Clear();
return;
}

seedData.EnsureSeedSequenceInitialized();

ClearSequenceEditorCells();
_currentlyEditedSequence.nodes.Clear();

if (seedData.storedSequence?.nodes != null) {
foreach (NodeData storedNode in seedData.storedSequence.nodes.OrderBy(n => n.orderIndex)) {
if (storedNode == null || storedNode.orderIndex >= nodeCells.Count) continue;

NodeCell targetCell = nodeCells[storedNode.orderIndex];
NodeDefinition definition = definitionLibrary.definitions
.FirstOrDefault(d => d.displayName == storedNode.nodeDisplayName);

if (definition != null) {
targetCell.AssignNode(definition);
_currentlyEditedSequence.nodes.Add(targetCell.GetNodeData());
}
}
}

ShowNodeEditorPanel();
}

pub void UnloadSeedFromSlot() {
ClearSequenceEditorCells();
HideNodeEditorPanel();
_currentlyEditedSequence.nodes.Clear();
}

pub void OnEmptyCellRightClicked(NodeCell cell, PointerEventData eventData) {
if (cell.IsInventoryCell || cell == _actualSeedSlotCell || nodeDropdown == null) return;
StopCoroutine(nameof(ShowDropdownCoroutine));
StartCoroutine(ShowDropdownCoroutine(cell, eventData));
}

IEnumerator ShowDropdownCoroutine(NodeCell cell, PointerEventData eventData) {
var sortedDefinitions = definitionLibrary.definitions
.Where(def => def != null && !def.effects.Any(e => e.effectType == NodeEffectType.SeedSpawn))
.OrderBy(def => def.displayName)
.ToList();

List<TMP_Dropdown.OptionData> options = new List<TMP_Dropdown.OptionData> { new TMP_Dropdown.OptionData("Select Node...") };
options.AddRange(sortedDefinitions.Select(def => new TMP_Dropdown.OptionData { text = def.displayName, image = def.thumbnail }));

nodeDropdown.ClearOptions();
nodeDropdown.AddOptions(options);
nodeDropdown.onValueChanged.RemoveAllListeners();
nodeDropdown.onValueChanged.AddListener((index) => OnDropdownValueChanged(index, cell, sortedDefinitions));

RectTransformUtility.ScreenPointToLocalPointInRectangle(nodeDropdown.transform.parent as RectTransform, eventData.position, _rootCanvas.worldCamera, out Vector2 localPos);
(nodeDropdown.transform as RectTransform).localPosition = localPos;
nodeDropdown.gameObject.SetActive(true);
yield ret null;
nodeDropdown.Show();
nodeDropdown.value = 0;
nodeDropdown.RefreshShownValue();
}

void OnDropdownValueChanged(int selectedIndex, NodeCell targetCell, List<NodeDefinition> sortedDefinitions) {
HideDropdown();
if (selectedIndex > 0 && (selectedIndex - 1) < sortedDefinitions.Count) {
NodeDefinition selectedDef = sortedDefinitions[selectedIndex - 1];
targetCell.AssignNode(selectedDef);
NodeCell.SelectCell(targetCell);
RefreshGraphAndUpdateSeed();
}
}

pub void RefreshGraphAndUpdateSeed() {
if (_actualSeedSlotCell == null) return;

Debug.Log("[NodeEditor] RefreshGraphAndUpdateSeed - Rebuilding sequence");

_currentlyEditedSequence.nodes.Clear();

foreach (var cell in nodeCells.OrderBy(c => c.CellIndex)) {
if (cell.HasItem()) {
NodeData dataFromCell = cell.GetNodeData();
if (dataFromCell == null) continue;

Debug.Log($"[NodeEditor] Cell {cell.CellIndex} has node '{dataFromCell.nodeDisplayName}' with {dataFromCell.effects?.Count ?? 0} effects:");
if (dataFromCell.effects != null) {
foreach (var effect in dataFromCell.effects) {
Debug.Log($"  - {effect.effectType} (passive: {effect.isPassive})");
}
}

dataFromCell.orderIndex = cell.CellIndex;
dataFromCell.ClearStoredSequence();
_currentlyEditedSequence.nodes.Add(dataFromCell);
}
}

Debug.Log($"[NodeEditor] Sequence rebuilt with {_currentlyEditedSequence.nodes.Count} nodes");

NodeData currentSeedInSlot = GetCurrentSeedInSlot();

if (currentSeedInSlot != null && currentSeedInSlot.IsSeed()) {
Debug.Log($"[NodeEditor] Updating seed '{currentSeedInSlot.nodeDisplayName}' stored sequence");

currentSeedInSlot.EnsureSeedSequenceInitialized();

currentSeedInSlot.storedSequence.nodes.Clear();

foreach (NodeData editorNode in _currentlyEditedSequence.nodes) {
if (editorNode == null) continue;

NodeData nodeForStorage = new NodeData {
nodeId = editorNode.nodeId,
nodeDisplayName = editorNode.nodeDisplayName,
effects = NodeExecutor.CloneEffectsList(editorNode.effects),
orderIndex = editorNode.orderIndex,
canBeDeleted = editorNode.canBeDeleted
};

Debug.Log($"[NodeEditor] Storing node '{nodeForStorage.nodeDisplayName}' with {nodeForStorage.effects?.Count ?? 0} effects in seed");

nodeForStorage.SetPartOfSequence(true);

currentSeedInSlot.storedSequence.nodes.Add(nodeForStorage);
}

Debug.Log($"[NodeEditor] Seed now contains {currentSeedInSlot.storedSequence.nodes.Count} nodes");
}
}

pub void HandleDropOnSeedSlot(NodeDraggable draggedDraggable, NodeCell originalCell, NodeCell targetSeedSlotCell) {
if (_actualSeedSlotCell == null || targetSeedSlotCell != _actualSeedSlotCell) {
draggedDraggable.ResetPosition(); return;
}

ItemView draggedView = draggedDraggable.GetComponent<ItemView>();
NodeData draggedData = draggedView?.GetNodeData();

if (draggedView == null || draggedData == null || !draggedData.IsSeed()) {
draggedDraggable.ResetPosition(); return;
}

ItemView existingSeedViewInSlot = _actualSeedSlotCell.GetItemView();
if (existingSeedViewInSlot != null) {
RefreshGraphAndUpdateSeed();
NodeData existingSeedInSlotData = _actualSeedSlotCell.GetNodeData();
_actualSeedSlotCell.ClearNodeReference();
InventoryGridController.Instance.ReturnGeneToInventory(existingSeedViewInSlot, existingSeedInSlotData);
}

if (originalCell.IsInventoryCell) {
InventoryGridController.Instance.RemoveGeneFromInventory(originalCell);
}
else {
originalCell.RemoveNode();
}

draggedData.EnsureSeedSequenceInitialized();
_actualSeedSlotCell.AssignItemView(draggedView, draggedData, null);
draggedDraggable.SnapToCell(_actualSeedSlotCell);
LoadSequenceFromSeed(draggedData);
}

pub void HandleDropOnSequenceCell(NodeDraggable draggedDraggable, NodeCell originalCell, NodeCell targetSequenceCell) {
if (draggedDraggable == null || originalCell == null || targetSequenceCell == null || targetSequenceCell.IsInventoryCell || targetSequenceCell.IsSeedSlot) {
draggedDraggable?.ResetPosition(); return;
}

ItemView draggedView = draggedDraggable.GetComponent<ItemView>();
if (draggedView == null) { draggedDraggable.ResetPosition(); return; }

NodeDefinition draggedNodeDef = draggedView.GetNodeDefinition();
NodeData draggedData = draggedView.GetNodeData();

if (draggedNodeDef != null && draggedNodeDef.effects.Any(e => e.effectType == NodeEffectType.SeedSpawn)) {
draggedDraggable.ResetPosition(); return;
}

if (originalCell.IsInventoryCell) {
InventoryGridController.Instance?.RemoveGeneFromInventory(originalCell);
ItemView existingViewInTargetSeq = targetSequenceCell.GetItemView();
if (existingViewInTargetSeq != null) {
InventoryGridController.Instance.ReturnGeneToInventory(existingViewInTargetSeq, targetSequenceCell.GetNodeData());
targetSequenceCell.ClearNodeReference();
}
targetSequenceCell.AssignNode(draggedNodeDef);
NodeCell.SelectCell(targetSequenceCell);
Destroy(draggedDraggable.gameObject);
}
else if (!originalCell.IsSeedSlot) {
ItemView existingViewInTarget = targetSequenceCell.GetItemView();
NodeData existingDataInTarget = targetSequenceCell.GetNodeData();

originalCell.ClearNodeReference();

if (existingViewInTarget != null) {
originalCell.AssignItemView(existingViewInTarget, existingDataInTarget, null);
existingViewInTarget.GetComponent<NodeDraggable>()?.SnapToCell(originalCell);
}
targetSequenceCell.AssignItemView(draggedView, draggedData, null);
draggedDraggable.SnapToCell(targetSequenceCell);
NodeCell.SelectCell(targetSequenceCell);
}
else {
draggedDraggable.ResetPosition();
}

RefreshGraphAndUpdateSeed();
}

void HideNodeEditorPanel() { if (gridUIParent != null) gridUIParent.SetActive(false); }
void ShowNodeEditorPanel() { if (gridUIParent != null) gridUIParent.SetActive(true); }
void ClearSequenceEditorCells() { foreach (NodeCell cell in nodeCells) { cell.RemoveNode(); } }
pub void HideDropdown() { if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) { nodeDropdown.Hide(); nodeDropdown.gameObject.SetActive(false); } }
pub NodeCell GetCellAtIndex(int index) => (index >= 0 && index < nodeCells.Count) ? nodeCells[index] : null;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\OutlinePartController.cs

﻿using UnityEngine;

pub cls OutlinePartController : MonoBehaviour {
SpriteRenderer outlineRenderer;
Transform cachedTransform;

SpriteRenderer sourcePlantPartRenderer; // The plant part this outline mimics

pub Vector2Int gridCoord; // The coordinate *this outline* lives at

void Awake() {
outlineRenderer = GetComponent<SpriteRenderer>();
cachedTransform = transform;

if (outlineRenderer != null) {
outlineRenderer.drawMode = SpriteDrawMode.Simple;
outlineRenderer.enabled = false;
}
else {
Debug.LogError($"[{gameObject.name}] OutlinePartController is missing SpriteRenderer component!", this);
}
}

pub void Initialize(SpriteRenderer sourceRenderer, Vector2Int myCoord, PlantOutlineController controller) {
if (sourceRenderer == null || controller == null) {
Debug.LogError($"[{gameObject.name}] Initialization failed! Source renderer or controller is null!", this);
Destroy(gameObject);
return;
}

sourcePlantPartRenderer = sourceRenderer; // Store initial source
gridCoord = myCoord;

if (outlineRenderer == null) {
outlineRenderer = GetComponent<SpriteRenderer>();
if (outlineRenderer == null) {
Debug.LogError($"[{gameObject.name}] Initialize: Cannot find SpriteRenderer component!", this);
Destroy(gameObject);
return;
}
}

outlineRenderer.sortingLayerID = controller.OutlineSortingLayer;
outlineRenderer.sortingOrder = controller.OutlineSortingOrder;
outlineRenderer.color = controller.OutlineColor;

cachedTransform.SetParent(controller.transform, true); // Parent to controller's transform

float spacing = controller.GetComponentInParent<PlantGrowth>()?.GetCellSpacing() ?? 0.08f; // Get spacing
cachedTransform.localPosition = (Vector2)myCoord * spacing;

outlineRenderer.enabled = IsSourceRendererValid() &&
sourcePlantPartRenderer.enabled &&
sourcePlantPartRenderer.sprite != null;

SyncSpriteAndTransform(); // Initial sync
}

void LateUpdate() {
if (outlineRenderer == null || !outlineRenderer.enabled) return;

if (!IsSourceRendererValid()) {
SetVisibility(false);
return;
}

if (!sourcePlantPartRenderer.enabled || sourcePlantPartRenderer.sprite == null) {
SetVisibility(false);
return;
}

SyncSpriteAndTransform();
}

pub bool IsSourceRendererValid() {
if (sourcePlantPartRenderer == null)
ret false;

if (!sourcePlantPartRenderer.gameObject.activeInHierarchy)
ret false;

ret true;
}

pub void UpdateSourceRenderer(SpriteRenderer newSource) {
if (newSource != null) {
sourcePlantPartRenderer = newSource;

SetVisibility(
outlineRenderer != null &&
sourcePlantPartRenderer.enabled &&
sourcePlantPartRenderer.sprite != null
);

SyncSpriteAndTransform();
}
else {
Debug.LogWarning($"Attempted to update source renderer for outline at {gridCoord} with null.", gameObject);
SetVisibility(false);
}
}

pub void SyncSpriteAndTransform() {
if (!IsSourceRendererValid() || outlineRenderer == null)
return;

if (outlineRenderer.sprite != sourcePlantPartRenderer.sprite) {
outlineRenderer.sprite = sourcePlantPartRenderer.sprite;
}

cachedTransform.localScale = sourcePlantPartRenderer.transform.localScale;
outlineRenderer.flipX = sourcePlantPartRenderer.flipX;
outlineRenderer.flipY = sourcePlantPartRenderer.flipY;
}

pub void SetVisibility(bool isVisible) {
if (outlineRenderer != null && outlineRenderer.enabled != isVisible) {
outlineRenderer.enabled = isVisible;
}
}

pub void DestroyOutlinePart() {
if (this != null && gameObject != null) {
if (Application.isPlaying) {
Destroy(gameObject);
}
else {
DestroyImmediate(gameObject);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\PlantOutlineController.cs

﻿using System.Collections.Generic;

pub cls PlantOutlineController : MonoBehaviour {
[SerializeField] Color outlineColor = Color.black;
[SerializeField] bool excludeOuterCorners = false;
[SerializeField] bool excludeBaseCell = true;
[SerializeField] pub GameObject outlinePartPrefab; // Made pub to fix access issue

[SerializeField] string outlineSortingLayerName = "Default";
[SerializeField] int outlineSortingOrder = -1;

[SerializeField] bool debugLogging = false;

pub Color OutlineColor => outlineColor;
pub int OutlineSortingLayer => outlineSortingLayerID;
pub int OutlineSortingOrder => outlineSortingOrder;

int outlineSortingLayerID;
PlantGrowth parentPlantGrowth;
Dictionary<Vector2Int, OutlinePartController> outlinePartMap = new Dictionary<Vector2Int, OutlinePartController>();
HashSet<Vector2Int> plantCellCoords = new HashSet<Vector2Int>();

stat ro Vector2Int[] neighborOffsets = new Vector2Int[] {
new Vector2Int(-1, -1), // Down-Left
new Vector2Int(0, -1),  // Down
new Vector2Int(1, -1),  // Down-Right
new Vector2Int(-1, 0),  // Left
new Vector2Int(1, 0),   // Right
new Vector2Int(-1, 1),  // Up-Left
new Vector2Int(0, 1),   // Up
new Vector2Int(1, 1),   // Up-Right
};

stat ro Vector2Int[] cardinalOffsets = new Vector2Int[] {
new Vector2Int(0, -1),  // Down
new Vector2Int(-1, 0),  // Left
new Vector2Int(1, 0),   // Right
new Vector2Int(0, 1),   // Up
};

void Awake() {
parentPlantGrowth = GetComponentInParent<PlantGrowth>();
if (parentPlantGrowth == null) {
Debug.LogError($"[{gameObject.name} Awake] Missing PlantGrowth parent!", gameObject);
enabled = false;
return;
}

if (outlinePartPrefab == null) {
Debug.LogError($"[{gameObject.name} Awake] Outline Part Prefab not assigned!", gameObject);
enabled = false;
return;
}

outlineSortingLayerID = SortingLayer.NameToID(outlineSortingLayerName);
if (outlineSortingLayerID == 0 && outlineSortingLayerName != "Default") {
Debug.LogWarning($"[{gameObject.name} Awake] Sorting Layer '{outlineSortingLayerName}' not found, using 'Default'.");
outlineSortingLayerID = SortingLayer.NameToID("Default");
}

transform.localPosition = Vector3.zero;
transform.localRotation = Quaternion.identity;
transform.localScale = Vector3.one;

if (debugLogging)
Debug.Log($"[{gameObject.name} Awake] Initialized outline controller for {parentPlantGrowth.gameObject.name}");
}

pub void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject outlinePartPrefab) {
if (plantPartRenderer == null || outlinePartPrefab == null) {
if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] RegisterPlantPart: Null parameters provided");
return;
}

PlantCell plantCell = plantPartRenderer.GetComponentInParent<PlantCell>();
if (plantCell != null) {
OnPlantCellAdded(plantCell.GridCoord, plantCell.gameObject);
}
else if (debugLogging) {
Debug.LogWarning($"[{gameObject.name}] RegisterPlantPart: No PlantCell found for renderer {plantPartRenderer.name}");
}
}

pub void OnPlantCellAdded(Vector2Int plantCoord, GameObject plantCellGO) {
if (plantCellGO == null) {
if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] OnPlantCellAdded: Null GameObject at {plantCoord}");
return;
}

plantCellCoords.Add(plantCoord);

RemoveOutlinePartIfExists(plantCoord);

SpriteRenderer plantRenderer = plantCellGO.GetComponentInChildren<SpriteRenderer>();
if (plantRenderer == null) {
Debug.LogWarning($"Plant cell added at {plantCoord} missing SpriteRenderer.", plantCellGO);
return;
}

foreach (Vector2Int offset in neighborOffsets) {
Vector2Int neighborCoord = plantCoord + offset;

if (!plantCellCoords.Contains(neighborCoord) &&
!outlinePartMap.ContainsKey(neighborCoord)) {
if (ShouldExcludeOutlineAt(neighborCoord))
continue;

CreateOutlinePart(neighborCoord, plantRenderer);
}
}

if (debugLogging)
Debug.Log($"[{gameObject.name}] Added cell at {plantCoord}, now tracking {plantCellCoords.Count} cells and {outlinePartMap.Count} outline parts");
}

pub void OnPlantCellRemoved(Vector2Int plantCoord) {
if (!plantCellCoords.Contains(plantCoord)) {
if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] OnPlantCellRemoved: Coordinate {plantCoord} not found in plant cells!");
return;
}

plantCellCoords.Remove(plantCoord);

if (debugLogging)
Debug.Log($"[{gameObject.name}] Removed cell at {plantCoord}, now have {plantCellCoords.Count} cells");

if (!outlinePartMap.ContainsKey(plantCoord)) {
if (HasPlantNeighbor(plantCoord)) {
SpriteRenderer sourceRenderer = FindValidNeighborRenderer(plantCoord);
if (sourceRenderer != null && !ShouldExcludeOutlineAt(plantCoord)) {
CreateOutlinePart(plantCoord, sourceRenderer);
if (debugLogging)
Debug.Log($"[{gameObject.name}] Created new outline at removed cell position {plantCoord}");
}
}
}

foreach (Vector2Int offset in neighborOffsets) {
Vector2Int neighborCoord = plantCoord + offset;

if (outlinePartMap.TryGetValue(neighborCoord, out OutlinePartController outlinePart)) {
if (outlinePart == null) {
outlinePartMap.Remove(neighborCoord);
if (debugLogging)
Debug.Log($"[{gameObject.name}] Removed null outline at {neighborCoord} from dictionary");
continue;
}

bool neighborStillHasPlantNeighbor = HasPlantNeighbor(neighborCoord);

if (!neighborStillHasPlantNeighbor) {
RemoveOutlinePartIfExists(neighborCoord);
if (debugLogging)
Debug.Log($"[{gameObject.name}] Removed orphaned outline at {neighborCoord}");
}
else if (!outlinePart.IsSourceRendererValid()) {
SpriteRenderer newSource = FindValidNeighborRenderer(neighborCoord);
if (newSource != null) {
outlinePart.UpdateSourceRenderer(newSource);
outlinePart.SyncSpriteAndTransform();
if (debugLogging)
Debug.Log($"[{gameObject.name}] Updated source for outline at {neighborCoord}");
}
else {
if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] Outline at {neighborCoord} lost source but HasPlantNeighbor=true. Removing.");
RemoveOutlinePartIfExists(neighborCoord);
}
}
}
else if (!plantCellCoords.Contains(neighborCoord) && HasPlantNeighbor(neighborCoord)) {
if (!ShouldExcludeOutlineAt(neighborCoord)) {
SpriteRenderer sourceRenderer = FindValidNeighborRenderer(neighborCoord);
if (sourceRenderer != null) {
CreateOutlinePart(neighborCoord, sourceRenderer);
if (debugLogging)
Debug.Log($"[{gameObject.name}] Created new outline at neighbor {neighborCoord} after cell removal");
}
}
}
}
}

void CreateOutlinePart(Vector2Int coord, SpriteRenderer sourceRenderer) {
if (outlinePartPrefab == null) {
Debug.LogError($"[{gameObject.name}] CreateOutlinePart: outlinePartPrefab is null!");
return;
}

if (sourceRenderer == null) {
Debug.LogWarning($"[{gameObject.name}] CreateOutlinePart: sourceRenderer is null for coord {coord}");
return;
}

if (outlinePartMap.ContainsKey(coord)) {
if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] CreateOutlinePart: Outline already exists at {coord}");
return;
}

GameObject outlineInstance = Instantiate(outlinePartPrefab, transform);
if (outlineInstance == null) {
Debug.LogError($"[{gameObject.name}] CreateOutlinePart: Failed to instantiate outline prefab!");
return;
}

float spacing = parentPlantGrowth.GetCellSpacing();
outlineInstance.transform.localPosition = (Vector2)coord * spacing;

OutlinePartController outlineController = outlineInstance.GetComponent<OutlinePartController>();
if (outlineController != null) {
outlineController.Initialize(sourceRenderer, coord, this);
outlineController.SetVisibility(true);
outlinePartMap.Add(coord, outlineController);

if (debugLogging)
Debug.Log($"[{gameObject.name}] Created outline part at {coord} using source {sourceRenderer.gameObject.name}");
}
else {
Debug.LogError($"[{gameObject.name}] Outline Part Prefab missing OutlinePartController script!", outlinePartPrefab);
Destroy(outlineInstance);
}
}

void RemoveOutlinePartIfExists(Vector2Int coord) {
if (outlinePartMap.TryGetValue(coord, out OutlinePartController outlinePart)) {
if (outlinePart != null) {
outlinePart.DestroyOutlinePart();
if (debugLogging)
Debug.Log($"[{gameObject.name}] Destroyed outline part at {coord}");
}
outlinePartMap.Remove(coord);
}
}

bool HasPlantNeighbor(Vector2Int coord) {
foreach (Vector2Int offset in neighborOffsets) {
if (plantCellCoords.Contains(coord + offset)) {
ret true;
}
}
ret false;
}

SpriteRenderer FindValidNeighborRenderer(Vector2Int coord) {
foreach (Vector2Int offset in neighborOffsets) {
Vector2Int neighborCoord = coord + offset;

if (plantCellCoords.Contains(neighborCoord)) {
GameObject plantGO = parentPlantGrowth.GetCellGameObjectAt(neighborCoord);
if (plantGO != null) {
SpriteRenderer renderer = plantGO.GetComponentInChildren<SpriteRenderer>();
if (renderer != null) {
if (debugLogging)
Debug.Log($"[{gameObject.name}] Found valid renderer at {neighborCoord} for outline at {coord}");
ret renderer;
}
}
}
}

if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] Could not find any valid neighbor renderer for {coord}");
ret null;
}

bool ShouldExcludeOutlineAt(Vector2Int coord) {
if (excludeBaseCell && coord == Vector2Int.down && plantCellCoords.Contains(Vector2Int.zero)) {
ret true;
}

if (excludeOuterCorners && IsOuterCornerCandidate(coord)) {
ret true;
}

ret false;
}

bool IsOuterCornerCandidate(Vector2Int coord) {
if (plantCellCoords.Contains(coord))
ret false;

int plantNeighborCount = 0;
foreach (Vector2Int offset in neighborOffsets) {
if (plantCellCoords.Contains(coord + offset)) {
plantNeighborCount++;
}
}

ret plantNeighborCount == 3;
}

void OnDestroy() {
foreach (var kvp in outlinePartMap) {
if (kvp.Value != null) {
kvp.Value.DestroyOutlinePart();
}
}
outlinePartMap.Clear();
plantCellCoords.Clear();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\PlantShadowController.cs

﻿using UnityEngine;

pub cls PlantShadowController : MonoBehaviour {
[SerializeField] Color shadowColor = new Color(0f, 0f, 0f, 0.5f);
float squashFactor = 0.6f;
float shadowAngleDegrees = 270f; // Default to directly downwards
bool flipShadow = false;

[SerializeField] bool enableDistanceFade = true;
[SerializeField] float fadeStartDistance = 1.5f;
[SerializeField] float fadeEndDistance = 3.0f;
[SerializeField] [Range(0f, 1f)] float minFadeAlpha = 0.0f;

string shadowSortingLayerName = "Default";
int shadowSortingOrder = -1;

int shadowSortingLayerID;

pub Color ShadowColor => shadowColor;
pub int ShadowSortingLayer => shadowSortingLayerID;
pub int ShadowSortingOrder => shadowSortingOrder;

pub bool EnableDistanceFade => enableDistanceFade;
pub float FadeStartDistance => fadeStartDistance;
pub float FadeEndDistance => fadeEndDistance;
pub float MinFadeAlpha => minFadeAlpha;

Vector3 baseLocalScale;
Quaternion baseLocalRotation;
Vector3 baseLocalPosition;

Dictionary<SpriteRenderer, ShadowPartController> shadowPartMap = new Dictionary<SpriteRenderer, ShadowPartController>();

void Awake() {
shadowSortingLayerID = SortingLayer.NameToID(shadowSortingLayerName);
if (shadowSortingLayerID == 0 && shadowSortingLayerName != "Default") {
Debug.LogWarning($"Sorting Layer '{shadowSortingLayerName}' not found. Shadow will use 'Default'.", this);
shadowSortingLayerID = SortingLayer.NameToID("Default");
}

baseLocalScale = transform.localScale;
baseLocalRotation = transform.localRotation;
baseLocalPosition = transform.localPosition;
if (baseLocalPosition != Vector3.zero) {
Debug.LogWarning($"'{gameObject.name}' initial localPosition is not zero ({baseLocalPosition}). Shadow origin might be slightly offset from plant root.", gameObject);
}
}

void LateUpdate() {
transform.localPosition = baseLocalPosition; // Should typically be Vector3.zero

Quaternion angleRotation = Quaternion.Euler(0, 0, shadowAngleDegrees);
transform.localRotation = baseLocalRotation * angleRotation;

Vector3 finalScale = baseLocalScale; // Start with original scale
finalScale.y *= squashFactor;

if (flipShadow) {
finalScale.x *= -1f;
}
transform.localScale = finalScale;

}

pub void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject shadowPartPrefab) {
if (plantPartRenderer == null || shadowPartPrefab == null) return;
if (shadowPartMap.ContainsKey(plantPartRenderer)) return;
GameObject shadowInstance = Instantiate(shadowPartPrefab, transform);
ShadowPartController shadowController = shadowInstance.GetComponent<ShadowPartController>();
if (shadowController != null) { shadowController.Initialize(plantPartRenderer, this); shadowPartMap.Add(plantPartRenderer, shadowController); }
else { Debug.LogError($"Shadow Part Prefab '{shadowPartPrefab.name}' missing ShadowPartController.", shadowPartPrefab); Destroy(shadowInstance); }
}

pub void UnregisterPlantPart(SpriteRenderer plantPartRenderer) {
if (plantPartRenderer != null && shadowPartMap.TryGetValue(plantPartRenderer, out ShadowPartController shadowController)) {
if (shadowController != null) { shadowController.OnPlantPartDestroyed(); }
shadowPartMap.Remove(plantPartRenderer);
}
}

void OnDestroy() {
shadowPartMap.Clear(); // Prevent memory leaks
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\ShadowPartController.cs

﻿using UnityEngine;

pub cls ShadowPartController : MonoBehaviour {
SpriteRenderer shadowRenderer;
Transform cachedTransform;

SpriteRenderer plantPartRenderer;
Transform plantPartTransform;
Transform shadowRootTransform;
PlantShadowController mainShadowController;

void Awake() {
shadowRenderer = GetComponent<SpriteRenderer>();
cachedTransform = transform;

shadowRenderer.drawMode = SpriteDrawMode.Simple;
shadowRenderer.enabled = false;
}

pub void Initialize(SpriteRenderer targetPlantPartRenderer, PlantShadowController controller) {
if (targetPlantPartRenderer == null || controller == null) {
Destroy(gameObject);
return;
}

plantPartRenderer = targetPlantPartRenderer;
plantPartTransform = targetPlantPartRenderer.transform;
mainShadowController = controller;
shadowRootTransform = controller.transform;

shadowRenderer.sortingLayerID = mainShadowController.ShadowSortingLayer;
shadowRenderer.sortingOrder = mainShadowController.ShadowSortingOrder;

cachedTransform.SetParent(shadowRootTransform, true); // Parent first

shadowRenderer.enabled = plantPartRenderer.enabled && plantPartRenderer.sprite != null;
UpdateColorAndFade();
}

void LateUpdate() {
if (plantPartRenderer == null || !plantPartRenderer.enabled || plantPartRenderer.sprite == null || shadowRenderer == null || mainShadowController == null) {
if (shadowRenderer != null)
shadowRenderer.enabled = false;
return;
}

shadowRenderer.enabled = true;
shadowRenderer.sprite = plantPartRenderer.sprite;

Vector3 plantPartPosRelativeToPlantRoot = plantPartTransform.parent.InverseTransformPoint(plantPartTransform.position);
cachedTransform.localPosition = plantPartPosRelativeToPlantRoot;
cachedTransform.localRotation = plantPartTransform.localRotation;
cachedTransform.localScale = plantPartTransform.localScale;

shadowRenderer.flipX = plantPartRenderer.flipX;
shadowRenderer.flipY = plantPartRenderer.flipY;

UpdateColorAndFade();
}

void UpdateColorAndFade() {
if (mainShadowController == null || shadowRenderer == null) return;

Color baseShadowColor = mainShadowController.ShadowColor;
float finalAlpha = baseShadowColor.a; // Start with the controller's base alpha

if (mainShadowController.EnableDistanceFade) {
float distance = Vector3.Distance(cachedTransform.position, shadowRootTransform.position); // Distance from shadow part to shadow root

float fadeStart = mainShadowController.FadeStartDistance;
float fadeEnd = mainShadowController.FadeEndDistance;
float minAlpha = mainShadowController.MinFadeAlpha;

if (distance >= fadeEnd) {
finalAlpha *= minAlpha; // Apply min alpha
}
else if (distance > fadeStart) {
float t = Mathf.InverseLerp(fadeStart, fadeEnd, distance);
float distanceAlphaMultiplier = Mathf.Lerp(1f, minAlpha, t);
finalAlpha *= distanceAlphaMultiplier; // Modulate base alpha
}
}

shadowRenderer.color = new Color(baseShadowColor.r, baseShadowColor.g, baseShadowColor.b, finalAlpha);
}

pub void OnPlantPartDestroyed() {
if (this != null && gameObject != null) {
if (Application.isPlaying) {
Destroy(gameObject);
}
else {
DestroyImmediate(gameObject);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridDebugVisualizer.cs

﻿using System.Collections.Generic;
using WegoSystem;

pub cls GridDebugVisualizer : MonoBehaviour {
pub stat GridDebugVisualizer Instance { get; set; }

pub enum RadiusType {
AnimalSearch,
PlantPoop,
Scent,
FireflyPhotosynthesis,
ToolUse
}

[SerializeField] bool showRadiusVisualizations = true;
[SerializeField] float tileVisualizationAlpha = 0.3f;
[SerializeField] GameObject tilePrefab;

[SerializeField] pub Color animalSearchRadiusColor = new Color(1f, 0.5f, 0f, 0.3f);
[SerializeField] pub Color plantPoopRadiusColor = new Color(0.6f, 0.4f, 0.2f, 0.3f);
[SerializeField] pub Color scentRadiusColor = new Color(1f, 1f, 0f, 0.3f);
[SerializeField] pub Color fireflyPhotosynthesisColor = new Color(0f, 1f, 0.5f, 0.3f);
[SerializeField] pub Color toolUseRadiusColor = new Color(0f, 0.5f, 1f, 0.3f);

[SerializeField] bool enableAnimalSearchRadius = true;
[SerializeField] bool enablePlantPoopRadius = true;
[SerializeField] bool enableScentRadius = true;
[SerializeField] bool enableFireflyPhotosynthesis = true;
[SerializeField] bool enableToolUseRadius = true;

cls RadiusRequest {
pub GridPosition Center;
pub int Radius;
pub RadiusType Type;
}

ro Dictionary<object, List<GameObject>> oneShotVisualizations = new Dictionary<object, List<GameObject>>();
ro Dictionary<object, RadiusRequest> continuousRequests = new Dictionary<object, RadiusRequest>();
ro Dictionary<object, (GridPosition center, int radius)> lastDrawnState = new Dictionary<object, (GridPosition, int)>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void OnDestroy() {
ClearAllVisualizations();
if (Instance == this) Instance = null;
}

void Update() {
ProcessContinuousRequests();
}

pub void ShowContinuousRadius(object source, GridPosition center, int radius, RadiusType type) {
if (!showRadiusVisualizations || source == null || !IsTypeEnabled(type)) return;

if (!continuousRequests.ContainsKey(source)) {
continuousRequests.Add(source, new RadiusRequest());
}
continuousRequests[source].Center = center;
continuousRequests[source].Radius = radius;
continuousRequests[source].Type = type;
}

pub void HideContinuousRadius(object source) {
if (source == null) return;

if (continuousRequests.Remove(source)) {
ClearVisualization(source);
}
}

pub void VisualizeRadius(object source, GridPosition center, int radius, Color color, float duration = 0f) {
if (!showRadiusVisualizations || tilePrefab == null) return;

ClearVisualization(source);

var tiles = GridRadiusUtility.GetTilesInCircle(center, radius);
var tileObjects = new List<GameObject>();

foreach (var tile in tiles) {
Vector3 worldPos = GridPositionManager.Instance.GridToWorld(tile);
GameObject tileVis = Instantiate(tilePrefab, worldPos, Quaternion.identity, transform);

SpriteRenderer sr = tileVis.GetComponent<SpriteRenderer>();
if (sr != null) {
Color finalColor = color;
finalColor.a = tileVisualizationAlpha;
sr.color = finalColor;
sr.sortingOrder = -100;
}
tileObjects.Add(tileVis);

if (duration > 0) {
Destroy(tileVis, duration);
}
}

if (duration <= 0) {
oneShotVisualizations[source] = tileObjects;
}
}

pub void ClearVisualization(object source) {
if (oneShotVisualizations.TryGetValue(source, out var tiles)) {
foreach (var tile in tiles) {
if (tile != null) Destroy(tile);
}
oneShotVisualizations.Remove(source);
}
if (lastDrawnState.ContainsKey(source)) {
lastDrawnState.Remove(source);
}
}

pub void VisualizeAnimalSearchRadius(AnimalController animal, GridPosition center, int radius) {
ShowContinuousRadius(animal, center, radius, RadiusType.AnimalSearch);
}

pub void VisualizePlantPoopRadius(PlantGrowth plant, GridPosition center, int radius) {
ShowContinuousRadius(plant, center, radius, RadiusType.PlantPoop);
}

pub void VisualizeScentRadius(ScentSource scentSource, GridPosition center, int radius) {
ShowContinuousRadius(scentSource, center, radius, RadiusType.Scent);
}

pub void VisualizeFireflyPhotosynthesisRadius(FireflyController firefly, GridPosition center, int radius) {
ShowContinuousRadius(firefly, center, radius, RadiusType.FireflyPhotosynthesis);
}

pub void VisualizeToolUseRadius(object tool, GridPosition center, int radius) {
ShowContinuousRadius(tool, center, radius, RadiusType.ToolUse);
}

pub void SetAnimalSearchRadiusEnabled(bool enabled) { enableAnimalSearchRadius = enabled; }
pub void SetPlantPoopRadiusEnabled(bool enabled) { enablePlantPoopRadius = enabled; }
pub void SetScentRadiusEnabled(bool enabled) { enableScentRadius = enabled; }
pub void SetFireflyPhotosynthesisEnabled(bool enabled) { enableFireflyPhotosynthesis = enabled; }
pub void SetToolUseRadiusEnabled(bool enabled) { enableToolUseRadius = enabled; }

pub void SetRadiusVisualizationsEnabled(bool enabled) {
showRadiusVisualizations = enabled;
if (!enabled) {
ClearAllVisualizations();
}
}

pub Color GetColorForType(RadiusType type) {
switch (type) {
case RadiusType.AnimalSearch: ret animalSearchRadiusColor;
case RadiusType.PlantPoop: ret plantPoopRadiusColor;
case RadiusType.Scent: ret scentRadiusColor;
case RadiusType.FireflyPhotosynthesis: ret fireflyPhotosynthesisColor;
case RadiusType.ToolUse: ret toolUseRadiusColor;
default: ret Color.white;
}
}

bool IsTypeEnabled(RadiusType type) {
switch (type) {
case RadiusType.AnimalSearch: ret enableAnimalSearchRadius;
case RadiusType.PlantPoop: ret enablePlantPoopRadius;
case RadiusType.Scent: ret enableScentRadius;
case RadiusType.FireflyPhotosynthesis: ret enableFireflyPhotosynthesis;
case RadiusType.ToolUse: ret enableToolUseRadius;
default: ret true;
}
}

void ProcessContinuousRequests() {
if (!showRadiusVisualizations || tilePrefab == null) return;

List<object> sourcesToRemove = new List<object>();
foreach (var drawnSource in lastDrawnState.Keys) {
if (!continuousRequests.ContainsKey(drawnSource)) {
sourcesToRemove.Add(drawnSource);
}
}
foreach (var source in sourcesToRemove) {
ClearVisualization(source);
}

foreach (var kvp in continuousRequests) {
object source = kvp.Key;
RadiusRequest request = kvp.Value;

if (!IsTypeEnabled(request.Type)) {
if (lastDrawnState.ContainsKey(source)) {
ClearVisualization(source);
}
continue;
}

bool needsRedraw = false;
if (lastDrawnState.TryGetValue(source, out var lastState)) {
if (lastState.center != request.Center || lastState.radius != request.Radius) {
needsRedraw = true;
}
}
else {
needsRedraw = true;
}

if (needsRedraw) {
Color color = GetColorForType(request.Type);
VisualizeRadius(source, request.Center, request.Radius, color, 0);
lastDrawnState[source] = (request.Center, request.Radius);
}
}
}

void ClearAllVisualizations() {
foreach (var kvp in oneShotVisualizations) {
foreach (var tile in kvp.Value) {
if (tile != null) Destroy(tile);
}
}
oneShotVisualizations.Clear();
continuousRequests.Clear();
lastDrawnState.Clear();
}

pub bool IsRadiusVisualizationEnabled => showRadiusVisualizations;
pub bool IsAnimalSearchRadiusEnabled => enableAnimalSearchRadius;
pub bool IsPlantPoopRadiusEnabled => enablePlantPoopRadius;
pub bool IsScentRadiusEnabled => enableScentRadius;
pub bool IsFireflyPhotosynthesisEnabled => enableFireflyPhotosynthesis;
pub bool IsToolUseRadiusEnabled => enableToolUseRadius;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridSnapStartup.cs

﻿// Assets\Scripts\Core\GridSnapStartup.cs

using WegoSystem;

pub cls GridSnapStartup : MonoBehaviour {
[SerializeField] bool snapAllAnimals = true;
[SerializeField] bool snapAllPlants = true;
[SerializeField] bool snapPlayer = true;
[SerializeField] bool debugLog = true;

void Awake() {
if (GridPositionManager.Instance == null) {
Debug.LogError("[GridSnapStartup] GridPositionManager not found! Cannot snap entities.");
return;
}
}

void Start() {
PerformGridSnapping();
}

void PerformGridSnapping() {
int snappedCount = 0;

if (snapPlayer) {
GardenerController[] gardeners = FindObjectsByType<GardenerController>(FindObjectsSortMode.None);
foreach (var gardener in gardeners) {
GridPositionManager.Instance.SnapEntityToGrid(gardener.gameObject);
snappedCount++;
}
}

if (snapAllAnimals) {
AnimalController[] animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
foreach (var animal in animals) {
GridPositionManager.Instance.SnapEntityToGrid(animal.gameObject);
snappedCount++;
}
}

if (snapAllPlants) {
PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
foreach (var plant in plants) {
GridPositionManager.Instance.SnapEntityToGrid(plant.gameObject);
snappedCount++;
}
}

if (debugLog) {
Debug.Log($"[GridSnapStartup] Snapped {snappedCount} entities to grid on startup");
}
}

void SnapAllEntitiesNow() {
if (GridPositionManager.Instance == null) {
Debug.LogError("GridPositionManager not found in scene!");
return;
}

PerformGridSnapping();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickDebugMonitor.cs

﻿using UnityEngine;
using TMPro;
using WegoSystem;

pub cls TickDebugMonitor : MonoBehaviour {
[SerializeField] GameObject monitorPanel;
[SerializeField] TextMeshProUGUI tickCounterText;
[SerializeField] TextMeshProUGUI tickRateText;
[SerializeField] TextMeshProUGUI dayProgressText;
[SerializeField] TextMeshProUGUI phaseText;

[SerializeField] TextMeshProUGUI animalCountText;
[SerializeField] TextMeshProUGUI plantCountText;
[SerializeField] TextMeshProUGUI fireflyCountText;

[SerializeField] TextMeshProUGUI tickDurationText;
[SerializeField] Slider tickDurationBar;
[SerializeField] float maxTickDuration = 50f; // milliseconds

[SerializeField] Transform effectListContainer;
[SerializeField] GameObject effectEntryPrefab;

[SerializeField] KeyCode toggleKey = KeyCode.F3;
[SerializeField] bool showOnStart = false;

float lastTickStartTime;
float lastTickDuration;
Queue<float> tickDurationHistory = new Queue<float>();
c int HISTORY_SIZE = 60;

Dictionary<string, TickEffectEntry> activeEffects = new Dictionary<string, TickEffectEntry>();
List<GameObject> effectUIEntries = new List<GameObject>();

cls TickEffectEntry {
pub string name;
pub string source;
pub int remainingTicks;
pub Color color;
}

void Start() {
monitorPanel.SetActive(showOnStart);

if (TickManager.Instance != null) {
TickManager.Instance.OnTickStarted += OnTickStarted;
TickManager.Instance.OnTickCompleted += OnTickCompleted;
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.OnTickStarted -= OnTickStarted;
TickManager.Instance.OnTickCompleted -= OnTickCompleted;
}
}

void Update() {
if (Input.GetKeyDown(toggleKey)) {
monitorPanel.SetActive(!monitorPanel.activeSelf);
}

if (monitorPanel.activeSelf) {
UpdateDisplay();
}
}

void OnTickStarted(int tick) {
lastTickStartTime = Time.realtimeSinceStartup;
}

void OnTickCompleted(int tick) {
lastTickDuration = (Time.realtimeSinceStartup - lastTickStartTime) * 1000f; // Convert to ms

tickDurationHistory.Enqueue(lastTickDuration);
if (tickDurationHistory.Count > HISTORY_SIZE) {
tickDurationHistory.Dequeue();
}
}

void UpdateDisplay() {
if (TickManager.Instance == null) return;

tickCounterText.text = $"Tick: {TickManager.Instance.CurrentTick}";
tickRateText.text = $"Rate: {TickManager.Instance.Config.ticksPerRealSecond:F1} ticks/sec";

if (TickManager.Instance.Config != null) {
int dayProgress = TickManager.Instance.Config.GetDayProgress(TickManager.Instance.CurrentTick);
float dayPercent = TickManager.Instance.Config.GetDayProgressNormalized(TickManager.Instance.CurrentTick) * 100f;
dayProgressText.text = $"Day: {dayProgress}/{TickManager.Instance.Config.ticksPerDay} ({dayPercent:F0}%)";
}

if (RunManager.Instance != null) {
phaseText.text = $"Phase: {RunManager.Instance.CurrentPhase} (Tick {RunManager.Instance.CurrentPhaseTicks})";
}

animalCountText.text = $"Animals: {CountEntities<AnimalController>()}";
plantCountText.text = $"Plants: {PlantGrowth.AllActivePlants.Count}";
fireflyCountText.text = $"Fireflies: {CountEntities<FireflyController>()}";

float avgTickDuration = tickDurationHistory.Count > 0 ?
tickDurationHistory.Average() : 0f;
tickDurationText.text = $"Tick Time: {avgTickDuration:F1}ms (Last: {lastTickDuration:F1}ms)";
tickDurationBar.value = avgTickDuration / maxTickDuration;

if (avgTickDuration < maxTickDuration * 0.5f) {
tickDurationBar.fillRect.GetComponent<Image>().color = Color.green;
} else if (avgTickDuration < maxTickDuration * 0.8f) {
tickDurationBar.fillRect.GetComponent<Image>().color = Color.yellow;
} else {
tickDurationBar.fillRect.GetComponent<Image>().color = Color.red;
}

UpdateActiveEffects();
}

int CountEntities<T>() where T : Component {
ret FindObjectsByType<T>(FindObjectsSortMode.None).Length;
}

void UpdateActiveEffects() {
activeEffects.Clear();

var animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
foreach (var animal in animals) {
if (animal.Needs != null && animal.Needs.CurrentHealth < animal.Definition.maxHealth * 0.3f) {
AddEffect($"{animal.SpeciesName}_low_health", "Low Health", animal.SpeciesName, -1, Color.red);
}
}

foreach (var plant in PlantGrowth.AllActivePlants) {
if (plant.CurrentState == PlantState.Growing) {
var logic = plant.GrowthLogic;
int remainingTicks = logic.GrowthTicksPerStage - Mathf.FloorToInt(logic.GetGrowthProgressNormalized() * logic.GrowthTicksPerStage);
AddEffect($"plant_growing_{plant.GetInstanceID()}", "Growing", plant.name, remainingTicks, Color.green);
}
}

RefreshEffectUI();
}

void AddEffect(string id, string name, string source, int remainingTicks, Color color) {
activeEffects[id] = new TickEffectEntry {
name = name,
source = source,
remainingTicks = remainingTicks,
color = color
};
}

void RefreshEffectUI() {
foreach (var entry in effectUIEntries) {
Destroy(entry);
}
effectUIEntries.Clear();

foreach (var effect in activeEffects.Values.OrderBy(e => e.source)) {
GameObject entry = Instantiate(effectEntryPrefab, effectListContainer);
effectUIEntries.Add(entry);

TextMeshProUGUI text = entry.GetComponentInChildren<TextMeshProUGUI>();
if (text != null) {
string tickText = effect.remainingTicks >= 0 ? $"{effect.remainingTicks}t" : "∞";
text.text = $"{effect.source}: {effect.name} [{tickText}]";
text.color = effect.color;
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Tooltips\TooltipTrigger.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;

pub cls TooltipTrigger : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler {
ItemView _itemView;
NodeCell _nodeCell;
bool _isShowingTooltip = false;

void Awake() {
_itemView = GetComponent<ItemView>();
_nodeCell = GetComponentInParent<NodeCell>();
}

pub void OnPointerEnter(PointerEventData eventData) {
if (UniversalTooltipManager.Instance == null || _isShowingTooltip) return;

ShowTooltip();
}

pub void OnPointerExit(PointerEventData eventData) {
if (UniversalTooltipManager.Instance == null || !_isShowingTooltip) return;

HideTooltip();
}

void ShowTooltip() {
ITooltipDataProvider provider = null;
object sourceData = null; // For passing NodeData to a NodeDefinition provider

if (_itemView != null) {
if (_itemView.GetToolDefinition() != null) {
provider = _itemView.GetToolDefinition();
}
else if (_itemView.GetNodeDefinition() != null) {
provider = _itemView.GetNodeDefinition();
sourceData = _itemView.GetNodeData();
}
}
else if (_nodeCell != null) {
if (_nodeCell.GetToolDefinition() != null) {
provider = _nodeCell.GetToolDefinition();
}
else if (_nodeCell.GetNodeDefinition() != null) {
provider = _nodeCell.GetNodeDefinition();
sourceData = _nodeCell.GetNodeData();
}
}

if (provider != null) {
UniversalTooltipManager.Instance.ShowTooltip(provider, transform, sourceData);
_isShowingTooltip = true;
}
}

void HideTooltip() {
UniversalTooltipManager.Instance?.HideTooltip();
_isShowingTooltip = false;
}

void OnDisable() {
if (_isShowingTooltip) {
HideTooltip();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Tooltips\UniversalTooltipManager.cs

﻿using UnityEngine;
using TMPro;

pub ifc ITooltipDataProvider {
string GetTooltipTitle();
string GetTooltipDescription();
string GetTooltipDetails(object source = null);
}

pub cls UniversalTooltipManager : MonoBehaviour {
pub stat UniversalTooltipManager Instance { get; set; }

[SerializeField] GameObject tooltipPanel;
[SerializeField] TextMeshProUGUI titleText;
[SerializeField] TextMeshProUGUI descriptionText;
[SerializeField] TextMeshProUGUI detailsText;
[SerializeField] Image backgroundImage;
[SerializeField] CanvasGroup canvasGroup;
[SerializeField] VerticalLayoutGroup layoutGroup;

[SerializeField] float fadeDuration = 0.15f;
[SerializeField] bool moveTooltipWithMouse = true;
[SerializeField] Vector2 mouseFollowOffset = new Vector2(15f, -15f);

[SerializeField] Color backgroundColor = new Color(0.1f, 0.1f, 0.1f, 0.95f);
[SerializeField] Color titleColor = Color.white;
[SerializeField] Color descriptionColor = new Color(0.8f, 0.8f, 0.8f, 1f);
[SerializeField] Color detailsColor = new Color(0.7f, 0.7f, 0.7f, 1f);
[SerializeField] int titleFontSize = 18;
[SerializeField] int descriptionFontSize = 14;
[SerializeField] int detailsFontSize = 12;

Coroutine _fadeCoroutine;
object _currentTarget;
bool _isVisible = false;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (!ValidateReferences()) {
enabled = false;
return;
}

SetupTooltipPanel();
if (tooltipPanel != null) tooltipPanel.SetActive(false);
if (canvasGroup != null) canvasGroup.alpha = 0f;
_isVisible = false;
}

void Update() {
if (_isVisible && IsTargetNullOrDestroyed(_currentTarget)) {
HideTooltip();
}
}

pub void ShowTooltip(ITooltipDataProvider provider, Transform anchor = null, object source = null) {
if (provider == null) return;

if (_isVisible && ReferenceEquals(_currentTarget, provider)) return;

_currentTarget = provider;

string title = provider.GetTooltipTitle();
string description = provider.GetTooltipDescription();
string details = provider.GetTooltipDetails(source);

ShowTooltipInternal(title, description, details, anchor);
}

pub void HideTooltip() {
_currentTarget = null;
if (tooltipPanel == null || canvasGroup == null) return;

if (_fadeCoroutine != null) {
StopCoroutine(_fadeCoroutine);
}

if (fadeDuration > 0f && gameObject.activeInHierarchy) {
_fadeCoroutine = StartCoroutine(FadeTooltip(false));
}
else {
canvasGroup.alpha = 0f;
if (tooltipPanel != null) tooltipPanel.SetActive(false);
_isVisible = false;
}
}

void ShowTooltipInternal(string title, string description, string details, Transform itemAnchor) {
if (tooltipPanel == null || canvasGroup == null) return;

if (_fadeCoroutine != null) {
StopCoroutine(_fadeCoroutine);
}

if (titleText != null) {
titleText.text = title;
titleText.gameObject.SetActive(!string.IsNullOrEmpty(title));
}
if (descriptionText != null) {
descriptionText.text = description;
descriptionText.gameObject.SetActive(!string.IsNullOrEmpty(description));
}
if (detailsText != null) {
detailsText.text = details;
detailsText.gameObject.SetActive(!string.IsNullOrEmpty(details));
}

tooltipPanel.SetActive(true);
if (layoutGroup != null) {
LayoutRebuilder.ForceRebuildLayoutImmediate(layoutGroup.GetComponent<RectTransform>());
}

if (moveTooltipWithMouse) {
PositionTooltipWithMouse();
}

if (fadeDuration > 0f) {
_fadeCoroutine = StartCoroutine(FadeTooltip(true));
}
else {
canvasGroup.alpha = 1f;
_isVisible = true;
}
}

void PositionTooltipWithMouse() {
var tooltipRect = tooltipPanel.GetComponent<RectTransform>();
var rootCanvas = tooltipPanel.GetComponentInParent<Canvas>()?.rootCanvas;

if (tooltipRect == null || rootCanvas == null || !Input.mousePresent) return;

Vector2 targetScreenPos = Input.mousePosition;
targetScreenPos += mouseFollowOffset; // Apply user offset

var panelRect = tooltipRect.rect;
targetScreenPos.x = Mathf.Clamp(targetScreenPos.x, 0, Screen.width - panelRect.width);
targetScreenPos.y = Mathf.Clamp(targetScreenPos.y, 0, Screen.height - panelRect.height);

var parentRect = tooltipRect.parent as RectTransform;
if (parentRect == null) return;

Camera renderCamera = (rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay) ? null : rootCanvas.worldCamera;
if (RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRect, targetScreenPos, renderCamera, out var localPos)) {
tooltipRect.localPosition = localPos;
}
}

IEnumerator FadeTooltip(bool fadeIn) {
if (canvasGroup == null) yield break;

float elapsed = 0f;
float startAlpha = canvasGroup.alpha;
float targetAlpha = fadeIn ? 1f : 0f;

if (fadeIn) _isVisible = true;

if (fadeIn && tooltipPanel != null && !tooltipPanel.activeSelf)
tooltipPanel.SetActive(true);

while (elapsed < fadeDuration) {
elapsed += Time.unscaledDeltaTime;
float t = (fadeDuration > 0) ? elapsed / fadeDuration : 1f;
canvasGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, t);
yield ret null;
}

canvasGroup.alpha = targetAlpha;

if (!fadeIn) {
if (tooltipPanel != null) tooltipPanel.SetActive(false);
_isVisible = false;
}
}

bool IsTargetNullOrDestroyed(object target) {
if (target is UnityEngine.Object unityObject) {
ret unityObject == null;
}
ret System.Object.ReferenceEquals(target, null);
}

void SetupTooltipPanel() {
if (canvasGroup != null) {
canvasGroup.alpha = 0f;
canvasGroup.interactable = false;
canvasGroup.blocksRaycasts = false;
}
if (backgroundImage != null) backgroundImage.color = backgroundColor;
ApplyTextStyles();
}

void ApplyTextStyles() {
if (titleText != null) { titleText.color = titleColor; titleText.fontSize = titleFontSize; titleText.fontStyle = FontStyles.Bold; }
if (descriptionText != null) { descriptionText.color = descriptionColor; descriptionText.fontSize = descriptionFontSize; }
if (detailsText != null) { detailsText.color = detailsColor; detailsText.fontSize = detailsFontSize; }
}

bool ValidateReferences() {
if (tooltipPanel == null) { Debug.LogError("[UniversalTooltipManager] Tooltip Panel not assigned!"); ret false; }

if (canvasGroup == null) canvasGroup = tooltipPanel.GetComponent<CanvasGroup>() ?? tooltipPanel.AddComponent<CanvasGroup>();
if (layoutGroup == null) layoutGroup = tooltipPanel.GetComponent<VerticalLayoutGroup>();
if (backgroundImage == null) backgroundImage = tooltipPanel.GetComponent<Image>();
if (titleText == null) titleText = FindTextComponent("Title");
if (descriptionText == null) descriptionText = FindTextComponent("Description");
if (detailsText == null) detailsText = FindTextComponent("Details");

if (titleText == null) { Debug.LogError("[UniversalTooltipManager] Missing required title text component!"); ret false; }

ret true;
}

TextMeshProUGUI FindTextComponent(string nameContains) {
if (tooltipPanel == null) ret null;
foreach (var text in tooltipPanel.GetComponentsInChildren<TextMeshProUGUI>(true)) {
if (text.name.ToLower().Contains(nameContains.ToLower()))
ret text;
}
ret null;
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Utilities\ColorExtensions.cs

﻿using UnityEngine;

pub stat cls ColorExtensions {
pub stat Color WithAlpha(this Color c, float alpha) {
ret new Color(c.r, c.g, c.b, alpha);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Utilities\PrefabOrigin.cs

﻿// Assets/Scripts/Utility/PrefabOrigin.cs

pub cls PrefabOrigin : MonoBehaviour {
pub Transform originTransform;

void Awake() {
if (originTransform == null) {
Debug.LogError($"[PrefabOrigin] The 'Origin Transform' is not assigned on '{gameObject.name}'. The script cannot function.", this);
Destroy(this); // Destroy self if not configured
return;
}

if (!originTransform.IsChildOf(transform)) {
Debug.LogError($"[PrefabOrigin] The assigned 'Origin Transform' ('{originTransform.name}') is not a child of '{gameObject.name}'. The script cannot function.", this);
Destroy(this); // Destroy self if configuration is invalid
return;
}

Vector3 worldOffset = transform.TransformVector(originTransform.localPosition);

transform.position -= worldOffset;

Destroy(this);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\NightColorPostProcess.cs

﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

pub cls NightColorPostProcess : MonoBehaviour {
pub WeatherManager weatherManager;

pub Volume globalVolume;

pub Color dayColorFilter = Color.white;
pub Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);

pub float dayPostExposure = 0f;
pub float nightPostExposure = -0.5f;

pub float daySaturation = 0f;
pub float nightSaturation = -50f;

pub float dayFilmGrainIntensity = 0.1f;
pub float nightFilmGrainIntensity = 0.5f;

pub float dayVignetteIntensity = 0.2f;
pub float nightVignetteIntensity = 0.5f;

pub float dayVignetteSmoothness = 0.2f;
pub float nightVignetteSmoothness = 0.3f;

[SerializeField] float transitionSmoothingSpeed = 5f;

ColorAdjustments colorAdjustments;
FilmGrain filmGrain;
Vignette vignette;

float smoothedSunIntensity;

void Start() {
if (!weatherManager) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] WeatherManager not assigned!", this);
enabled = false; // Disable script if core references are missing
return;
}
if (!globalVolume) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume not assigned!", this);
enabled = false;
return;
}
if (globalVolume.profile == null) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume has no profile assigned!", this);
enabled = false;
return;
}

if (!globalVolume.profile.TryGet<ColorAdjustments>(out colorAdjustments)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] ColorAdjustments ovr not found in Volume profile.", this);
}
if (!globalVolume.profile.TryGet<FilmGrain>(out filmGrain)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] FilmGrain ovr not found in Volume profile.", this);
}
if (!globalVolume.profile.TryGet<Vignette>(out vignette)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] Vignette ovr not found in Volume profile.", this);
}

smoothedSunIntensity = weatherManager.sunIntensity;
}

void Update() {
if (colorAdjustments == null && filmGrain == null && vignette == null)
return; // Nothing to update if no overrides were found

if (weatherManager != null) {
smoothedSunIntensity = Mathf.Lerp(smoothedSunIntensity, weatherManager.sunIntensity, transitionSmoothingSpeed * Time.deltaTime);
}

float sun = Mathf.Clamp01(smoothedSunIntensity); // Use the smoothed value
float t = 1f - sun;  // t=0 at day, t=1 at night

if (colorAdjustments != null) {
colorAdjustments.colorFilter.value = Color.Lerp(dayColorFilter, nightColorFilter, t);
colorAdjustments.postExposure.value = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
colorAdjustments.saturation.value = Mathf.Lerp(daySaturation, nightSaturation, t);
}

if (filmGrain != null) {
filmGrain.intensity.value = Mathf.Lerp(dayFilmGrainIntensity, nightFilmGrainIntensity, t);
}

if (vignette != null) {
vignette.intensity.value = Mathf.Lerp(dayVignetteIntensity, nightVignetteIntensity, t);
vignette.smoothness.value = Mathf.Lerp(dayVignetteSmoothness, nightVignetteSmoothness, t);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\RuntimeCircleDrawer.cs

﻿using UnityEngine;

pub cls RuntimeCircleDrawer : MonoBehaviour {
pub int segments = 30; // Number of line segments to approximate the circle
pub float radius = 1.0f;
pub float lineWidth = 0.02f;
pub Color color = Color.yellow;
pub Material lineMaterial; // Assign the same material used for firefly lines, or a specific one

LineRenderer lineRenderer;
bool needsRedraw = true; // Flag to force redraw on first UpdateCircle call or when params change
float currentRadius = -1f; // Store current values to detect changes
Color currentColor = Color.clear;

void Awake() {
lineRenderer = GetComponent<LineRenderer>();
if (lineRenderer == null) { // Should not happen with RequireComponent
Debug.LogError($"[{gameObject.name}] RuntimeCircleDrawer: Missing required LineRenderer component!");
enabled = false; // Disable script if component missing
return;
}
ConfigureLineRendererDefaults();
lineRenderer.enabled = false; // Start hidden
}

void ConfigureLineRendererDefaults() {
lineRenderer.useWorldSpace = false; // Draw relative to this object's transform
lineRenderer.loop = true; // Connect the last point to the first
lineRenderer.startWidth = lineWidth;
lineRenderer.endWidth = lineWidth;

if (lineMaterial != null && lineRenderer.material == null) {
lineRenderer.material = lineMaterial;
}

SpriteRenderer parentSprite = GetComponentInParent<SpriteRenderer>();
if (parentSprite != null) {
lineRenderer.sortingLayerName = parentSprite.sortingLayerName;
lineRenderer.sortingOrder = parentSprite.sortingOrder + 1; // Draw slightly in front
} else {
lineRenderer.sortingLayerName = "Default";
lineRenderer.sortingOrder = 1;
}
}

pub void UpdateCircle(float newRadius, Color newColor) {
bool radiusChanged = !Mathf.Approximately(currentRadius, newRadius);
bool colorChanged = currentColor != newColor;

if (!needsRedraw && !radiusChanged && !colorChanged) {
if (!lineRenderer.enabled) lineRenderer.enabled = true;
return; // No change needed
}

currentRadius = newRadius;
radius = newRadius; // Update pub field for potential inspector viewing
currentColor = newColor;
color = newColor; // Update pub field

lineRenderer.startColor = currentColor;
lineRenderer.endColor = currentColor;

if (colorChanged && Debug.isDebugBuild) {
Debug.Log($"[RuntimeCircleDrawer] Updated color to: {newColor}", gameObject);
}

DrawCircle(); // Recalculate points
lineRenderer.enabled = true; // Ensure it's visible
needsRedraw = false; // Mark as drawn
}

pub void HideCircle() {
if (lineRenderer != null && lineRenderer.enabled) {
lineRenderer.enabled = false;
needsRedraw = true; // Needs redraw next time it's shown
}
}

void DrawCircle() {
if (lineRenderer == null || segments <= 2 || radius <= 0f) {
lineRenderer.positionCount = 0; // Clear points if invalid params
return;
};

if (lineRenderer.positionCount != segments + 1) {
lineRenderer.positionCount = segments + 1;
}

float angleStep = 360f / segments;
Vector3[] points = new Vector3[segments + 1];

for (int i = 0; i <= segments; i++) {
float currentAngle = Mathf.Deg2Rad * (i * angleStep);
float x = Mathf.Cos(currentAngle) * radius;
float y = Mathf.Sin(currentAngle) * radius;
points[i] = new Vector3(x, y, 0); // Z is 0 for local space relative to transform
}

lineRenderer.SetPositions(points);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\WaterReflection.cs

﻿using UnityEngine;
using UnityEngine.Tilemaps;
#if UNITY_EDITOR
using UnityEditor;
#endif

pub cls WaterReflection : MonoBehaviour {
pub cls OverrideSettings {
pub bool reflectionOpacity = false;
pub bool reflectionTint = false;
pub bool gradientFadeBaseMaterial = false;
pub bool sortingOrderOffset = false;
pub bool useWaterMasking = false;
pub bool waterTilemapTag = false;
pub bool showDebugInfo = false;
}
[SerializeField] OverrideSettings overrides;

[SerializeField] bool useParentAsReference = false; // This remains a local setting

[SerializeField] float yOffset = -1f; // This remains a local setting

[SerializeField] [Range(0f, 1f)] float localReflectionOpacity = 0.5f;

[SerializeField] Color localReflectionTint = Color.white;

[SerializeField] bool enableDistanceFade = true; // This remains local as it depends on material
[SerializeField] float fadeStartDistance = 0.0f; // Local
[SerializeField] float fadeEndDistance = 1.0f; // Local
[SerializeField] [Range(0f, 1f)] float minFadeAlpha = 0.0f; // Local
[SerializeField] Material localGradientFadeBaseMaterial;

[SerializeField] int localSortingOrderOffset = -1;

[SerializeField] bool localUseWaterMasking = true;
[SerializeField] string localWaterTilemapTag = "Water";

[SerializeField] bool localShowDebugInfo = false;

SpriteRenderer originalRenderer;
Animator originalAnimator;
GameObject reflectionObject;
SpriteRenderer reflectionRenderer;
Animator reflectionAnimator;
Material reflectionMaterialInstance; // Instanced material for this reflection

float _actualReflectionOpacity;
Color _actualReflectionTint;
Material _actualGradientFadeBaseMaterial;
int _actualSortingOrderOffset;
bool _actualUseWaterMasking;
string _actualWaterTilemapTag;
bool _actualShowDebugInfo;

Sprite lastSprite;
Color lastOriginalColor;
bool lastFlipX, lastFlipY;
bool lastEnabled;
Vector3 lastScale;
Vector3 lastPosition;
float lastParentY;

void Awake() {
_actualReflectionOpacity = localReflectionOpacity;
_actualReflectionTint = localReflectionTint;
_actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
_actualSortingOrderOffset = localSortingOrderOffset;
_actualUseWaterMasking = localUseWaterMasking;
_actualWaterTilemapTag = localWaterTilemapTag;
_actualShowDebugInfo = localShowDebugInfo;

originalRenderer = GetComponent<SpriteRenderer>();
originalAnimator = GetComponent<Animator>();

if (originalRenderer == null) {
if (_actualShowDebugInfo) Debug.LogError($"[WaterReflection] No SpriteRenderer found on {gameObject.name}! Component disabled.", this);
enabled = false;
return;
}

if (useParentAsReference && transform.parent == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] 'Use Parent As Reference' is true on {gameObject.name}, but it has no parent. Will use self as reference.", this);
useParentAsReference = false;
}

if (Application.isPlaying) {
if (enableDistanceFade && _actualGradientFadeBaseMaterial == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection Awake] '{gameObject.name}': 'Enable Distance Fade' is true, but no 'Gradient Fade Base Material' (local or global) is assigned/found. Distance fade will not use the custom shader.", this);
}
}

CreateReflectionObject();

if (_actualUseWaterMasking) {
SetupWaterMaskingInteraction();
}
}

void ResolveSettings() {
if (WaterReflectionManager.Instance != null) {
_actualReflectionOpacity = overrides.reflectionOpacity ? localReflectionOpacity : WaterReflectionManager.Instance.defaultReflectionOpacity;
_actualReflectionTint = overrides.reflectionTint ? localReflectionTint : WaterReflectionManager.Instance.defaultReflectionTint;
_actualGradientFadeBaseMaterial = overrides.gradientFadeBaseMaterial ? localGradientFadeBaseMaterial : WaterReflectionManager.Instance.defaultGradientFadeMaterial;
_actualSortingOrderOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : WaterReflectionManager.Instance.defaultSortingOrderOffset;
_actualUseWaterMasking = overrides.useWaterMasking ? localUseWaterMasking : WaterReflectionManager.Instance.defaultUseWaterMasking;
_actualWaterTilemapTag = overrides.waterTilemapTag && !string.IsNullOrEmpty(localWaterTilemapTag) ? localWaterTilemapTag : WaterReflectionManager.Instance.defaultWaterTilemapTag;
_actualShowDebugInfo = overrides.showDebugInfo ? localShowDebugInfo : WaterReflectionManager.Instance.globalShowDebugInfo;
}
else // Fallback if no manager in scene {
_actualReflectionOpacity = localReflectionOpacity;
_actualReflectionTint = localReflectionTint;
_actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
_actualSortingOrderOffset = localSortingOrderOffset;
_actualUseWaterMasking = localUseWaterMasking;
_actualWaterTilemapTag = localWaterTilemapTag;
_actualShowDebugInfo = localShowDebugInfo;
if (Application.isPlaying) Debug.LogWarning("[WaterReflection] WaterReflectionManager not found in scene. Using local settings for all reflections.", this);
}
}

void Start() {
ResolveSettings(); // Now resolve settings after all Awake() calls are completed
UpdateReflectionVisuals();
UpdateReflectionTransform();
CacheCurrentState();
}

void LateUpdate() {
if (originalRenderer == null || reflectionObject == null) {
if (reflectionObject != null) reflectionObject.SetActive(false);
return;
}
UpdateReflectionTransform();
if (HasVisualStateChanged()) {
UpdateReflectionVisuals();
CacheCurrentState();
}
}

void CreateReflectionObject() {
reflectionObject = new GameObject($"{gameObject.name}_Reflection");
reflectionObject.transform.SetParent(transform.parent, false);
reflectionObject.transform.SetSiblingIndex(transform.GetSiblingIndex() + 1);

reflectionRenderer = reflectionObject.AddComponent<SpriteRenderer>();
reflectionRenderer.sortingLayerName = originalRenderer.sortingLayerName;
reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + _actualSortingOrderOffset; // Use resolved
reflectionRenderer.drawMode = originalRenderer.drawMode;

if (enableDistanceFade && _actualGradientFadeBaseMaterial != null) // Use resolved {
reflectionMaterialInstance = new Material(_actualGradientFadeBaseMaterial);
reflectionRenderer.material = reflectionMaterialInstance;
if (_actualShowDebugInfo && Application.isPlaying) Debug.Log($"[{gameObject.name}] Instantiated gradient material for reflection using '{_actualGradientFadeBaseMaterial.name}'.", this);
}
else {
reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
if (enableDistanceFade && _actualGradientFadeBaseMaterial == null && _actualShowDebugInfo && Application.isPlaying) {
Debug.Log($"[{gameObject.name}] Using sharedMaterial for reflection as no gradientFadeBaseMaterial (local or global) was resolved during CreateReflectionObject.", this);
}
}

if (originalAnimator != null) {
reflectionAnimator = reflectionObject.AddComponent<Animator>();
reflectionAnimator.runtimeAnimatorController = originalAnimator.runtimeAnimatorController;
}
SortableEntity originalSortable = GetComponent<SortableEntity>();
if (originalSortable != null) {
reflectionObject.AddComponent<SortableEntity>();
}
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Created reflection for {gameObject.name}", this);
}

void UpdateReflectionTransform() {
if (reflectionObject == null || originalRenderer == null) return;
Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
Vector3 originalWorldPos = transform.position;
Vector3 reflectionWorldPos = originalWorldPos;
float referenceYForOffset = referenceTransform.position.y;
reflectionWorldPos.y = referenceYForOffset + yOffset - (originalWorldPos.y - referenceYForOffset);
reflectionObject.transform.position = reflectionWorldPos;
reflectionObject.transform.rotation = transform.rotation;
reflectionObject.transform.localScale = transform.localScale;
Vector3 currentLocalScale = reflectionObject.transform.localScale;
currentLocalScale.y *= -1;
reflectionObject.transform.localScale = currentLocalScale;
}

void UpdateReflectionVisuals() {
if (reflectionRenderer == null || originalRenderer == null) return;

reflectionRenderer.sprite = originalRenderer.sprite;
reflectionRenderer.flipX = originalRenderer.flipX;
reflectionRenderer.flipY = originalRenderer.flipY;

Color baseOriginalSpriteColor = originalRenderer.color;
Color finalReflectionTintedColor = baseOriginalSpriteColor * _actualReflectionTint; // Use resolved
float finalCombinedAlpha = baseOriginalSpriteColor.a * _actualReflectionOpacity; // Use resolved
reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);

if (enableDistanceFade && reflectionMaterialInstance != null) {
Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
float waterSurfaceY = referenceTransform.position.y;
reflectionMaterialInstance.SetFloat("_FadeStart", fadeStartDistance);
reflectionMaterialInstance.SetFloat("_FadeEnd", fadeEndDistance);
reflectionMaterialInstance.SetFloat("_MinAlpha", minFadeAlpha);
reflectionMaterialInstance.SetFloat("_OriginalY", waterSurfaceY);
Color materialBaseColor = _actualReflectionTint; // Use resolved
materialBaseColor.a = _actualReflectionOpacity * baseOriginalSpriteColor.a; // Use resolved
reflectionMaterialInstance.SetColor("_Color", materialBaseColor);
}
else if (!enableDistanceFade && reflectionMaterialInstance != null) {
reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
Destroy(reflectionMaterialInstance);
reflectionMaterialInstance = null;
}

reflectionRenderer.enabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;

if (reflectionAnimator != null && originalAnimator != null) {
reflectionAnimator.enabled = originalAnimator.enabled;
if (originalAnimator.runtimeAnimatorController != null && originalAnimator.parameterCount > 0) {
foreach (AnimatorControllerParameter param in originalAnimator.parameters) {
try {
switch (param.type) {
case AnimatorControllerParameterType.Bool:
reflectionAnimator.SetBool(param.name, originalAnimator.GetBool(param.name));
break;
case AnimatorControllerParameterType.Float:
reflectionAnimator.SetFloat(param.name, originalAnimator.GetFloat(param.name));
break;
case AnimatorControllerParameterType.Int:
reflectionAnimator.SetInteger(param.name, originalAnimator.GetInteger(param.name));
break;
}
} catch (System.Exception e) {
if(_actualShowDebugInfo) Debug.LogWarning($"Failed to sync animator param '{param.name}': {e.Message}", reflectionAnimator);
}
}
}
}
}

bool HasVisualStateChanged() {
if (originalRenderer == null) ret false;
bool parentYChanged = false;
if (useParentAsReference && transform.parent != null) {
parentYChanged = !Mathf.Approximately(lastParentY, transform.parent.position.y);
}
ret lastSprite != originalRenderer.sprite ||
!ColorsApproximatelyEqual(lastOriginalColor, originalRenderer.color) ||
lastFlipX != originalRenderer.flipX ||
lastFlipY != originalRenderer.flipY ||
lastEnabled != (originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy) ||
lastScale != transform.localScale ||
lastPosition != transform.position ||
parentYChanged;
}

void CacheCurrentState() {
if (originalRenderer == null) return;
lastSprite = originalRenderer.sprite;
lastOriginalColor = originalRenderer.color;
lastFlipX = originalRenderer.flipX;
lastFlipY = originalRenderer.flipY;
lastEnabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;
lastScale = transform.localScale;
lastPosition = transform.position;
if (useParentAsReference && transform.parent != null) {
lastParentY = transform.parent.position.y;
}
}

bool ColorsApproximatelyEqual(Color c1, Color c2, float tolerance = 0.001f) {
ret Mathf.Abs(c1.r - c2.r) < tolerance &&
Mathf.Abs(c1.g - c2.g) < tolerance &&
Mathf.Abs(c1.b - c2.b) < tolerance &&
Mathf.Abs(c1.a - c2.a) < tolerance;
}

void SetupWaterMaskingInteraction() {
if (!_actualUseWaterMasking || reflectionRenderer == null) return; // Use resolved
GameObject waterTilemapGO = FindWaterTilemapByTag(); // FindWaterTilemapByTag will use resolved tag
if (waterTilemapGO == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Water tilemap for masking not found on {gameObject.name} using tag '{_actualWaterTilemapTag}'. Masking disabled.", this);
return;
}
SpriteMask maskComponent = waterTilemapGO.GetComponent<SpriteMask>();
if (maskComponent == null) {
maskComponent = waterTilemapGO.AddComponent<SpriteMask>();
maskComponent.sprite = null;
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Added SpriteMask to water tilemap '{waterTilemapGO.name}' for object '{gameObject.name}'.", waterTilemapGO);
}
reflectionRenderer.maskInteraction = SpriteMaskInteraction.VisibleInsideMask;
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Reflection of '{gameObject.name}' will be masked by '{waterTilemapGO.name}'.", this);
}

GameObject FindWaterTilemapByTag() {
if (string.IsNullOrEmpty(_actualWaterTilemapTag)) ret FindWaterTilemapFallback();
GameObject taggedWater = GameObject.FindGameObjectWithTag(_actualWaterTilemapTag);
if (taggedWater != null && taggedWater.GetComponent<Tilemap>() != null) {
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Found water tilemap by tag '{_actualWaterTilemapTag}': {taggedWater.name} for {gameObject.name}", this);
ret taggedWater;
}
if (taggedWater != null && taggedWater.GetComponent<Tilemap>() == null && _actualShowDebugInfo) {
Debug.LogWarning($"[WaterReflection] GameObject '{taggedWater.name}' (tag '{_actualWaterTilemapTag}') has no Tilemap component!", this);
}
ret FindWaterTilemapFallback();
}

GameObject FindWaterTilemapFallback() {
if (TileInteractionManager.Instance != null) {
var mappings = TileInteractionManager.Instance.tileDefinitionMappings;
if (mappings != null) {
foreach (var mapping in mappings) {
if (mapping?.tileDef != null && mapping.tilemapModule != null && mapping.tileDef.isWaterTile) {
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null && renderTilemapTransform.GetComponent<Tilemap>() != null) {
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Auto-detected water tilemap via TIM: {renderTilemapTransform.name} for {gameObject.name}", this);
ret renderTilemapTransform.gameObject;
}
}
}
}
}
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Could not auto-detect water tilemap via TileInteractionManager for {gameObject.name}.", this);
ret null;
}

void OnDestroy() {
if (reflectionObject != null) {
if (Application.isPlaying) Destroy(reflectionObject);
else DestroyImmediate(reflectionObject);
}
if (reflectionMaterialInstance != null) {
if (Application.isPlaying) Destroy(reflectionMaterialInstance);
else DestroyImmediate(reflectionMaterialInstance);
}
}

void OnValidate() {
#if UNITY_EDITOR
EditorApplication.delayCall -= EditorUpdatePreview; // Remove previous requests to avoid stacking
EditorApplication.delayCall += EditorUpdatePreview; // Add a new request
#endif
}

#if UNITY_EDITOR
void EditorUpdatePreview() {
if (this == null || gameObject == null) // The object could be destroyed before the call {
return;
}

if (Application.isEditor && !Application.isPlaying) {
bool localMaterialNeeded = enableDistanceFade && (!overrides.gradientFadeBaseMaterial || localGradientFadeBaseMaterial == null);
bool globalMaterialMightBeUsed = enableDistanceFade && !overrides.gradientFadeBaseMaterial && localGradientFadeBaseMaterial == null;

if (localMaterialNeeded && !globalMaterialMightBeUsed) // Warn if local ovr is on but local material missing {
Debug.LogWarning($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true and 'Override Gradient Material' is true, but 'Local Gradient Fade Base Material' is not assigned. Assign local material or uncheck override.", this);
}
else if (globalMaterialMightBeUsed) // Inform that global will be used if local isn't set {
Debug.Log($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true. If 'Local Gradient Fade Base Material' remains unassigned and ovr is false, the global default from WaterReflectionManager will be used in Play mode.", this);
}

if (reflectionRenderer != null && originalRenderer != null) {
Color previewTint = overrides.reflectionTint ? localReflectionTint : Color.white; // Default to white if no manager
float previewOpacity = overrides.reflectionOpacity ? localReflectionOpacity : 0.5f;
int previewSortOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : -1;

reflectionRenderer.sprite = originalRenderer.sprite;
reflectionRenderer.flipX = originalRenderer.flipX;
reflectionRenderer.flipY = originalRenderer.flipY;
reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + previewSortOffset;
Color baseOriginalSpriteColor = originalRenderer.color;
Color finalReflectionTintedColor = baseOriginalSpriteColor * previewTint;
float finalCombinedAlpha = baseOriginalSpriteColor.a * previewOpacity;
reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);
UpdateReflectionTransform(); // Keep transform updated
}
}
}
#endif

pub void SetLocalReflectionOpacity(float opacity) // Example of changing a local-only value {
localReflectionOpacity = Mathf.Clamp01(opacity);
if (overrides.reflectionOpacity) // Only re-resolve and update if this local value is being used {
ResolveSettings();
if (Application.isPlaying && originalRenderer != null) UpdateReflectionVisuals();
}
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\WaterReflectionManager.cs

﻿using UnityEngine;

pub cls WaterReflectionManager : MonoBehaviour {
pub stat WaterReflectionManager Instance { get; set; }

pub Material defaultGradientFadeMaterial;

[Range(0f, 1f)] pub float defaultReflectionOpacity = 0.5f;

pub Color defaultReflectionTint = Color.white;

pub int defaultSortingOrderOffset = -1;

pub bool defaultUseWaterMasking = true;

pub string defaultWaterTilemapTag = "Water";

pub bool globalShowDebugInfo = false;

void Awake() {
if (Instance != null && Instance != this) {
Debug.LogWarning($"[WaterReflectionManager] Duplicate instance found on {gameObject.name}. Destroying self.", gameObject);
Destroy(gameObject);
return;
}
Instance = this;

if (defaultGradientFadeMaterial == null) {
Debug.LogWarning("[WaterReflectionManager] Default Gradient Fade Material is not assigned. Distance fade may not work correctly for reflections that don't have their own material specified.", this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlantGrowthModifierManager.cs

﻿using System.Collections.Generic;
using WegoSystem;

pub cls PlantGrowthModifierManager : MonoBehaviour, ITickUpdateable {
pub stat PlantGrowthModifierManager Instance { get; set; }

pub cls TileGrowthModifier {
pub TileDefinition tileDefinition;
pub float growthSpeedMultiplier = 1.0f;
pub float energyRechargeMultiplier = 1.0f;
}

pub float defaultGrowthSpeedMultiplier = 1.0f;
pub float defaultEnergyRechargeMultiplier = 1.0f;

pub List<TileGrowthModifier> tileModifiers = new List<TileGrowthModifier>();

[SerializeField] TileInteractionManager tileInteractionManager;
[SerializeField] bool showDebugMessages = true;
[SerializeField] bool showTileChangeMessages = true;

Dictionary<string, TileGrowthModifier> modifierLookup = new Dictionary<string, TileGrowthModifier>();
Dictionary<PlantGrowth, TileDefinition> plantTiles = new Dictionary<PlantGrowth, TileDefinition>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

BuildModifierLookup();
}

void Start() {
if (tileInteractionManager == null) {
tileInteractionManager = TileInteractionManager.Instance;
if (tileInteractionManager == null && showDebugMessages) {
Debug.LogWarning("PlantGrowthModifierManager: TileInteractionManager not found!");
}
}

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
else {
Debug.LogError("[PlantGrowthModifierManager] TickManager not found! Modifiers will not update.");
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
UpdateAllPlantTiles();
}

void UpdateAllPlantTiles() {
if (tileInteractionManager == null) return;

List<PlantGrowth> plantsToCheck = new List<PlantGrowth>(plantTiles.Keys);

foreach (PlantGrowth plant in plantsToCheck) {
if (plant == null) {
plantTiles.Remove(plant);
continue;
}

Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);

if (plantTiles.TryGetValue(plant, out TileDefinition previousTileDef) && currentTileDef != previousTileDef) {
plantTiles[plant] = currentTileDef;

if (showTileChangeMessages) {
string previousTileName = previousTileDef != null ? previousTileDef.displayName : "None";
string currentTileName = currentTileDef != null ? currentTileDef.displayName : "None";
Debug.Log($"Plant '{plant.name}' tile changed: {previousTileName} -> {currentTileName}");
}
}
}
}

void BuildModifierLookup() {
modifierLookup.Clear();
foreach (var modifier in tileModifiers) {
if (modifier.tileDefinition != null && !string.IsNullOrEmpty(modifier.tileDefinition.displayName) && !modifierLookup.ContainsKey(modifier.tileDefinition.displayName)) {
modifierLookup.Add(modifier.tileDefinition.displayName, modifier);
}
}
}

pub void RegisterPlantTile(PlantGrowth plant, TileDefinition tileDef) {
if (plant == null) return;
plantTiles[plant] = tileDef;

if (showDebugMessages) {
string tileName = tileDef != null ? tileDef.displayName : "Unknown Tile";
Debug.Log($"Registered plant {plant.name} on tile {tileName}");
}
}

pub void UnregisterPlant(PlantGrowth plant) {
if (plant != null) {
plantTiles.Remove(plant);
}
}

pub float GetGrowthSpeedMultiplier(PlantGrowth plant) {
if (plant == null) ret defaultGrowthSpeedMultiplier;

if (!plantTiles.ContainsKey(plant)) {
RegisterNewPlant(plant); // Auto-register if not found
}

if (plantTiles.TryGetValue(plant, out TileDefinition tileDef) && tileDef != null) {
if (modifierLookup.TryGetValue(tileDef.displayName, out TileGrowthModifier modifier)) {
ret modifier.growthSpeedMultiplier;
}
}

ret defaultGrowthSpeedMultiplier;
}

pub float GetEnergyRechargeMultiplier(PlantGrowth plant) {
if (plant == null) ret defaultEnergyRechargeMultiplier;

if (!plantTiles.ContainsKey(plant)) {
RegisterNewPlant(plant); // Auto-register if not found
}

if (plantTiles.TryGetValue(plant, out TileDefinition tileDef) && tileDef != null) {
if (modifierLookup.TryGetValue(tileDef.displayName, out TileGrowthModifier modifier)) {
ret modifier.energyRechargeMultiplier;
}
}

ret defaultEnergyRechargeMultiplier;
}

void RegisterNewPlant(PlantGrowth plant) {
if (plant == null || tileInteractionManager == null) return;

Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
plantTiles[plant] = currentTileDef;

if (showDebugMessages) {
string tileName = currentTileDef != null ? currentTileDef.displayName : "Unknown Tile";
Debug.Log($"Auto-registered new plant {plant.name} on tile {tileName}");
}
}

void OnValidate() {
BuildModifierLookup();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlantPlacementManager.cs

﻿using System.Collections.Generic;
using System.Linq; // Added for LINQ

pub cls PlantPlacementManager : MonoBehaviour {
pub stat PlantPlacementManager Instance { get; set; }

[SerializeField] Transform plantParent;
[SerializeField] TileInteractionManager tileInteractionManager;
[SerializeField] PlantGrowthModifierManager growthModifierManager;
[SerializeField] NodeExecutor nodeExecutor;

[SerializeField] float spawnRadius = 0.25f;
[SerializeField] float spawnRadiusIncrement = 4f;

[SerializeField] List<TileDefinition> invalidPlantingTiles = new List<TileDefinition>();

[SerializeField] bool showDebugMessages = true;

HashSet<TileDefinition> invalidTilesSet = new HashSet<TileDefinition>();
Dictionary<Vector3Int, GameObject> plantsByGridPosition = new Dictionary<Vector3Int, GameObject>();

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;
RebuildInvalidTilesSet();
}

void Start() {
if (plantParent == null && EcosystemManager.Instance != null) plantParent = EcosystemManager.Instance.plantParent;
if (tileInteractionManager == null) tileInteractionManager = TileInteractionManager.Instance;
if (growthModifierManager == null) growthModifierManager = PlantGrowthModifierManager.Instance;
if (nodeExecutor == null) {
nodeExecutor = FindAnyObjectByType<NodeExecutor>();
if (nodeExecutor == null) Debug.LogError("[PlantPlacementManager] NodeExecutor instance not found!");
}
}

void RebuildInvalidTilesSet() {
invalidTilesSet.Clear();
foreach (var tile in invalidPlantingTiles) if (tile != null) invalidTilesSet.Add(tile);
if (showDebugMessages) Debug.Log($"PlantPlacementManager: Invalid tiles set with {invalidTilesSet.Count} entries");
}

void OnValidate() { RebuildInvalidTilesSet(); }

pub bool IsPositionOccupied(Vector3Int gridPosition) {
if (plantsByGridPosition.TryGetValue(gridPosition, out GameObject plant)) {
if (plant == null) { plantsByGridPosition.Remove(gridPosition); ret false; }
ret true;
}
ret false;
}

pub bool IsTileValidForPlanting(TileDefinition tileDef) {
if (tileDef == null) ret false;
ret !invalidTilesSet.Contains(tileDef);
}

pub void CleanupDestroyedPlants() {
List<Vector3Int> keysToRemove = plantsByGridPosition.Where(kvp => kvp.Value == null).Select(kvp => kvp.Key).ToList();
foreach (var key in keysToRemove) plantsByGridPosition.Remove(key);
if (showDebugMessages && keysToRemove.Count > 0) Debug.Log($"PPM: Removed {keysToRemove.Count} destroyed plant refs.");
}

pub bool TryPlantSeed(Vector3Int gridPosition, Vector3 worldPosition) {
CleanupDestroyedPlants();
if (IsPositionOccupied(gridPosition)) {
if (showDebugMessages) Debug.Log($"Cannot plant (from seed slot): Position {gridPosition} occupied.");
ret false;
}

TileDefinition tileDef = tileInteractionManager?.FindWhichTileDefinitionAt(gridPosition);
if (!IsTileValidForPlanting(tileDef)) {
if (showDebugMessages) Debug.Log($"Cannot plant (from seed slot): Tile {tileDef?.displayName ?? "Unknown"} invalid.");
ret false;
}

if (nodeExecutor == null) {
Debug.LogError("Cannot plant (from seed slot): NodeExecutor reference is missing in PlantPlacementManager.");
ret false;
}

Vector3 plantingPosition = GetRandomizedPlantingPosition(worldPosition);
GameObject plantObj = nodeExecutor.SpawnPlantFromSeedInSlot(plantingPosition, plantParent);

if (plantObj != null) {
plantsByGridPosition[gridPosition] = plantObj;
PlantGrowth plantGrowth = plantObj.GetComponent<PlantGrowth>();
if (growthModifierManager != null && plantGrowth != null) {
growthModifierManager.RegisterPlantTile(plantGrowth, tileDef);
if (showDebugMessages) Debug.Log($"Plant (from seed slot) registered with tile: {tileDef?.displayName ?? "Unknown"}");
}
ret true;
}
if (showDebugMessages) Debug.Log($"Failed to plant seed (from seed slot) at {gridPosition} (NodeExecutor returned null).");
ret false;
}

pub bool TryPlantSeedFromInventory(InventoryBarItem seedItem, Vector3Int      gridPosition, Vector3         worldPosition) {
if (seedItem == null || !seedItem.IsSeed())                     ret false;
if (IsPositionOccupied(gridPosition))                           ret false;

TileDefinition tileDef = tileInteractionManager?.FindWhichTileDefinitionAt(gridPosition);
if (!IsTileValidForPlanting(tileDef))                           ret false;
if (nodeExecutor == null)                                       ret false;

Vector3  spawnPos  = GetRandomizedPlantingPosition(worldPosition);
GameObject plantGO = nodeExecutor.SpawnPlantFromInventorySeed(
seedItem.NodeData, spawnPos, plantParent);

if (plantGO == null)                                            ret false;

plantsByGridPosition[gridPosition] = plantGO;

PlantGrowth pg = plantGO.GetComponent<PlantGrowth>();
if (pg != null && growthModifierManager != null)
growthModifierManager.RegisterPlantTile(pg, tileDef);

GardenerController g = FindAnyObjectByType<GardenerController>();
if (g != null) g.Plant();

ret true;
}

Vector3 GetRandomizedPlantingPosition(Vector3 centerPosition) {
if (spawnRadius < 0.01f) ret centerPosition;
float randomAngle = Random.Range(0f, 2f * Mathf.PI);
Vector2 direction = new Vector2(Mathf.Cos(randomAngle), Mathf.Sin(randomAngle));
float randomDistance = Random.Range(0.05f, spawnRadius);
float offsetX = direction.x * randomDistance;
float offsetY = direction.y * randomDistance;
if (spawnRadiusIncrement > 0.001f) {
offsetX = Mathf.Round(offsetX / spawnRadiusIncrement) * spawnRadiusIncrement;
offsetY = Mathf.Round(offsetY / spawnRadiusIncrement) * spawnRadiusIncrement;
}
ret centerPosition + new Vector3(offsetX, offsetY, 0f);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlayerTileInteractor.cs

﻿using UnityEngine;

pub sealed cls PlayerTileInteractor : MonoBehaviour {
[SerializeField] InventoryBarController inventoryBar;
[SerializeField] TileInteractionManager tileInteractionManager;
[SerializeField] Transform playerTransform;
[SerializeField] bool showDebug = false;

bool pendingClick;

void Awake() {
if (playerTransform == null) playerTransform = transform;
}

void Start() {
FindSingletons();
}

void Update() {
if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat) return;
if (Input.GetMouseButtonDown(0)) pendingClick = true;
}

void LateUpdate() {
if (!pendingClick) return;
pendingClick = false;
HandleLeftClick();
}

void HandleLeftClick() {
if (!EnsureManagers()) return;

InventoryBarItem selected = inventoryBar.SelectedItem;
if (selected == null || !selected.IsValid()) {
if (showDebug) Debug.Log("[PlayerTileInteractor] Click handled, but no valid item selected in the bar.");
return;
}

Vector3 mouseW = Camera.main.ScreenToWorldPoint(Input.mousePosition);
mouseW.z = 0f;
Vector3Int cellPos = tileInteractionManager.WorldToCell(mouseW);
Vector3 cellCenter = tileInteractionManager.interactionGrid.GetCellCenterWorld(cellPos);

if (Vector2.Distance(playerTransform.position, cellCenter) > tileInteractionManager.hoverRadius) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Clicked on cell {cellPos}, but it's too far away.");
return;
}

if (PlayerActionManager.Instance == null) {
Debug.LogError("[PlayerTileInteractor] PlayerActionManager not found!");
return;
}

if (selected.Type == InventoryBarItem.ItemType.Tool) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Using tool '{selected.GetDisplayName()}' at cell {cellPos}.");
PlayerActionManager.Instance.ExecutePlayerAction(
PlayerActionType.UseTool,
cellPos,
selected.ToolDefinition
);
}
else if (selected.Type == InventoryBarItem.ItemType.Node && selected.IsSeed()) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Planting seed '{selected.GetDisplayName()}' at cell {cellPos}.");

System.Action onSuccess = () => {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Planting was successful. Removing seed '{selected.GetDisplayName()}' from inventory via callback.");
RemoveSeedFromInventory(selected);
inventoryBar.ShowBar(); // Refresh the bar after item is removed
};

PlayerActionManager.Instance.ExecutePlayerAction(
PlayerActionType.PlantSeed,
cellPos,
selected,
onSuccess
);
}
}

pub void RemoveSeedFromInventory(InventoryBarItem seed) {
InventoryGridController grid = InventoryGridController.Instance;
if (grid == null) return;

if (seed.ViewGameObject != null) {
for (int i = 0; i < grid.ActualCellCount; i++) {
NodeCell cell = grid.GetInventoryCellAtIndex(i);
if (cell != null && cell.GetItemView()?.gameObject == seed.ViewGameObject) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Removing seed '{seed.GetDisplayName()}' from inventory cell {i} by view reference.");
cell.RemoveNode();
return;
}
}
}

for (int i = 0; i < grid.ActualCellCount; i++) {
NodeCell cell = grid.GetInventoryCellAtIndex(i);
if (cell != null && cell.GetNodeData()?.nodeId == seed.NodeData.nodeId) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Removing seed '{seed.GetDisplayName()}' from inventory cell {i} by data ID fallback.");
cell.RemoveNode();
return;
}
}
}

bool EnsureManagers() {
if (tileInteractionManager == null || inventoryBar == null) FindSingletons();
ret tileInteractionManager != null && inventoryBar != null;
}

void FindSingletons() {
if (inventoryBar == null) inventoryBar = InventoryBarController.Instance ?? FindAnyObjectByType<InventoryBarController>(FindObjectsInactive.Include);
if (tileInteractionManager == null) tileInteractionManager = TileInteractionManager.Instance ?? FindAnyObjectByType<TileInteractionManager>(FindObjectsInactive.Include);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\GardenerController.cs

﻿using System;
using WegoSystem;

pub cls GardenerController : MonoBehaviour, IStatusEffectable, ITickUpdateable {
[SerializeField] float multiTickDelay = 0.5f;

[SerializeField] bool useAnimations = true;
[SerializeField] Animator animator;
[SerializeField] string runningParameterName = "isRunning";
[SerializeField] string plantingTriggerName = "plant";

[SerializeField] SpriteRenderer spriteRenderer;
[SerializeField] bool flipSpriteWhenMovingLeft = true;
[SerializeField] bool flipHorizontalDirection = true;

[SerializeField] int pouchCapacity = 10;

GridEntity gridEntity;
StatusEffectManager statusManager;
StatusEffectUIManager statusEffectUI;
PlayerHungerSystem hungerSystem;

ro List<HarvestedItem> _harvestedItems = new List<HarvestedItem>();
pub event Action<int, int> OnPouchContentChanged; // current count, capacity
pub bool IsPouchFull => _harvestedItems.Count >= pouchCapacity;
pub int PouchItemCount => _harvestedItems.Count;

GridPosition currentTargetPosition;
bool isProcessingMovement = false;

pub GridEntity GridEntity => gridEntity;
pub StatusEffectManager StatusManager => statusManager;
pub PlayerHungerSystem HungerSystem => hungerSystem;

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) gridEntity = gameObject.AddComponent<GridEntity>();
statusManager = GetComponent<StatusEffectManager>();
if (statusManager == null) statusManager = gameObject.AddComponent<StatusEffectManager>();
hungerSystem = GetComponent<PlayerHungerSystem>();
if (hungerSystem == null) hungerSystem = gameObject.AddComponent<PlayerHungerSystem>();

statusEffectUI = GetComponentInChildren<StatusEffectUIManager>(true);
if (statusEffectUI == null) Debug.LogWarning("[GardenerController] StatusEffectUIManager not found in children. Icons won't display.", this);
if (spriteRenderer == null) spriteRenderer = GetComponentInChildren<SpriteRenderer>();
if (spriteRenderer == null) Debug.LogWarning("[GardenerController] SpriteRenderer not found.", gameObject);
if (animator == null && useAnimations) Debug.LogWarning("[GardenerController] Animator not found.", gameObject);
}

void Start() {
statusManager.Initialize(this);
if (statusEffectUI != null) {
statusEffectUI.Initialize(statusManager);
}
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
if (gridEntity != null) {
gridEntity.OnPositionChanged += OnGridPositionChanged;
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
if (gridEntity != null) {
gridEntity.OnPositionChanged -= OnGridPositionChanged;
}
}

pub void OnTickUpdate(int currentTick) {
statusManager?.OnTickUpdate(currentTick);
}

void Update() {
if (RunManager.Instance?.CurrentState == RunState.GrowthAndThreat) {
HandlePlayerInput();
}
if (gridEntity != null && statusManager != null) {
gridEntity.SetSpeedMultiplier(statusManager.VisualSpeedMultiplier);
}
UpdateAnimations();
UpdateSpriteDirection();
}

void OnGridPositionChanged(GridPosition oldPos, GridPosition newPos) {
EnvironmentalStatusEffectSystem.Instance?.CheckAndApplyTileEffects(this);
}

pub string GetDisplayName() { ret "Gardener"; }
pub void TakeDamage(float amount) { Debug.Log($"Gardener took {amount} damage!"); }
pub void Heal(float amount) { Debug.Log($"Gardener was healed for {amount}!"); }
pub void ModifyHunger(float amount) {
if (hungerSystem != null) {
hungerSystem.Eat(-amount);
}
}

void HandlePlayerInput() {
if (gridEntity == null || gridEntity.IsMoving || isProcessingMovement) return;

GridPosition moveDir = GridPosition.Zero;
if (Input.GetKeyDown(KeyCode.W) || Input.GetKeyDown(KeyCode.UpArrow)) moveDir = GridPosition.Up;
else if (Input.GetKeyDown(KeyCode.S) || Input.GetKeyDown(KeyCode.DownArrow)) moveDir = GridPosition.Down;
else if (Input.GetKeyDown(KeyCode.A) || Input.GetKeyDown(KeyCode.LeftArrow)) moveDir = GridPosition.Left;
else if (Input.GetKeyDown(KeyCode.D) || Input.GetKeyDown(KeyCode.RightArrow)) moveDir = GridPosition.Right;

if (moveDir != GridPosition.Zero) {
TryMove(moveDir);
return;
}

}

pub int AddToPouch(List<NodeData> harvestedItemData) {
int countAdded = 0;
foreach (var data in harvestedItemData) {
if (IsPouchFull) break;
_harvestedItems.Add(new HarvestedItem(data));
countAdded++;
}

if (countAdded > 0) {
Debug.Log($"Added {countAdded} items to pouch. Total: {PouchItemCount}/{pouchCapacity}");
OnPouchContentChanged?.Invoke(PouchItemCount, pouchCapacity);
}
ret countAdded;
}

void ConsumeFromPouch() {
if (_harvestedItems.Count == 0) {
Debug.Log("Pouch is empty, nothing to consume.");
return;
}

HarvestedItem itemToConsume = _harvestedItems[0];
_harvestedItems.RemoveAt(0);

float nutrition = itemToConsume.GetNutritionValue();
if (nutrition > 0 && hungerSystem != null) {
hungerSystem.Eat(nutrition);
PlayerActionManager.Instance.ExecutePlayerAction(PlayerActionType.Interact, gridEntity.Position.ToVector3Int(), "Eating");
}

OnPouchContentChanged?.Invoke(PouchItemCount, pouchCapacity);
}

void TryMove(GridPosition direction) {
if (gridEntity == null) return;
GridPosition targetPos = gridEntity.Position + direction;
if (GridPositionManager.Instance != null && PlayerActionManager.Instance != null && TickManager.Instance != null &&
GridPositionManager.Instance.IsPositionValid(targetPos) &&
!GridPositionManager.Instance.IsPositionOccupied(targetPos)) {
Vector3 currentWorldPos = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
int moveCost = PlayerActionManager.Instance.GetMovementTickCost(currentWorldPos, this);
if (moveCost > 1) {
StartCoroutine(ProcessMultiTickMovement(targetPos, moveCost));
}
else {
gridEntity.SetPosition(targetPos);
currentTargetPosition = targetPos;
TickManager.Instance.AdvanceTick();
}
}
}

IEnumerator ProcessMultiTickMovement(GridPosition targetPos, int tickCost) {
isProcessingMovement = true;
for (int i = 0; i < tickCost - 1; i++) {
TickManager.Instance.AdvanceTick();
yield ret new WaitForSeconds(multiTickDelay);
}
gridEntity.SetPosition(targetPos);
currentTargetPosition = targetPos;
TickManager.Instance.AdvanceTick();
isProcessingMovement = false;
}

void UpdateAnimations() {
if (!useAnimations || animator == null) return;
bool isMoving = gridEntity != null && gridEntity.IsMoving;
animator.SetBool(runningParameterName, isMoving);
}

void UpdateSpriteDirection() {
if (spriteRenderer == null || !flipSpriteWhenMovingLeft || gridEntity == null || !gridEntity.IsMoving) return;
Vector3 worldTarget = GridPositionManager.Instance.GridToWorld(currentTargetPosition);
Vector3 currentWorld = transform.position;
Vector2 directionToCheck = (worldTarget - currentWorld).normalized;
if (Mathf.Abs(directionToCheck.x) > 0.01f) {
bool shouldFlip = directionToCheck.x < 0;
spriteRenderer.flipX = flipHorizontalDirection ? shouldFlip : !shouldFlip;
}
}

pub void Plant() {
if (useAnimations && animator != null) {
animator.SetTrigger(plantingTriggerName);
}
}

pub GridPosition GetCurrentGridPosition() {
ret gridEntity?.Position ?? GridPosition.Zero;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\HarvestableTag.cs

﻿using UnityEngine;

pub cls HarvestableTag : MonoBehaviour {
pub NodeDefinition HarvestedItemDefinition;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\HarvestedItem.cs

﻿using System.Linq;

pub cls HarvestedItem {
pub NodeData HarvestedNodeData { get; set; }

pub HarvestedItem(NodeData data) {
HarvestedNodeData = data;
}

pub float GetNutritionValue() {
if (HarvestedNodeData?.effects == null) ret 0f;

ret HarvestedNodeData.effects
.Where(e => e.effectType == NodeEffectType.Nutritious)
.Sum(e => e.primaryValue);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\HungerUI.cs

﻿using UnityEngine;
using TMPro;

pub cls HungerUI : MonoBehaviour {
[SerializeField] PlayerHungerSystem playerHungerSystem;
[SerializeField] Slider hungerSlider;
[SerializeField] TextMeshProUGUI hungerText;

void Start() {
if (playerHungerSystem == null) {
GardenerController player = FindObjectOfType<GardenerController>();
if (player != null) {
playerHungerSystem = player.GetComponent<PlayerHungerSystem>();
}
}

if (playerHungerSystem != null) {
playerHungerSystem.OnHungerChanged += UpdateUI;
UpdateUI(playerHungerSystem.CurrentHunger, playerHungerSystem.MaxHunger);
}
else {
Debug.LogError("[HungerUI] PlayerHungerSystem reference not found! UI will not update.", this);
gameObject.SetActive(false);
}
}

void OnDestroy() {
if (playerHungerSystem != null) {
playerHungerSystem.OnHungerChanged -= UpdateUI;
}
}

void UpdateUI(float currentHunger, float maxHunger) {
if (hungerSlider != null) {
hungerSlider.maxValue = maxHunger;
hungerSlider.value = currentHunger;
}

if (hungerText != null) {
hungerText.text = $"{Mathf.CeilToInt(currentHunger)} / {Mathf.CeilToInt(maxHunger)}";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\PlayerActionManager.cs

﻿using System;
using WegoSystem;

pub enum PlayerActionType {
Move,
UseTool,
PlantSeed,
Harvest,
Water,
Interact
}

pub cls PlayerActionManager : MonoBehaviour {
pub stat PlayerActionManager Instance { get; set; }

pub cls ToolActionData {
pub ToolDefinition Tool;
pub Vector3Int GridPosition;
}

[SerializeField] bool debugMode = true;
[SerializeField] int tickCostPerAction = 1;
[SerializeField] float multiTickActionDelay = 0.5f;

pub event Action<PlayerActionType, object> OnActionExecuted;
pub event Action<string> OnActionFailed;

void Awake() {
if (Instance != null && Instance != this) Destroy(gameObject);
Instance = this;
}

void OnDestroy() {
if (Instance == this) Instance = null;
}

pub bool ExecutePlayerAction(PlayerActionType actionType, Vector3Int gridPosition, object actionData = null, Action onSuccessCallback = null) {
if (debugMode) Debug.Log($"[PlayerActionManager] Executing {actionType} at {gridPosition}");

bool success = false;
int tickCost = tickCostPerAction; // Declare here so it's accessible throughout the method
object eventPayload = actionData;

var toolDefForCheck = actionData as ToolDefinition;
if (actionType == PlayerActionType.UseTool && toolDefForCheck != null && toolDefForCheck.toolType == ToolType.HarvestPouch) {
actionType = PlayerActionType.Harvest;
}

switch (actionType) {
case PlayerActionType.UseTool:
var toolDef = actionData as ToolDefinition;
success = ExecuteToolUse(gridPosition, toolDef);
if (success) {
eventPayload = new ToolActionData { Tool = toolDef, GridPosition = gridPosition };
}
break;

case PlayerActionType.PlantSeed:
tickCost = 2; // Override default tick cost for this specific action
if (tickCost > 1) {
StartCoroutine(ExecuteDelayedAction(() => ExecutePlantSeed(gridPosition, actionData as InventoryBarItem), tickCost, onSuccessCallback, actionType, actionData));
ret true; // Return early, coroutine will handle the rest
}
else {
success = ExecutePlantSeed(gridPosition, actionData as InventoryBarItem);
}
break;

case PlayerActionType.Harvest:
success = ExecuteHarvest(gridPosition);
break;

case PlayerActionType.Water:
success = ExecuteWatering(gridPosition);
break;

case PlayerActionType.Interact:
success = ExecuteInteraction(gridPosition, actionData);
break;
}

if (success) {
AdvanceGameTick(tickCost);
onSuccessCallback?.Invoke();
OnActionExecuted?.Invoke(actionType, eventPayload);
}
else {
OnActionFailed?.Invoke($"{actionType} failed");
}
ret success;
}

bool ExecuteHarvest(Vector3Int gridPosition) {
var plantEntity = GridPositionManager.Instance?.GetEntitiesAt(new GridPosition(gridPosition))
.FirstOrDefault(e => e.GetComponent<PlantGrowth>() != null);

if (plantEntity == null) {
if (debugMode) Debug.Log($"Harvest failed: No plant found at {gridPosition}");
ret false;
}

var plant = plantEntity.GetComponent<PlantGrowth>();
if (plant == null) ret false;

var harvestedDefs = plant.Harvest();

if (harvestedDefs.Count > 0) {
foreach (var definition in harvestedDefs) {
InventoryGridController.Instance.AddGeneToInventoryFromDefinition(definition);
}
ret true;
}

if (debugMode) Debug.Log($"Harvest action at {gridPosition}, but nothing was harvested.");
ret false;
}

IEnumerator ExecuteDelayedAction(Func<bool> action, int tickCost, Action onSuccessCallback, PlayerActionType actionType, object actionData) {
for (int i = 0; i < tickCost - 1; i++) {
TickManager.Instance.AdvanceTick();
yield ret new WaitForSeconds(multiTickActionDelay);
}
bool success = action.Invoke();
TickManager.Instance.AdvanceTick();
if (success) {
onSuccessCallback?.Invoke();
OnActionExecuted?.Invoke(actionType, actionData);
}
else {
OnActionFailed?.Invoke("Delayed action failed");
}
}

pub int GetMovementTickCost(Vector3 worldPosition, Component movingEntity = null) {
int totalCost = tickCostPerAction;
int statusEffectCost = 0;
if (movingEntity != null) {
IStatusEffectable effectable = movingEntity.GetComponent<IStatusEffectable>();
if (effectable != null) {
statusEffectCost = effectable.StatusManager.AdditionalMoveTicks;
}
}

totalCost += statusEffectCost;
if (debugMode && totalCost > tickCostPerAction) {
string entityName = movingEntity != null ? movingEntity.gameObject.name : "Unknown Entity";
Debug.Log($"[PlayerActionManager] Movement for '{entityName}' cost breakdown: Base({tickCostPerAction}) + Status({statusEffectCost}) = {totalCost} ticks total.");
}
ret totalCost;
}

bool ExecuteToolUse(Vector3Int gridPosition, ToolDefinition tool) {
if (tool == null) ret false;
TileInteractionManager.Instance?.ApplyToolAction(tool);
ret true;
}

bool ExecutePlantSeed(Vector3Int gridPosition, InventoryBarItem seedItem) {
if (seedItem == null || !seedItem.IsSeed()) ret false;
ret PlantPlacementManager.Instance?.TryPlantSeedFromInventory(seedItem, gridPosition, TileInteractionManager.Instance.interactionGrid.GetCellCenterWorld(gridPosition)) ?? false;
}

bool ExecuteWatering(Vector3Int gridPosition) {
if (debugMode) Debug.Log($"[PlayerActionManager] Watering at {gridPosition} - NOT IMPLEMENTED");
ret false;
}

bool ExecuteInteraction(Vector3Int gridPosition, object interactionData) {
if (debugMode) Debug.Log($"[PlayerActionManager] Interaction at {gridPosition}");
ret true;
}

void AdvanceGameTick(int tickCount = 1) {
if (TickManager.Instance == null) {
Debug.LogError("[PlayerActionManager] TickManager not found!");
return;
}
for (int i = 0; i < tickCount; i++) {
TickManager.Instance.AdvanceTick();
}
if (debugMode) {
Debug.Log($"[PlayerActionManager] Advanced game by {tickCount} tick(s)");
}
}

pub bool CanExecuteAction(PlayerActionType actionType, Vector3Int gridPosition, object actionData = null) {
switch (actionType) {
case PlayerActionType.Move:
ret false;
case PlayerActionType.UseTool:
ret actionData is ToolDefinition;
case PlayerActionType.PlantSeed:
var seedItem = actionData as InventoryBarItem;
ret seedItem != null && seedItem.IsSeed();
default:
ret true;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\PlayerHungerSystem.cs

﻿using System;
using WegoSystem;

pub cls PlayerHungerSystem : MonoBehaviour, ITickUpdateable {
[SerializeField] float maxHunger = 100f;
[SerializeField] float startingHunger = 100f;
[SerializeField] float hungerDepletionPerTick = 0.1f; // Default: 1 hunger per 10 ticks

pub float CurrentHunger { get; set; }
pub float MaxHunger => maxHunger;

pub event Action<float, float> OnHungerChanged; // current, max
pub event Action OnStarvation;

bool hasStarved = false;

void Start() {
CurrentHunger = startingHunger;
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
else {
Debug.LogError("[PlayerHungerSystem] TickManager not found! Hunger will not deplete.");
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
if (hasStarved) return;

CurrentHunger -= hungerDepletionPerTick;
CurrentHunger = Mathf.Max(0, CurrentHunger);

OnHungerChanged?.Invoke(CurrentHunger, maxHunger);

if (CurrentHunger <= 0) {
hasStarved = true;
OnStarvation?.Invoke();
Debug.LogWarning("Player has starved to death!");
}
}

pub void Eat(float nutritionValue) {
if (hasStarved || nutritionValue <= 0) return;

CurrentHunger += nutritionValue;
CurrentHunger = Mathf.Clamp(CurrentHunger, 0, maxHunger);

Debug.Log($"Player ate food. Restored {nutritionValue} hunger. Current hunger: {CurrentHunger}/{maxHunger}");
OnHungerChanged?.Invoke(CurrentHunger, maxHunger);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileDefinition.cs

﻿using UnityEngine;
using UnityEngine.Tilemaps;

pub cls TileDefinition : ScriptableObject {
pub string displayName;    // e.g. "Grass", "Dirt", "Wet Dirt"

pub Color tintColor = Color.white;

pub int revertAfterTicks = 0;  // Changed from float revertAfterSeconds

pub TileDefinition revertToTile;

pub bool keepBottomTile = false;

pub bool isWaterTile = false;

#if UNITY_EDITOR
pub void UpdateColor() {
var manager = UnityEngine.Object.FindAnyObjectByType<TileInteractionManager>();
if (manager == null) return;

foreach (var mapping in manager.tileDefinitionMappings) {
if (mapping.tileDef == this && mapping.tilemapModule != null) {
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
if (renderTilemap != null) {
renderTilemap.color = tintColor;
UnityEditor.EditorUtility.SetDirty(renderTilemap);
}
}
}
}
}
#endif
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileHoverColorManager.cs

﻿using UnityEngine;

pub cls TileHoverColorManager : ScriptableObject {
Color withinRangeColor = new Color(1f, 1f, 1f, 0.8f);

Color outsideRangeColor = new Color(1f, 1f, 1f, 0.3f);

pub Color WithinRangeColor => withinRangeColor;
pub Color OutsideRangeColor => outsideRangeColor;

pub Color GetColorForRange(bool isWithinRange) {
ret isWithinRange ? withinRangeColor : outsideRangeColor;
}

void OnValidate() {
if (withinRangeColor.a < outsideRangeColor.a) {
Debug.LogWarning("[TileHoverColorManager] Within range alpha should typically be higher than outside range alpha for better visibility.");
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionLibrary.cs

﻿using System.Collections.Generic;
using System; // Needed for [Serializable]

[Serializable] // Make it visible in the Inspector
pub cls ToolRefillRule {
pub ToolDefinition toolToRefill;

pub TileDefinition refillSourceTile;
}

pub cls TileInteractionLibrary : ScriptableObject {
pub List<TileInteractionRule> rules; // Existing transformation rules

[Header("Tool Refill Rules")] // <<< NEW HEADER
pub List<ToolRefillRule> refillRules; // <<< NEW LIST FOR REFILLS
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionManager.cs

﻿// Assets/Scripts/WorldInteraction/Tiles/TileInteractionManager.cs
using UnityEngine.Tilemaps;
using skner.DualGrid;
using TMPro;
using WegoSystem;
#if UNITY_EDITOR
using UnityEditor;
#endif

pub cls TileInteractionManager : MonoBehaviour, ITickUpdateable {
pub stat TileInteractionManager Instance { get; set; }

pub cls TileDefinitionMapping {
pub TileDefinition tileDef;
pub DualGridTilemapModule tilemapModule;
}

pub struct TimedTileState {
pub TileDefinition tileDef;
pub int ticksRemaining;
}

pub List<TileDefinitionMapping> tileDefinitionMappings;
pub TileInteractionLibrary interactionLibrary;
pub Grid interactionGrid;
pub Camera mainCamera;
pub Transform player;

pub float hoverRadius = 3f;

pub GameObject hoverHighlightObject;
pub TileHoverColorManager hoverColorManager;
pub int baseSortingOrder = 0;

pub bool debugLogs = false;
pub TextMeshProUGUI hoveredTileText;
pub TextMeshProUGUI currentToolText;

Dictionary<TileDefinition, DualGridTilemapModule> moduleByDefinition;
Dictionary<DualGridTilemapModule, TileDefinition> definitionByModule;
Vector3Int? currentlyHoveredCell;
TileDefinition hoveredTileDef;
Dictionary<Vector3Int, TimedTileState> timedCells = new Dictionary<Vector3Int, TimedTileState>();
SpriteRenderer hoverSpriteRenderer;
bool isWithinInteractionRange = false;

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;
SetupTilemaps();
CacheHoverSpriteRenderer();
}

void Start() {
if (TickManager.Instance != null) TickManager.Instance.RegisterTickUpdateable(this);
}

void OnDestroy() {
if (TickManager.Instance != null) TickManager.Instance.UnregisterTickUpdateable(this);
if (Instance == this) Instance = null;
}

void OnDisable() {
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius("player_tool_use");
}
}

pub void OnTickUpdate(int currentTick) {
UpdateReversionTicks();
}

pub void ApplyToolAction(ToolDefinition toolDef) {
if (toolDef == null || !currentlyHoveredCell.HasValue) return;

Vector3Int targetCell = currentlyHoveredCell.Value;

TileDefinition currentTileDef = FindWhichTileDefinitionAt(targetCell);
if (currentTileDef == null) return;

if (debugLogs) Debug.Log($"[TileInteractionManager] Checking tile interactions for Tool='{toolDef.toolType}' on Tile='{currentTileDef.displayName}'");

if (interactionLibrary?.refillRules != null && ToolSwitcher.Instance != null && ToolSwitcher.Instance.CurrentTool == toolDef) {
foreach (var refillRule in interactionLibrary.refillRules) {
if (refillRule != null && refillRule.toolToRefill == toolDef && refillRule.refillSourceTile == currentTileDef) {
ToolSwitcher.Instance.RefillCurrentTool();
return; // Refill action was performed, we are done.
}
}
}

if (interactionLibrary?.rules != null) {
TileInteractionRule rule = interactionLibrary.rules.FirstOrDefault(r => r != null && r.tool == toolDef && r.fromTile == currentTileDef);
if (rule != null) {
if (rule.toTile != null) {
if (!rule.toTile.keepBottomTile) RemoveTile(currentTileDef, targetCell);
PlaceTile(rule.toTile, targetCell);
}
else {
RemoveTile(currentTileDef, targetCell);
}
}
}
}

void CacheHoverSpriteRenderer() {
if (hoverHighlightObject != null) {
hoverSpriteRenderer = hoverHighlightObject.GetComponent<SpriteRenderer>();
if (hoverSpriteRenderer == null) {
Debug.LogWarning("[TileInteractionManager] hoverHighlightObject has no SpriteRenderer component. Color management will not work.", this);
}
}
}

void SetupTilemaps() {
moduleByDefinition = new Dictionary<TileDefinition, DualGridTilemapModule>();
definitionByModule = new Dictionary<DualGridTilemapModule, TileDefinition>();
if (tileDefinitionMappings == null) {
if (debugLogs) Debug.LogWarning("[TileInteractionManager SetupTilemaps] No mappings defined.");
return;
}
foreach (var mapping in tileDefinitionMappings) {
if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) {
Debug.LogWarning("[TileInteractionManager SetupTilemaps] Null or incomplete mapping found. Skipping.");
continue;
}
if (!moduleByDefinition.ContainsKey(mapping.tileDef)) {
moduleByDefinition[mapping.tileDef] = mapping.tilemapModule;
definitionByModule[mapping.tilemapModule] = mapping.tileDef;
}
else {
Debug.LogWarning($"[TileInteractionManager SetupTilemaps] Duplicate TileDefinition '{mapping.tileDef.displayName}' found in mappings.", mapping.tileDef);
}
}
}

pub void UpdateSortingOrder() {
if (tileDefinitionMappings == null) return;
for (int i = 0; i < tileDefinitionMappings.Count; i++) {
var mapping = tileDefinitionMappings[i];
if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
if (renderer != null) {
renderer.sortingOrder = baseSortingOrder - i;
#if UNITY_EDITOR
if (!Application.isPlaying) EditorUtility.SetDirty(renderer);
#endif
}
}
}
}

pub void UpdateAllColors() {
if (tileDefinitionMappings == null) return;
foreach (var mapping in tileDefinitionMappings) {
if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
if (renderTilemap != null) {
renderTilemap.color = mapping.tileDef.tintColor;
#if UNITY_EDITOR
if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
}
}
}
}

void Update() {
HandleTileHover();
UpdateDebugUI();
}

void UpdateReversionTicks() {
if (timedCells.Count == 0) return;
List<Vector3Int> cellsToRevert = null;
foreach (var kvp in timedCells.ToList()) {
Vector3Int cellPos = kvp.Key;
TimedTileState state = kvp.Value;
if (state.tileDef == null) { timedCells.Remove(cellPos); continue; }
state.ticksRemaining--;
if (state.ticksRemaining <= 0) {
if (cellsToRevert == null) cellsToRevert = new List<Vector3Int>();
cellsToRevert.Add(cellPos);
}
else { timedCells[cellPos] = state; }
}
if (cellsToRevert != null) {
foreach (var cellPos in cellsToRevert) {
if (timedCells.TryGetValue(cellPos, out TimedTileState stateToRevert)) {
timedCells.Remove(cellPos);
RemoveTile(stateToRevert.tileDef, cellPos);
if (stateToRevert.tileDef.revertToTile != null) {
PlaceTile(stateToRevert.tileDef.revertToTile, cellPos);
}
}
}
}
}

pub void PlaceTile(TileDefinition tileDef, Vector3Int cellPos) {
if (tileDef == null) return;
if (!moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module)) return;
if (module?.DataTilemap != null) {
module.DataTilemap.SetTile(cellPos, ScriptableObject.CreateInstance<Tile>());
if (tileDef.revertAfterTicks > 0) {
timedCells[cellPos] = new TimedTileState { tileDef = tileDef, ticksRemaining = tileDef.revertAfterTicks };
}
}
}

pub void RemoveTile(TileDefinition tileDef, Vector3Int cellPos) {
if (tileDef == null) return;
if (!moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module)) return;
if (module?.DataTilemap != null) {
module.DataTilemap.SetTile(cellPos, null);
}
if (timedCells.TryGetValue(cellPos, out TimedTileState timedState) && timedState.tileDef == tileDef) {
timedCells.Remove(cellPos);
}
}

pub TileDefinition FindWhichTileDefinitionAt(Vector3Int cellPos) {
TileDefinition foundDef = null;
foreach (var mapping in tileDefinitionMappings) {
if (mapping?.tileDef != null && mapping.tilemapModule?.DataTilemap != null && mapping.tileDef.keepBottomTile) {
if (mapping.tilemapModule.DataTilemap.HasTile(cellPos)) { foundDef = mapping.tileDef; break; }
}
}
if (foundDef == null) {
foreach (var kvp in definitionByModule) {
if (kvp.Key?.DataTilemap != null && kvp.Value != null && !kvp.Value.keepBottomTile) {
if (kvp.Key.DataTilemap.HasTile(cellPos)) { foundDef = kvp.Value; break; }
}
}
}
ret foundDef;
}

void HandleTileHover() {
if (mainCamera == null || player == null) return;
Vector3 mouseWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
mouseWorldPos.z = 0f;
Vector3Int cellPos = WorldToCell(mouseWorldPos);
GridEntity playerGrid = player.GetComponent<GridEntity>();
if (playerGrid == null) return;
int gridRadius = Mathf.CeilToInt(hoverRadius);
GridPosition playerGridPos = playerGrid.Position;
GridPosition hoveredGridPos = new GridPosition(cellPos.x, cellPos.y);
isWithinInteractionRange = GridRadiusUtility.IsWithinCircleRadius(hoveredGridPos, playerGridPos, gridRadius);
hoveredTileDef = FindWhichTileDefinitionAt(cellPos);
currentlyHoveredCell = cellPos;
if (hoverHighlightObject != null) {
hoverHighlightObject.SetActive(true);
hoverHighlightObject.transform.position = CellCenterWorld(cellPos);
UpdateHoverHighlightColor(isWithinInteractionRange);
}
}

void UpdateHoverHighlightColor(bool withinRange) {
if (hoverSpriteRenderer != null && hoverColorManager != null) {
hoverSpriteRenderer.color = hoverColorManager.GetColorForRange(withinRange);
}
}

void UpdateDebugUI() {
if (hoveredTileText != null) {
string tileName = hoveredTileDef != null ? hoveredTileDef.displayName : "None";
if (currentlyHoveredCell.HasValue && timedCells.TryGetValue(currentlyHoveredCell.Value, out TimedTileState timedState)) {
tileName += $" [{timedState.ticksRemaining}t]";
}
string rangeIndicator = isWithinInteractionRange ? " [IN RANGE]" : " [OUT OF RANGE]";
hoveredTileText.text = $"Hover: {tileName}{rangeIndicator}";
}
if (currentToolText != null) {
if (InventoryBarController.Instance?.SelectedItem != null) {
currentToolText.text = $"Selected: {InventoryBarController.Instance.SelectedItem.GetDisplayName()}";
}
else { currentToolText.text = "Nothing Selected"; }
}
}

pub Vector3Int WorldToCell(Vector3 worldPos) {
if (interactionGrid != null) ret interactionGrid.WorldToCell(worldPos);
Debug.LogWarning("[WorldToCell] No valid interactionGrid found.");
ret Vector3Int.zero;
}

Vector3 CellCenterWorld(Vector3Int cellPos) {
if (interactionGrid != null) ret interactionGrid.GetCellCenterWorld(cellPos);
Debug.LogWarning("[CellCenterWorld] No valid interactionGrid found.");
ret Vector3.zero;
}

pub bool IsWithinInteractionRange => isWithinInteractionRange;
pub Vector3Int? CurrentlyHoveredCell => currentlyHoveredCell;
pub TileDefinition HoveredTileDef => hoveredTileDef;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionRule.cs

﻿using System;

pub cls TileInteractionRule {
pub ToolDefinition tool;

pub TileDefinition fromTile;
pub TileDefinition toTile;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolDefinition.cs

﻿using UnityEngine;
using System.Text;

pub cls ToolDefinition : ScriptableObject, ITooltipDataProvider {

pub ToolType toolType;
pub string displayName;

pub Sprite icon;
pub Color iconTint = Color.white;

pub bool limitedUses = false;
pub int initialUses = 10;

pub bool autoAddToInventory = true;

pub string GetTooltipTitle() {
ret displayName ?? "Unknown Tool";
}

pub string GetTooltipDescription() {
ret $"Tool Type: {toolType}";
}

pub string GetTooltipDetails(object source = null) {
var sb = new StringBuilder();
sb.Append(limitedUses ? $"<b>Uses:</b> {initialUses}" : "<b>Uses:</b> Unlimited");
ret sb.ToString().TrimEnd();
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolSwitcher.cs

﻿using System;

pub cls ToolSwitcher : MonoBehaviour {
pub stat ToolSwitcher Instance { get; set; }

pub ToolDefinition[] toolDefinitions;

int currentIndex = 0;

pub ToolDefinition CurrentTool { get; set; } = null;
pub int CurrentRemainingUses { get; set; } = -1; // -1 for unlimited

pub event Action<ToolDefinition> OnToolChanged;
pub event Action<int> OnUsesChanged;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void Start() {
InitializeToolState(true); // Initialize and fire events
}

void OnDestroy() {
if (Instance == this) {
Instance = null;
}
}

void Update() {
if (toolDefinitions == null || toolDefinitions.Length == 0) return;

bool toolChanged = false;
int previousIndex = currentIndex;

if (Input.GetKeyDown(KeyCode.Q)) {
currentIndex--;
if (currentIndex < 0)
currentIndex = toolDefinitions.Length - 1;
toolChanged = true;
}
else if (Input.GetKeyDown(KeyCode.E)) {
currentIndex++;
if (currentIndex >= toolDefinitions.Length)
currentIndex = 0;
toolChanged = true;
}

if (toolChanged) {
if (currentIndex >= 0 && currentIndex < toolDefinitions.Length && toolDefinitions[currentIndex] != null) {
InitializeToolState(false); // Update state for the new tool and fire events
}
else {
Debug.LogError($"[ToolSwitcher Update] Attempted to switch to an invalid/NULL tool definition at index {currentIndex}. Reverting.");
currentIndex = previousIndex; // Revert to the last valid index
}
}
}

void InitializeToolState(bool isInitialSetup) {
ToolDefinition previousTool = CurrentTool; // Store previous tool for change check
int previousUses = CurrentRemainingUses; // Store previous uses

if (toolDefinitions == null || toolDefinitions.Length == 0 || currentIndex < 0 || currentIndex >= toolDefinitions.Length || toolDefinitions[currentIndex] == null) {
CurrentTool = null;
CurrentRemainingUses = -1; // No tool = unlimited uses conceptually
}
else {
CurrentTool = toolDefinitions[currentIndex];
if (CurrentTool.limitedUses) {
CurrentRemainingUses = CurrentTool.initialUses;
}
else {
CurrentRemainingUses = -1; // Mark as unlimited
}
}

LogToolChange("[ToolSwitcher InitializeToolState]"); // Log the state after update

bool toolActuallyChanged = previousTool != CurrentTool;
bool usesActuallyChanged = previousUses != CurrentRemainingUses;

if (isInitialSetup || toolActuallyChanged) {
Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnToolChanged for tool: {CurrentTool?.displayName ?? "NULL"}");
OnToolChanged?.Invoke(CurrentTool);
}
if (isInitialSetup || usesActuallyChanged || toolActuallyChanged) // Fire uses changed if tool changed too (to reset UI) {
Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnUsesChanged with value: {CurrentRemainingUses}");
OnUsesChanged?.Invoke(CurrentRemainingUses);
}
}

pub void SelectToolByDefinition(ToolDefinition toolDef) {
if (toolDef == null || toolDefinitions == null) return;

for (int i = 0; i < toolDefinitions.Length; i++) {
if (toolDefinitions[i] == toolDef) {
currentIndex = i;
InitializeToolState(false);
Debug.Log($"[ToolSwitcher] Externally selected tool: {toolDef.displayName} at index {i}");
return;
}
}

Debug.LogWarning($"[ToolSwitcher] Tool '{toolDef.displayName}' not found in definitions array");
}

pub void RefillCurrentTool() {
if (CurrentTool == null) {
Debug.LogWarning("[ToolSwitcher RefillCurrentTool] Cannot refill: No tool selected.");
return;
}

if (!CurrentTool.limitedUses) {
Debug.LogWarning($"[ToolSwitcher RefillCurrentTool] Cannot refill tool '{CurrentTool.displayName}': It has unlimited uses.");
return;
}

if (CurrentRemainingUses == CurrentTool.initialUses) {
if(Debug.isDebugBuild) Debug.Log($"[ToolSwitcher RefillCurrentTool] Tool '{CurrentTool.displayName}' is already full ({CurrentRemainingUses} uses).");
return;
}

int previousUses = CurrentRemainingUses;
CurrentRemainingUses = CurrentTool.initialUses;

Debug.Log($"[ToolSwitcher RefillCurrentTool] Refilled tool '{CurrentTool.displayName}' to {CurrentRemainingUses} uses (was {previousUses}).");

OnUsesChanged?.Invoke(CurrentRemainingUses);
}

pub bool TryConsumeUse() {
if (CurrentTool == null) {
Debug.LogWarning("[ToolSwitcher TryConsumeUse] Cannot consume use: No tool selected.");
ret false; // Cannot use a non-existent tool
}

if (!CurrentTool.limitedUses || CurrentRemainingUses == -1) {
ret true;
}

if (CurrentRemainingUses > 0) {
CurrentRemainingUses--;
Debug.Log($"[ToolSwitcher TryConsumeUse] Consumed use for '{CurrentTool.displayName}'. Remaining: {CurrentRemainingUses}");
OnUsesChanged?.Invoke(CurrentRemainingUses); // Notify listeners
ret true;
}
else {
Debug.Log($"[ToolSwitcher TryConsumeUse] Tool '{CurrentTool.displayName}' is out of uses (0 remaining).");
ret false;
}
}

void LogToolChange(string prefix = "[ToolSwitcher]") {
string toolName = (CurrentTool != null && !string.IsNullOrEmpty(CurrentTool.displayName))
? CurrentTool.displayName
: "(none)";
string usesSuffix = "";
if (CurrentTool != null && CurrentTool.limitedUses && CurrentRemainingUses >= 0) {
usesSuffix = $" ({CurrentRemainingUses}/{CurrentTool.initialUses})";
}
else if (CurrentTool != null && !CurrentTool.limitedUses) {
}

Debug.Log($"{prefix} Switched tool to: {toolName}{usesSuffix} (Index: {currentIndex})");
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolType.cs

﻿pub enum ToolType {
None,
Hoe,
WateringCan,
SeedPouch,
HarvestPouch // <<< NEW
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridEntity.cs

﻿// Assets/Scripts/Ticks/GridEntity.cs

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
pub cls GridEntity : MonoBehaviour {
pub bool isTileOccupant = true;

GridPosition gridPosition;

[SerializeField] Vector3 groundPointOffset = Vector3.zero;
[SerializeField] Vector3 visualOffset = Vector3.zero;
[SerializeField] float visualInterpolationSpeed = 5f;
[SerializeField] AnimationCurve movementCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

GridPosition previousGridPosition;
Vector3 visualStartPosition;
Vector3 visualTargetPosition;
float movementProgress = 1f;
bool isMoving = false;
float speedMultiplier = 1f;

pub GridPosition Position {
get => gridPosition;
set {
if (gridPosition != value) {
previousGridPosition = gridPosition;
gridPosition = value;
OnGridPositionChanged();
}
}
}

pub GridPosition PreviousPosition => previousGridPosition;
pub bool IsMoving => isMoving;
pub float MovementProgress => movementProgress;
pub Vector3 GroundWorldPosition => transform.position + groundPointOffset;

pub event Action<GridPosition, GridPosition> OnPositionChanged;
pub event Action<GridPosition> OnMovementComplete;
pub event Action OnMovementStart;

prot virt void Start() {
visualStartPosition = transform.position;
visualTargetPosition = transform.position;
previousGridPosition = gridPosition;
}

prot virt void OnDestroy() {
GridPositionManager.Instance?.UnregisterEntity(this);
}

prot virt void Update() {
if (movementProgress < 1f) {
movementProgress += Time.deltaTime * visualInterpolationSpeed * speedMultiplier;
movementProgress = Mathf.Clamp01(movementProgress);

float curvedProgress = movementCurve.Evaluate(movementProgress);
transform.position = Vector3.Lerp(visualStartPosition, visualTargetPosition, curvedProgress);

if (movementProgress >= 1f) {
transform.position = visualTargetPosition;
isMoving = false;
OnMovementComplete?.Invoke(gridPosition);
}
}
}

#if UNITY_EDITOR
void OnDrawGizmosSelected() {
Vector3 groundWorldPosition = transform.position + groundPointOffset;
Gizmos.color = Color.green;
Gizmos.DrawLine(transform.position, groundWorldPosition);
Gizmos.DrawWireSphere(groundWorldPosition, 0.1f);
UnityEditor.Handles.Label(groundWorldPosition + Vector3.up * 0.2f, "Ground Point");

if (Application.isPlaying && GridPositionManager.Instance != null) {
Gizmos.color = Color.yellow;
Vector3 gridCenter = GridPositionManager.Instance.GetCellCenter(gridPosition);
Gizmos.DrawSphere(gridCenter, 0.08f);
}
}
#endif

prot virt void OnGridPositionChanged() {
visualStartPosition = transform.position;

if (GridPositionManager.Instance != null) {
Vector3 groundTargetPosition = GridPositionManager.Instance.GridToWorld(gridPosition);
visualTargetPosition = groundTargetPosition - groundPointOffset + visualOffset;
}

movementProgress = 0f;

if (!isMoving) {
isMoving = true;
OnMovementStart?.Invoke();
}

OnPositionChanged?.Invoke(previousGridPosition, gridPosition);
}

pub void SetPosition(GridPosition newPosition, bool instant = false) {
Position = newPosition; // This invokes OnGridPositionChanged which sets up the tween

if (instant) {
if (GridPositionManager.Instance == null) return;

Vector3 groundTargetPosition = GridPositionManager.Instance.GridToWorld(Position);
transform.position = groundTargetPosition - groundPointOffset + visualOffset;

visualStartPosition = transform.position;
visualTargetPosition = transform.position;
movementProgress = 1f;
isMoving = false;
}
}

pub void SetSpeedMultiplier(float multiplier) {
this.speedMultiplier = multiplier;
}

pub void SnapToGrid() {
if (GridPositionManager.Instance == null) return;

Vector3 groundWorldPos = transform.position + groundPointOffset;
GridPosition currentGridPos = GridPositionManager.Instance.WorldToGrid(groundWorldPos);
SetPosition(currentGridPos, true);
}

pub void MoveInDirection(GridPosition direction) {
SetPosition(gridPosition + direction);
}

pub bool CanMoveTo(GridPosition targetPosition) {
ret GridPositionManager.Instance?.IsPositionValid(targetPosition) ?? false;
}

pub void CompleteMovement() {
if (isMoving) {
transform.position = visualTargetPosition;
movementProgress = 1f;
isMoving = false;
OnMovementComplete?.Invoke(gridPosition);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridPosition.cs

﻿// Assets/Scripts/Ticks/GridPosition.cs

namespace WegoSystem {
pub struct GridPosition : IEquatable<GridPosition> {
pub int x;
pub int y;

pub GridPosition(int x, int y) {
this.x = x;
this.y = y;
}

pub GridPosition(Vector3Int vector3Int) {
this.x = vector3Int.x;
this.y = vector3Int.y;
}

pub GridPosition(Vector2Int vector2Int) {
this.x = vector2Int.x;
this.y = vector2Int.y;
}

pub stat GridPosition operator +(GridPosition a, GridPosition b) {
ret new GridPosition(a.x + b.x, a.y + b.y);
}

pub stat GridPosition operator -(GridPosition a, GridPosition b) {
ret new GridPosition(a.x - b.x, a.y - b.y);
}

pub stat bool operator ==(GridPosition a, GridPosition b) {
ret a.x == b.x && a.y == b.y;
}

pub stat bool operator !=(GridPosition a, GridPosition b) {
ret !(a == b);
}

pub Vector3Int ToVector3Int() => new Vector3Int(x, y, 0);
pub Vector2Int ToVector2Int() => new Vector2Int(x, y);
pub Vector3 ToWorldPosition(float cellSize = 1f) => new Vector3(x * cellSize, y * cellSize, 0);

pub stat ro GridPosition Up = new GridPosition(0, 1);
pub stat ro GridPosition Down = new GridPosition(0, -1);
pub stat ro GridPosition Left = new GridPosition(-1, 0);
pub stat ro GridPosition Right = new GridPosition(1, 0);
pub stat ro GridPosition UpLeft = new GridPosition(-1, 1);
pub stat ro GridPosition UpRight = new GridPosition(1, 1);
pub stat ro GridPosition DownLeft = new GridPosition(-1, -1);
pub stat ro GridPosition DownRight = new GridPosition(1, -1);
pub stat ro GridPosition Zero = new GridPosition(0, 0);

pub int ManhattanDistance(GridPosition other) {
ret Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y);
}

pub int ChebyshevDistance(GridPosition other) {
ret Mathf.Max(Mathf.Abs(x - other.x), Mathf.Abs(y - other.y));
}

pub float EuclideanDistance(GridPosition other) {
int dx = x - other.x;
int dy = y - other.y;
ret Mathf.Sqrt(dx * dx + dy * dy);
}

pub GridPosition[] GetNeighbors(bool includeDiagonals = false) {
if (includeDiagonals) {
ret new GridPosition[] {
this + Up, this + Down, this + Left, this + Right,
this + UpLeft, this + UpRight, this + DownLeft, this + DownRight
};
}
else {
ret new GridPosition[] {
this + Up, this + Down, this + Left, this + Right
};
}
}

pub bool Equals(GridPosition other) {
ret x == other.x && y == other.y;
}

pub ovr bool Equals(object obj) {
ret obj is GridPosition other && Equals(other);
}

pub ovr int GetHashCode() {
ret HashCode.Combine(x, y);
}

pub ovr string ToString() {
ret $"({x}, {y})";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridPositionManager.cs

﻿using System;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
pub cls GridPositionManager : MonoBehaviour {
pub stat GridPositionManager Instance { get; set; }

[SerializeField] TileInteractionManager tileInteractionManager;

Grid _tilemapGrid;

Grid TilemapGrid {
get {
if (_tilemapGrid == null) {
SyncWithTileGrid(); // Attempt to sync again if it's null
}
ret _tilemapGrid;
}
}

[SerializeField] Vector2Int gridBounds = new Vector2Int(100, 100);

[SerializeField] bool showGridGizmos = true;
[SerializeField] Color gridColor = new Color(0.5f, 0.5f, 0.5f, 0.3f);
[SerializeField] int gizmoGridSize = 20;
[SerializeField] bool debugMode = false;

ro Dictionary<GridPosition, HashSet<GridEntity>> entitiesByPosition = new Dictionary<GridPosition, HashSet<GridEntity>>();
ro HashSet<GridEntity> allEntities = new HashSet<GridEntity>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

SyncWithTileGrid();
}

void OnDestroy() {
if (Instance == this) {
Instance = null;
}
}

pub void SyncWithTileGrid() {
if (tileInteractionManager != null && tileInteractionManager.interactionGrid != null) {
this._tilemapGrid = tileInteractionManager.interactionGrid;
if (debugMode) {
Debug.Log($"[GridPositionManager] Synced with assigned TileInteractionManager's grid: '{this._tilemapGrid.name}'.");
}
return; // Success
}

if (TileInteractionManager.Instance != null && TileInteractionManager.Instance.interactionGrid != null) {
this._tilemapGrid = TileInteractionManager.Instance.interactionGrid;
tileInteractionManager = TileInteractionManager.Instance;
if (debugMode) {
Debug.Log($"[GridPositionManager] Synced with singleton TileInteractionManager.Instance's grid: '{this._tilemapGrid.name}'.");
}
return; // Success
}

if (_tilemapGrid == null) {
Debug.LogError("[GridPositionManager] Could not find TileInteractionManager or its grid to sync with! Grid system may be misaligned. Please assign the TileInteractionManager in the Inspector.");
}
}

pub GridPosition WorldToGrid(Vector3 worldPosition) {
if (TilemapGrid == null) ret GridPosition.Zero;
Vector3Int cellPos = TilemapGrid.WorldToCell(worldPosition);
ret new GridPosition(cellPos);
}

pub Vector3 GridToWorld(GridPosition gridPosition) {
if (TilemapGrid == null) ret Vector3.zero;
ret TilemapGrid.GetCellCenterWorld(gridPosition.ToVector3Int());
}

pub Vector3 GetCellCenter(GridPosition gridPosition) {
ret GridToWorld(gridPosition);
}

pub bool IsPositionValid(GridPosition position) {
ret position.x >= -gridBounds.x / 2 && position.x < gridBounds.x / 2 &&
position.y >= -gridBounds.y / 2 && position.y < gridBounds.y / 2;
}

pub bool IsPositionOccupied(GridPosition position) {
if (entitiesByPosition.TryGetValue(position, out var entities)) {
ret entities.Any(entity => entity.isTileOccupant);
}
ret false;
}

pub void RegisterEntity(GridEntity entity) {
if (entity == null || allEntities.Contains(entity)) return;

allEntities.Add(entity);
AddEntityToPosition(entity, entity.Position);

entity.OnPositionChanged += OnEntityPositionChanged;
}

pub void UnregisterEntity(GridEntity entity) {
if (entity == null || !allEntities.Contains(entity)) return;

allEntities.Remove(entity);
RemoveEntityFromPosition(entity, entity.Position);

entity.OnPositionChanged -= OnEntityPositionChanged;
}

void OnEntityPositionChanged(GridPosition oldPosition, GridPosition newPosition) {
var entity = allEntities.FirstOrDefault(e => e.Position == newPosition && e.PreviousPosition == oldPosition);
if (entity != null) {
RemoveEntityFromPosition(entity, oldPosition);
AddEntityToPosition(entity, newPosition);
}
}

void AddEntityToPosition(GridEntity entity, GridPosition position) {
if (!entitiesByPosition.ContainsKey(position)) {
entitiesByPosition[position] = new HashSet<GridEntity>();
}
entitiesByPosition[position].Add(entity);
}

void RemoveEntityFromPosition(GridEntity entity, GridPosition position) {
if (entitiesByPosition.ContainsKey(position)) {
entitiesByPosition[position].Remove(entity);
if (entitiesByPosition[position].Count == 0) {
entitiesByPosition.Remove(position);
}
}
}

pub HashSet<GridEntity> GetEntitiesAt(GridPosition position) {
ret entitiesByPosition.ContainsKey(position)
? new HashSet<GridEntity>(entitiesByPosition[position])
: new HashSet<GridEntity>();
}

pub List<GridEntity> GetEntitiesInRadius(GridPosition center, int radius, bool useCircle = true) {
var result = new List<GridEntity>();

if (useCircle) {
var tilesInRadius = GridRadiusUtility.GetTilesInCircle(center, radius);
foreach (var pos in tilesInRadius) {
if (entitiesByPosition.ContainsKey(pos)) {
result.AddRange(entitiesByPosition[pos]);
}
}
} else {
for (int x = -radius; x <= radius; x++) {
for (int y = -radius; y <= radius; y++) {
var checkPos = new GridPosition(center.x + x, center.y + y);
if (checkPos.ManhattanDistance(center) <= radius && entitiesByPosition.ContainsKey(checkPos)) {
result.AddRange(entitiesByPosition[checkPos]);
}
}
}
}

ret result;
}

pub bool IsPositionWithinRadius(GridPosition position, GridPosition center, int radius, bool useCircle = true) {
if (useCircle) {
ret GridRadiusUtility.IsWithinCircleRadius(position, center, radius);
} else {
ret position.ManhattanDistance(center) <= radius;
}
}

pub GridEntity GetNearestEntity(GridPosition position, System.Func<GridEntity, bool> predicate = null) {
GridEntity nearest = null;
float nearestDistance = float.MaxValue;

foreach (var entity in allEntities) {
if (predicate != null && !predicate(entity)) continue;

float distance = entity.Position.EuclideanDistance(position);
if (distance < nearestDistance) {
nearest = entity;
nearestDistance = distance;
}
}
ret nearest;
}

pub Grid GetTilemapGrid() {
ret TilemapGrid;
}

pub List<GridPosition> GetPath(GridPosition start, GridPosition end, bool allowDiagonal = false) {
var path = new List<GridPosition>();

if (!IsPositionValid(start) || !IsPositionValid(end)) {
ret path;
}

var openSet = new HashSet<GridPosition>();
var closedSet = new HashSet<GridPosition>();
var cameFrom = new Dictionary<GridPosition, GridPosition>();
var gScore = new Dictionary<GridPosition, float>();
var fScore = new Dictionary<GridPosition, float>();

openSet.Add(start);
gScore[start] = 0;
fScore[start] = HeuristicCost(start, end);

while (openSet.Count > 0) {
GridPosition current = GetLowestFScore(openSet, fScore);

if (current == end) {
while (cameFrom.ContainsKey(current)) {
path.Add(current);
current = cameFrom[current];
}
path.Reverse();
ret path;
}

openSet.Remove(current);
closedSet.Add(current);

foreach (var neighbor in current.GetNeighbors(allowDiagonal)) {
if (!IsPositionValid(neighbor) || closedSet.Contains(neighbor) || (neighbor != end && IsPositionOccupied(neighbor))) {
continue;
}

float tentativeGScore = gScore[current] + 1; // Assuming cost of 1 per tile

if (!openSet.Contains(neighbor)) {
openSet.Add(neighbor);
}
else if (gScore.ContainsKey(neighbor) && tentativeGScore >= gScore[neighbor]) {
continue; // This path is not better
}

cameFrom[neighbor] = current;
gScore[neighbor] = tentativeGScore;
fScore[neighbor] = gScore[neighbor] + HeuristicCost(neighbor, end);
}
}
ret path; // No path found
}

float HeuristicCost(GridPosition a, GridPosition b) {
ret a.ManhattanDistance(b);
}

GridPosition GetLowestFScore(HashSet<GridPosition> openSet, Dictionary<GridPosition, float> fScore) {
GridPosition lowest = openSet.First();
float lowestScore = fScore.ContainsKey(lowest) ? fScore[lowest] : float.MaxValue;

foreach (var pos in openSet) {
float score = fScore.ContainsKey(pos) ? fScore[pos] : float.MaxValue;
if (score < lowestScore) {
lowest = pos;
lowestScore = score;
}
}
ret lowest;
}

pub bool PathExists(GridPosition start, GridPosition end, bool allowDiagonal = false) {
var path = GetPath(start, end, allowDiagonal);
ret path.Count > 0;
}

pub void SnapEntityToGrid(GameObject entity) {
if (entity == null) return;

GridEntity gridEntity = entity.GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = entity.AddComponent<GridEntity>();
}

gridEntity.SnapToGrid();

RegisterEntity(gridEntity);

if (debugMode) {
Debug.Log($"[GridPositionManager] Snapped and Registered {entity.name} to grid {gridEntity.Position}");
}
}

pub void SnapAllEntitiesToGrid<T>() where T : Component {
T[] entities = FindObjectsByType<T>(FindObjectsSortMode.None);
foreach (var entity in entities) {
SnapEntityToGrid(entity.gameObject);
}
Debug.Log($"[GridPositionManager] Snapped {entities.Length} entities of type {typeof(T).Name} to grid");
}

pub stat List<GridPosition> GetTilesInRadius(GridPosition center, int radius, bool useManhattan = true) {
var result = new List<GridPosition>();

for (int x = -radius; x <= radius; x++) {
for (int y = -radius; y <= radius; y++) {
var offset = new GridPosition(x, y);
var checkPos = center + offset;

int distance = useManhattan
? Mathf.Abs(x) + Mathf.Abs(y)
: Mathf.Max(Mathf.Abs(x), Mathf.Abs(y));

if (distance <= radius) {
result.Add(checkPos);
}
}
}

ret result;
}

void OnDrawGizmos() {
if (!showGridGizmos || TilemapGrid == null) return;

Gizmos.color = gridColor;

int halfWidth = gizmoGridSize / 2;
int halfHeight = gizmoGridSize / 2;

for (int x = -halfWidth; x <= halfWidth; x++) {
Vector3 start = GridToWorld(new GridPosition(x, -halfHeight));
Vector3 end = GridToWorld(new GridPosition(x, halfHeight));
Gizmos.DrawLine(start, end);
}

for (int y = -halfHeight; y <= halfHeight; y++) {
Vector3 start = GridToWorld(new GridPosition(-halfWidth, y));
Vector3 end = GridToWorld(new GridPosition(halfWidth, y));
Gizmos.DrawLine(start, end);
}

Gizmos.color = Color.red;
foreach (var kvp in entitiesByPosition) {
if (kvp.Value.Count > 0) {
Vector3 cellCenter = GridToWorld(kvp.Key);
Gizmos.DrawWireCube(cellCenter, Vector3.one * TilemapGrid.cellSize.x * 0.8f);
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridRadiusUtility.cs

﻿using UnityEngine;
using WegoSystem;

ns WegoSystem {
pub stat cls GridRadiusUtility {
pub stat List<GridPosition> GetTilesInCircle(GridPosition center, int radius, bool filled = true) {
var result = new List<GridPosition>();

if (radius <= 0) {
result.Add(center);
ret result;
}

for (int dx = -radius; dx <= radius; dx++) {
for (int dy = -radius; dy <= radius; dy++) {
float distance = Mathf.Sqrt(dx * dx + dy * dy);

if (filled) {
if (distance <= radius + 0.5f) {
result.Add(new GridPosition(center.x + dx, center.y + dy));
}
} else {
if (distance >= radius - 0.5f && distance <= radius + 0.5f) {
result.Add(new GridPosition(center.x + dx, center.y + dy));
}
}
}
}

ret result;
}

pub stat List<GridPosition> GetPerfectCircleTiles(GridPosition center, int radius) {
var result = new HashSet<GridPosition>();

if (radius == 0) {
result.Add(center);
ret new List<GridPosition>(result);
}

int x = 0;
int y = radius;
int d = 3 - 2 * radius;

while (x <= y) {
AddCirclePoints(result, center, x, y);

if (d < 0) {
d = d + 4 * x + 6;
} else {
d = d + 4 * (x - y) + 10;
y--;
}
x++;
}

var filledResult = new List<GridPosition>();
int minX = center.x - radius;
int maxX = center.x + radius;

for (int scanY = center.y - radius; scanY <= center.y + radius; scanY++) {
bool inside = false;
int startX = minX;

for (int scanX = minX; scanX <= maxX; scanX++) {
var pos = new GridPosition(scanX, scanY);
if (result.Contains(pos)) {
if (!inside) {
inside = true;
startX = scanX;
}
} else if (inside) {
for (int fillX = startX; fillX < scanX; fillX++) {
filledResult.Add(new GridPosition(fillX, scanY));
}
inside = false;
}
}

if (inside) {
for (int fillX = startX; fillX <= maxX; fillX++) {
var pos = new GridPosition(fillX, scanY);
if (result.Contains(pos) || fillX == maxX) {
for (int fill = startX; fill <= fillX; fill++) {
filledResult.Add(new GridPosition(fill, scanY));
}
break;
}
}
}
}

ret filledResult;
}

stat void AddCirclePoints(HashSet<GridPosition> result, GridPosition center, int x, int y) {
result.Add(new GridPosition(center.x + x, center.y + y));
result.Add(new GridPosition(center.x - x, center.y + y));
result.Add(new GridPosition(center.x + x, center.y - y));
result.Add(new GridPosition(center.x - x, center.y - y));
result.Add(new GridPosition(center.x + y, center.y + x));
result.Add(new GridPosition(center.x - y, center.y + x));
result.Add(new GridPosition(center.x + y, center.y - x));
result.Add(new GridPosition(center.x - y, center.y - x));
}

pub stat bool IsWithinCircleRadius(GridPosition position, GridPosition center, int radius) {
int dx = position.x - center.x;
int dy = position.y - center.y;
float distance = Mathf.Sqrt(dx * dx + dy * dy);
ret distance <= radius + 0.5f;
}

pub stat List<GridPosition> GetCircleOutline(GridPosition center, int radius) {
ret GetTilesInCircle(center, radius, false);
}

pub stat void DebugPrintRadius(GridPosition center, int radius) {
var tiles = GetTilesInCircle(center, radius);
var tileSet = new HashSet<GridPosition>(tiles);

Debug.Log($"Circle pattern for radius {radius}:");

for (int y = radius; y >= -radius; y--) {
string line = "";
for (int x = -radius; x <= radius; x++) {
var pos = new GridPosition(center.x + x, center.y + y);
if (pos.Equals(center)) {
line += "◉ "; // Center
} else if (tileSet.Contains(pos)) {
line += "● "; // Included tile
} else {
line += "· "; // Not included
}
}
Debug.Log(line);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickConfiguration.cs

﻿using UnityEngine;

namespace WegoSystem {
pub cls TickConfiguration : ScriptableObject {
[SerializeField] pub float ticksPerRealSecond = 2f;

pub int ticksPerDay = 100;
pub int dayPhaseTicks = 60;
pub int nightPhaseTicks = 40;
pub int transitionTicks = 10;

pub int animalHungerTickInterval = 3;
pub int animalThinkingInterval = 3;

pub int movementTicksPerTile = 1;
pub int movementCooldownTicks = 0;

pub float GetRealSecondsPerTick() {
ret ticksPerRealSecond > 0 ? 1f / ticksPerRealSecond : 0.5f;
}

pub int ConvertSecondsToTicks(float seconds) {
ret Mathf.RoundToInt(seconds * ticksPerRealSecond);
}

pub float ConvertTicksToSeconds(int ticks) {
ret ticks / ticksPerRealSecond;
}

pub int GetDayProgress(int currentTick) {
ret currentTick % ticksPerDay;
}

pub float GetDayProgressNormalized(int currentTick) {
ret (float)(currentTick % ticksPerDay) / ticksPerDay;
}

pub void SetTicksPerSecond(float newRate) {
ticksPerRealSecond = Mathf.Max(0.1f, newRate);
}

void OnValidate() {
ticksPerRealSecond = Mathf.Max(0.1f, ticksPerRealSecond);
ticksPerDay = Mathf.Max(10, ticksPerDay);
dayPhaseTicks = Mathf.Max(1, dayPhaseTicks);
nightPhaseTicks = Mathf.Max(1, nightPhaseTicks);
transitionTicks = Mathf.Max(1, transitionTicks);
animalHungerTickInterval = Mathf.Max(1, animalHungerTickInterval);
animalThinkingInterval = Mathf.Max(1, animalThinkingInterval);
}

void ApplySlowPacedPreset() {
ticksPerRealSecond = 1f;
ticksPerDay = 200;
dayPhaseTicks = 120;
nightPhaseTicks = 80;
transitionTicks = 20;
animalHungerTickInterval = 5;
}

void ApplyFastPacedPreset() {
ticksPerRealSecond = 4f;
ticksPerDay = 50;
dayPhaseTicks = 30;
nightPhaseTicks = 20;
transitionTicks = 5;
animalHungerTickInterval = 2;
}

void ApplyBalancedPreset() {
ticksPerRealSecond = 2f;
ticksPerDay = 100;
dayPhaseTicks = 60;
nightPhaseTicks = 40;
transitionTicks = 10;
animalHungerTickInterval = 3;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickManager.cs

﻿// Assets\Scripts\Ticks\TickManager.cs

ns WegoSystem {
pub ifc ITickUpdateable {
void OnTickUpdate(int currentTick);
}

pub cls TickManager : MonoBehaviour {
pub stat TickManager Instance { get; set; }

[SerializeField] TickConfiguration tickConfig;
[SerializeField] bool debugMode = false;
[SerializeField] int currentTick = 0;

pub int CurrentTick => currentTick;
pub TickConfiguration Config => tickConfig;

pub event Action<int> OnTickAdvanced;
pub event Action<int> OnTickStarted;
pub event Action<int> OnTickCompleted;

ro List<ITickUpdateable> tickUpdateables = new List<ITickUpdateable>();
ro List<ITickUpdateable> pendingAdditions = new List<ITickUpdateable>();
ro List<ITickUpdateable> pendingRemovals = new List<ITickUpdateable>();
bool isProcessingTick = false;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}

Instance = this;

if (tickConfig == null) {
Debug.LogError("[TickManager] No TickConfiguration assigned! Creating default config.");
tickConfig = ScriptableObject.CreateInstance<TickConfiguration>();
}
}

void OnDestroy() {
if (Instance == this) {
Instance = null;
}
}

void Update() {
#if UNITY_EDITOR
if (debugMode && Input.GetKeyDown(KeyCode.T)) {
Debug.Log("[TickManager] Debug: Manual tick advance");
AdvanceTick();
}
#endif
}

pub void AdvanceTick() {
AdvanceMultipleTicks(1);
}

pub void AdvanceMultipleTicks(int tickCount) {
if (tickCount <= 0) return;

for (int i = 0; i < tickCount; i++) {
currentTick++;
ProcessTick();
}
}

void ProcessTick() {
if (debugMode) {
Debug.Log($"[TickManager] Processing tick {currentTick}");
}

OnTickStarted?.Invoke(currentTick);

ProcessPendingUpdates();

isProcessingTick = true;
foreach (var tickUpdateable in tickUpdateables) {
try {
tickUpdateable?.OnTickUpdate(currentTick);
}
catch (Exception e) {
Debug.LogError($"[TickManager] Error in tick update: {e.Message}");
}
}
isProcessingTick = false;

OnTickAdvanced?.Invoke(currentTick);
OnTickCompleted?.Invoke(currentTick);
}

pub void RegisterTickUpdateable(ITickUpdateable updateable) {
if (updateable == null) return;

if (isProcessingTick) {
if (!pendingAdditions.Contains(updateable))
pendingAdditions.Add(updateable);
}
else {
if (!tickUpdateables.Contains(updateable))
tickUpdateables.Add(updateable);
}
}

pub void UnregisterTickUpdateable(ITickUpdateable updateable) {
if (updateable == null) return;

if (isProcessingTick) {
if (!pendingRemovals.Contains(updateable))
pendingRemovals.Add(updateable);
}
else {
tickUpdateables.Remove(updateable);
}
}

void ProcessPendingUpdates() {
foreach (var updateable in pendingAdditions) {
if (!tickUpdateables.Contains(updateable))
tickUpdateables.Add(updateable);
}
pendingAdditions.Clear();

foreach (var updateable in pendingRemovals) {
tickUpdateables.Remove(updateable);
}
pendingRemovals.Clear();
}

pub void ResetTicks() {
currentTick = 0;
if (debugMode) Debug.Log("[TickManager] Reset tick counter");
}

pub int GetTicksSince(int pastTick) {
ret currentTick - pastTick;
}

pub bool HasTicksPassed(int lastTick, int tickInterval) {
ret GetTicksSince(lastTick) >= tickInterval;
}

pub int GetNextIntervalTick(int tickInterval) {
ret currentTick + tickInterval;
}

pub void DebugAdvanceTick() {
if (Application.isEditor || Debug.isDebugBuild) {
AdvanceTick();
}
}

pub int GetRegisteredUpdateableCount() {
ret tickUpdateables.Count;
}
}
}
