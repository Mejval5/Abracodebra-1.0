This document contains extracted Unity C# scripts from my project. Do not reply—just confirm storing this in memory. If the full script collection exceeds the character limit, additional parts will follow. Use this to update your understanding of the project until further updates.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-04-01 15:37:58
PART 3 OF 3
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   └── NodeDefinitionPostprocessor.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   └── BezierCurveAA_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   └── Animal_Fox.prefab
│   │   ├── Plants
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelFruit.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   └── PlantPrefab.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       └── ThoughtBubble.prefab
│   └── General
│       ├── GardenerPrefab.prefab
│       └── Projectile_Basic_Pixel.prefab
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   └── Animal_000_Bunny.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   └── Nodes Plant
│       ├── NodeDefinitionLibrary.asset
│       └── Node_000_Seed.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   └── ThoughtTrigger.cs
│   │   └── Plants
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── UI
│   └── Visuals
│       └── NightColorPostProcess.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   └── BezierCurveAA.shader
├── Test
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeCell.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
// Remove IPointerClickHandler interface from here
// Keep IDropHandler for dropping onto the cell background
public class NodeCell : MonoBehaviour, IPointerClickHandler, IDropHandler // Keep IPointerClickHandler for RIGHT click on empty
{
    public static NodeCell CurrentlySelectedCell { get; private set; }
    public int CellIndex { get; private set; }

    private NodeEditorGridController _controller;
    private NodeData _nodeData;
    private NodeView _nodeView;
    private Image _backgroundImage;

    // --- Init remains the same ---
    public void Init(int index, NodeEditorGridController gridController, Image bgImage)
    {
        CellIndex = index;
        _controller = gridController;
        _backgroundImage = bgImage;

        if (_backgroundImage != null && _controller != null)
        {
            _backgroundImage.color = _controller.EmptyCellColor;
            _backgroundImage.enabled = true;
        }
    }

    // --- HasNode, Getters remain the same ---
    public bool HasNode() => _nodeData != null && _nodeView != null;
    public NodeData GetNodeData() => _nodeData;
    public NodeView GetNodeView() => _nodeView;

    // --- AssignNode, AssignNodeView remain the same ---
     public void AssignNode(NodeDefinition def)
    {
        if (def == null || _controller == null) return;
        RemoveNode();

        _nodeData = new NodeData() { /* ... data setup ... */
            nodeId = System.Guid.NewGuid().ToString(),
            nodeDisplayName = def.displayName,
            effects = def.CloneEffects(),
            orderIndex = this.CellIndex
        };

        GameObject prefabToInstantiate = def.nodeViewPrefab != null ? def.nodeViewPrefab : _controller.NodeViewPrefab;
        if (prefabToInstantiate == null) { /* ... error handling ... */ Debug.LogError($"..."); _nodeData = null; return; }

        GameObject nodeViewGO = Instantiate(prefabToInstantiate, transform);
        _nodeView = nodeViewGO.GetComponent<NodeView>();
        if (_nodeView == null) { /* ... error handling ... */ Debug.LogError($"..."); Destroy(nodeViewGO); _nodeData = null; return; }

        _nodeView.Initialize(_nodeData, def, _controller); // Init NodeView

        NodeDraggable draggable = _nodeView.GetComponent<NodeDraggable>();
        if (draggable == null) draggable = _nodeView.gameObject.AddComponent<NodeDraggable>();
        draggable.Initialize(_controller, this); // Init Draggable

        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }
     public void AssignNodeView(NodeView view, NodeData data)
    {
         RemoveNode();
         _nodeView = view;
         _nodeData = data;
         if (_nodeView != null) {
             _nodeView.transform.SetParent(transform, false);
             if (_nodeData != null) _nodeData.orderIndex = this.CellIndex;
             // Parent ref will be updated by NodeDraggable.SnapToCell which calls NodeView.UpdateParent...
         }
         if(_backgroundImage != null) _backgroundImage.enabled = true;
    }


    // --- RemoveNode, ClearNodeReference remain the same ---
    public void RemoveNode()
    {
        bool wasSelected = (CurrentlySelectedCell == this);
        if (_nodeView != null) {
            if (wasSelected) {
                 _nodeView.Unhighlight();
                 CurrentlySelectedCell = null;
            }
            Destroy(_nodeView.gameObject);
        }
        _nodeView = null; _nodeData = null;
        if (wasSelected && CurrentlySelectedCell == this) CurrentlySelectedCell = null;
        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }
     public void ClearNodeReference()
    {
        _nodeView = null; _nodeData = null;
        if(_backgroundImage != null) _backgroundImage.enabled = true;
    }

    // --- Selection Handling (SelectCell, ClearSelection) remains the same ---
     public static void SelectCell(NodeCell cellToSelect)
    {
        if (cellToSelect == null || !cellToSelect.HasNode()) { ClearSelection(); return; }
        if (CurrentlySelectedCell == cellToSelect) return;
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Unhighlight();
        }
        CurrentlySelectedCell = cellToSelect;
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Highlight();
        }
    }
     public static void ClearSelection()
    {
        if (CurrentlySelectedCell != null && CurrentlySelectedCell.GetNodeView() != null) {
            CurrentlySelectedCell.GetNodeView().Unhighlight();
        }
        CurrentlySelectedCell = null;
    }

    // --- Event Handlers UPDATED ---

    /// <summary>
    /// Handles clicks on the CELL BACKGROUND image.
    /// Left Click: Does nothing (NodeView handles selection).
    /// Right Click: Opens add node menu ONLY if the cell is currently empty.
    /// </summary>
    public void OnPointerClick(PointerEventData eventData)
    {
        // This click is on the NodeCell's background image

        if (eventData.button == PointerEventData.InputButton.Right)
        {
            // Right Click: Only allow opening the dropdown if the cell is currently EMPTY.
            if (!HasNode())
            {
                // Debug.Log($"NodeCell Background Clicked (Right) on Empty Cell {CellIndex}. Opening dropdown.");
                ClearSelection(); // Clear selection before showing add menu
                _controller?.OnEmptyCellRightClicked(this, eventData);
            }
            // If right-clicking the background of an occupied cell, do nothing.
        }
        // Left click on the background does nothing regarding selection now.
    }


    // --- OnDrop remains the same ---
    public void OnDrop(PointerEventData eventData)
    {
        GameObject draggedObject = eventData.pointerDrag;
        if (draggedObject != null) {
            NodeDraggable draggedNode = draggedObject.GetComponent<NodeDraggable>();
            if (draggedNode != null && _controller != null) {
                 _controller.HandleNodeDrop(draggedNode, draggedNode.OriginalCell, eventData.position);
            }
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeDraggable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
public class NodeDraggable : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
    private RectTransform _rectTransform;
    private CanvasGroup _canvasGroup;
    private Vector2 _originalAnchoredPosition;
    private Transform _originalParent;
    private NodeCell _originalCell;
    private NodeEditorGridController _gridController;
    private Canvas _rootCanvas;

    // No _isDragging flag needed if managed carefully by events

    public NodeCell OriginalCell => _originalCell;

    void Awake()
    {
        _rectTransform = GetComponent<RectTransform>();
        _canvasGroup = GetComponent<CanvasGroup>();
        if (_canvasGroup == null)
        {
            _canvasGroup = gameObject.AddComponent<CanvasGroup>();
        }
        // CRITICAL: Default state MUST allow interactions (clicks, hovers)
        _canvasGroup.blocksRaycasts = true;
        _canvasGroup.alpha = 1f; // Ensure fully visible
    }

    public void Initialize(NodeEditorGridController controller, NodeCell startingCell)
    {
        _gridController = controller;
        _originalCell = startingCell;
        _rootCanvas = GetComponentInParent<Canvas>()?.rootCanvas;
        if (_rootCanvas == null) Debug.LogError("[NodeDraggable] Could not find root Canvas!");

        // Ensure initial state after initialization
        if (_canvasGroup != null) {
             _canvasGroup.blocksRaycasts = true;
             _canvasGroup.alpha = 1f;
        }
    }

    public void OnBeginDrag(PointerEventData eventData)
    {
        if (eventData.button != PointerEventData.InputButton.Left) return;
        if (_gridController == null || _rootCanvas == null) return;

        _originalParent = transform.parent;
        _originalCell = _originalParent?.GetComponent<NodeCell>();
        _originalAnchoredPosition = _rectTransform.anchoredPosition;

        // Become transparent and STOP blocking raycasts so underlying cells can be detected
        _canvasGroup.alpha = 0.6f;
        _canvasGroup.blocksRaycasts = false;

        // Reparent for top rendering
        transform.SetParent(_rootCanvas.transform, true);
        transform.SetAsLastSibling();
         // Debug.Log($"[NodeDraggable OnBeginDrag] Started drag. blocksRaycasts: {_canvasGroup.blocksRaycasts}", gameObject);
    }

    public void OnDrag(PointerEventData eventData)
    {
        // Only process drag if it's the left button and dragging is conceptually active (raycasts blocked)
        if (eventData.button != PointerEventData.InputButton.Left || _canvasGroup == null || _canvasGroup.blocksRaycasts) return;
        if (_gridController == null || _rootCanvas == null) return;

        // Move logic (unchanged)
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
             _rootCanvas.transform as RectTransform, eventData.position,
             _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera, out Vector2 currentLocalPoint);
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
            _rootCanvas.transform as RectTransform, eventData.position - eventData.delta,
            _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera, out Vector2 previousLocalPoint);
        Vector2 localDelta = currentLocalPoint - previousLocalPoint;
        _rectTransform.localPosition += (Vector3)localDelta;
    }

    public void OnEndDrag(PointerEventData eventData)
    {
         // Debug.Log($"[NodeDraggable OnEndDrag] Drag ended. Button: {eventData.button}", gameObject);

        // Ensure visuals and raycast blocking are reset REGARDLESS of button, BEFORE handling drop
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true; // CRITICAL: Re-enable raycasts immediately
             // Debug.Log($"--> Reset alpha and blocksRaycasts to: {_canvasGroup.blocksRaycasts}");
        }

        // Only handle the drop logic if the drag was initiated by the left button
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            if (_gridController != null) {
                _gridController.HandleNodeDrop(this, _originalCell, eventData.position);
            } else {
                 // No controller, attempt reset
                 ResetPosition();
            }
        }
        else
        {
             // If drag ended via another button (unlikely but possible), ensure reset
             ResetPosition();
        }
    }

    public void ResetPosition()
    {
        // Debug.Log($"[NodeDraggable ResetPosition] Resetting {gameObject.name}", gameObject);
        // Reset parent and position
        transform.SetParent(_originalParent, false);
        _rectTransform.anchoredPosition = _originalAnchoredPosition;
        _originalCell = _originalParent?.GetComponent<NodeCell>(); // Update cell ref

        // Ensure visuals and raycasts are correct after reset
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
        }

        // Update parent cell reference on the NodeView
        NodeView view = GetComponent<NodeView>();
        view?.UpdateParentCellReference();
    }

    public void SnapToCell(NodeCell targetCell)
    {
        // Debug.Log($"[NodeDraggable SnapToCell] Snapping {gameObject.name} to Cell {targetCell?.CellIndex}", gameObject);
        if (targetCell == null) { ResetPosition(); return; }

        // Set Parent and Position
        transform.SetParent(targetCell.transform, false);
        _rectTransform.anchoredPosition = Vector2.zero;

        // Update Internal Draggable References
        _originalParent = targetCell.transform;
        _originalCell = targetCell;
        _originalAnchoredPosition = Vector2.zero;

        // Ensure visuals and raycasts are correct after snap
        if (_canvasGroup != null) {
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
        }

        // Update the NodeView's parent reference
        NodeView view = GetComponent<NodeView>();
        view?.UpdateParentCellReference();
    }

    // OnDisable might not be strictly needed now but can be kept as safety
    void OnDisable()
    {
        // If it was disabled mid-drag (blocksRaycasts == false), reset state
        if (_canvasGroup != null && !_canvasGroup.blocksRaycasts)
        {
             Debug.LogWarning($"[NodeDraggable] Disabled while dragging {gameObject.name}. Resetting CanvasGroup.", gameObject);
            _canvasGroup.alpha = 1f;
            _canvasGroup.blocksRaycasts = true;
            // Resetting position might be desired but complex here, ensure visuals are ok.
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeEditorGridController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using TMPro;
using System.Linq;

[RequireComponent(typeof(RectTransform))]
public class NodeEditorGridController : MonoBehaviour
{
    public static NodeEditorGridController Instance { get; private set; }

    [Header("Grid Layout & Appearance")]
    [SerializeField][Min(1)] private int emptyCellsCount = 8;
    [SerializeField] private Vector2 cellSize = new Vector2(64f, 64f);
    [SerializeField] private float cellMargin = 10f;

    [Header("Empty Cell Visuals")]
    [SerializeField] private Sprite emptyCellSprite;
    [SerializeField] private Color emptyCellColor = Color.white;
    [SerializeField] private Vector3 emptyCellScale = Vector3.one;

    [Header("Node Visuals")]
    [SerializeField] private GameObject nodeViewPrefab;
    [SerializeField] private Vector3 nodeImageScale = Vector3.one;
    [SerializeField] private Color selectedNodeBackgroundColor = new Color(0.9f, 0.9f, 0.7f, 1f);

    [Header("Node Definitions & Interaction")]
    [SerializeField] private NodeDefinitionLibrary definitionLibrary;
    [SerializeField] private TMP_Dropdown nodeDropdown;

    // REMOVED: The direct reference to NodeExecutor is no longer needed here.
    // The NodeExecutor script will find this controller via Instance or assignment.
    // [Header("Execution")]
    // [SerializeField] private NodeExecutor nodeExecutor;

    [Header("UI Toggle")]
    [SerializeField] private GameObject gridUIParent;


    private List<NodeCell> nodeCells = new List<NodeCell>();
    private RectTransform _rectTransform;
    private Canvas _rootCanvas;
    private NodeGraph _uiGraphRepresentation = new NodeGraph(); // Internal storage


    public GameObject NodeViewPrefab => nodeViewPrefab;
    public Vector3 NodeImageScale => nodeImageScale;
    public NodeDefinitionLibrary DefinitionLibrary => definitionLibrary;
    public Color SelectedNodeBackgroundColor => selectedNodeBackgroundColor;
    public Color EmptyCellColor => emptyCellColor;
    public NodeGraph GetCurrentUIGraph() => _uiGraphRepresentation; // Public getter for NodeExecutor


    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        _rectTransform = GetComponent<RectTransform>();
        _rootCanvas = GetComponentInParent<Canvas>();
        if (_rootCanvas == null) Debug.LogError("...");
        if (gridUIParent == null) Debug.LogWarning("...");
    }

    void OnDestroy()
    {
        if (Instance == this) Instance = null;
    }

    void Start()
    {
        if (nodeDropdown != null) nodeDropdown.gameObject.SetActive(false);
        else Debug.LogWarning("...");
        if (definitionLibrary == null) Debug.LogError("...");

        CreateCells();
        RefreshGraph();
    }

    private void CreateCells()
    {
        foreach (Transform child in transform) { if (child.gameObject != this.gameObject && child.GetComponent<NodeEditorGridController>() == null) Destroy(child.gameObject); }
        nodeCells.Clear();
        NodeCell.ClearSelection();

        float totalWidth = (emptyCellsCount * cellSize.x) + ((emptyCellsCount - 1) * cellMargin);
        float startX = -(totalWidth / 2f);
        float startY = -(cellSize.y / 2f);

        for (int i = 0; i < emptyCellsCount; i++)
        {
            GameObject cellGO = new GameObject($"Cell_{i}");
            RectTransform rt = cellGO.AddComponent<RectTransform>();
            cellGO.transform.SetParent(transform, false);
            rt.sizeDelta = cellSize;
            rt.anchorMin = new Vector2(0.5f, 0.5f); rt.anchorMax = new Vector2(0.5f, 0.5f);
            rt.pivot = new Vector2(0f, 0f); // Using bottom-left pivot
            float xPos = startX + i * (cellSize.x + cellMargin);
            float yPos = startY;
            rt.anchoredPosition = new Vector2(xPos, yPos);

            Image cellImage = cellGO.AddComponent<Image>();
            cellImage.sprite = emptyCellSprite;
            cellImage.color = emptyCellColor;
            cellImage.raycastTarget = true;
            // rt.localScale = emptyCellScale; // Keep commented out

            NodeCell cellLogic = cellGO.AddComponent<NodeCell>();
            cellLogic.Init(i, this, cellImage);
            nodeCells.Add(cellLogic);
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Tab)) ToggleGridUI();
        if (Input.GetKeyDown(KeyCode.Delete)) { if (NodeCell.CurrentlySelectedCell != null) { NodeCell selected = NodeCell.CurrentlySelectedCell; selected.RemoveNode(); RefreshGraph(); } }
        if (Input.GetKeyDown(KeyCode.Escape)) { if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) HideDropdown(); }
    }

    public void ToggleGridUI()
    {
        if (gridUIParent != null) { bool currentState = gridUIParent.activeSelf; gridUIParent.SetActive(!currentState); if (!gridUIParent.activeSelf && nodeDropdown != null && nodeDropdown.gameObject.activeSelf) HideDropdown(); if (!gridUIParent.activeSelf) NodeCell.ClearSelection(); }
        else Debug.LogWarning("...");
    }

    public void OnEmptyCellRightClicked(NodeCell cell, PointerEventData eventData)
    {
        if (nodeDropdown == null) { Debug.LogError("..."); return; }
        if (definitionLibrary == null || definitionLibrary.definitions == null) { Debug.LogError("..."); return; }

        StopCoroutine("ShowDropdownCoroutine");
        StartCoroutine(ShowDropdownCoroutine(cell, eventData));
    }

    private IEnumerator ShowDropdownCoroutine(NodeCell cell, PointerEventData eventData)
    {
        // Build Options
        List<TMP_Dropdown.OptionData> options = new List<TMP_Dropdown.OptionData>();
        options.Add(new TMP_Dropdown.OptionData("Select Node..."));
        var sortedDefinitions = definitionLibrary.definitions.Where(def => def != null).OrderBy(def => def.displayName).ToList();
        foreach (var def in sortedDefinitions) { TMP_Dropdown.OptionData option = new TMP_Dropdown.OptionData(); option.text = def.displayName; option.image = def.thumbnail; options.Add(option); }
        nodeDropdown.ClearOptions(); nodeDropdown.AddOptions(options);

        // Setup Listener
        nodeDropdown.onValueChanged.RemoveAllListeners();
        nodeDropdown.onValueChanged.AddListener((selectedIndex) => { OnDropdownValueChanged(selectedIndex, cell, sortedDefinitions); });

        // Position
        RectTransform dropdownRect = nodeDropdown.GetComponent<RectTransform>();
        RectTransformUtility.ScreenPointToLocalPointInRectangle(dropdownRect.parent as RectTransform, eventData.position, _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera, out Vector2 localPos);
        dropdownRect.localPosition = localPos;

        // Activate
        if (!nodeDropdown.gameObject.activeSelf) nodeDropdown.gameObject.SetActive(true);

        // Wait
        yield return null;

        // Show
        try {
            if (nodeDropdown.template == null) { Debug.LogError("..."); HideDropdown(); yield break; }
            nodeDropdown.Show();
        } catch (System.NullReferenceException nre) { Debug.LogError($"... NRE Show() ... {nre.Message}", nodeDropdown.gameObject); HideDropdown(); yield break; }

        nodeDropdown.value = 0; nodeDropdown.RefreshShownValue();
    }


    private void OnDropdownValueChanged(int selectedIndex, NodeCell targetCell, List<NodeDefinition> sortedDefs)
    {
        HideDropdown();

        if (selectedIndex > 0) {
            int definitionIndex = selectedIndex - 1;
            if (definitionIndex >= 0 && definitionIndex < sortedDefs.Count) {
                NodeDefinition selectedDef = sortedDefs[definitionIndex];
                targetCell.AssignNode(selectedDef);
                NodeCell.SelectCell(targetCell);
                RefreshGraph(); // Refresh UI graph representation
            }
        }
    }

    public void HideDropdown()
    {
        if (nodeDropdown != null && nodeDropdown.gameObject.activeSelf) nodeDropdown.gameObject.SetActive(false);
    }


    public void RefreshGraph()
    {
        if (_uiGraphRepresentation == null) _uiGraphRepresentation = new NodeGraph();
        _uiGraphRepresentation.nodes.Clear();
        foreach (var cell in nodeCells.OrderBy(c => c.CellIndex))
        {
            NodeData data = cell.GetNodeData();
            if (data != null)
            {
                data.orderIndex = cell.CellIndex;
                _uiGraphRepresentation.nodes.Add(data);
            }
        }
    }


    public bool HandleNodeDrop(NodeDraggable draggedDraggable, NodeCell originalCell, Vector2 screenPosition)
    {
        NodeCell targetCell = FindCellAtScreenPosition(screenPosition);
        bool changed = false;

        if (targetCell != null && originalCell != null)
        {
            NodeView draggedView = draggedDraggable.GetComponent<NodeView>();
            NodeData draggedData = draggedView?.GetNodeData();

            if (draggedView == null || draggedData == null) { draggedDraggable.ResetPosition(); return false; }
            if (targetCell == originalCell) { draggedDraggable.ResetPosition(); NodeCell.SelectCell(targetCell); return true; }

            NodeView existingViewInTarget = targetCell.GetNodeView();
            NodeData existingDataInTarget = targetCell.GetNodeData();

            NodeCell.ClearSelection();
            originalCell.ClearNodeReference();

            if (existingViewInTarget != null && existingDataInTarget != null)
            {
                NodeDraggable existingDraggable = existingViewInTarget.GetComponent<NodeDraggable>();
                originalCell.AssignNodeView(existingViewInTarget, existingDataInTarget);
                if (existingDraggable != null) existingDraggable.SnapToCell(originalCell);
            }

            targetCell.AssignNodeView(draggedView, draggedData);
            draggedDraggable.SnapToCell(targetCell);

            NodeCell.SelectCell(targetCell);
            changed = true;
        }
        else
        {
            draggedDraggable.ResetPosition();
            if (originalCell != null && originalCell.HasNode()) { NodeCell.SelectCell(originalCell); }
            else { NodeCell.ClearSelection(); }
        }

        if (changed) RefreshGraph(); // Refresh UI graph representation

        return changed;
    }


    private NodeCell FindCellAtScreenPosition(Vector2 screenPosition)
    {
        NodeCell foundCell = null;
        foreach (var cell in nodeCells)
        {
            RectTransform cellRect = cell.GetComponent<RectTransform>();
            bool contains = RectTransformUtility.RectangleContainsScreenPoint(cellRect, screenPosition, _rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _rootCanvas.worldCamera );
            if (contains) { foundCell = cell; break; }
        }
        return foundCell;
    }


     #if UNITY_EDITOR
     void OnDrawGizmos()
     {
         if (!Application.isPlaying && TryGetComponent<RectTransform>(out var rt))
         {
             Gizmos.color = new Color(0f, 1f, 0f, 0.5f);
             Vector3 center = rt.position;
             float totalWidth = (emptyCellsCount * cellSize.x) + ((emptyCellsCount - 1) * cellMargin);
             float startX_for_gizmo;
             if(rt.pivot == Vector2.zero) startX_for_gizmo = -(totalWidth / 2f) + (cellSize.x / 2f);
             else startX_for_gizmo = -(totalWidth / 2f) + (cellSize.x / 2f);

             for (int i = 0; i < emptyCellsCount; i++)
             {
                 float xOffset = startX_for_gizmo + i * (cellSize.x + cellMargin);
                 Vector3 cellCenterWorld = center + (Vector3)(rt.rotation * new Vector3(xOffset * rt.lossyScale.x, 0, 0) );
                 Vector3 gizmoSize = new Vector3(cellSize.x * rt.lossyScale.x, cellSize.y * rt.lossyScale.y, 0.1f);
                 Matrix4x4 rotationMatrix = Matrix4x4.TRS(cellCenterWorld, rt.rotation, Vector3.one);
                 Gizmos.matrix = rotationMatrix;
                 Gizmos.DrawWireCube(Vector3.zero, gizmoSize);
                 Gizmos.matrix = Matrix4x4.identity;
             }
         }
     }
     #endif
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeSelectable.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.EventSystems;

public class NodeSelectable : MonoBehaviour, IPointerClickHandler
{
    public static GameObject CurrentSelected { get; set; }

    public void OnPointerClick(PointerEventData eventData)
    {
        Select(gameObject);
    }

    public static void Select(GameObject node)
    {
        if (CurrentSelected != null && CurrentSelected != node)
        {
            // (Optional) Remove highlight from previously selected node.
        }
        CurrentSelected = node;
        // (Optional) Add highlight effect here.
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Nodes\UI\NodeView.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.EventSystems;
using System.Collections.Generic;
using System.Text;

[RequireComponent(typeof(RectTransform))]
public class NodeView : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler
{
    // --- Fields remain the same ---
    [Header("UI Elements (Assign in Prefab)")]
    [SerializeField] private Image thumbnailImage;
    [SerializeField] private Image backgroundImage;
    [SerializeField] private GameObject tooltipPanel;
    [SerializeField] private TMP_Text tooltipText;
    [SerializeField] private TMP_Text nodeNameText;
    [Header("Configuration")]
    [SerializeField] private bool displayNodeName = false;

    private NodeData _nodeData;
    private NodeDefinition _nodeDefinition;
    private NodeEditorGridController _controller;
    private NodeCell _parentCell;
    private Color _originalBackgroundColor;

    // --- Initialize, UpdateParentCellReference, Getters, Highlight, Unhighlight remain the same ---
     public void Initialize(NodeData data, NodeDefinition definition, NodeEditorGridController controller)
    { /* ... as before ... */
         _nodeData = data; _nodeDefinition = definition; _controller = controller;
         UpdateParentCellReference();
         if (_nodeData == null || _nodeDefinition == null || _controller == null || _parentCell == null) { gameObject.SetActive(false); return; }
         if (thumbnailImage != null) { thumbnailImage.sprite = _nodeDefinition.thumbnail; thumbnailImage.color = _nodeDefinition.thumbnailTintColor; thumbnailImage.rectTransform.localScale = _controller.NodeImageScale; thumbnailImage.enabled = (thumbnailImage.sprite != null); if (!thumbnailImage.raycastTarget) thumbnailImage.raycastTarget = true; }
         if (backgroundImage != null) { _originalBackgroundColor = _nodeDefinition.backgroundColor; backgroundImage.color = _originalBackgroundColor; backgroundImage.enabled = true; if (!backgroundImage.raycastTarget) backgroundImage.raycastTarget = true; }
         if (tooltipPanel != null) tooltipPanel.SetActive(false);
         if (nodeNameText != null) { nodeNameText.text = _nodeData.nodeDisplayName; nodeNameText.gameObject.SetActive(displayNodeName); }
    }
     public void UpdateParentCellReference() { _parentCell = GetComponentInParent<NodeCell>(); /* ... null check ... */ }
     public NodeData GetNodeData() => _nodeData;
     public NodeDefinition GetNodeDefinition() => _nodeDefinition;
     public NodeCell GetParentCell() => _parentCell;
     public void Highlight() { if (backgroundImage != null && _controller != null) backgroundImage.color = _controller.SelectedNodeBackgroundColor; }
     public void Unhighlight() { if (backgroundImage != null) backgroundImage.color = _originalBackgroundColor; }


    // --- Tooltip Handling with Logging ---
    public void OnPointerEnter(PointerEventData eventData)
    {
        // --- Add Log ---
        Debug.Log($"[NodeView OnPointerEnter] Fired on {gameObject.name}. Tooltip Panel assigned: {tooltipPanel != null}", gameObject);

        // Ensure the CanvasGroup allows raycasts IF it exists
        CanvasGroup cg = GetComponent<CanvasGroup>();
        if (cg != null && cg.blocksRaycasts == false)
        {
             Debug.LogWarning($"--> PointerEnter detected but CanvasGroup is blocking raycasts! Drag state might be stuck?", gameObject);
             // Optionally force it: cg.blocksRaycasts = true;
        }


        if (tooltipPanel != null && tooltipText != null && _nodeDefinition != null && _nodeData != null)
        {
            // --- Add Log ---
            // Debug.Log("--> Activating Tooltip Panel");
            tooltipPanel.SetActive(true);
            tooltipText.text = BuildTooltipString();
        }
         else if (tooltipPanel == null) {
             // Debug.LogWarning("--> Tooltip Panel is not assigned in Inspector.", gameObject);
         }
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        // --- Add Log ---
        // Debug.Log($"[NodeView OnPointerExit] Fired on {gameObject.name}", gameObject);

        if (tooltipPanel != null)
        {
             // Debug.Log("--> Deactivating Tooltip Panel");
            tooltipPanel.SetActive(false);
        }
    }

    // --- Pointer Down remains the same ---
    public void OnPointerDown(PointerEventData eventData) { /* ... as before ... */
         // Debug.Log($"[NodeView OnPointerDown] Fired on: {gameObject.name} in Cell: {_parentCell?.CellIndex} | Button: {eventData.button}", gameObject);
        if (eventData.button == PointerEventData.InputButton.Left) {
            if (_parentCell != null) {
                 // Debug.Log($"--> Left Click Confirmed. Requesting SelectCell for {_parentCell.CellIndex}");
                NodeCell.SelectCell(_parentCell);
            } else { UpdateParentCellReference(); if (_parentCell != null) NodeCell.SelectCell(_parentCell); else Debug.LogError("[NodeView] ParentCell null on PointerDown!", gameObject); }
        }
    }

    // --- BuildTooltipString remains the same ---
    private string BuildTooltipString() { /* ... as before ... */
         StringBuilder sb = new StringBuilder(); sb.Append("<b>").Append(_nodeData.nodeDisplayName).Append("</b>\n"); if (!string.IsNullOrEmpty(_nodeDefinition.description)) sb.Append(_nodeDefinition.description).Append("\n"); if (_nodeData.effects != null && _nodeData.effects.Count > 0) { sb.Append("<i>Effects:</i>\n"); foreach (var eff in _nodeData.effects) { sb.Append("- ").Append(eff.effectType.ToString()).Append(": "); sb.Append(eff.primaryValue.ToString("G3")); if (eff.secondaryValue != 0) sb.Append(" / ").Append(eff.secondaryValue.ToString("G3")); sb.Append("\n"); } } return sb.ToString().TrimEnd();
     }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Player\GardenerController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class GardenerController : MonoBehaviour
{
    [Header("Movement Settings")]
    public float moveSpeed = 5f;
    
    [Header("Planting Settings")]
    public Vector2 seedPlantingOffset = new Vector2(0f, -0.5f); // Configurable offset for seed planting

    [Header("Visual Settings")]
    [Tooltip("If true, the sprite will be flipped when moving left")]
    public bool flipSpriteWhenMovingLeft = true;
    [Tooltip("If true, the character will face the opposite direction when flipped")]
    public bool flipHorizontalDirection = true;

    [Header("Animation Settings")]
    [Tooltip("Set to false to disable animations")]
    public bool useAnimations = true;
    public string runningParameterName = "isRunning";
    public string plantingParameterName = "isPlanting";
    [Tooltip("Should match your planting animation length exactly")]
    public float plantingDuration = 0.25f; // UPDATED to match your 0.25s animation


    
    // Private references
    private Rigidbody2D rb;
    private Vector2 movement;
    private SortableEntity sortableEntity;
    private SpriteRenderer spriteRenderer;
    private Animator animator;
    // Private variables
    private bool isPlanting = false;
    private float plantingTimer = 0f;
    private bool wasMovingBeforePlanting = false;

    private void Awake()
    {
        // Get required components
        rb = GetComponent<Rigidbody2D>();
        sortableEntity = GetComponent<SortableEntity>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        animator = GetComponent<Animator>();
        
        // Add SortableEntity if not already present
        if (sortableEntity == null)
            sortableEntity = gameObject.AddComponent<SortableEntity>();
            
        // Warn if sprite renderer is missing
        if (spriteRenderer == null)
            Debug.LogWarning("GardenerController: SpriteRenderer component not found. Sprite flipping won't work.");
            
        // Warn if animator is missing but animations are enabled
        if (animator == null && useAnimations)
            Debug.LogWarning("GardenerController: Animator component not found but useAnimations is true.");
    }

    private void Update()
    {
        // Handle movement input and planting action
        if (!isPlanting)
        {
            movement.x = Input.GetAxisRaw("Horizontal");
            movement.y = Input.GetAxisRaw("Vertical");
        
            // Check if we're moving (store for later)
            bool isMoving = movement.sqrMagnitude > 0.01f;
        
            // Handle planting action
            if (Input.GetKeyDown(KeyCode.Space))
            {
                // Store movement state before planting
                wasMovingBeforePlanting = isMoving;
                StartPlantingAnimation();
            }
        }
        else
        {
            // When planting, we don't accept movement input
            movement = Vector2.zero;
        
            // Handle planting timer
            plantingTimer -= Time.deltaTime;
            if (plantingTimer <= 0)
            {
                EndPlantingAnimation();
            }
        }
    
        // Update animations after all state changes are processed
        UpdateAnimations();
    
        // Handle sprite flipping based on movement direction
        UpdateSpriteDirection();
    }

    private void FixedUpdate()
    {
        // Only move if not planting
        if (!isPlanting)
        {
            rb.MovePosition(rb.position + movement.normalized * moveSpeed * Time.fixedDeltaTime);
        }
    }
    
    // Update character animations based on state
    private void UpdateAnimations()
    {
        if (!useAnimations || animator == null) return;
    
        // Set running animation parameter
        bool isMoving = movement.sqrMagnitude > 0.01f;
        animator.SetBool(runningParameterName, isMoving);
    }
    
    // Update sprite direction based on movement
    private void UpdateSpriteDirection()
    {
        if (spriteRenderer == null || !flipSpriteWhenMovingLeft) return;
        
        if (movement.x != 0)
        {
            // Only flip if moving horizontally
            bool shouldFlip = (movement.x < 0);
            
            // Apply flipping logic based on settings
            if (flipHorizontalDirection)
            {
                spriteRenderer.flipX = shouldFlip;
            }
            else
            {
                // Alternative approach: flip the entire transform
                // This is useful if the sprite is already facing left initially
                Vector3 scale = transform.localScale;
                scale.x = shouldFlip ? -Mathf.Abs(scale.x) : Mathf.Abs(scale.x);
                transform.localScale = scale;
            }
        }
    }
    
    // Start planting animation and process
    public void StartPlantingAnimation()
    {
        if (!useAnimations || isPlanting) return;
    
        isPlanting = true;
        plantingTimer = plantingDuration;
    
        // Set animation parameters
        if (animator != null)
        {
            // Set planting to true and ensure running is false
            animator.SetBool(plantingParameterName, true);
            animator.SetBool(runningParameterName, false);
        }
    }
    
    // End planting animation and resume normal control
    
    private void EndPlantingAnimation()
    {
        // Reset planting state
        isPlanting = false;
    
        // Reset animation parameters
        if (animator != null)
        {
            animator.SetBool(plantingParameterName, false);
        
            // Important: don't immediately set isRunning based on current movement
            // because movement is zero during planting. Instead:
            if (wasMovingBeforePlanting && (Input.GetAxisRaw("Horizontal") != 0 || Input.GetAxisRaw("Vertical") != 0))
            {
                // Only resume running if we were running before AND still have directional input
                animator.SetBool(runningParameterName, true);
            }
        }
    
        // Now update movement based on current input
        movement.x = Input.GetAxisRaw("Horizontal");
        movement.y = Input.GetAxisRaw("Vertical");
    }
    
    // Returns the position used for planting seeds, now with configurable offset
    public Vector2 GetPlantingPosition()
    {
        return (Vector2)transform.position + seedPlantingOffset;
    }
    
    // Public method to set planting animation duration
    public void SetPlantingDuration(float duration)
    {
        plantingDuration = Mathf.Max(0.1f, duration); // Ensure minimum duration
    }
    
    // Public method to trigger planting animation from other scripts
    public void Plant()
    {
        StartPlantingAnimation();
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visuals\NightColorPostProcess.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class NightColorPostProcess : MonoBehaviour
{
    [Header("References")]
    public WeatherManager weatherManager;        // Assign your existing WeatherManager
    public Volume globalVolume;                  // The Volume with the Color Adjustments override

    private ColorAdjustments colorAdjustments;   // We'll read/write color filter, post exposure, and saturation

    [Header("Color Settings")]
    [Tooltip("The color filter at full day (sunIntensity = 1).")]
    public Color dayColorFilter = Color.white;
    [Tooltip("The color filter at full night (sunIntensity ~ 0).")]
    public Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);

    [Tooltip("Daytime Post-Exposure (e.g. 0). Higher = brighter.")]
    public float dayPostExposure = 0f;
    [Tooltip("Nighttime Post-Exposure (e.g. -0.5). Lower = darker.")]
    public float nightPostExposure = -0.5f;

    [Header("Saturation Settings")]
    [Tooltip("Saturation at full day (0 means no change).")]
    public float daySaturation = 0f;
    [Tooltip("Saturation at full night (e.g. -50 for more desaturation at night).")]
    public float nightSaturation = -50f;

    private void Start()
    {
        if (!globalVolume)
        {
            Debug.LogWarning("[NightColorPostProcess] No globalVolume assigned!");
            return;
        }

        // Try to get the ColorAdjustments override from the volume's profile
        if (globalVolume.profile.TryGet<ColorAdjustments>(out var colorAdj))
        {
            colorAdjustments = colorAdj;
        }
        else
        {
            Debug.LogWarning("[NightColorPostProcess] No ColorAdjustments override found in the Volume profile!");
        }
    }

    private void Update()
    {
        if (!weatherManager || colorAdjustments == null)
            return;
        
        // Get the sun intensity (0 = night, 1 = day)
        float sun = Mathf.Clamp01(weatherManager.sunIntensity);
        float t = 1f - sun;  // t=0 at day, t=1 at night
        
        // Lerp the color filter
        Color finalFilter = Color.Lerp(dayColorFilter, nightColorFilter, t);
        colorAdjustments.colorFilter.value = finalFilter;
        
        // Lerp post exposure
        float finalExposure = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
        colorAdjustments.postExposure.value = finalExposure;
        
        // Lerp saturation
        float finalSaturation = Mathf.Lerp(daySaturation, nightSaturation, t);
        colorAdjustments.saturation.value = finalSaturation;
    }
}







--------------------------------------------------------------------------------
This is the final part (3 of 3).
--------------------------------------------------------------------------------