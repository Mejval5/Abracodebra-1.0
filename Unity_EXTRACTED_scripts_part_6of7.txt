This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-05-19 01:01:18
PART 6 OF 7
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantOutline.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           ├── DualGridRuleTile_Grass.asset
│           └── DualGridRuleTile_Water.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_PoopFertilizer.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       └── Wave_001.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── LeafData.cs
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.Cell.cs
│   │   │   ├── PlantGrowth.Growth.cs
│   │   │   ├── PlantGrowth.NodeExecution.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManagement.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── OutlinePartController.cs
│       ├── PlantOutlineController.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       └── ShadowPartController.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   └── SpriteEmissiveUnlit.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlantPlacementManagement.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

public class PlantPlacementManager : MonoBehaviour
{
    public static PlantPlacementManager Instance { get; private set; }

    [Header("References")]
    [SerializeField] private GameObject plantPrefab;
    [SerializeField] private NodeEditorGridController nodeEditorGrid;
    [SerializeField] private Transform plantParent;
    [SerializeField] private TileInteractionManager tileInteractionManager;
    [SerializeField] private PlantGrowthModifierManager growthModifierManager;

    [Header("Planting Settings")]
    [Tooltip("Maximum radius from cell center for random seed placement (in units)")]
    [SerializeField] private float spawnRadius = 0.25f;
    
    [Tooltip("Increment for position randomization (in pixels, for pixel-perfect placement)")]
    [SerializeField] private float spawnRadiusIncrement = 4f;

    [Header("Tile Restrictions")]
    [Tooltip("List of tiles that cannot be planted on")]
    [SerializeField] private List<TileDefinition> invalidPlantingTiles = new List<TileDefinition>();

    [Header("Debug")]
    [SerializeField] private bool showDebugMessages = true;
    
    // Cache for quick lookup of invalid tiles
    private HashSet<TileDefinition> invalidTilesSet = new HashSet<TileDefinition>();
    
    // Dictionary to track plant positions (using grid cell positions as keys)
    private Dictionary<Vector3Int, GameObject> plantsByGridPosition = new Dictionary<Vector3Int, GameObject>();
    
    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        
        // Build the set of invalid tiles for faster lookup
        RebuildInvalidTilesSet();
    }

    private void Start()
    {
        // Initialize references if not set in inspector
        if (plantParent == null && EcosystemManager.Instance != null)
        {
            plantParent = EcosystemManager.Instance.plantParent;
        }
        
        if (nodeEditorGrid == null)
        {
            nodeEditorGrid = NodeEditorGridController.Instance;
        }
        
        if (tileInteractionManager == null)
        {
            tileInteractionManager = TileInteractionManager.Instance;
        }
        
        if (growthModifierManager == null)
        {
            growthModifierManager = PlantGrowthModifierManager.Instance;
        }
    }
    
    private void RebuildInvalidTilesSet()
    {
        invalidTilesSet.Clear();
        foreach (var tile in invalidPlantingTiles)
        {
            if (tile != null)
            {
                invalidTilesSet.Add(tile);
            }
        }
        
        if (showDebugMessages)
        {
            Debug.Log($"PlantPlacementManager: Built invalid tiles set with {invalidTilesSet.Count} entries");
        }
    }
    
    private void OnValidate()
    {
        // Rebuild the set when changed in Inspector
        RebuildInvalidTilesSet();
    }

    // Check if a grid position is occupied by a plant
    public bool IsPositionOccupied(Vector3Int gridPosition)
    {
        // If we have a reference, check if it's still valid (not destroyed)
        if (plantsByGridPosition.TryGetValue(gridPosition, out GameObject plant))
        {
            if (plant == null)
            {
                // Plant has been destroyed, remove from dictionary
                plantsByGridPosition.Remove(gridPosition);
                return false;
            }
            return true;
        }
        return false;
    }
    
    // Check if a tile is valid for planting
    public bool IsTileValidForPlanting(TileDefinition tileDef)
    {
        // If the tile is null, it's not valid
        if (tileDef == null)
            return false;
            
        // Check if this tile is in our invalid set
        return !invalidTilesSet.Contains(tileDef);
    }

    // Clean up destroyed plants from our dictionary (call periodically if needed)
    public void CleanupDestroyedPlants()
    {
        List<Vector3Int> keysToRemove = new List<Vector3Int>();
        
        foreach (var kvp in plantsByGridPosition)
        {
            if (kvp.Value == null)
            {
                keysToRemove.Add(kvp.Key);
            }
        }
        
        foreach (var key in keysToRemove)
        {
            plantsByGridPosition.Remove(key);
        }
        
        if (showDebugMessages && keysToRemove.Count > 0)
        {
            Debug.Log($"PlantPlacementManager: Removed {keysToRemove.Count} destroyed plant references.");
        }
    }

    // Try to plant a seed at the given grid position
    public bool TryPlantSeed(Vector3Int gridPosition, Vector3 worldPosition)
    {
        // Clean up any destroyed plants first
        CleanupDestroyedPlants();
        
        // Return false if position is already occupied
        if (IsPositionOccupied(gridPosition))
        {
            if (showDebugMessages)
            {
                Debug.Log($"Cannot plant: Position {gridPosition} already has a plant.");
            }
            return false;
        }
        
        // Get the tile at this position
        TileDefinition tileDef = null;
        if (tileInteractionManager != null)
        {
            tileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
            
            // Check if the tile is valid for planting
            if (!IsTileValidForPlanting(tileDef))
            {
                if (showDebugMessages)
                {
                    string tileName = tileDef != null ? tileDef.displayName : "Unknown";
                    Debug.Log($"Cannot plant: Tile {tileName} is not valid for planting.");
                }
                return false;
            }
        }

        // Get the current graph from the NodeEditorGridController
        if (nodeEditorGrid == null)
        {
            nodeEditorGrid = NodeEditorGridController.Instance;
            if (nodeEditorGrid == null)
            {
                Debug.LogError("Cannot plant: NodeEditorGridController not found.");
                return false;
            }
        }

        NodeGraph graphToSpawn = nodeEditorGrid.GetCurrentUIGraph();
        if (graphToSpawn == null || graphToSpawn.nodes == null || graphToSpawn.nodes.Count == 0)
        {
            if (showDebugMessages)
            {
                Debug.Log("Cannot plant: No nodes in UI graph to spawn.");
            }
            return false;
        }
        
        // Validate graph has a seed node
        bool seedFound = false;
        foreach (var node in graphToSpawn.nodes)
        {
            if (node != null && node.effects != null)
            {
                foreach (var effect in node.effects)
                {
                    if (effect != null && effect.effectType == NodeEffectType.SeedSpawn && effect.isPassive)
                    {
                        seedFound = true;
                        break;
                    }
                }
            }
            if (seedFound) break;
        }

        if (!seedFound)
        {
            if (showDebugMessages)
            {
                Debug.Log("Cannot plant: Node graph lacks a SeedSpawn effect.");
            }
            return false;
        }

        // Calculate randomized planting position based on our settings
        Vector3 plantingPosition = GetRandomizedPlantingPosition(worldPosition);
        
        // Spawn the plant at the randomized position
        GameObject plantObj = SpawnPlant(graphToSpawn, plantingPosition);
        if (plantObj != null)
        {
            // Track the plant position
            plantsByGridPosition[gridPosition] = plantObj;
            
            // Register the plant with the growth modifier manager
            if (growthModifierManager != null)
            {
                PlantGrowth plantGrowth = plantObj.GetComponent<PlantGrowth>();
                if (plantGrowth != null)
                {
                    growthModifierManager.RegisterPlantTile(plantGrowth, tileDef);
                    
                    if (showDebugMessages)
                    {
                        string tileDebugName = tileDef != null ? tileDef.displayName : "Unknown";
                        Debug.Log($"Plant registered with tile: {tileDebugName}");
                    }
                }
            }
            
            return true;
        }
        return false;
    }

    // Spawn a plant using the given node graph at the specified position
    private GameObject SpawnPlant(NodeGraph graphToSpawn, Vector3 position)
    {
        if (plantPrefab == null)
        {
            Debug.LogError("Cannot spawn plant: Plant prefab not assigned.");
            return null;
        }

        Debug.Log($"SpawnPlant called with position: {position}");
    
        // Instantiate the plant prefab
        GameObject plantObj = Instantiate(plantPrefab, position, Quaternion.identity, plantParent);
    
        // Verify the position was actually applied
        Debug.Log($"Plant instantiated at position: {plantObj.transform.position}");

        // Get the PlantGrowth component
        PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
        if (growthComponent != null)
        {
            // Create a deep copy of the node graph to prevent modifications affecting the original
            NodeGraph graphCopy = CloneNodeGraph(graphToSpawn);

            // Initialize the plant with the deep copy
            growthComponent.InitializeAndGrow(graphCopy);
            return plantObj;
        }
        else
        {
            Debug.LogError("Plant prefab missing PlantGrowth component! Destroying spawned object.");
            Destroy(plantObj);
            return null;
        }
    }

    // Create a deep copy of a NodeGraph
    private NodeGraph CloneNodeGraph(NodeGraph original)
    {
        NodeGraph copy = new NodeGraph();
        copy.nodes = new List<NodeData>();

        foreach (NodeData originalNode in original.nodes)
        {
            if (originalNode == null) continue;

            NodeData newNode = new NodeData
            {
                nodeId = originalNode.nodeId,
                nodeDisplayName = originalNode.nodeDisplayName,
                orderIndex = originalNode.orderIndex,
                canBeDeleted = originalNode.canBeDeleted
            };

            // Deep copy effects
            newNode.effects = CloneEffectsList(originalNode.effects);
            copy.nodes.Add(newNode);
        }

        return copy;
    }

    // Create a deep copy of a list of NodeEffectData
    private List<NodeEffectData> CloneEffectsList(List<NodeEffectData> originalList)
    {
        if (originalList == null) return new List<NodeEffectData>();

        List<NodeEffectData> newList = new List<NodeEffectData>();
        foreach (var originalEffect in originalList)
        {
            if (originalEffect == null) continue;

            NodeEffectData newEffect = new NodeEffectData
            {
                effectType = originalEffect.effectType,
                primaryValue = originalEffect.primaryValue,
                secondaryValue = originalEffect.secondaryValue,
                isPassive = originalEffect.isPassive,
                scentDefinitionReference = originalEffect.scentDefinitionReference
            };
            newList.Add(newEffect);
        }
        return newList;
    }
    
    // Generate a randomized position within the given radius, with simple increments
    // Generate a randomized position within the given radius
    private Vector3 GetRandomizedPlantingPosition(Vector3 centerPosition)
    {
        // First, let's add comprehensive debugging
        Debug.Log($"Starting position randomization from center: {centerPosition}, radius: {spawnRadius}, increment: {spawnRadiusIncrement}");
    
        // Critical check - if radius is too small, just return the center
        if (spawnRadius < 0.01f)
        {
            Debug.LogWarning("Spawn radius too small (<0.01), using center position");
            return centerPosition;
        }
    
        // Generate a random angle in radians (0 to 2π)
        float randomAngle = Random.Range(0f, 2f * Mathf.PI);
        Debug.Log($"Random angle: {randomAngle} radians ({randomAngle * Mathf.Rad2Deg} degrees)");
    
        // Convert angle to direction vector
        Vector2 direction = new Vector2(Mathf.Cos(randomAngle), Mathf.Sin(randomAngle));
        Debug.Log($"Direction vector: {direction}");
    
        // Get a random distance within spawn radius
        float randomDistance = Random.Range(0.05f, spawnRadius);
        Debug.Log($"Random distance: {randomDistance}");
    
        // Calculate actual offset
        float offsetX = direction.x * randomDistance;
        float offsetY = direction.y * randomDistance;
        Debug.Log($"Raw offset: ({offsetX}, {offsetY})");
    
        // Apply increment if needed
        if (spawnRadiusIncrement > 0.001f)
        {
            float originalX = offsetX;
            float originalY = offsetY;
        
            offsetX = Mathf.Round(offsetX / spawnRadiusIncrement) * spawnRadiusIncrement;
            offsetY = Mathf.Round(offsetY / spawnRadiusIncrement) * spawnRadiusIncrement;
        
            Debug.Log($"Snapped offset: ({offsetX}, {offsetY}) from ({originalX}, {originalY})");
        }
    
        // Create the final position
        Vector3 randomizedPosition = centerPosition + new Vector3(offsetX, offsetY, 0f);
        Debug.Log($"FINAL randomized position: {randomizedPosition}");
    
        return randomizedPosition;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\PlayerTileInteractor.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[RequireComponent(typeof(ToolSwitcher))]
public class PlayerTileInteractor : MonoBehaviour
{
    private ToolSwitcher toolSwitcher;

    private void Awake()
    {
        toolSwitcher = GetComponent<ToolSwitcher>();
        if (toolSwitcher == null)
            Debug.LogError("PlayerTileInteractor: No ToolSwitcher found on this GameObject!");
    }

    private void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            if (TileInteractionManager.Instance == null)
            {
                Debug.LogError("No TileInteractionManager in scene!");
                return;
            }

            ToolDefinition currentTool = toolSwitcher.CurrentTool;
            if (currentTool == null)
            {
                Debug.Log("No tool is currently selected.");
                return;
            }

            // Attempt to apply the tool
            TileInteractionManager.Instance.ApplyToolAction(currentTool);
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using UnityEngine.Tilemaps;

[CreateAssetMenu(fileName = "TileDefinition", menuName = "Tiles/Tile Definition")]
public class TileDefinition : ScriptableObject
{
    [Header("Basic Identification")]
    [Tooltip("Display name for this tile type (used in UI and debugging)")]
    public string displayName;    // e.g. "Grass", "Dirt", "Wet Dirt"
    
    [Header("Visual Properties")]
    [Tooltip("Optional tint color to apply to the RenderTilemap")]
    public Color tintColor = Color.white;
    
    [Header("Auto-Reversion (optional)")]
    [Tooltip("If > 0, after this many seconds, the tile reverts to 'revertToTile'.")]
    public float revertAfterSeconds = 0f;

    [Tooltip("If revertAfterSeconds > 0, tile reverts to this tile definition.")]
    public TileDefinition revertToTile;

    [Header("Overlay Option")]
    [Tooltip("If true, this tile will be placed on top without removing the tile underneath ")]
    public bool keepBottomTile = false;

#if UNITY_EDITOR
    // This method will be called from the custom editor
    public void UpdateColor()
    {
        // Find the TileInteractionManager in the scene using the non-deprecated method
        var manager = UnityEngine.Object.FindAnyObjectByType<TileInteractionManager>();
        if (manager == null) return;

        foreach (var mapping in manager.tileDefinitionMappings)
        {
            if (mapping.tileDef == this && mapping.tilemapModule != null)
            {
                Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                if (renderTilemapTransform != null)
                {
                    Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
                    if (renderTilemap != null)
                    {
                        renderTilemap.color = tintColor;
                        UnityEditor.EditorUtility.SetDirty(renderTilemap);
                    }
                }
            }
        }
    }
#endif
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Data/TileInteractionLibrary.cs
using System.Collections.Generic;
using UnityEngine;
using System; // Needed for [Serializable]

// --- NEW: Define the structure for a refill rule ---
[Serializable] // Make it visible in the Inspector
public class ToolRefillRule
{
    [Tooltip("The tool that can be refilled.")]
    public ToolDefinition toolToRefill;

    [Tooltip("The tile that must be interacted with to trigger the refill.")]
    public TileDefinition refillSourceTile;
}
// ----------------------------------------------------

[CreateAssetMenu(fileName = "TileInteractionLibrary", menuName = "Tiles/Tile Interaction Library")]
public class TileInteractionLibrary : ScriptableObject
{
    [Header("Standard Tile Transformations")]
    [Tooltip("List of rules: (Tool, fromTile) => toTile.")]
    public List<TileInteractionRule> rules; // Existing transformation rules

    [Header("Tool Refill Rules")] // <<< NEW HEADER
    [Tooltip("List of rules defining how tools are refilled.")]
    public List<ToolRefillRule> refillRules; // <<< NEW LIST FOR REFILLS
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Data/TileInteractionManager.cs
using System.Collections;
using UnityEngine;
using UnityEngine.Tilemaps;
using skner.DualGrid; // Assuming this is the correct namespace for your DualGrid package
using System.Collections.Generic;
using System.Linq;
using TMPro;
#if UNITY_EDITOR
using UnityEditor; // Correct placement for editor-specific using directive
#endif

public class TileInteractionManager : MonoBehaviour
{
    public static TileInteractionManager Instance { get; private set; }
    [System.Serializable] public class TileDefinitionMapping { public TileDefinition tileDef; public DualGridTilemapModule tilemapModule; }
    [Header("Tile Definition Mappings")] public List<TileDefinitionMapping> tileDefinitionMappings;
    [Header("Interaction Library")] public TileInteractionLibrary interactionLibrary; // Now contains both rule types
    [Header("Grid & Scene References")] public Grid interactionGrid; public Camera mainCamera; public Transform player; public float hoverRadius = 3f; public GameObject hoverHighlightObject;
    [Header("Tilemap Rendering Settings")] public int baseSortingOrder = 0;
    [Header("Debug / UI")] public bool debugLogs = false; public TextMeshProUGUI hoveredTileText; public TextMeshProUGUI currentToolText;
    private Dictionary<TileDefinition, DualGridTilemapModule> moduleByDefinition;
    private Dictionary<DualGridTilemapModule, TileDefinition> definitionByModule;
    private Vector3Int? currentlyHoveredCell = null;
    private TileDefinition hoveredTileDef = null;
    private struct TimedTileState { public TileDefinition tileDef; public float timeLeft; }
    private Dictionary<Vector3Int, TimedTileState> timedCells = new Dictionary<Vector3Int, TimedTileState>();
    private ToolSwitcher playerToolSwitcher;

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;

        // Initialize dictionaries here
        moduleByDefinition = new Dictionary<TileDefinition, DualGridTilemapModule>();
        definitionByModule = new Dictionary<DualGridTilemapModule, TileDefinition>();

        SetupTilemaps(); // Setup tilemaps after dictionaries are created
    }

    void Start()
    {
        // Ensure dictionaries are populated if something went wrong in Awake or for runtime recompiles
        if (moduleByDefinition == null || moduleByDefinition.Count == 0 || definitionByModule == null || definitionByModule.Count == 0)
        {
            Debug.LogWarning("[TileInteractionManager Start] Dictionaries were empty or null, re-running SetupTilemaps.");
            SetupTilemaps();
        }

        // Find the Player's ToolSwitcher
        if (player != null)
        {
            // Use GetComponentInChildren to find it even if it's nested
            playerToolSwitcher = player.GetComponentInChildren<ToolSwitcher>(true); // Include inactive just in case
            if (playerToolSwitcher == null)
            {
                Debug.LogError("[TileInteractionManager Start] Could not find ToolSwitcher component on Player or its children!", player);
            }
            else
            {
                 if(debugLogs) Debug.Log("[TileInteractionManager Start] Found Player ToolSwitcher.", playerToolSwitcher.gameObject);
            }
        }
        else
        {
            Debug.LogError("[TileInteractionManager Start] Player Transform reference is not assigned in the Inspector!", this);
        }
    }

    private void SetupTilemaps()
    {
        // Clear dictionaries before rebuilding
        moduleByDefinition.Clear();
        definitionByModule.Clear();

        if (tileDefinitionMappings == null)
        {
            Debug.LogError("[TileInteractionManager SetupTilemaps] Tile Definition Mappings list is null!", this);
            return;
        }

        for (int i = 0; i < tileDefinitionMappings.Count; i++)
        {
            var mapping = tileDefinitionMappings[i];
            if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null)
            {
                 Debug.LogWarning($"[TileInteractionManager SetupTilemaps] Skipping null or incomplete mapping at index {i}.");
                 continue;
            }

            // Add to dictionaries
            if (!moduleByDefinition.ContainsKey(mapping.tileDef))
            {
                moduleByDefinition[mapping.tileDef] = mapping.tilemapModule;
                // *** CORRECTED ASSIGNMENT HERE ***
                definitionByModule[mapping.tilemapModule] = mapping.tileDef;

                // Find the RenderTilemap child
                Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
                if (renderTilemapTransform != null)
                {
                    // Set Sorting Order
                    TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
                    if (renderer != null)
                    {
                        renderer.sortingOrder = baseSortingOrder - i;
                        if (debugLogs) Debug.Log($"Setting sorting order for {mapping.tileDef.displayName} to {renderer.sortingOrder}");
                    }
                    else { Debug.LogWarning($"RenderTilemap for {mapping.tileDef.displayName} missing TilemapRenderer.", renderTilemapTransform); }

                    // Set Initial Color
                    Tilemap tilemap = renderTilemapTransform.GetComponent<Tilemap>();
                    if (tilemap != null)
                    {
                        tilemap.color = mapping.tileDef.tintColor;
                        if (debugLogs) Debug.Log($"Setting color for {mapping.tileDef.displayName} to {tilemap.color}");
                    }
                     else { Debug.LogWarning($"RenderTilemap for {mapping.tileDef.displayName} missing Tilemap component.", renderTilemapTransform); }
                }
                 else { Debug.LogWarning($"Could not find 'RenderTilemap' child for module of {mapping.tileDef.displayName}.", mapping.tilemapModule.gameObject); }

                if (debugLogs) Debug.Log($"[Mapping] Added: {mapping.tileDef.displayName} => {mapping.tilemapModule.gameObject.name}");
            }
            else
            {
                Debug.LogWarning($"[TileInteractionManager SetupTilemaps] Duplicate TileDefinition '{mapping.tileDef.displayName}' found in mappings. Ignoring subsequent entries.", mapping.tileDef);
            }
        }
         if (debugLogs) Debug.Log($"[TileInteractionManager SetupTilemaps] Setup complete. {moduleByDefinition.Count} definitions mapped.");
    }

    // Method for editor button: Update Sorting Order
    public void UpdateSortingOrder()
    {
        if (tileDefinitionMappings == null) return;
        for (int i = 0; i < tileDefinitionMappings.Count; i++)
        {
            var mapping = tileDefinitionMappings[i];
            if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;

            Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
            if (renderTilemapTransform != null)
            {
                TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
                if (renderer != null)
                {
                    renderer.sortingOrder = baseSortingOrder - i;
#if UNITY_EDITOR
                    if (!Application.isPlaying) EditorUtility.SetDirty(renderer);
#endif
                    if (debugLogs) Debug.Log($"Updated sorting order for {mapping.tileDef.displayName} to {renderer.sortingOrder}");
                }
            }
        }
    }

    // Method for editor button: Update All Colors
    public void UpdateAllColors()
    {
        if (tileDefinitionMappings == null) return;
        foreach (var mapping in tileDefinitionMappings)
        {
            if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;

            Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
            if (renderTilemapTransform != null)
            {
                Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
                if (renderTilemap != null)
                {
                    renderTilemap.color = mapping.tileDef.tintColor;
#if UNITY_EDITOR
                    if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
                    if (debugLogs) Debug.Log($"Updated color for {mapping.tileDef.displayName} to {renderTilemap.color}");
                }
            }
        }
    }

    void Update()
    {
        HandleTileHover();
        UpdateReversion();
        UpdateDebugUI(); // Update UI every frame
    }

    private void UpdateReversion()
    {
        if (timedCells.Count == 0) return;

        List<Vector3Int> cellsToRevert = null; // Initialize null

        // Iterate over a temporary copy to allow modification
        foreach (var kvp in timedCells.ToList())
        {
            Vector3Int cellPos = kvp.Key;
            TimedTileState state = kvp.Value;

            // Check if the state's tile definition is still valid (safety check)
            if (state.tileDef == null) {
                timedCells.Remove(cellPos); // Clean up invalid entry
                continue;
            }

            state.timeLeft -= Time.deltaTime;

            if (state.timeLeft <= 0f)
            {
                if (cellsToRevert == null) cellsToRevert = new List<Vector3Int>();
                cellsToRevert.Add(cellPos);
            }
            else
            {
                timedCells[cellPos] = state; // Update time left
            }
        }

        if (cellsToRevert != null)
        {
            foreach (var cellPos in cellsToRevert)
            {
                // Check if the entry still exists before processing
                if (timedCells.TryGetValue(cellPos, out TimedTileState stateToRevert))
                {
                    timedCells.Remove(cellPos); // Remove before acting

                    // Always remove the reverting tile itself
                    RemoveTile(stateToRevert.tileDef, cellPos);

                    // Place the revert-to tile *if specified*
                    if (stateToRevert.tileDef.revertToTile != null)
                    {
                        if (debugLogs) Debug.Log($"Reverting tile at {cellPos} from {stateToRevert.tileDef.displayName} to {stateToRevert.tileDef.revertToTile.displayName}");
                        PlaceTile(stateToRevert.tileDef.revertToTile, cellPos);
                    } else {
                        if (debugLogs) Debug.Log($"Tile {stateToRevert.tileDef.displayName} at {cellPos} expired and removed (no revert target).");
                    }
                }
            }
        }
    }

    private void RegisterTimedTile(Vector3Int cellPos, TileDefinition tileDef)
    {
        // Only register if revert time is positive
        // RevertToTile check is now handled during reversion itself
        if (tileDef != null && tileDef.revertAfterSeconds > 0f)
        {
            TimedTileState newState = new TimedTileState
            {
                tileDef = tileDef,
                timeLeft = tileDef.revertAfterSeconds
            };
            timedCells[cellPos] = newState;
            if (debugLogs) Debug.Log($"Registered timed reversion for {tileDef.displayName} at {cellPos} ({tileDef.revertAfterSeconds}s).");
        }
         // Clear any existing timer if revertAfterSeconds is 0 or less
         else if (timedCells.ContainsKey(cellPos))
         {
              timedCells.Remove(cellPos);
              if (debugLogs) Debug.Log($"Cleared timed reversion for {cellPos} because revert time is not positive.");
         }
    }

    public void PlaceTile(TileDefinition tileDef, Vector3Int cellPos)
    {
        if (tileDef == null) { Debug.LogWarning($"PlaceTile: Attempted to place a NULL TileDefinition at {cellPos}."); return; }

        if (moduleByDefinition == null || !moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) || module == null)
        {
            Debug.LogWarning($"PlaceTile: No mapped module found for TileDefinition '{tileDef.displayName}'. Cannot place tile.");
            return;
        }

        // Handle removing existing tiles based on the new tile's 'keepBottomTile' flag
        if (!tileDef.keepBottomTile)
        {
            TileDefinition existingDef = FindWhichTileDefinitionAt(cellPos);
            if (existingDef != null && existingDef != tileDef)
            {
                 if (debugLogs) Debug.Log($"Placing '{tileDef.displayName}' (KeepBottom=false), removing existing '{existingDef.displayName}' at {cellPos}.");
                 RemoveTile(existingDef, cellPos);
            }
        } else {
             if (debugLogs) Debug.Log($"Placing '{tileDef.displayName}' (KeepBottom=true) over whatever is at {cellPos}.");
        }

        // Set the tile on the correct module's DataTilemap
        if (module.DataTilemap != null)
        {
            // Using a basic Tile asset is fine for the data layer
            TileBase dataTile = ScriptableObject.CreateInstance<Tile>();
            module.DataTilemap.SetTile(cellPos, dataTile);
        } else { Debug.LogWarning($"Module for '{tileDef.displayName}' has no DataTilemap assigned.", module.gameObject); }

        // Update RenderTilemap color immediately
        Transform renderTilemapTransform = module.transform.Find("RenderTilemap");
        if (renderTilemapTransform != null)
        {
            Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
            if (renderTilemap != null)
            {
                renderTilemap.color = tileDef.tintColor;
#if UNITY_EDITOR
                if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
            }
        }

        // Register for timed reversion if applicable
        RegisterTimedTile(cellPos, tileDef);
    }

    public void RemoveTile(TileDefinition tileDef, Vector3Int cellPos)
    {
        if (tileDef == null) { Debug.LogWarning($"RemoveTile: Attempted to remove a NULL TileDefinition at {cellPos}."); return; }

        if (moduleByDefinition == null || !moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) || module == null)
        {
            if (debugLogs) Debug.LogWarning($"RemoveTile: No mapped module found for TileDefinition '{tileDef.displayName}'. Cannot remove tile.");
            return;
        }

        // Remove from the module's DataTilemap
        if (module.DataTilemap != null)
        {
             // Check if the tile actually exists before removing
             if (module.DataTilemap.HasTile(cellPos)) {
                 module.DataTilemap.SetTile(cellPos, null);
                 if (debugLogs) Debug.Log($"Removed '{tileDef.displayName}' from DataTilemap at {cellPos}.");
             } else {
                 if (debugLogs) Debug.Log($"RemoveTile: Tile '{tileDef.displayName}' not found on DataTilemap at {cellPos}, skipping removal.");
             }
        } else { Debug.LogWarning($"Module for '{tileDef.displayName}' has no DataTilemap assigned.", module.gameObject); }

        // Also remove from timed reversion tracking if it matches
        if (timedCells.TryGetValue(cellPos, out TimedTileState timedState) && timedState.tileDef == tileDef)
        {
            timedCells.Remove(cellPos);
            if (debugLogs) Debug.Log($"Cleared timed reversion for {tileDef.displayName} at {cellPos} during removal.");
        }
    }

    public TileDefinition FindWhichTileDefinitionAt(Vector3Int cellPos)
    {
        if (definitionByModule == null || tileDefinitionMappings == null) {
             Debug.LogError("[FindWhichTileDefinitionAt] Dictionaries not initialized!");
             return null;
        }

        TileDefinition foundDef = null;

        // Prioritize checking overlay tiles first (those with keepBottomTile = true)
        // Iterate mappings list directly to check the flag easily
        foreach (var mapping in tileDefinitionMappings)
        {
             if (mapping?.tileDef != null && mapping.tilemapModule?.DataTilemap != null && mapping.tileDef.keepBottomTile)
             {
                 if (mapping.tilemapModule.DataTilemap.HasTile(cellPos))
                 {
                     foundDef = mapping.tileDef;
                     break; // Found the top overlay tile
                 }
             }
        }

        // If no overlay found, check non-overlay tiles
        if (foundDef == null)
        {
             // Use the definitionByModule dictionary which maps modules back to definitions
             foreach (var kvp in definitionByModule)
             {
                 DualGridTilemapModule module = kvp.Key;
                 TileDefinition def = kvp.Value;

                 // Ensure it's not an overlay tile (we already checked those) and the module/tilemap are valid
                 if (module?.DataTilemap != null && def != null && !def.keepBottomTile)
                 {
                     if (module.DataTilemap.HasTile(cellPos))
                     {
                         foundDef = def;
                         break; // Found the base tile
                     }
                 }
             }
        }

        // if (debugLogs && foundDef != null) Debug.Log($"[FindWhichTileDefinitionAt] Found '{foundDef.displayName}' at {cellPos}");
        // else if (debugLogs && foundDef == null) Debug.Log($"[FindWhichTileDefinitionAt] Found no tile at {cellPos}");

        return foundDef;
    }

    private void HandleTileHover()
    {
        if (mainCamera == null || player == null) return;

        Vector3 mouseWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
        mouseWorldPos.z = 0f; // Ensure Z is 0 for 2D comparison
        Vector3Int cellPos = WorldToCell(mouseWorldPos);

        // Check distance only if player reference exists
        float distance = (player != null) ? Vector2.Distance(player.position, CellCenterWorld(cellPos)) : float.MaxValue;

        TileDefinition foundTile = FindWhichTileDefinitionAt(cellPos);

        // Only update hover state if within radius
        if (distance <= hoverRadius)
        {
            bool changedCell = !currentlyHoveredCell.HasValue || currentlyHoveredCell.Value != cellPos;
            currentlyHoveredCell = cellPos;
            hoveredTileDef = foundTile;

            if (hoverHighlightObject != null)
            {
                hoverHighlightObject.SetActive(true);
                hoverHighlightObject.transform.position = CellCenterWorld(cellPos);
            }
            //if (debugLogs && changedCell) Debug.Log($"[Hover Enter] Cell={cellPos}, Tile={foundTile?.displayName ?? "None"}, Dist={distance:F2}");
        }
        else
        {
            bool changedCell = currentlyHoveredCell.HasValue;
            currentlyHoveredCell = null;
            hoveredTileDef = null;
            if (hoverHighlightObject != null)
            {
                hoverHighlightObject.SetActive(false);
            }
            //if (debugLogs && changedCell) Debug.Log($"[Hover Exit] Cell outside radius ({distance:F2} > {hoverRadius})");
        }
    }

    private void UpdateDebugUI()
    {
        // Hovered Tile Text
        if (hoveredTileText != null)
        {
            string tileName = hoveredTileDef != null ? hoveredTileDef.displayName : "None";
            hoveredTileText.text = $"Hover: {tileName}";
        }

        // Current Tool Text (includes uses)
        if (currentToolText != null)
        {
            if (playerToolSwitcher != null && playerToolSwitcher.CurrentTool != null)
            {
                ToolDefinition tool = playerToolSwitcher.CurrentTool;
                string toolString = $"Tool: {tool.displayName}";
                if (tool.limitedUses)
                {
                    int uses = playerToolSwitcher.CurrentRemainingUses;
                    toolString += $" ({uses})"; // Show remaining uses
                }
                currentToolText.text = toolString;
            }
            else
            {
                currentToolText.text = "Tool: None";
            }
        }
    }

    public Vector3Int WorldToCell(Vector3 worldPos)
    {
        if (interactionGrid != null) return interactionGrid.WorldToCell(worldPos);

        // Fallback: Try to get grid from the first valid mapping
        if (tileDefinitionMappings != null && tileDefinitionMappings.Count > 0) {
             foreach(var mapping in tileDefinitionMappings) {
                 if (mapping?.tilemapModule?.DataTilemap?.layoutGrid != null) {
                     return mapping.tilemapModule.DataTilemap.layoutGrid.WorldToCell(worldPos);
                 }
             }
        }

        Debug.LogWarning("[WorldToCell] No valid interactionGrid or mapped Tilemap found to determine cell position.");
        return Vector3Int.zero;
    }

    private Vector3 CellCenterWorld(Vector3Int cellPos)
    {
         if (interactionGrid != null) return interactionGrid.GetCellCenterWorld(cellPos);

         // Fallback: Try to get grid from the first valid mapping
         if (tileDefinitionMappings != null && tileDefinitionMappings.Count > 0) {
             foreach(var mapping in tileDefinitionMappings) {
                 if (mapping?.tilemapModule?.DataTilemap?.layoutGrid != null) {
                     return mapping.tilemapModule.DataTilemap.layoutGrid.GetCellCenterWorld(cellPos);
                 }
             }
        }

        Debug.LogWarning("[CellCenterWorld] No valid interactionGrid or mapped Tilemap found to determine cell center.");
        return Vector3.zero; // Or grid.CellToWorld(cellPos) + grid.cellSize * 0.5f if grid guaranteed?
    }

    private void HandleSeedPlanting(Vector3Int cellPosition)
    {
        PlantPlacementManager plantManager = PlantPlacementManager.Instance;
        if (plantManager == null) { Debug.LogError("Cannot plant: PlantPlacementManager not found!"); return; }

        TileDefinition tileDef = FindWhichTileDefinitionAt(cellPosition);
        if (!plantManager.IsTileValidForPlanting(tileDef))
        {
            if (debugLogs) Debug.Log($"Cannot plant on {tileDef?.displayName ?? "Unknown"} - invalid tile.");
            // Maybe add player feedback here (sound/visual)
            return;
        }

        GardenerController gardener = player?.GetComponent<GardenerController>();
        if (gardener == null) { Debug.LogError("Cannot plant: GardenerController not found on player!"); return; }

        Vector3 worldPosition = CellCenterWorld(cellPosition); // Plant near cell center

        gardener.Plant(); // Trigger animation
        StartCoroutine(PlantAfterAnimation(gardener, plantManager, cellPosition, worldPosition));
    }

    private IEnumerator PlantAfterAnimation(GardenerController gardener, PlantPlacementManager plantManager, Vector3Int cellPosition, Vector3 worldPosition)
    {
        // Ensure gardener and duration are valid
        float waitTime = (gardener != null) ? gardener.plantingDuration : 0.1f;
        yield return new WaitForSeconds(waitTime);

        if (plantManager != null) // Check again in case it was destroyed
        {
            bool planted = plantManager.TryPlantSeed(cellPosition, worldPosition);
            if (debugLogs) Debug.Log(planted ? $"Planted seed successfully at {cellPosition}" : $"Failed to plant seed at {cellPosition}");
        }
    }

    // --- ApplyToolAction is MODIFIED ---
    public void ApplyToolAction(ToolDefinition toolDef)
    {
        // --- Initial Checks (unchanged) ---
        if (toolDef == null) { Debug.LogWarning("ApplyToolAction called with a NULL toolDef."); return; }
        if (!currentlyHoveredCell.HasValue) return;
        if (hoveredTileDef == null) { if (debugLogs) Debug.Log("ApplyToolAction: No recognized tile at hovered cell."); return; }
        if (playerToolSwitcher == null) { Debug.LogError("ApplyToolAction: ToolSwitcher reference is missing! Cannot apply tool."); return; }
        float distance = Vector2.Distance(player.position, CellCenterWorld(currentlyHoveredCell.Value));
        if (distance > hoverRadius) { if (debugLogs) Debug.Log($"ApplyToolAction: Cell too far ({distance:F2} > {hoverRadius})."); return; }
        if (playerToolSwitcher.CurrentTool != toolDef) { Debug.LogWarning($"ApplyToolAction: Tool passed ({toolDef.displayName}) does not match current tool ({playerToolSwitcher.CurrentTool?.displayName}). Aborting."); return; }
        // ---------------------------------

        // --- Consume Use Attempt ---
        // We *attempt* to consume first. If it fails (out of uses), we stop.
        // If it succeeds, we proceed to check for refill or transformation.
        bool consumed = playerToolSwitcher.TryConsumeUse();
        // --- Note: We don't stop here even if consumed is false, because a refill action might still be possible even if uses are 0 (e.g. refill an empty can) ---
        // --- UPDATE: Actually, let's only proceed if consumed is TRUE OR if a refill rule applies ---

        if (debugLogs) Debug.Log($"[ApplyToolAction] Using Tool='{toolDef.toolType}', On Tile='{hoveredTileDef.displayName}', At Cell={currentlyHoveredCell.Value}. Consumed Use: {consumed}");


        // --- Check for REFILL Action FIRST ---
        bool wasRefillAction = false;
        if (interactionLibrary != null && interactionLibrary.refillRules != null)
        {
            foreach (var refillRule in interactionLibrary.refillRules)
            {
                // Check if rule matches the current tool and hovered tile
                if (refillRule != null && refillRule.toolToRefill == toolDef && refillRule.refillSourceTile == hoveredTileDef)
                {
                    // Match found! Attempt to refill.
                    if (debugLogs) Debug.Log($"Refill rule matched: Tool '{toolDef.displayName}' on Tile '{hoveredTileDef.displayName}'.");
                    playerToolSwitcher.RefillCurrentTool(); // Call the refill method
                    wasRefillAction = true;
                    break; // Stop checking refill rules once one matches
                }
            }
        }
        // If it was a refill action, we are done. Don't proceed to tile transformation.
        if (wasRefillAction)
        {
            // Note: The use was already consumed before the refill check.
            // If you want to *not* consume a use when refilling, you'd need
            // to add a RefundUse() method to ToolSwitcher and call it here,
            // or move the TryConsumeUse() call *after* the refill check.
            // Current logic: Click on water consumes 1 use, then refills to max.
            return;
        }
        // --------------------------------------


        // --- Proceed ONLY if use was successfully consumed AND it wasn't a refill ---
        if (!consumed)
        {
            if (debugLogs) Debug.Log($"ApplyToolAction: Tool '{toolDef.displayName}' could not be used (out of uses) and no refill rule applied.");
            return; // Stop if out of uses and not refilling
        }


        // --- Handle Standard Tile Transformation ---

        // Special case: SeedPouch (check again after use consumption)
        if (toolDef.toolType == ToolType.SeedPouch)
        {
            HandleSeedPlanting(currentlyHoveredCell.Value);
            return; // Seed planting handles its own logic
        }

        // Find standard matching rule
        if (interactionLibrary == null || interactionLibrary.rules == null) { Debug.LogWarning("Interaction Library or its standard rules list is null!"); return; }
        TileInteractionRule rule = interactionLibrary.rules.FirstOrDefault(r => r != null && r.tool == toolDef && r.fromTile == hoveredTileDef);

        if (rule == null)
        {
            if (debugLogs) Debug.Log($"No standard interaction rule found for tool '{toolDef.toolType}' on tile '{hoveredTileDef.displayName}'.");
            // Since a use was consumed but no action taken, maybe refund here?
            // playerToolSwitcher.RefundUse(); // Requires implementation
            return;
        }

        // Apply the standard rule
        if (rule.toTile != null) // If there's a tile to change TO
        {
            if (debugLogs) Debug.Log($"Applying standard rule: '{hoveredTileDef.displayName}' -> '{rule.toTile.displayName}'");
            if (!rule.toTile.keepBottomTile)
            {
                RemoveTile(hoveredTileDef, currentlyHoveredCell.Value);
            }
            PlaceTile(rule.toTile, currentlyHoveredCell.Value);
        }
        else // If the rule specifies removing the tile (toTile is null)
        {
            if (debugLogs) Debug.Log($"Applying standard rule: Remove '{hoveredTileDef.displayName}'");
            RemoveTile(hoveredTileDef, currentlyHoveredCell.Value);
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Data\TileInteractionRule.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System;
using UnityEngine;

[Serializable]
public class TileInteractionRule
{
    [Header("Tool Condition")]
    [Tooltip("Which tool triggers this rule.")]
    public ToolDefinition tool;

    [Header("Tile Transformation")]
    [Tooltip("Which tile must be present to apply the rule.")]
    public TileDefinition fromTile;
    [Tooltip("Which tile to transform into.")]
    public TileDefinition toTile;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Editor\TileDefinitionEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(TileDefinition))]
public class TileDefinitionEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
        
        TileDefinition tileDefinition = (TileDefinition)target;
        
        EditorGUILayout.Space();
        if (GUILayout.Button("UPDATE COLOR IN SCENE", GUILayout.Height(30)))
        {
            tileDefinition.UpdateColor();
        }
    }
}
#endif




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Editor\TileInteractionManagerEditor.cs
////////////////////////////////////////////////////////////////////////////////
﻿#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(TileInteractionManager))]
public class TileInteractionManagerEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
        
        TileInteractionManager manager = (TileInteractionManager)target;
        
        EditorGUILayout.Space();
        EditorGUILayout.BeginHorizontal();
        
        if (GUILayout.Button("UPDATE SORTING ORDER", GUILayout.Height(30)))
        {
            manager.UpdateSortingOrder();
            EditorUtility.SetDirty(manager);
        }
        
        if (GUILayout.Button("UPDATE ALL COLORS", GUILayout.Height(30)))
        {
            manager.UpdateAllColors();
            EditorUtility.SetDirty(manager);
        }
        
        EditorGUILayout.EndHorizontal();
        
        EditorGUILayout.HelpBox("Order: First item in list gets highest sorting order value (" + 
                                manager.baseSortingOrder + "). Each subsequent item is " + 
                                (manager.baseSortingOrder - 1) + ", " + 
                                (manager.baseSortingOrder - 2) + ", etc.", MessageType.Info);
    }
}
#endif




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Tools/ToolDefinition.cs
using UnityEngine;

[CreateAssetMenu(fileName = "ToolDefinition", menuName = "Tiles/Tool Definition")]
public class ToolDefinition : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("Which tool type this represents (e.g. Hoe, WateringCan).")]
    public ToolType toolType;
    [Tooltip("Human-readable name (for debugging/UI).")]
    public string displayName;

    [Header("Visuals")]
    [Tooltip("Icon sprite for the tool.")]
    public Sprite icon;
    [Tooltip("Tint color to apply to the icon sprite.")]
    public Color iconTint = Color.white;

    [Header("Usage Limits")] // <<< NEW HEADER
    [Tooltip("If true, this tool has a limited number of uses.")]
    public bool limitedUses = false; // <<< NEW FIELD (Defaults to unlimited)
    [Tooltip("The number of uses the tool starts with (only relevant if Limited Uses is true).")]
    [Min(0)] // Ensure it's not negative
    public int initialUses = 10; // <<< NEW FIELD
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolSwitcher.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Tiles/Tools/ToolSwitcher.cs
using UnityEngine;
using System;

public class ToolSwitcher : MonoBehaviour
{
    [Tooltip("All available tool definitions, e.g. Hoe, WateringCan, etc.")]
    public ToolDefinition[] toolDefinitions;

    private int currentIndex = 0;

    // --- Public Properties ---
    public ToolDefinition CurrentTool { get; private set; } = null;
    /// <summary>
    /// Gets the remaining uses for the current tool. Returns -1 if the tool has unlimited uses.
    /// </summary>
    public int CurrentRemainingUses { get; private set; } = -1; // <<< NEW: Track remaining uses (-1 for unlimited)

    // --- Events ---
    public event Action<ToolDefinition> OnToolChanged;
    /// <summary>
    /// Event fired when the remaining uses of the current tool changes. Passes the new remaining count (-1 for unlimited).
    /// </summary>
    public event Action<int> OnUsesChanged; // <<< NEW EVENT for UI updates

    private void Awake()
    {
        // Debug logs from previous step can be kept or removed
        // Debug.Log("[ToolSwitcher Awake] Initializing...");
    }

    private void Start()
    {
        InitializeToolState(true); // Initialize and fire events
    }

    private void Update()
    {
        if (toolDefinitions == null || toolDefinitions.Length == 0) return;

        bool toolChanged = false;
        int previousIndex = currentIndex;

        if (Input.GetKeyDown(KeyCode.Q))
        {
            currentIndex--;
            if (currentIndex < 0)
                currentIndex = toolDefinitions.Length - 1;
            toolChanged = true;
        }
        else if (Input.GetKeyDown(KeyCode.E))
        {
            currentIndex++;
            if (currentIndex >= toolDefinitions.Length)
                currentIndex = 0;
            toolChanged = true;
        }

        if (toolChanged)
        {
            // Ensure the new index points to a valid definition before updating state
            if (currentIndex >= 0 && currentIndex < toolDefinitions.Length && toolDefinitions[currentIndex] != null)
            {
                InitializeToolState(false); // Update state for the new tool and fire events
            }
            else
            {
                 Debug.LogError($"[ToolSwitcher Update] Attempted to switch to an invalid/NULL tool definition at index {currentIndex}. Reverting.");
                 currentIndex = previousIndex; // Revert to the last valid index
                 // No state change, no events needed here
            }
        }
    }

    /// <summary>
    /// Sets the CurrentTool and resets CurrentRemainingUses based on the tool's definition.
    /// Optionally fires OnToolChanged and OnUsesChanged events.
    /// </summary>
    /// <param name="isInitialSetup">If true, forces event firing even if tool doesn't technically change.</param>
    private void InitializeToolState(bool isInitialSetup)
    {
        ToolDefinition previousTool = CurrentTool; // Store previous tool for change check
        int previousUses = CurrentRemainingUses; // Store previous uses

        if (toolDefinitions == null || toolDefinitions.Length == 0 || currentIndex < 0 || currentIndex >= toolDefinitions.Length || toolDefinitions[currentIndex] == null)
        {
            // Handle cases with no tools or invalid selection
            CurrentTool = null;
            CurrentRemainingUses = -1; // No tool = unlimited uses conceptually
        }
        else
        {
            // Valid tool selected
            CurrentTool = toolDefinitions[currentIndex];
            if (CurrentTool.limitedUses)
            {
                CurrentRemainingUses = CurrentTool.initialUses;
            }
            else
            {
                CurrentRemainingUses = -1; // Mark as unlimited
            }
        }
        
        

        LogToolChange("[ToolSwitcher InitializeToolState]"); // Log the state after update

        // Fire events if state actually changed or if it's the initial setup
        bool toolActuallyChanged = previousTool != CurrentTool;
        bool usesActuallyChanged = previousUses != CurrentRemainingUses;

        if (isInitialSetup || toolActuallyChanged)
        {
             Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnToolChanged for tool: {CurrentTool?.displayName ?? "NULL"}");
             OnToolChanged?.Invoke(CurrentTool);
        }
        if (isInitialSetup || usesActuallyChanged || toolActuallyChanged) // Fire uses changed if tool changed too (to reset UI)
        {
             Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnUsesChanged with value: {CurrentRemainingUses}");
             OnUsesChanged?.Invoke(CurrentRemainingUses);
        }
    }


    /// <summary>
    /// Refills the current tool to its maximum capacity if it's a limited-use tool.
    /// </summary>
    public void RefillCurrentTool() // <<< NEW METHOD
    {
        if (CurrentTool == null)
        {
            Debug.LogWarning("[ToolSwitcher RefillCurrentTool] Cannot refill: No tool selected.");
            return;
        }

        if (!CurrentTool.limitedUses)
        {
            Debug.LogWarning($"[ToolSwitcher RefillCurrentTool] Cannot refill tool '{CurrentTool.displayName}': It has unlimited uses.");
            return;
        }

        // Check if already full to avoid unnecessary event firing
        if (CurrentRemainingUses == CurrentTool.initialUses)
        {
            if(Debug.isDebugBuild) Debug.Log($"[ToolSwitcher RefillCurrentTool] Tool '{CurrentTool.displayName}' is already full ({CurrentRemainingUses} uses).");
            return;
        }

        // Set uses back to initial amount
        int previousUses = CurrentRemainingUses;
        CurrentRemainingUses = CurrentTool.initialUses;

        Debug.Log($"[ToolSwitcher RefillCurrentTool] Refilled tool '{CurrentTool.displayName}' to {CurrentRemainingUses} uses (was {previousUses}).");

        // Notify listeners that uses changed
        OnUsesChanged?.Invoke(CurrentRemainingUses);
    }
    
    /// <summary>
    /// Attempts to consume one use of the current tool.
    /// </summary>
    /// <returns>True if a use was consumed or if the tool has unlimited uses. False if the tool has limited uses and is out of uses.</returns>
    public bool TryConsumeUse()
    {
        if (CurrentTool == null)
        {
            Debug.LogWarning("[ToolSwitcher TryConsumeUse] Cannot consume use: No tool selected.");
            return false; // Cannot use a non-existent tool
        }

        if (!CurrentTool.limitedUses || CurrentRemainingUses == -1)
        {
            // Tool is unlimited, consumption always succeeds
            // Debug.Log($"[ToolSwitcher TryConsumeUse] Tool '{CurrentTool.displayName}' has unlimited uses."); // Optional log
            return true;
        }

        // Tool has limited uses
        if (CurrentRemainingUses > 0)
        {
            CurrentRemainingUses--;
            Debug.Log($"[ToolSwitcher TryConsumeUse] Consumed use for '{CurrentTool.displayName}'. Remaining: {CurrentRemainingUses}");
            OnUsesChanged?.Invoke(CurrentRemainingUses); // Notify listeners
            return true;
        }
        else
        {
            // Out of uses
            Debug.Log($"[ToolSwitcher TryConsumeUse] Tool '{CurrentTool.displayName}' is out of uses (0 remaining).");
            // Optionally play an 'empty click' sound here
            return false;
        }
    }

    // Added prefix parameter for context
    private void LogToolChange(string prefix = "[ToolSwitcher]")
    {
        string toolName = (CurrentTool != null && !string.IsNullOrEmpty(CurrentTool.displayName))
                          ? CurrentTool.displayName
                          : "(none)";
        string usesSuffix = "";
        if (CurrentTool != null && CurrentTool.limitedUses && CurrentRemainingUses >= 0)
        {
            usesSuffix = $" ({CurrentRemainingUses}/{CurrentTool.initialUses})";
        }
        else if (CurrentTool != null && !CurrentTool.limitedUses)
        {
            // usesSuffix = " (Unlimited)"; // Optional: Indicate unlimited
        }

        Debug.Log($"{prefix} Switched tool to: {toolName}{usesSuffix} (Index: {currentIndex})");
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Tiles\Tools\ToolType.cs
////////////////////////////////////////////////////////////////////////////////
﻿public enum ToolType
{
    None,
    Hoe,
    WateringCan,
    SeedPouch // New tool type
    // etc.
}





--------------------------------------------------------------------------------
This is part 6 out of 7 of script collection. 1 more parts remain.
--------------------------------------------------------------------------------