This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my project. If the full script collection exceeds the character limit, additional parts will follow. On top of these scripts, there is a custom dual-grid package used as an extension for unity tilemaps, I'm also enclosing some guides for that in another files.

================================================================================
UNITY PROJECT SCRIPT EXPORT - 2025-05-26 16:14:09
PART 2 OF 7
================================================================================

--------------------------------------------------------------------------------
Assets
├── Animation
│   ├── GodRay300B_001.controller
│   ├── GodRay60_001.controller
│   ├── GodRays300.anim
│   ├── GodRays300B.anim
│   ├── MiniVillagerMan_Animator.controller
│   └── MiniVillagerMan_AnimatorBackup.controller
├── DefaultVolumeProfile.asset
├── Editor
│   ├── NodeDefinitionAutoAdder.cs
│   ├── NodeDefinitionCreator.cs
│   ├── NodeDefinitionEditor.cs
│   ├── NodeDefinitionLibraryEditor.cs
│   ├── NodeDefinitionPostprocessor.cs
│   └── NodeEffectDrawer.cs
├── HueFolders
│   ├── Editor
│   │   ├── HueFolders.Editor.asmdef
│   │   ├── HueFoldersBrowser.cs
│   │   └── SettingsProvider.cs
│   ├── Readme.pdf
│   └── package.json
├── InputSystem_Actions.inputactions
├── Materials
│   ├── BezierCurveAA_Material.mat
│   └── Firefly_Glow_Material.mat
├── Post Processing
├── Prefabs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── Animal_Bird.prefab
│   │   │   ├── Animal_Bunny.prefab
│   │   │   ├── Animal_Deer.prefab
│   │   │   ├── Animal_Fox.prefab
│   │   │   └── FireflyPrefab.prefab
│   │   ├── Plants
│   │   │   ├── PixelBerry.prefab
│   │   │   ├── PixelFlower.prefab
│   │   │   ├── PixelLeaf.prefab
│   │   │   ├── PixelSeed.prefab
│   │   │   ├── PixelStem.prefab
│   │   │   ├── PlantOutline.prefab
│   │   │   ├── PlantPrefab.prefab
│   │   │   └── PlantShadow.prefab
│   │   ├── Props
│   │   │   ├── Poop_Big.prefab
│   │   │   ├── Poop_Medium_01.prefab
│   │   │   └── Poop_Medium_02.prefab
│   │   └── UI
│   │       ├── EmptySlot16.prefab
│   │       ├── EmptySlot32.prefab
│   │       ├── HoverTileMarker.prefab
│   │       ├── Indicator_Opportunity.prefab
│   │       ├── Indicator_Resource.prefab
│   │       ├── Indicator_Threat.prefab
│   │       ├── NodeCellEmpty16.prefab
│   │       ├── NodePics
│   │       │   ├── Seed_01.prefab
│   │       │   └── Seed_02.prefab
│   │       ├── NodeView.prefab
│   │       ├── ThoughtBubble.prefab
│   │       ├── Visualizer_Circle_Prefab.prefab
│   │       └── Visualizer_Line_Prefab.prefab
│   ├── General
│   │   ├── GardenerPrefab.prefab
│   │   └── Projectile_Basic_Pixel.prefab
│   └── Tiles
│       ├── Common
│       │   └── PLains_0_Corner_LT.asset
│       ├── Palettes
│       │   └── PaletteDual_Ground.prefab
│       └── Rule Tiles
│           ├── DualGridRuleTile_Dirt.asset
│           ├── DualGridRuleTile_DirtWet.asset
│           ├── DualGridRuleTile_Grass.asset
│           └── DualGridRuleTile_Water.asset
├── Scenes
│   ├── MainScene.unity
│   ├── SampleScene
│   │   └── GlobalPostProcessVolume Profile.asset
│   └── SampleScene.unity
├── Scriptable Objects
│   ├── Animals
│   │   ├── AnimalLibrary.asset
│   │   ├── Animal_000_Bunny.asset
│   │   └── Animal_001_Deer.asset
│   ├── Animals Diet
│   │   ├── Diet_000_Bunny.asset
│   │   └── Diet_001_Deer.asset
│   ├── Food
│   │   ├── FoodType_000_Berry.asset
│   │   └── FoodType_000_Leaf.asset
│   ├── Life Thoughts
│   │   └── AnimalThoughtLibrary.asset
│   ├── Nodes Plant
│   │   ├── NodeDefinitionLibrary.asset
│   │   ├── Node_000_Seed.asset
│   │   ├── Node_001_Berry.asset
│   │   ├── Node_002_FireflyPheromone.asset
│   │   └── Node_003_PoopFertilizer.asset
│   ├── Scents
│   │   ├── ScentLibrary.asset
│   │   └── Scent_000_FireflyPheromone.asset
│   ├── Tiles
│   │   ├── TileDefinition_000_Grass.asset
│   │   ├── TileDefinition_001_Dirt.asset
│   │   ├── TileDefinition_002_DirtWet.asset
│   │   ├── TileDefinition_003_Water.asset
│   │   └── TileInteractionLibrary.asset
│   ├── Tools
│   │   ├── ToolDefinition_000_GardeningHoe.asset
│   │   ├── ToolDefinition_001_WateringCan.asset
│   │   └── ToolDefinition_002_SeedPouch.asset
│   └── Waves
│       ├── Wave_000.asset
│       ├── Wave_001.asset
│       └── Wave_002.asset
├── Scripts
│   ├── Battle
│   │   ├── Plant
│   │   │   ├── LeafData.cs
│   │   │   ├── PlantCell.cs
│   │   │   ├── PlantGrowth.Cell.cs
│   │   │   ├── PlantGrowth.Growth.cs
│   │   │   ├── PlantGrowth.NodeExecution.cs
│   │   │   ├── PlantGrowth.cs
│   │   │   └── WeatherManager.cs
│   │   ├── SpellProjectile.cs
│   │   └── Status Effects
│   │       ├── BurningStatusEffect.cs
│   │       └── StatusEffect.cs
│   ├── Core
│   │   └── SortableEntity.cs
│   ├── Ecosystem
│   │   ├── Animals
│   │   │   ├── AnimalDefinition.cs
│   │   │   └── AnimalLibrary.cs
│   │   ├── Core
│   │   │   ├── AnimalController.cs
│   │   │   ├── AnimalSpawnData.cs
│   │   │   ├── AnimalThoughtLibrary.cs
│   │   │   ├── EcosystemManager.cs
│   │   │   ├── FaunaManager.cs
│   │   │   ├── FloraManager.cs
│   │   │   ├── PoopController.cs
│   │   │   ├── ScentSource.cs
│   │   │   ├── SlowdownZone.cs
│   │   │   ├── ThoughtBubbleController.cs
│   │   │   ├── ThoughtTrigger.cs
│   │   │   ├── WaveDefinition.cs
│   │   │   └── WaveManager.cs
│   │   ├── Effects
│   │   │   ├── FireflyController.cs
│   │   │   └── FireflyManager.cs
│   │   ├── Food
│   │   │   ├── AnimalDiet.cs
│   │   │   ├── FoodItem.cs
│   │   │   └── FoodType.cs
│   │   ├── Plants
│   │   └── Scents
│   │       ├── ScentDefinition.cs
│   │       └── ScentLibrary.cs
│   ├── Nodes
│   │   ├── Core
│   │   │   ├── NodeData.cs
│   │   │   ├── NodeDefinition.cs
│   │   │   ├── NodeDefinitionLibrary.cs
│   │   │   ├── NodeEffectData.cs
│   │   │   ├── NodeEffectType.cs
│   │   │   └── OutputNodeEffect.cs
│   │   ├── Runtime
│   │   │   ├── NodeExecutor.cs
│   │   │   └── NodeGraph.cs
│   │   └── UI
│   │       ├── ColorExtensions.cs
│   │       ├── DeselectOnClickOutside.cs
│   │       ├── NodeCell.cs
│   │       ├── NodeDraggable.cs
│   │       ├── NodeEditorGridController.cs
│   │       ├── NodeSelectable.cs
│   │       └── NodeView.cs
│   ├── Player
│   │   └── GardenerController.cs
│   ├── Rendering
│   ├── Tiles
│   │   ├── Data
│   │   │   ├── PlantGrowthModifierManager.cs
│   │   │   ├── PlantPlacementManagement.cs
│   │   │   ├── PlayerTileInteractor.cs
│   │   │   ├── TileDefinition.cs
│   │   │   ├── TileInteractionLibrary.cs
│   │   │   ├── TileInteractionManager.cs
│   │   │   └── TileInteractionRule.cs
│   │   ├── Editor
│   │   │   ├── TileDefinitionEditor.cs
│   │   │   └── TileInteractionManagerEditor.cs
│   │   └── Tools
│   │       ├── ToolDefinition.cs
│   │       ├── ToolSwitcher.cs
│   │       └── ToolType.cs
│   ├── UI
│   └── Visuals
│       ├── NightColorPostProcess.cs
│       ├── OutlinePartController.cs
│       ├── PlantOutlineController.cs
│       ├── PlantShadowController.cs
│       ├── RuntimeCircleDrawer.cs
│       └── ShadowPartController.cs
├── Settings
│   ├── Lit2DSceneTemplate.scenetemplate
│   ├── Renderer2D.asset
│   ├── Scenes
│   │   └── URP2DSceneTemplate.unity
│   └── UniversalRP.asset
├── Shaders
│   ├── BezierCurveAA.shader
│   ├── Sprite-Lit-Advanced_Overlay_Base.mat
│   ├── Sprite-Lit-Default_OverlayAdvanced.shader
│   ├── Sprite-Lit-Default_OverlayCustom.shader
│   ├── Sprite-Lit-Default_Overlay_Base.mat
│   ├── SpriteEmissiveUnlit.shader
│   └── WaterReflection.shader
├── TextureImporter.preset
└── UniversalRenderPipelineGlobalSettings.asset
--------------------------------------------------------------------------------

SCRIPT CONTENTS
================================================================================

SCRIPT CONTENTS
================================================================================

////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\PlantGrowth.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/PlantGrowth.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using TMPro;

// --- Enums ---
public enum PlantState { Initializing, Growing, GrowthComplete, Mature_Idle, Mature_Executing }

public partial class PlantGrowth : MonoBehaviour
{
    // ------------------------------------------------
    // --- SERIALIZED FIELDS ---
    // ------------------------------------------------

    [Header("UI & Visuals")]
    [SerializeField] private TMP_Text energyText;
    [SerializeField] private GameObject seedCellPrefab;
    [SerializeField] private GameObject stemCellPrefab;
    [SerializeField] private GameObject leafCellPrefab;
    [SerializeField] private GameObject berryCellPrefab; // Used for PlantCellType.Fruit
    [SerializeField] private float cellSpacing = 0.08f;

    [Header("Shadow Setup")]
    [SerializeField] [Tooltip("Assign the PlantShadowController component from the child _ShadowRoot GameObject")]
    private PlantShadowController shadowController;
    [SerializeField] [Tooltip("Assign your 'PlantShadow' prefab (GO + SpriteRenderer + ShadowPartController script)")]
    private GameObject shadowPartPrefab;

    [Header("Outline Setup")]
    [SerializeField] [Tooltip("Enable or disable plant outline visualization")]
    private bool enableOutline = true;
    [SerializeField] [Tooltip("Assign the PlantOutlineController component from the child _OutlineRoot GameObject")]
    private PlantOutlineController outlineController;
    [SerializeField] [Tooltip("Assign your outline part prefab (GO + SpriteRenderer + OutlinePartController script)")]
    private GameObject outlinePartPrefab;

    [Header("Growth & UI Timing")]
    [SerializeField] private bool showGrowthPercentage = true;
    [SerializeField] private bool allowPhotosynthesisDuringGrowth = false;
    [SerializeField] [Tooltip("Percentage UI updates only on these increments (e.g., 5 shows 0, 5, 10...).")]
    [Range(1, 25)] private int percentageIncrement = 5;
    // --- NEW FIELD ---
    [SerializeField] [Tooltip("If true, percentage display approximates smooth progress based on time. If false, it reflects discrete stem cell additions.")]
    private bool continuousIncrement = false;
    // -----------------

    // ------------------------------------------------
    // --- INTERNAL STATE & DATA ---
    // ------------------------------------------------

    private NodeGraph nodeGraph;
    public PlantState currentState = PlantState.Initializing;
    public float currentEnergy = 0f;
    private Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
    private List<GameObject> activeCellGameObjects = new List<GameObject>();
    private FireflyManager fireflyManagerInstance;
    private GameObject rootCellInstance;
    private Coroutine growthCoroutine;
    private bool isGrowthCompletionHandled = false;

    // ------------------------------------------------
    // --- POOP FERTILIZER DATA ---
    // ------------------------------------------------
    private float poopDetectionRadius = 0f;
    private float poopEnergyBonus = 0f; // Renamed from poopAbsorptionRate
    private List<LeafData> leafDataList = new List<LeafData>();

    // ------------------------------------------------
    // --- CALCULATED STATS ---
    // ------------------------------------------------

    private int targetStemLength;
    private float finalGrowthSpeed; // Represents time interval per step
    private int finalLeafGap;
    private int finalLeafPattern;
    private float finalGrowthRandomness;
    private float finalMaxEnergy;
    private float finalPhotosynthesisRate;
    private float cycleCooldown;
    private float nodeCastDelay;

    // ------------------------------------------------
    // --- RUNTIME VARIABLES ---
    // ------------------------------------------------

    private int currentStemCount = 0;
    private float cycleTimer = 0f;
    private int displayedGrowthPercentage = -1;
    private bool? offsetRightForPattern1 = null;
    // --- NEW FIELDS for Continuous Mode ---
    private float currentGrowthElapsedTime = 0f;
    private float estimatedTotalGrowthTime = 1f; // Default to 1 to avoid division by zero
    // --- NEW FIELDS for better growth tracking ---
    private float actualGrowthProgress = 0f; // The normalized progress value (0-1) representing true growth completion
    private int stepsCompleted = 0; // Track how many steps have been completed
    private int totalPlannedSteps = 0; // Total number of steps in the growth plan

    // ------------------------------------------------
    // --- UNITY LIFECYCLE METHODS ---
    // ------------------------------------------------

    void Awake()
    {
        // --- Critical Setup Check ---
        bool setupValid = true;
        if (shadowController == null) { shadowController = GetComponentInChildren<PlantShadowController>(true); if (shadowController == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': PlantShadowController ref missing!", this); setupValid = false; } else { Debug.LogWarning($"PlantGrowth on '{gameObject.name}': Found PlantShadowController dynamically.", this); } }
        if (shadowPartPrefab == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Shadow Part Prefab missing!", this); setupValid = false; }
        if (enableOutline) { if (outlineController == null) { outlineController = GetComponentInChildren<PlantOutlineController>(true); if (outlineController == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': PlantOutlineController ref missing but outline is enabled!", this); setupValid = false; } else { Debug.LogWarning($"PlantGrowth on '{gameObject.name}': Found PlantOutlineController dynamically.", this); } } if (outlinePartPrefab == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Outline Part Prefab missing but outline is enabled!", this); setupValid = false; } }
        if (seedCellPrefab == null) { Debug.LogError($"PlantGrowth ERROR on '{gameObject.name}': Seed Cell Prefab missing!", this); setupValid = false; } if (energyText == null) Debug.LogWarning($"PlantGrowth on '{gameObject.name}': Energy Text (TMP_Text) missing.", this);
        if (!setupValid) { enabled = false; return; }
        if (!enableOutline && outlineController != null) { outlineController.gameObject.SetActive(false); }
        fireflyManagerInstance = FireflyManager.Instance;
        EnsureUIReferences();
    }

    void Start()
    {
        UpdateUI();
    }

    private void Update()
    {
        // Handle frame-dependent UI updates and state transitions
        switch (currentState)
        {
            case PlantState.Growing:
                if (allowPhotosynthesisDuringGrowth)
                    AccumulateEnergy();

                // --- Update percentage UI every frame ONLY if in continuous mode ---
                if (showGrowthPercentage && continuousIncrement)
                {
                    UpdateGrowthPercentageUI();
                }
                // (Discrete mode updates are handled within the coroutine)
                break;

            case PlantState.GrowthComplete:
                if (!isGrowthCompletionHandled)
                {
                    isGrowthCompletionHandled = true;
                    if (showGrowthPercentage && targetStemLength > 0)
                    {
                        UpdateGrowthPercentageUI(true); // Force 100% display
                    }
                    currentState = PlantState.Mature_Idle;
                    cycleTimer = cycleCooldown;
                    UpdateUI(); // Update energy text if needed
                }
                break;

            case PlantState.Mature_Idle:
                AccumulateEnergy();
                UpdateUI();
                cycleTimer -= Time.deltaTime;
                if (cycleTimer <= 0f && currentEnergy >= 1f)
                {
                    currentState = PlantState.Mature_Executing;
                    StartCoroutine(ExecuteMatureCycle()); // Assumes ExecuteMatureCycle is in another partial file
                }
                break;

            case PlantState.Mature_Executing:
                AccumulateEnergy();
                UpdateUI();
                break;

            case PlantState.Initializing:
                break;
        }
    }

    private void OnDestroy()
    {
        StopAllCoroutines(); growthCoroutine = null;
        if (PlantGrowthModifierManager.Instance != null) { PlantGrowthModifierManager.Instance.UnregisterPlant(this); }
        ClearAllVisuals(); // Assumes ClearAllVisuals is in another partial file
    }

    // ------------------------------------------------
    // --- PUBLIC INITIALIZATION ---
    // ------------------------------------------------

    public void InitializeAndGrow(NodeGraph graph)
    {
        if (graph == null || graph.nodes == null) { Debug.LogError($"[{gameObject.name}] Null/empty NodeGraph provided.", gameObject); Destroy(gameObject); return; }
        if (growthCoroutine != null) { StopCoroutine(growthCoroutine); growthCoroutine = null; }
        ClearAllVisuals();
        rootCellInstance = null; currentStemCount = 0; offsetRightForPattern1 = null; isGrowthCompletionHandled = false; displayedGrowthPercentage = -1;
        currentGrowthElapsedTime = 0f; // <-- RESET
        estimatedTotalGrowthTime = 1f; // <-- RESET to default
        stepsCompleted = 0; // <-- RESET new variable
        totalPlannedSteps = 0; // <-- RESET new variable
        actualGrowthProgress = 0f; // <-- RESET new variable
        nodeGraph = graph; currentState = PlantState.Initializing; currentEnergy = 0f;
        // Clear any old leaf data
        leafDataList.Clear();
        CalculateAndApplyStats();
        GameObject spawnedSeed = SpawnCellVisual(PlantCellType.Seed, Vector2Int.zero, null, null);
        if (spawnedSeed != null) {
            rootCellInstance = spawnedSeed;
            if (PlantGrowthModifierManager.Instance != null && TileInteractionManager.Instance != null) { Vector3Int gridPos = TileInteractionManager.Instance.WorldToCell(transform.position); TileDefinition currentTile = TileInteractionManager.Instance.FindWhichTileDefinitionAt(gridPos); PlantGrowthModifierManager.Instance.RegisterPlantTile(this, currentTile); }
            if (targetStemLength > 0) {
                currentState = PlantState.Growing;
                UpdateGrowthPercentageUI(); // Initial UI update (0%)
                growthCoroutine = StartCoroutine(GrowthCoroutine_TimeBased());
            } else {
                Debug.LogWarning($"[{gameObject.name}] Target stem length is {targetStemLength}. Skipping visual growth phase.", gameObject);
                currentState = PlantState.GrowthComplete; isGrowthCompletionHandled = false; UpdateUI();
            }
        } else { Debug.LogError($"[{gameObject.name}] Failed to spawn initial seed! Aborting growth.", gameObject); currentState = PlantState.Mature_Idle; Destroy(gameObject, 0.1f); }
        UpdateUI();
    }

    // ------------------------------------------------
    // --- ENERGY & UI ---
    // ------------------------------------------------

    private void AccumulateEnergy()
    {
        if (finalPhotosynthesisRate <= 0 || finalMaxEnergy <= 0) return; float sunlight = WeatherManager.Instance ? WeatherManager.Instance.sunIntensity : 1f; int leafCount = cells.Values.Count(c => c == PlantCellType.Leaf); float tileMultiplier = (PlantGrowthModifierManager.Instance != null) ? PlantGrowthModifierManager.Instance.GetEnergyRechargeMultiplier(this) : 1.0f; float fireflyBonusRate = 0f; if (fireflyManagerInstance != null) { int nearbyFlyCount = fireflyManagerInstance.GetNearbyFireflyCount(transform.position, fireflyManagerInstance.photosynthesisRadius); fireflyBonusRate = Mathf.Min(nearbyFlyCount * fireflyManagerInstance.photosynthesisIntensityPerFly, fireflyManagerInstance.maxPhotosynthesisBonus); } float standardPhotosynthesis = finalPhotosynthesisRate * leafCount * sunlight; float totalRate = (standardPhotosynthesis + fireflyBonusRate) * tileMultiplier; float delta = totalRate * Time.deltaTime; currentEnergy = Mathf.Clamp(currentEnergy + delta, 0f, finalMaxEnergy);
    }

    // --- FIXED: UpdateGrowthPercentageUI with Continuous Mode Logic ---
    /// <summary>
    /// Calculates the target display percentage based on chosen mode (discrete/continuous)
    /// and updates the UI text ONLY if the snapped value has changed.
    /// </summary>
    /// <param name="forceComplete">If true, forces the display to 100%.</param>
    private void UpdateGrowthPercentageUI(bool forceComplete = false)
    {
        if (!showGrowthPercentage || energyText == null) return;

        float rawPercentageFloat = 0f; // The calculated percentage before snapping

        if (forceComplete || currentState == PlantState.GrowthComplete)
        {
            rawPercentageFloat = 100f;
        }
        // --- Check Continuous Flag Here ---
        else if (continuousIncrement) // --- CONTINUOUS MODE ---
        {
            // NEW: Use actual growth progress instead of elapsed time
            if (totalPlannedSteps > 0) 
            {
                // Calculate percentage based on steps completed
                rawPercentageFloat = ((float)stepsCompleted / totalPlannedSteps) * 100f;
                
                // Add partial progress toward next step based on actual growth progress
                if (actualGrowthProgress > 0f && stepsCompleted < totalPlannedSteps)
                {
                    float stepSize = 100f / totalPlannedSteps;
                    float partialStepProgress = actualGrowthProgress * stepSize;
                    rawPercentageFloat = (stepsCompleted * stepSize) + partialStepProgress;
                }
            }
            else
            {
                // Fallback if no planned steps (shouldn't happen)
                rawPercentageFloat = (currentState == PlantState.Growing) ? 0f : 100f;
            }
        }
        else // --- DISCRETE MODE ---
        {
            // Calculate based on current stem count vs target
            if (targetStemLength <= 0)
            {
                rawPercentageFloat = 0f; // No stems to grow
            }
            else
            {
                rawPercentageFloat = Mathf.Clamp(((float)currentStemCount / targetStemLength) * 100f, 0f, 100f);
            }
        }

        // --- Snap the calculated percentage (Applies to BOTH modes) ---
        int targetDisplayValue; // The final value to show (snapped)
        if (percentageIncrement <= 1)
        {
            targetDisplayValue = Mathf.FloorToInt(rawPercentageFloat);
        }
        else
        {
            // Use proper rounding to closest increment rather than floor
            targetDisplayValue = Mathf.RoundToInt(rawPercentageFloat / percentageIncrement) * percentageIncrement;
        }
        targetDisplayValue = Mathf.Min(targetDisplayValue, 100); // Clamp final value
        
        // Ensure we don't show 100% until growth is complete, unless forced
        if (targetDisplayValue == 100 && currentState == PlantState.Growing && !forceComplete)
        {
            targetDisplayValue = 95; // Cap at 95% until actually complete
        }

        // --- Update TextMeshPro only if the snapped value changed ---
        if (targetDisplayValue != displayedGrowthPercentage)
        {
            displayedGrowthPercentage = targetDisplayValue;
            energyText.text = $"{displayedGrowthPercentage}%";
        }
    }


    // --- UpdateUI (Consolidated) ---
    private void UpdateUI()
    {
        if (energyText == null) return;

        // If showing percentage AND in a state where it's relevant (Growing or just completed)
        // Let UpdateGrowthPercentageUI handle it (called from Update or completion logic)
        if (showGrowthPercentage && (currentState == PlantState.Growing || currentState == PlantState.GrowthComplete))
        {
           // If not using continuous increment, the discrete update happens in the coroutine.
           // If using continuous, it happens in Update(). If complete, it happens in Update().
           // No need to directly modify text here for percentage display.
        }
        else // Otherwise (Idle, Executing, or not showing percentage), show Energy
        {
            energyText.text = $"{Mathf.FloorToInt(currentEnergy)}/{Mathf.FloorToInt(finalMaxEnergy)}";
        }
    }

    // ------------------------------------------------
    // --- UI REFERENCE HELPER ---
    // ------------------------------------------------

    private void EnsureUIReferences()
    {
        if (energyText) return; energyText = GetComponentInChildren<TMP_Text>(true); if (!energyText) { Debug.LogWarning($"[{gameObject.name}] Energy Text (TMP_Text) UI reference not assigned in Inspector and not found in children.", gameObject); }
    }

    // ------------------------------------------------
    // --- POOP FERTILIZER METHODS ---
    // ------------------------------------------------
    
    private void CheckForPoopAndAbsorb()
    {
        // Skip if no missing leaves to regrow and no energy bonus
        bool hasMissingLeaves = leafDataList.Any(leaf => !leaf.IsActive);
        bool canAddEnergy = poopEnergyBonus > 0f;
        
        if (Debug.isDebugBuild && poopDetectionRadius > 0f)
        {
            string leafStatus = hasMissingLeaves ? 
                $"Has {leafDataList.Count(l => !l.IsActive)} missing leaves" : 
                "No missing leaves";
            Debug.Log($"[{gameObject.name}] PoopFertilizer: {leafStatus}, Radius: {poopDetectionRadius}, Energy bonus: {poopEnergyBonus}");
        }
        
        if (!hasMissingLeaves && !canAddEnergy) return;
        
        // Look for poop in range
        Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, poopDetectionRadius);
        
        if (Debug.isDebugBuild && poopDetectionRadius > 0f)
        {
            Debug.Log($"[{gameObject.name}] PoopFertilizer: Found {colliders.Length} colliders in radius {poopDetectionRadius}");
            int poopCount = 0;
            foreach (Collider2D col in colliders)
            {
                if (col.GetComponent<PoopController>() != null)
                    poopCount++;
            }
            Debug.Log($"[{gameObject.name}] PoopFertilizer: {poopCount} of those colliders have PoopController");
        }
        
        // Process poop that we find
        foreach (Collider2D collider in colliders)
        {
            PoopController poop = collider.GetComponent<PoopController>();
            if (poop != null)
            {
                bool absorbed = false;
                
                // First try to regrow a leaf if there are missing leaves
                if (hasMissingLeaves)
                {
                    absorbed = TryRegrowLeaf();
                }
                
                // If we couldn't regrow a leaf (or didn't need to) but have energy bonus, add energy
                if ((!absorbed || !hasMissingLeaves) && canAddEnergy)
                {
                    currentEnergy = Mathf.Min(finalMaxEnergy, currentEnergy + poopEnergyBonus);
                    absorbed = true;
                    
                    if (Debug.isDebugBuild)
                        Debug.Log($"[{gameObject.name}] Added {poopEnergyBonus} energy from poop fertilizer. Current energy: {currentEnergy}");
                }
                
                // Destroy the poop if it was successfully used
                if (absorbed)
                {
                    Destroy(poop.gameObject);
                    break; // Process only one poop per cycle
                }
            }
        }
    }

    private bool TryRegrowLeaf()
    {
        // Look for a missing leaf to regrow
        int missingLeafIndex = -1;
        
        // Debug counts
        if (Debug.isDebugBuild)
        {
            int totalLeaves = leafDataList.Count;
            int missingLeaves = leafDataList.Count(leaf => !leaf.IsActive);
            Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Total leaves: {totalLeaves}, Missing leaves: {missingLeaves}");
        }
        
        for (int i = 0; i < leafDataList.Count; i++)
        {
            if (!leafDataList[i].IsActive)
            {
                missingLeafIndex = i;
                break;
            }
        }
        
        if (missingLeafIndex == -1)
        {
            if (Debug.isDebugBuild)
                Debug.Log($"[{gameObject.name}] TryRegrowLeaf: No missing leaves found to regrow.");
            return false; // No missing leaves found
        }
        
        // Get the leaf coordinate and mark it as active
        Vector2Int leafCoord = leafDataList[missingLeafIndex].GridCoord;
        
        // IMPORTANT: Check if the coordinate is already occupied by another cell
        if (cells.ContainsKey(leafCoord))
        {
            if (Debug.isDebugBuild)
                Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Cannot regrow leaf at {leafCoord} because cell is already occupied.");
            return false;
        }
        
        // Create the new leaf visual
        GameObject newLeaf = SpawnCellVisual(PlantCellType.Leaf, leafCoord);
        
        if (newLeaf != null)
        {
            // Update the leaf data to mark it as active ONLY if spawn succeeded
            leafDataList[missingLeafIndex] = new LeafData(leafCoord, true);
            
            if (Debug.isDebugBuild)
                Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Successfully regrew leaf at {leafCoord} using poop fertilizer!");
            return true;
        }
        
        // If we get here, the leaf couldn't be created
        if (Debug.isDebugBuild)
            Debug.Log($"[{gameObject.name}] TryRegrowLeaf: Failed to spawn new leaf at {leafCoord}");
        
        // Leave the leaf marked as inactive in the tracking list
        return false;
    }

    // -----------------------------------------------
    // --- PUBLIC ACCESSORS FOR OUTLINES ---
    // -----------------------------------------------

    public bool DoesCellExistAt(Vector2Int coord) { return cells.ContainsKey(coord); }
    public float GetCellSpacing() { return this.cellSpacing; }
    public GameObject GetCellGameObjectAt(Vector2Int coord) { return activeCellGameObjects.FirstOrDefault(go => go != null && go.GetComponent<PlantCell>()?.GridCoord == coord); }
    public bool IsOutlineEnabled() { return enableOutline; }
    
    // Accessor for poop fertilizer visualization
    public float GetPoopDetectionRadius() { return poopDetectionRadius; }

    // --- PARTIAL CLASS METHODS (Assumed in other files) ---
    // Define these methods in the corresponding partial class files:
    // In PlantGrowth.Cell.cs: ReportCellDestroyed, RemovePlantCell, ClearAllVisuals, SpawnCellVisual, CalculateAndApplyStats, RegisterShadowForCell
    // In PlantGrowth.Growth.cs: GrowthStep class, GrowthCoroutine_TimeBased, PreCalculateGrowthPlan, GetStemDirection, CalculateLeafPositions
    // In PlantGrowth.NodeExecution.cs: ExecuteMatureCycle, TrySpawnBerry, ApplyScentDataToObject

} // End PARTIAL Class definition




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Plant\WeatherManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Battle/Plant/WeatherManager.cs
using UnityEngine;
using System;

public class WeatherManager : MonoBehaviour
{
    public static WeatherManager Instance { get; private set; }

    public enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }

    [Header("Day/Night Cycle Settings")]
    public bool dayNightCycleEnabled = true;
    public float dayDuration = 20f;
    public float nightDuration = 20f;
    public float transitionDuration = 5f;
    public AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

    [Header("Sunlight Settings")]
    [Range(0f, 1f)]
    public float sunIntensity = 1f;

    [Header("Fixed Sunlight When Cycle Off")]
    [Range(0f, 1f)]
    public float fixedSunIntensity = 1f;

    [Header("Sunlight Visualization")]
    public SpriteRenderer fadeSprite;
    public float minAlpha = 0f;
    public float maxAlpha = 1f;

    [Header("Time Scaling & Pausing")] // <<< UPDATED HEADER
    [Range(1f, 100f)]
    public float timeScaleMultiplier = 1f;
    public bool IsPaused { get; set; } = false; // <<< NEW: Pause flag

    // --- Public Properties & Events ---
    public CyclePhase CurrentPhase => currentPhase;
    public event Action<CyclePhase> OnPhaseChanged;
    public float CurrentPhaseTimer => phaseTimer; // <<< NEW: Expose timer
    public float CurrentTotalPhaseTime => totalPhaseTime; // <<< NEW: Expose total time

    // --- Internals ---
    private CyclePhase currentPhase = CyclePhase.Day;
    private float phaseTimer = 0f;
    private float totalPhaseTime = 0f;

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;
    }

    void Start()
    {
        EnterPhase(CyclePhase.Day, true);
    }

    void Update()
    {
        // --- PAUSE CHECK ---
        if (IsPaused) // <<< NEW: Check if paused
        {
            // If paused, potentially ensure timeScale is 1? Or leave it? Let's reset it.
            if (timeScaleMultiplier != 1f) timeScaleMultiplier = 1f;
            return; // Do nothing else if paused
        }
        // ---------------------

        if (!dayNightCycleEnabled)
        {
            sunIntensity = fixedSunIntensity;
            UpdateFadeSprite();
            if (timeScaleMultiplier != 1f) timeScaleMultiplier = 1f;
            return;
        }

        phaseTimer -= Time.deltaTime * timeScaleMultiplier;

        if (phaseTimer <= 0f)
        {
            CyclePhase nextPhase = currentPhase;
            switch (currentPhase)
            {
                case CyclePhase.Day: nextPhase = CyclePhase.TransitionToNight; break;
                case CyclePhase.TransitionToNight: nextPhase = CyclePhase.Night; break;
                case CyclePhase.Night: nextPhase = CyclePhase.TransitionToDay; break;
                case CyclePhase.TransitionToDay: nextPhase = CyclePhase.Day; break;
            }
            EnterPhase(nextPhase);
        }
        else
        {
            UpdateSunIntensity();
        }

        UpdateFadeSprite();
    }

    private void EnterPhase(CyclePhase nextPhase, bool forceEvent = false)
    {
        CyclePhase previousPhase = currentPhase;
        currentPhase = nextPhase;

        switch (nextPhase)
        {
            case CyclePhase.Day: totalPhaseTime = dayDuration; break;
            case CyclePhase.Night: totalPhaseTime = nightDuration; break;
            case CyclePhase.TransitionToNight:
            case CyclePhase.TransitionToDay: totalPhaseTime = transitionDuration; break;
        }
        totalPhaseTime = Mathf.Max(0.01f, totalPhaseTime);
        phaseTimer = totalPhaseTime;

        UpdateSunIntensity();

        if (previousPhase != currentPhase || forceEvent)
        {
            if (Debug.isDebugBuild) Debug.Log($"[WeatherManager] Phase Changed To: {currentPhase}");
            OnPhaseChanged?.Invoke(currentPhase);
        }
    }

    private void UpdateSunIntensity()
    {
        if (totalPhaseTime <= 0) return;
        float progress = 1f - Mathf.Clamp01(phaseTimer / totalPhaseTime);
        switch (currentPhase)
        {
            case CyclePhase.Day: sunIntensity = 1f; break;
            case CyclePhase.TransitionToNight: sunIntensity = Mathf.Lerp(1f, 0f, transitionCurve.Evaluate(progress)); break;
            case CyclePhase.Night: sunIntensity = 0f; break;
            case CyclePhase.TransitionToDay: sunIntensity = Mathf.Lerp(0f, 1f, transitionCurve.Evaluate(progress)); break;
        }
        sunIntensity = Mathf.Clamp01(sunIntensity);
    }

    private void UpdateFadeSprite()
    {
        if (fadeSprite != null)
        {
            float alpha = Mathf.Lerp(maxAlpha, minAlpha, sunIntensity);
            Color c = fadeSprite.color; c.a = alpha; fadeSprite.color = c;
        }
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\SpellProjectile.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SpellProjectile : MonoBehaviour
{
    [Header("Projectile Stats")]
    public float damage;
    public float speed;
    [Tooltip("If true, the projectile will be destroyed upon hitting a wizard.")]
    public bool destroyOnHit = true;

    [Header("Burning Effect (optional)")]
    public float burningDamage;   // DPS
    public float burningDuration; // Duration in seconds

    [Header("Friendly Fire")]
    public bool friendlyFire = false;
    public bool casterIsEnemy = false;

    public void Initialize(float dmg, float spd)
    {
        damage = dmg;
        speed = spd;
    }

    private void Update()
    {
        transform.Translate(Vector2.up * speed * Time.deltaTime);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\BurningStatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public class BurningStatusEffect : StatusEffect
{
    public BurningStatusEffect(float d, float dps) : base(d, dps) { }

    
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Battle\Status Effects\StatusEffect.cs
////////////////////////////////////////////////////////////////////////////////
﻿public abstract class StatusEffect
{
    public float duration; // Total duration.
    public float damagePerSecond;
    protected float elapsed = 0f;

    // Public property to expose elapsed time.
    public float Elapsed { get { return elapsed; } }

    public StatusEffect(float d, float dps)
    {
        duration = d;
        damagePerSecond = dps;
    }

    public bool IsExpired() => elapsed >= duration;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\SortableEntity.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

public class SortableEntity : MonoBehaviour
{
    [Header("Sorting Configuration")]
    [Tooltip("Offset added to Y position for sorting calculation")]
    [SerializeField] private float sortingLayerYOffset = 0f;

    [Tooltip("Use parent's Y coordinate for sorting")]
    [SerializeField] private bool useParentYCoordinate = false;

    [Tooltip("Debug logging for sorting")]
    public bool debugSorting = false;

    private SpriteRenderer spriteRenderer;

    private void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        // If no SpriteRenderer, try to find one in children
        if (spriteRenderer == null)
            spriteRenderer = GetComponentInChildren<SpriteRenderer>();

        // Ensure sprite renderer exists
        if (spriteRenderer == null)
        {
            Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
        }
    }

    private void Start()
    {
        UpdateSortingOrder();
    }

    private void LateUpdate()
    {
        UpdateSortingOrder();
    }

    public void UpdateSortingOrder()
    {
        if (spriteRenderer == null) return;

        // Determine Y position for sorting
        float yPositionForSorting = useParentYCoordinate && transform.parent != null 
            ? transform.parent.position.y 
            : transform.position.y;

        int sortOrder = CalculateSortOrder(yPositionForSorting);
        spriteRenderer.sortingOrder = sortOrder;

        if (debugSorting)
        {
            Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
        }
    }

    private int CalculateSortOrder(float yPosition)
    {
        // Subtract offset to effectively move the sorting position
        return Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
    }

    // Public method to get current sorting order
    public int GetCurrentSortOrder()
    {
        if (spriteRenderer == null) return 0;
        return spriteRenderer.sortingOrder;
    }

    // Public method to set sorting order directly if needed
    public void SetSortingOrder(int order)
    {
        if (spriteRenderer != null)
            spriteRenderer.sortingOrder = order;
    }

    // Public method to set the parent Y coordinate usage flag
    // This eliminates the need for reflection in other scripts
    public void SetUseParentYCoordinate(bool value)
    {
        useParentYCoordinate = value;
    }
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[CreateAssetMenu(fileName = "Animal_", menuName = "Ecosystem/Animal Definition (Simplified)")]
public class AnimalDefinition : ScriptableObject
{
    [Header("Identification")]
    [Tooltip("The species name (e.g., 'Bunny', 'Fox').")]
    public string animalName = "DefaultAnimal";

    [Header("Core Stats")]
    public float maxHealth = 10f; // Keep health for potential future damage/predators
    public float movementSpeed = 2f;

    [Header("Diet")]
    [Tooltip("Reference to the AnimalDiet ScriptableObject defining eating habits.")]
    public AnimalDiet diet; // Needs to reference the simplified AnimalDiet SO

    [Header("Visuals")]
    [Tooltip("The prefab to instantiate for this animal.")]
    public GameObject prefab;

    // Removed meatFoodType
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "AnimalLibrary", menuName = "Ecosystem/Animal Library")]
public class AnimalLibrary : ScriptableObject
{
    public List<AnimalDefinition> animals;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalController.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using TMPro;

[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(SortableEntity))]
[RequireComponent(typeof(Collider2D))]
public class AnimalController : MonoBehaviour
{
    // --- Fields ---
    private AnimalDefinition definition;
    private AnimalDiet animalDiet;
    
    [Header("Optional Features")]
    public AnimalThoughtLibrary thoughtLibrary;
    public GameObject thoughtBubblePrefab;
    public Transform bubbleSpawnTransform;
    public Transform poopSpawnPoint;
    public List<GameObject> poopPrefabs;
    public Animator animator;
    
    [Header("UI References")]
    [SerializeField] private TextMeshProUGUI hpText;
    [SerializeField] private TextMeshProUGUI hungerText; // NEW: Hunger text reference

    [Header("UI Settings")] // NEW HEADER
    [Tooltip("Which key to hold to display HP and Hunger texts")]
    [SerializeField] private KeyCode showStatsKey = KeyCode.LeftAlt; // NEW: Configurable key for showing stats
    
    [Header("Behavior Tuning")]
    public float searchRadius = 5f;
    public float eatDistance = 0.5f;
    public float eatDuration = 1.5f;
    [Range(0f, 1f)]
    public float wanderPauseChance = 0.3f;
    public float wanderMinMoveDuration = 1f;
    public float wanderMaxMoveDuration = 3f;
    public float wanderMinPauseDuration = 0.5f;
    public float wanderMaxPauseDuration = 2f;
    public float minPoopDelay = 5f;
    public float maxPoopDelay = 10f;
    public float poopDuration = 1f;
    public float poopColorVariation = 0.1f;
    public float thoughtCooldownTime = 5f;
    [SerializeField] private List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();
    [SerializeField] private List<ScentDefinition> repellentScentDefinitions = new List<ScentDefinition>();

    // --- NEW: Food reassessment timer fields ---
    [Header("Food Seeking Improvements")]
    [Tooltip("How often (in seconds) to reassess nearby food even when current target is valid")]
    public float foodReassessmentInterval = 0.5f;
    private float foodReassessmentTimer = 0f;

    // --- Internal State ---
    private float currentHealth;
    private float currentHunger;
    private GameObject currentTargetFood = null;
    private Vector2 moveDirection = Vector2.zero;
    private bool isEating = false;
    private float eatTimer = 0f;
    private bool isWanderPaused = false;
    private float wanderStateTimer = 0f;
    private bool isPooping = false;
    private float poopTimer = 0f;
    private float poopDelayTimer = 0f;
    private bool hasPooped = true;
    private float thoughtCooldownTimer = 0f;
    private bool isSeekingScreenCenter = false;
    private Vector2 screenCenterTarget;

    // --- Component References ---
    private Rigidbody2D rb;
    private SpriteRenderer spriteRenderer;
    private Collider2D animalCollider;

    // --- Movement Bounds (Shifted Padded Screen Bounds) ---
    private Vector2 minBounds;
    private Vector2 maxBounds;

    // --- Public Accessors ---
    public float CurrentHealth => currentHealth;
    public string SpeciesName => definition ? definition.animalName : "Uninitialized";

    // --- NEW: Fields for slowdown system ---
    private float baseMovementSpeed;
    private List<float> activeSpeedMultipliers = new List<float>();

    // --- Initialize ---
    public void Initialize(AnimalDefinition def, Vector2 shiftedMinBounds, Vector2 shiftedMaxBounds, bool spawnedOffscreen = false)
    {
        definition = def; 
        if (definition == null) { Destroy(gameObject); return; }
        
        animalDiet = def.diet; 
        if (animalDiet == null) { enabled = false; return; }
        
        rb = GetComponent<Rigidbody2D>(); 
        spriteRenderer = GetComponentInChildren<SpriteRenderer>(); 
        animalCollider = GetComponent<Collider2D>();
        
        if (animalCollider == null) 
        { 
            Debug.LogError($"[{gameObject.name}] Missing Collider2D!", gameObject); 
            enabled = false; 
            return; 
        }

        // Store base movement speed - NEW
        baseMovementSpeed = definition.movementSpeed;
        activeSpeedMultipliers.Clear(); // NEW

        currentHealth = definition.maxHealth;
        currentHunger = 0f;
        hasPooped = true;
        poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay);
        foodReassessmentTimer = Random.Range(0f, foodReassessmentInterval); // Randomize initial timer

        // Store the SHIFTED bounds received from FaunaManager
        minBounds = shiftedMinBounds;
        maxBounds = shiftedMaxBounds;
        
        // Calculate the target center based on the SHIFTED bounds
        screenCenterTarget = (minBounds + maxBounds) / 2f;

        isSeekingScreenCenter = spawnedOffscreen;
        if (isSeekingScreenCenter)
        {
            if(Debug.isDebugBuild) 
                Debug.Log($"[{gameObject.name} Initialize] Offscreen spawn. Seeking SHIFTED center ({screenCenterTarget}). SHIFTED Bounds: min{minBounds}, max{maxBounds}", gameObject);
            
            moveDirection = (screenCenterTarget - (Vector2)transform.position).normalized;
            if (moveDirection == Vector2.zero) 
                moveDirection = Random.insideUnitCircle.normalized;
        }
    
        EnsureUITextReferences();
    
        // Hide text elements initially
        SetStatsTextVisibility(false);
    
        UpdateHpText(); 
        UpdateHungerText();
    
        if (spriteRenderer == null) { /* Warning */ }
    }
    
    private void EnsureUITextReferences() 
    { 
        if (hpText == null) 
        {
            hpText = GetComponentInChildren<TextMeshProUGUI>(true);
            // If we found a TMP_Text but it should be for HP, don't assign it to both
            if (hpText != null && hpText.gameObject.name.Contains("Hunger"))
            {
                hungerText = hpText;
                hpText = null;
            }
        }
    
        if (hungerText == null)
        {
            // Try to find any TextMeshProUGUI component that's not the HP text
            TextMeshProUGUI[] allTexts = GetComponentsInChildren<TextMeshProUGUI>(true);
            foreach (var text in allTexts)
            {
                if (text != hpText)
                {
                    hungerText = text;
                    break;
                }
            }
        }
    }

    // --- Update ---
    void Update()
    {
        if (!enabled || rb == null) return;

        // Check for ALT key (or configured key) press to show/hide stats
        bool showStats = Input.GetKey(showStatsKey);
        SetStatsTextVisibility(showStats);

        if (isSeekingScreenCenter)
        {
            Vector2 currentPos = rb.position;
            // Check if center is within the SHIFTED padded bounds
            bool centerWithinBounds =
                currentPos.x >= minBounds.x && currentPos.x <= maxBounds.x &&
                currentPos.y >= minBounds.y && currentPos.y <= maxBounds.y;

            if (centerWithinBounds)
            {
                if(Debug.isDebugBuild) 
                    Debug.Log($"[{gameObject.name} Update] Center reached SHIFTED bounds! Pos: {currentPos}. MinB: {minBounds}, MaxB: {maxBounds}. Switching to normal AI.", gameObject);
                
                isSeekingScreenCenter = false;
                moveDirection = Vector2.zero;
            }
            else
            {
                // Seek the SHIFTED center target
                moveDirection = (screenCenterTarget - currentPos).normalized;
                if (moveDirection == Vector2.zero) 
                    moveDirection = Random.insideUnitCircle.normalized;
                
                FlipSpriteBasedOnDirection();
                UpdateAnimationState();
                return; // Skip normal AI
            }
        }

        // Normal AI Logic
        UpdateHunger();
        HandlePooping();
        UpdateThoughts();
        
        if (isEating) 
        { 
            HandleEating(); 
            moveDirection = Vector2.zero; 
        }
        else if (isPooping) 
        { 
            moveDirection = Vector2.zero; 
        }
        else 
        { 
            DecideNextAction(); 
        }

        FlipSpriteBasedOnDirection();
        UpdateAnimationState();
    }
    
    private void SetStatsTextVisibility(bool visible)
    {
        if (hpText != null)
        {
            hpText.gameObject.SetActive(visible);
        }
    
        if (hungerText != null)
        {
            hungerText.gameObject.SetActive(visible);
        }
    }

    // --- FixedUpdate ---
    void FixedUpdate()
    {
        if (rb == null) return;
        
        if (!isEating && !isPooping && moveDirection != Vector2.zero)
        {
            Vector2 currentPos = rb.position;
            Vector2 desiredMove = moveDirection.normalized * definition.movementSpeed * Time.fixedDeltaTime;
            Vector2 nextPos = currentPos + desiredMove;

            if (!isSeekingScreenCenter) // Clamp only when NOT seeking
            {
                // Clamp the CENTER position using the SHIFTED bounds
                nextPos.x = Mathf.Clamp(nextPos.x, minBounds.x, maxBounds.x);
                nextPos.y = Mathf.Clamp(nextPos.y, minBounds.y, maxBounds.y);
            }
            rb.MovePosition(nextPos);
        }
    }

    void UpdateHunger() 
    { 
        currentHunger += animalDiet.hungerIncreaseRate * Time.deltaTime; 
        currentHunger = Mathf.Min(currentHunger, animalDiet.maxHunger);
        // Update hunger text when hunger changes
        UpdateHungerText();
    }
    
    void ApplyStarvationDamage() 
    { 
        /* ... */ 
        UpdateHpText(); 
    }
    
    void HandlePooping() 
    { 
        if (!isEating && !hasPooped) 
        { 
            poopDelayTimer -= Time.deltaTime; 
            if (!isPooping && poopDelayTimer <= 0f) 
            { 
                StartPooping(); 
            } 
            if (isPooping) 
            { 
                poopTimer -= Time.deltaTime; 
                if (poopTimer <= 0f) 
                { 
                    FinishPooping(); 
                } 
            } 
        } 
    }
    
    void UpdateThoughts() 
    { 
        if (thoughtCooldownTimer > 0) 
        { 
            thoughtCooldownTimer -= Time.deltaTime; 
        } 
    }
    
    void DecideNextAction() 
    { 
        if (currentHunger >= animalDiet.hungerThreshold) 
        { 
            SeekFood(); 
        } 
        else 
        { 
            Wander(); 
            currentTargetFood = null; 
        } 
    }
    
    // --- Food seeking with periodic reassessment ---
    void SeekFood() 
    { 
        if (CanShowThought()) ShowThought(ThoughtTrigger.Hungry);
        
        // Reassess food periodically even if current target is valid
        foodReassessmentTimer -= Time.deltaTime;
        bool shouldReassess = foodReassessmentTimer <= 0f;
        bool targetValid = currentTargetFood != null && currentTargetFood.activeInHierarchy && 
                          currentTargetFood.GetComponent<FoodItem>() != null;
        
        // Reassess when timer expires or if target is invalid
        if (shouldReassess || !targetValid) 
        {
            // Store position of old target for comparison
            Vector3 oldTargetPosition = targetValid ? currentTargetFood.transform.position : Vector3.zero;
            
            // Find potentially better food
            GameObject potentialBetterFood = FindNearestFood();
            
            if (potentialBetterFood != null) 
            {
                // Always switch to new target if no current target
                if (!targetValid) 
                {
                    currentTargetFood = potentialBetterFood;
                    if(Debug.isDebugBuild) 
                        Debug.Log($"[{gameObject.name} SeekFood] Found new food target (no previous): {potentialBetterFood.name}");
                }
                // Switch to new target if it's better than current
                else if (potentialBetterFood != currentTargetFood) 
                {
                    // Get preferences for comparison
                    FoodItem currentFoodItem = currentTargetFood.GetComponent<FoodItem>();
                    FoodItem newFoodItem = potentialBetterFood.GetComponent<FoodItem>();
                    
                    if (currentFoodItem != null && newFoodItem != null) 
                    {
                        float currentPriority = animalDiet.GetPreference(currentFoodItem.foodType)?.preferencePriority ?? 0f;
                        float newPriority = animalDiet.GetPreference(newFoodItem.foodType)?.preferencePriority ?? 0f;
                        
                        // Switch if new food has higher priority
                        if (newPriority > currentPriority) 
                        {
                            if(Debug.isDebugBuild) 
                                Debug.Log($"[{gameObject.name} SeekFood] Switching to higher priority food: {newFoodItem.foodType.foodName} (priority: {newPriority}) from {currentFoodItem.foodType.foodName} (priority: {currentPriority})");
                            
                            currentTargetFood = potentialBetterFood;
                        }
                    }
                }
            }
            
            // Reset timer
            foodReassessmentTimer = foodReassessmentInterval;
        }
        
        // Proceed with target as before
        if (currentTargetFood != null) 
        {
            MoveTowardFood(currentTargetFood);
        } 
        else 
        {
            Wander();
        }
    }

    GameObject FindNearestFood() 
    { 
        Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, searchRadius); 
        return animalDiet.FindBestFood(colliders, transform.position); 
    }
    
    void MoveTowardFood(GameObject foodObj) 
    { 
        if (foodObj == null) return; 
        
        float distance = Vector2.Distance(transform.position, foodObj.transform.position); 
        if (distance <= eatDistance) 
        { 
            StartEating(); 
        } 
        else 
        { 
            moveDirection = (foodObj.transform.position - transform.position).normalized; 
            isWanderPaused = false; 
            wanderStateTimer = 0f; 
        } 
    }
    
    void StartEating() 
    { 
        isEating = true; 
        eatTimer = eatDuration; 
        moveDirection = Vector2.zero; 
        if (CanShowThought()) ShowThought(ThoughtTrigger.Eating); 
    }
    
    void HandleEating() 
    { 
        eatTimer -= Time.deltaTime; 
        if (eatTimer <= 0f) 
        { 
            isEating = false; 
            FinishEatingAction(); 
        } 
    }
    
    void FinishEatingAction() 
    { 
        if (currentTargetFood == null) return; 
        
        FoodItem foodItem = currentTargetFood.GetComponent<FoodItem>(); 
        if (foodItem != null && foodItem.foodType != null) 
        { 
            float satiationGain = animalDiet.GetSatiationValue(foodItem.foodType); 
            currentHunger -= satiationGain; 
            currentHunger = Mathf.Max(0f, currentHunger); 
            Destroy(currentTargetFood); 
            hasPooped = false; 
            poopDelayTimer = Random.Range(minPoopDelay, maxPoopDelay); 
            currentTargetFood = null;
            // Update hunger text
            UpdateHungerText();
        } 
        else 
        { 
            currentTargetFood = null; 
        } 
    }
    
    void StartPooping() 
    { 
        isPooping = true; 
        poopTimer = poopDuration; 
        moveDirection = Vector2.zero; 
        if (CanShowThought()) ShowThought(ThoughtTrigger.Pooping); 
    }
    
    void FinishPooping() 
    { 
        SpawnPoop(); 
        isPooping = false; 
        hasPooped = true; 
    }
    
    void SpawnPoop() 
    { 
        if (poopPrefabs == null || poopPrefabs.Count == 0) return; 
        
        int index = Random.Range(0, poopPrefabs.Count); 
        GameObject prefab = poopPrefabs[index]; 
        if (prefab == null) return; 
        
        Transform spawnT = poopSpawnPoint ? poopSpawnPoint : transform; 
        GameObject poopObj = Instantiate(prefab, spawnT.position, Quaternion.identity); 
        
        SpriteRenderer sr = poopObj.GetComponent<SpriteRenderer>(); 
        if (sr != null) 
        { 
            sr.flipX = Random.value > 0.5f; 
            Color c = sr.color; 
            float v = poopColorVariation; 
            sr.color = new Color(
                Mathf.Clamp01(c.r + Random.Range(-v, v)),
                Mathf.Clamp01(c.g + Random.Range(-v, v)),
                Mathf.Clamp01(c.b + Random.Range(-v, v)),
                c.a
            ); 
        } 
        
        PoopController pc = poopObj.GetComponent<PoopController>() ?? poopObj.AddComponent<PoopController>(); 
        pc.Initialize(); 
    }
    
    void Wander() 
    { 
        if (wanderStateTimer <= 0f) 
        { 
            if (isWanderPaused) 
            { 
                isWanderPaused = false; 
                moveDirection = Random.insideUnitCircle.normalized; 
                wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration); 
            } 
            else 
            { 
                if (Random.value < wanderPauseChance) 
                { 
                    isWanderPaused = true; 
                    moveDirection = Vector2.zero; 
                    wanderStateTimer = Random.Range(wanderMinPauseDuration, wanderMaxPauseDuration); 
                } 
                else 
                { 
                    moveDirection = Random.insideUnitCircle.normalized; 
                    wanderStateTimer = Random.Range(wanderMinMoveDuration, wanderMaxMoveDuration); 
                } 
            } 
        } 
        else 
        { 
            wanderStateTimer -= Time.deltaTime; 
        } 
    }
    
    void FlipSpriteBasedOnDirection() 
    { 
        if (spriteRenderer != null && Mathf.Abs(moveDirection.x) > 0.01f) 
        { 
            spriteRenderer.flipX = moveDirection.x < 0; 
        } 
    }
    
    void UpdateAnimationState() 
    { 
        if (animator == null) return; 
        bool isMoving = !isEating && !isPooping && moveDirection.sqrMagnitude > 0.01f; 
        animator.SetBool("IsMoving", isMoving); 
        animator.SetBool("IsEating", isEating); 
    }
    
    bool CanShowThought() 
    { 
        return thoughtLibrary != null && thoughtBubblePrefab != null && thoughtCooldownTimer <= 0f; 
    }
    
    void ShowThought(ThoughtTrigger trigger) 
    { 
        if (thoughtLibrary == null || thoughtLibrary.allThoughts == null) return; 
        
        var entry = thoughtLibrary.allThoughts.FirstOrDefault(t => 
            t != null && t.speciesName == SpeciesName && t.trigger == trigger
        ); 
        
        if (entry != null && entry.lines != null && entry.lines.Count > 0) 
        { 
            string line = entry.lines[Random.Range(0, entry.lines.Count)]; 
            Transform spawnT = bubbleSpawnTransform ? bubbleSpawnTransform : transform; 
            GameObject bubbleGO = Instantiate(thoughtBubblePrefab, spawnT.position, Quaternion.identity, spawnT); 
            bubbleGO.transform.localPosition = Vector3.zero; 
            
            ThoughtBubbleController bubble = bubbleGO.GetComponent<ThoughtBubbleController>(); 
            if (bubble) 
            { 
                bubble.Initialize(line, spawnT, 2f); 
                thoughtCooldownTimer = thoughtCooldownTime; 
            } 
            else 
            { 
                Destroy(bubbleGO); 
            } 
        } 
    }
    
    public enum CauseOfDeath { Unknown, Starvation, EatenByPredator }
    
    private void Die(CauseOfDeath cause) 
    { 
        Debug.Log($"[{SpeciesName} died: {cause}]", gameObject); 
        Destroy(gameObject); 
    }
    
    public bool SpeciesNameEquals(string other) 
    { 
        return definition != null && definition.animalName == other; 
    }
    
    private void UpdateHpText() 
    { 
        if (hpText == null || definition == null) return; 
        hpText.text = $"HP: {Mathf.FloorToInt(currentHealth)}/{Mathf.FloorToInt(definition.maxHealth)}"; 
    }
    
    private void UpdateHungerText()
    {
        if (hungerText == null || animalDiet == null) return;
        hungerText.text = $"Hunger: {Mathf.FloorToInt(currentHunger)}/{Mathf.FloorToInt(animalDiet.maxHunger)}";
    }

    // --- NEW METHODS FOR SLOWDOWN SYSTEM ---
    
    // Method to apply speed multiplier from SlowdownZone
    public void ApplySpeedMultiplier(float multiplier)
    {
        if (!activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Add(multiplier);
            UpdateMovementSpeed();
            
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Applied speed multiplier: {multiplier}. New speed: {definition.movementSpeed}");
            }
        }
    }

    // Method to remove speed multiplier when leaving SlowdownZone
    public void RemoveSpeedMultiplier(float multiplier)
    {
        if (activeSpeedMultipliers.Contains(multiplier))
        {
            activeSpeedMultipliers.Remove(multiplier);
            UpdateMovementSpeed();
            
            if (Debug.isDebugBuild)
            {
                Debug.Log($"[{gameObject.name}] Removed speed multiplier: {multiplier}. New speed: {definition.movementSpeed}");
            }
        }
    }

    // Method to recalculate movement speed based on active multipliers
    private void UpdateMovementSpeed()
    {
        // Start with base speed (original speed from definition)
        float newSpeed = baseMovementSpeed;
        
        // Apply all active multipliers
        if (activeSpeedMultipliers.Count > 0)
        {
            // Use the most restrictive (lowest) multiplier
            float lowestMultiplier = 1.0f;
            foreach (float multiplier in activeSpeedMultipliers)
            {
                if (multiplier < lowestMultiplier)
                {
                    lowestMultiplier = multiplier;
                }
            }
            
            newSpeed *= lowestMultiplier;
        }
        
        // Update the definition's movement speed (which is used in FixedUpdate)
        definition.movementSpeed = newSpeed;
        
        // Optionally update animation speed to match movement
        if (animator != null)
        {
            float speedRatio = newSpeed / baseMovementSpeed;
            animator.speed = Mathf.Max(0.5f, speedRatio); // Don't go below half speed
        }
    }

}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalSpawnData.cs
////////////////////////////////////////////////////////////////////////////////
﻿using UnityEngine;

[System.Serializable]
public class AnimalSpawnData {
    public AnimalDefinition animalDefinition;
    [Range(0f, 1f)]
    [Tooltip("Spawn rate multiplier (0 = no spawn; lower values = less frequent spawns).")]
    public float spawnRateMultiplier = 1f;
    [Tooltip("Maximum number of this animal type allowed to be spawned (0 = no limit).")]
    public int maximumSpawned = 0;
    
    [HideInInspector]
    public float spawnTimer = 0f;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\AnimalThoughtLibrary.cs
////////////////////////////////////////////////////////////////////////////////
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "AnimalThoughtLibrary", menuName = "Ecosystem/Animal Thought Library")]
public class AnimalThoughtLibrary : ScriptableObject
{
    public List<AnimalThoughtLine> allThoughts;
}

[System.Serializable]
public class AnimalThoughtLine
{
    [Header("Which Animal?")]
    public string speciesName; // e.g. "Bunny", "Fox", "Bird"

    [Header("Trigger Condition")]
    public ThoughtTrigger trigger;

    [Header("Possible Lines to Randomly Choose From")]
    public List<string> lines;
}




////////////////////////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Core\EcosystemManager.cs
////////////////////////////////////////////////////////////////////////////////
﻿// FILE: Assets/Scripts/Ecosystem/Core/EcosystemManager.cs
using UnityEngine;

public class EcosystemManager : MonoBehaviour
{
    public static EcosystemManager Instance { get; private set; }

    [Header("Parent Transforms")]
    public Transform animalParent;
    public Transform plantParent;

    [Header("Libraries")]
    [Tooltip("Reference to the Scent Library asset.")]
    public ScentLibrary scentLibrary; // <<< ADDED

    [Header("Sorting Options")]
    public bool sortAnimalsBySpecies = true;
    public bool sortPlantsBySpecies = true;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // Validate Library Reference
        if (scentLibrary == null)
        {
            Debug.LogWarning($"[{nameof(EcosystemManager)}] Scent Library not assigned! Scent effects will not work.", this);
        }
    }
}





--------------------------------------------------------------------------------
This is part 2 out of 7 of script collection. 5 more parts remain.
--------------------------------------------------------------------------------